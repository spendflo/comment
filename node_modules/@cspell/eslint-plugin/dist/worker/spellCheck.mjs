import assert from 'assert';
import { createTextDocument, DocumentValidator, refreshDictionaryCache } from 'cspell-lib';
import * as path from 'path';
import { format } from 'util';
import { walkTree } from './walkTree.mjs';
const defaultSettings = {
    patterns: [
    // @todo: be able to use cooked / transformed strings.
    // {
    //     // Do not block unicode escape sequences.
    //     name: 'js-unicode-escape',
    //     pattern: /$^/g,
    // },
    ],
};
let isDebugMode = false;
function log(...args) {
    if (!isDebugMode)
        return;
    console.log(...args);
}
export async function spellCheck(filename, text, root, options) {
    const toIgnore = new Set();
    const importedIdentifiers = new Set();
    isDebugMode = options.debugMode || false;
    const validator = getDocValidator(filename, text, options);
    await validator.prepare();
    const issues = [];
    function checkLiteral(node) {
        if (node.type !== 'Literal')
            return;
        if (!options.checkStrings)
            return;
        if (typeof node.value === 'string') {
            debugNode(node, node.value);
            if (options.ignoreImports && isImportOrRequired(node))
                return;
            if (options.ignoreImportProperties && isImportedProperty(node))
                return;
            checkNodeText(node, node.value);
        }
    }
    function checkJSXText(node) {
        if (node.type !== 'JSXText')
            return;
        if (!options.checkJSXText)
            return;
        if (typeof node.value === 'string') {
            debugNode(node, node.value);
            checkNodeText(node, node.value);
        }
    }
    function checkTemplateElement(node) {
        if (node.type !== 'TemplateElement')
            return;
        if (!options.checkStringTemplates)
            return;
        debugNode(node, node.value);
        checkNodeText(node, node.value.cooked || node.value.raw);
    }
    function checkIdentifier(node) {
        if (node.type !== 'Identifier')
            return;
        debugNode(node, node.name);
        if (options.ignoreImports) {
            if (isRawImportIdentifier(node)) {
                toIgnore.add(node.name);
                return;
            }
            if (isImportIdentifier(node)) {
                importedIdentifiers.add(node.name);
                if (isLocalImportIdentifierUnique(node)) {
                    checkNodeText(node, node.name);
                }
                return;
            }
            else if (options.ignoreImportProperties && isImportedProperty(node)) {
                return;
            }
        }
        if (!options.checkIdentifiers)
            return;
        if (toIgnore.has(node.name) && !isObjectProperty(node))
            return;
        if (skipCheckForRawImportIdentifiers(node))
            return;
        checkNodeText(node, node.name);
    }
    function checkComment(node) {
        if (node.type !== 'Line' && node.type !== 'Block')
            return;
        if (!options.checkComments)
            return;
        debugNode(node, node.value);
        checkNodeText(node, node.value);
    }
    function checkNodeText(node, text) {
        if (!node.range)
            return;
        const adj = node.type === 'Literal' ? 1 : 0;
        const range = [node.range[0] + adj, node.range[1] - adj];
        const scope = calcScope(node);
        const result = validator.checkText(range, text, scope);
        result.forEach((issue) => reportIssue(issue, node.type));
    }
    function calcScope(_node) {
        // inheritance(node);
        return [];
    }
    function isImportIdentifier(node) {
        const parent = node.parent;
        if (node.type !== 'Identifier' || !parent)
            return false;
        return ((parent.type === 'ImportSpecifier' ||
            parent.type === 'ImportNamespaceSpecifier' ||
            parent.type === 'ImportDefaultSpecifier') &&
            parent.local === node);
    }
    function isRawImportIdentifier(node) {
        const parent = node.parent;
        if (node.type !== 'Identifier' || !parent)
            return false;
        return ((parent.type === 'ImportSpecifier' && parent.imported === node) ||
            (parent.type === 'ExportSpecifier' && parent.local === node));
    }
    function isLocalImportIdentifierUnique(node) {
        const parent = getImportParent(node);
        if (!parent)
            return true;
        const { imported, local } = parent;
        if (imported.name !== local.name)
            return true;
        return imported.range?.[0] !== local.range?.[0] && imported.range?.[1] !== local.range?.[1];
    }
    function getImportParent(node) {
        const parent = node.parent;
        return parent?.type === 'ImportSpecifier' ? parent : undefined;
    }
    function skipCheckForRawImportIdentifiers(node) {
        if (options.ignoreImports)
            return false;
        const parent = getImportParent(node);
        return !!parent && parent.imported === node && !isLocalImportIdentifierUnique(node);
    }
    function isImportedProperty(node) {
        const obj = findOriginObject(node);
        return !!obj && obj.type === 'Identifier' && importedIdentifiers.has(obj.name);
    }
    function isObjectProperty(node) {
        return node.parent?.type === 'MemberExpression';
    }
    function reportIssue(issue, nodeType) {
        const word = issue.text;
        const start = issue.offset;
        const end = issue.offset + (issue.length || issue.text.length);
        const suggestions = normalizeSuggestions(issue.suggestionsEx, nodeType);
        const severity = issue.isFlagged ? 'Forbidden' : 'Unknown';
        issues.push({ word, start, end, nodeType, suggestions, severity });
    }
    const processors = {
        Line: checkComment,
        Block: checkComment,
        Literal: checkLiteral,
        TemplateElement: checkTemplateElement,
        Identifier: checkIdentifier,
        JSXText: checkJSXText,
    };
    function checkNode(node) {
        processors[node.type]?.(node);
    }
    function mapNode(node, index, nodes) {
        const child = nodes[index + 1];
        if (node.type === 'ImportSpecifier') {
            const extra = node.imported === child ? '.imported' : node.local === child ? '.local' : '';
            return node.type + extra;
        }
        if (node.type === 'ImportDeclaration') {
            const extra = node.source === child ? '.source' : '';
            return node.type + extra;
        }
        if (node.type === 'ExportSpecifier') {
            const extra = node.exported === child ? '.exported' : node.local === child ? '.local' : '';
            return node.type + extra;
        }
        if (node.type === 'ExportNamedDeclaration') {
            const extra = node.source === child ? '.source' : '';
            return node.type + extra;
        }
        if (node.type === 'Property') {
            const extra = node.key === child ? 'key' : node.value === child ? 'value' : '';
            return [node.type, node.kind, extra].join('.');
        }
        if (node.type === 'MemberExpression') {
            const extra = node.property === child ? 'property' : node.object === child ? 'object' : '';
            return node.type + '.' + extra;
        }
        if (node.type === 'ArrowFunctionExpression') {
            const extra = node.body === child ? 'body' : 'param';
            return node.type + '.' + extra;
        }
        if (node.type === 'FunctionDeclaration') {
            const extra = node.id === child ? 'id' : node.body === child ? 'body' : 'params';
            return node.type + '.' + extra;
        }
        if (node.type === 'ClassDeclaration' || node.type === 'ClassExpression') {
            const extra = node.id === child ? 'id' : node.body === child ? 'body' : 'superClass';
            return node.type + '.' + extra;
        }
        if (node.type === 'CallExpression') {
            const extra = node.callee === child ? 'callee' : 'arguments';
            return node.type + '.' + extra;
        }
        if (node.type === 'Literal') {
            return tagLiteral(node);
        }
        if (node.type === 'Block') {
            return node.value[0] === '*' ? 'Comment.docBlock' : 'Comment.block';
        }
        if (node.type === 'Line') {
            return 'Comment.line';
        }
        return node.type;
    }
    function inheritance(node) {
        const a = [...parents(node), node];
        return a.map(mapNode);
    }
    function* parents(node) {
        while (node && node.parent) {
            yield node.parent;
            node = node.parent;
        }
    }
    function inheritanceSummary(node) {
        return inheritance(node).join(' ');
    }
    /**
     * find the origin of a member expression
     */
    function findOriginObject(node) {
        const parent = node.parent;
        if (parent?.type !== 'MemberExpression' || parent.property !== node)
            return undefined;
        let obj = parent.object;
        while (obj.type === 'MemberExpression') {
            obj = obj.object;
        }
        return obj;
    }
    function isFunctionCall(node, name) {
        return node?.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === name;
    }
    function isRequireCall(node) {
        return isFunctionCall(node, 'require');
    }
    function isImportOrRequired(node) {
        return isRequireCall(node.parent) || (node.parent?.type === 'ImportDeclaration' && node.parent.source === node);
    }
    function debugNode(node, value) {
        if (!isDebugMode)
            return;
        const val = format('%o', value);
        log(`${inheritanceSummary(node)}: ${val}`);
    }
    walkTree(root, checkNode);
    return issues;
}
function tagLiteral(node) {
    assert(node.type === 'Literal');
    const kind = typeof node.value;
    const extra = kind === 'string'
        ? node.raw?.[0] === '"'
            ? 'string.double'
            : 'string.single'
        : node.value === null
            ? 'null'
            : kind;
    return node.type + '.' + extra;
}
const cache = { lastDoc: undefined };
const docValCache = new WeakMap();
function getDocValidator(filename, text, options) {
    const doc = getTextDocument(filename, text);
    const cachedValidator = docValCache.get(doc);
    if (cachedValidator) {
        refreshDictionaryCache(0);
        cachedValidator.updateDocumentText(text);
        return cachedValidator;
    }
    const settings = calcInitialSettings(options);
    isDebugMode = options.debugMode || false;
    const validator = new DocumentValidator(doc, options, settings);
    docValCache.set(doc, validator);
    return validator;
}
function calcInitialSettings(options) {
    const { customWordListFile, cwd } = options;
    if (!customWordListFile)
        return defaultSettings;
    const filePath = isCustomWordListFile(customWordListFile) ? customWordListFile.path : customWordListFile;
    const dictFile = path.resolve(cwd, filePath);
    const settings = {
        ...defaultSettings,
        dictionaryDefinitions: [{ name: 'eslint-plugin-custom-words', path: dictFile }],
        dictionaries: ['eslint-plugin-custom-words'],
    };
    return settings;
}
function getTextDocument(filename, content) {
    if (cache.lastDoc?.filename === filename) {
        return cache.lastDoc.doc;
    }
    const doc = createTextDocument({ uri: filename, content });
    cache.lastDoc = { filename, doc };
    return doc;
}
function isCustomWordListFile(value) {
    return !!value && typeof value === 'object';
}
const needToAdjustSpace = {
    Identifier: true,
};
const isSpecial = /[^\p{L}_0-9]/u;
const allSpecial = /[^\p{L}_0-9]/gu;
function normalizeSuggestions(suggestions, nodeType) {
    if (!suggestions)
        return undefined;
    if (!(nodeType in needToAdjustSpace))
        return suggestions;
    return suggestions.map((sug) => {
        if (!isSpecial.test(sug.word))
            return sug;
        const s = { ...sug };
        s.word = s.word.replace(allSpecial, '_');
        if (s.wordAdjustedToMatchCase) {
            s.wordAdjustedToMatchCase = s.wordAdjustedToMatchCase.replace(allSpecial, '_');
        }
        return s;
    });
}
//# sourceMappingURL=spellCheck.mjs.map