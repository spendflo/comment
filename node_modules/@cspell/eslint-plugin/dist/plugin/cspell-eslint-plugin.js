"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configs = exports.rules = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const synckit_1 = require("synckit");
const defaultCheckOptions_1 = require("./defaultCheckOptions");
const optionsSchema = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(__dirname, '../../assets/options.schema.json'), 'utf8'));
const schema = optionsSchema;
const spellCheck = (0, synckit_1.createSyncFn)(require.resolve('../worker/worker.mjs'), undefined, 30000);
const messages = {
    wordUnknown: 'Unknown word: "{{word}}"',
    wordForbidden: 'Forbidden word: "{{word}}"',
    suggestWord: '{{word}}{{preferred}}',
};
const meta = {
    docs: {
        description: 'CSpell spellchecker',
        category: 'Possible Errors',
        recommended: false,
    },
    messages,
    hasSuggestions: true,
    fixable: 'code',
    schema: [schema],
};
let isDebugMode = false;
function log(...args) {
    if (!isDebugMode)
        return;
    console.log(...args);
}
function nullFix() {
    return null;
}
function create(context) {
    const options = (0, defaultCheckOptions_1.normalizeOptions)(context.options[0], context.getCwd());
    const autoFix = options.autoFix;
    isDebugMode = options.debugMode || false;
    isDebugMode && logContext(context);
    function reportIssue(issue) {
        const messageId = issue.severity === 'Forbidden' ? 'wordForbidden' : 'wordUnknown';
        const { word, start, end } = issue;
        const data = {
            word,
        };
        const code = context.getSourceCode();
        const startPos = code.getLocFromIndex(start);
        const endPos = code.getLocFromIndex(end);
        const loc = { start: startPos, end: endPos };
        function fixFactory(word) {
            return (fixer) => fixer.replaceTextRange([start, end], word);
        }
        function createSug(sug) {
            const word = sug.wordAdjustedToMatchCase || sug.word;
            const preferred = sug.isPreferred ? '*' : '';
            const data = { word, preferred };
            const messageId = 'suggestWord';
            return {
                messageId,
                data,
                fix: fixFactory(word),
            };
        }
        log('Suggestions: %o', issue.suggestions);
        const fixable = issue.suggestions?.filter((sug) => !!sug.isPreferred);
        const canFix = fixable?.length === 1;
        const preferredSuggestion = autoFix && canFix && fixable[0];
        const fix = preferredSuggestion
            ? fixFactory(preferredSuggestion.wordAdjustedToMatchCase || preferredSuggestion.word)
            : nullFix;
        const suggestions = issue.suggestions?.map((sug) => createSug(sug));
        const suggest = suggestions;
        const des = {
            messageId,
            data,
            loc,
            suggest,
            fix,
        };
        context.report(des);
    }
    function checkProgram() {
        const sc = context.getSourceCode();
        const issues = spellCheck(context.getFilename(), sc.text, sc.ast, options);
        issues.forEach((issue) => reportIssue(issue));
    }
    return { Program: checkProgram };
}
exports.rules = {
    spellchecker: {
        meta,
        create,
    },
};
function logContext(context) {
    log('\n\n************************');
    // log(context.getSourceCode().text);
    log(`

id: ${context.id}
cwd: ${context.getCwd()}
filename: ${context.getFilename()}
physicalFilename: ${context.getPhysicalFilename()}
scope: ${context.getScope().type}
`);
}
exports.configs = {
    recommended: {
        plugins: ['@cspell'],
        rules: {
            '@cspell/spellchecker': ['warn', {}],
        },
    },
    debug: {
        plugins: ['@cspell'],
        rules: {
            '@cspell/spellchecker': ['warn', { debugMode: true }],
        },
    },
};
//# sourceMappingURL=cspell-eslint-plugin.js.map