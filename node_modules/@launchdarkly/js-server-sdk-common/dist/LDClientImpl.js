"use strict";
/* eslint-disable @typescript-eslint/no-unused-vars */
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable class-methods-use-this */
const js_sdk_common_1 = require("@launchdarkly/js-sdk-common");
const BigSegmentsManager_1 = require("./BigSegmentsManager");
const ClientMessages_1 = require("./ClientMessages");
const DataSourceUpdates_1 = require("./data_sources/DataSourceUpdates");
const NullUpdateProcessor_1 = require("./data_sources/NullUpdateProcessor");
const PollingProcessor_1 = require("./data_sources/PollingProcessor");
const Requestor_1 = require("./data_sources/Requestor");
const StreamingProcessor_1 = require("./data_sources/StreamingProcessor");
const errors_1 = require("./errors");
const collection_1 = require("./evaluation/collection");
const ErrorKinds_1 = require("./evaluation/ErrorKinds");
const EvalResult_1 = require("./evaluation/EvalResult");
const Evaluator_1 = require("./evaluation/Evaluator");
const ContextDeduplicator_1 = require("./events/ContextDeduplicator");
const DiagnosticsManager_1 = require("./events/DiagnosticsManager");
const EventFactory_1 = require("./events/EventFactory");
const EventSender_1 = require("./events/EventSender");
const isExperiment_1 = require("./events/isExperiment");
const NullEventProcessor_1 = require("./events/NullEventProcessor");
const FlagsStateBuilder_1 = require("./FlagsStateBuilder");
const Configuration_1 = require("./options/Configuration");
const store_1 = require("./store");
const VersionedDataKinds_1 = require("./store/VersionedDataKinds");
var InitState;
(function (InitState) {
    InitState[InitState["Initializing"] = 0] = "Initializing";
    InitState[InitState["Initialized"] = 1] = "Initialized";
    InitState[InitState["Failed"] = 2] = "Failed";
})(InitState || (InitState = {}));
/**
 * @ignore
 */
class LDClientImpl {
    constructor(sdkKey, platform, options, callbacks) {
        var _a, _b, _c, _d, _e;
        this.sdkKey = sdkKey;
        this.platform = platform;
        this.initState = InitState.Initializing;
        this.eventFactoryDefault = new EventFactory_1.default(false);
        this.eventFactoryWithReasons = new EventFactory_1.default(true);
        this.onError = callbacks.onError;
        this.onFailed = callbacks.onFailed;
        this.onReady = callbacks.onReady;
        const { onUpdate, hasEventListeners } = callbacks;
        const config = new Configuration_1.default(options);
        if (!sdkKey && !config.offline) {
            throw new Error('You must configure the client with an SDK key');
        }
        this.config = config;
        this.logger = config.logger;
        const clientContext = new js_sdk_common_1.ClientContext(sdkKey, config, platform);
        const featureStore = config.featureStoreFactory(clientContext);
        this.asyncFeatureStore = new store_1.AsyncStoreFacade(featureStore);
        const dataSourceUpdates = new DataSourceUpdates_1.default(featureStore, hasEventListeners, onUpdate);
        if (config.sendEvents && !config.offline && !config.diagnosticOptOut) {
            this.diagnosticsManager = new DiagnosticsManager_1.default(sdkKey, config, platform, featureStore);
        }
        const makeDefaultProcessor = () => config.stream
            ? new StreamingProcessor_1.default(sdkKey, config, this.platform.requests, this.platform.info, dataSourceUpdates, this.diagnosticsManager)
            : new PollingProcessor_1.default(config, new Requestor_1.default(sdkKey, config, this.platform.info, this.platform.requests), dataSourceUpdates);
        if (config.offline || config.useLdd) {
            this.updateProcessor = new NullUpdateProcessor_1.default();
        }
        else {
            this.updateProcessor =
                (_b = (_a = config.updateProcessorFactory) === null || _a === void 0 ? void 0 : _a.call(config, clientContext, dataSourceUpdates)) !== null && _b !== void 0 ? _b : makeDefaultProcessor();
        }
        if (!config.sendEvents || config.offline) {
            this.eventProcessor = new NullEventProcessor_1.default();
        }
        else {
            this.eventProcessor = new js_sdk_common_1.internal.EventProcessor(config, clientContext, new EventSender_1.default(config, clientContext), new ContextDeduplicator_1.default(config), this.diagnosticsManager);
        }
        this.featureStore = featureStore;
        const manager = new BigSegmentsManager_1.default((_d = (_c = config.bigSegments) === null || _c === void 0 ? void 0 : _c.store) === null || _d === void 0 ? void 0 : _d.call(_c, clientContext), (_e = config.bigSegments) !== null && _e !== void 0 ? _e : {}, config.logger, this.platform.crypto);
        this.bigSegmentsManager = manager;
        this.bigSegmentStatusProviderInternal = manager.statusProvider;
        const queries = {
            getFlag(key, cb) {
                featureStore.get(VersionedDataKinds_1.default.Features, key, (item) => cb(item));
            },
            getSegment(key, cb) {
                featureStore.get(VersionedDataKinds_1.default.Segments, key, (item) => cb(item));
            },
            getBigSegmentsMembership(userKey) {
                return manager.getUserMembership(userKey);
            },
        };
        this.evaluator = new Evaluator_1.default(this.platform, queries);
        this.updateProcessor.start((err) => {
            var _a, _b;
            if (err) {
                let error;
                if ((err.status && err.status === 401) || (err.code && err.code === 401)) {
                    error = new Error('Authentication failed. Double check your SDK key.');
                }
                else {
                    error = err;
                }
                this.onError(error);
                this.onFailed(error);
                if (!this.initialized()) {
                    this.initState = InitState.Failed;
                    (_a = this.initReject) === null || _a === void 0 ? void 0 : _a.call(this, error);
                }
            }
            else if (!this.initialized()) {
                this.initState = InitState.Initialized;
                (_b = this.initResolve) === null || _b === void 0 ? void 0 : _b.call(this, this);
                this.onReady();
            }
        });
    }
    initialized() {
        return this.initState === InitState.Initialized;
    }
    waitForInitialization() {
        if (this.initState === InitState.Initialized) {
            return Promise.resolve(this);
        }
        if (!this.initializedPromise) {
            this.initializedPromise = new Promise((resolve, reject) => {
                this.initResolve = resolve;
                this.initReject = reject;
            });
        }
        return this.initializedPromise;
    }
    variation(key, context, defaultValue, callback) {
        return new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, this.eventFactoryDefault, (res) => {
                resolve(res.detail.value);
                callback === null || callback === void 0 ? void 0 : callback(null, res.detail.value);
            });
        });
    }
    variationDetail(key, context, defaultValue, callback) {
        return new Promise((resolve) => {
            this.evaluateIfPossible(key, context, defaultValue, this.eventFactoryWithReasons, (res) => {
                resolve(res.detail);
                callback === null || callback === void 0 ? void 0 : callback(null, res.detail);
            });
        });
    }
    allFlagsState(context, options, callback) {
        var _a, _b, _c;
        if (this.config.offline) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('allFlagsState() called in offline mode. Returning empty state.');
            const allFlagState = new FlagsStateBuilder_1.default(false, false).build();
            callback === null || callback === void 0 ? void 0 : callback(null, allFlagState);
            return Promise.resolve(allFlagState);
        }
        const evalContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!evalContext.valid) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(`${(_c = evalContext.message) !== null && _c !== void 0 ? _c : 'Invalid context.'}. Returning empty state.`);
            return Promise.resolve(new FlagsStateBuilder_1.default(false, false).build());
        }
        return new Promise((resolve) => {
            const doEval = (valid) => this.featureStore.all(VersionedDataKinds_1.default.Features, (allFlags) => {
                const builder = new FlagsStateBuilder_1.default(valid, !!(options === null || options === void 0 ? void 0 : options.withReasons));
                const clientOnly = !!(options === null || options === void 0 ? void 0 : options.clientSideOnly);
                const detailsOnlyIfTracked = !!(options === null || options === void 0 ? void 0 : options.detailsOnlyForTrackedFlags);
                (0, collection_1.allAsync)(Object.values(allFlags), (storeItem, iterCb) => {
                    var _a;
                    const flag = storeItem;
                    if (clientOnly && !((_a = flag.clientSideAvailability) === null || _a === void 0 ? void 0 : _a.usingEnvironmentId)) {
                        iterCb(true);
                        return;
                    }
                    this.evaluator.evaluateCb(flag, evalContext, (res) => {
                        var _a;
                        if (res.isError) {
                            this.onError(new Error(`Error for feature flag "${flag.key}" while evaluating all flags: ${res.message}`));
                        }
                        const requireExperimentData = (0, isExperiment_1.default)(flag, res.detail.reason);
                        builder.addFlag(flag, res.detail.value, (_a = res.detail.variationIndex) !== null && _a !== void 0 ? _a : undefined, res.detail.reason, flag.trackEvents || requireExperimentData, requireExperimentData, detailsOnlyIfTracked);
                        iterCb(true);
                    });
                }, () => {
                    const res = builder.build();
                    callback === null || callback === void 0 ? void 0 : callback(null, res);
                    resolve(res);
                });
            });
            if (!this.initialized()) {
                this.featureStore.initialized((storeInitialized) => {
                    var _a, _b;
                    let valid = true;
                    if (storeInitialized) {
                        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('Called allFlagsState before client initialization; using last known' +
                            ' values from data store');
                    }
                    else {
                        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn('Called allFlagsState before client initialization. Data store not available; ' +
                            'returning empty state');
                        valid = false;
                    }
                    doEval(valid);
                });
            }
            else {
                doEval(true);
            }
        });
    }
    secureModeHash(context) {
        const checkedContext = js_sdk_common_1.Context.fromLDContext(context);
        const key = checkedContext.valid ? checkedContext.canonicalKey : undefined;
        const hmac = this.platform.crypto.createHmac('sha256', this.sdkKey);
        if (key === undefined) {
            throw new errors_1.LDClientError('Could not generate secure mode hash for invalid context');
        }
        hmac.update(key);
        return hmac.digest('hex');
    }
    close() {
        this.eventProcessor.close();
        this.updateProcessor.close();
        this.featureStore.close();
        this.bigSegmentsManager.close();
    }
    isOffline() {
        return this.config.offline;
    }
    track(key, context, data, metricValue) {
        var _a;
        const checkedContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!checkedContext.valid) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(ClientMessages_1.default.missingContextKeyNoEvent);
            return;
        }
        this.eventProcessor.sendEvent(this.eventFactoryDefault.customEvent(key, checkedContext, data, metricValue));
    }
    identify(context) {
        var _a;
        const checkedContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!checkedContext.valid) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(ClientMessages_1.default.missingContextKeyNoEvent);
            return;
        }
        this.eventProcessor.sendEvent(this.eventFactoryDefault.identifyEvent(checkedContext));
    }
    async flush(callback) {
        try {
            await this.eventProcessor.flush();
        }
        catch (err) {
            callback === null || callback === void 0 ? void 0 : callback(err, false);
        }
        callback === null || callback === void 0 ? void 0 : callback(null, true);
    }
    variationInternal(flagKey, context, defaultValue, eventFactory, cb) {
        var _a, _b;
        if (this.config.offline) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('Variation called in offline mode. Returning default value.');
            cb(EvalResult_1.default.forError(ErrorKinds_1.default.ClientNotReady, undefined, defaultValue));
            return;
        }
        const evalContext = js_sdk_common_1.Context.fromLDContext(context);
        if (!evalContext.valid) {
            this.onError(new errors_1.LDClientError(`${(_b = evalContext.message) !== null && _b !== void 0 ? _b : 'Context not valid;'} returning default value.`));
            cb(EvalResult_1.default.forError(ErrorKinds_1.default.UserNotSpecified, undefined, defaultValue));
            return;
        }
        this.featureStore.get(VersionedDataKinds_1.default.Features, flagKey, (item) => {
            const flag = item;
            if (!flag) {
                const error = new errors_1.LDClientError(`Unknown feature flag "${flagKey}"; returning default value`);
                this.onError(error);
                const result = EvalResult_1.default.forError(ErrorKinds_1.default.FlagNotFound, undefined, defaultValue);
                this.eventProcessor.sendEvent(this.eventFactoryDefault.unknownFlagEvent(flagKey, evalContext, result.detail));
                cb(result);
                return;
            }
            this.evaluator.evaluateCb(flag, evalContext, (evalRes) => {
                var _a, _b;
                if (evalRes.detail.variationIndex === undefined ||
                    evalRes.detail.variationIndex === null) {
                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Result value is null in variation');
                    evalRes.setDefault(defaultValue);
                }
                (_b = evalRes.events) === null || _b === void 0 ? void 0 : _b.forEach((event) => {
                    this.eventProcessor.sendEvent(event);
                });
                this.eventProcessor.sendEvent(eventFactory.evalEvent(flag, evalContext, evalRes.detail, defaultValue));
                cb(evalRes);
            }, eventFactory);
        });
    }
    evaluateIfPossible(flagKey, context, defaultValue, eventFactory, cb) {
        if (!this.initialized()) {
            this.featureStore.initialized((storeInitialized) => {
                var _a, _b;
                if (storeInitialized) {
                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('Variation called before LaunchDarkly client initialization completed' +
                        " (did you wait for the 'ready' event?) - using last known values from feature store");
                    this.variationInternal(flagKey, context, defaultValue, eventFactory, cb);
                    return;
                }
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn('Variation called before LaunchDarkly client initialization completed (did you wait for the' +
                    "'ready' event?) - using default value");
                cb(EvalResult_1.default.forError(ErrorKinds_1.default.ClientNotReady, undefined, defaultValue));
            });
            return;
        }
        this.variationInternal(flagKey, context, defaultValue, eventFactory, cb);
    }
}
exports.default = LDClientImpl;
//# sourceMappingURL=LDClientImpl.js.map