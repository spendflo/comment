"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const js_sdk_common_1 = require("@launchdarkly/js-sdk-common");
const defaultHeaders_1 = require("../data_sources/defaultHeaders");
const httpErrorMessage_1 = require("../data_sources/httpErrorMessage");
const errors_1 = require("../errors");
class EventSender {
    constructor(config, clientContext) {
        this.defaultHeaders = Object.assign({}, (0, defaultHeaders_1.default)(clientContext.basicConfiguration.sdkKey, config, clientContext.platform.info));
        this.eventsUri = `${clientContext.basicConfiguration.serviceEndpoints.events}/bulk`;
        this.diagnosticEventsUri = `${clientContext.basicConfiguration.serviceEndpoints.events}/diagnostic`;
        this.requests = clientContext.platform.requests;
        this.crypto = clientContext.platform.crypto;
    }
    async tryPostingEvents(events, uri, payloadId, canRetry) {
        const tryRes = {
            status: js_sdk_common_1.subsystem.LDDeliveryStatus.Succeeded,
        };
        const headers = Object.assign(Object.assign({}, this.defaultHeaders), { 'content-type': 'application/json' });
        if (payloadId) {
            headers['x-launchdarkly-payload-id'] = payloadId;
            headers['x-launchDarkly-event-schema'] = '4';
        }
        let error;
        try {
            const res = await this.requests.fetch(uri, {
                headers,
                body: JSON.stringify(events),
                method: 'POST',
            });
            const serverDate = Date.parse(res.headers.get('date') || '');
            if (serverDate) {
                tryRes.serverTime = serverDate;
            }
            if (res.status <= 204) {
                return tryRes;
            }
            error = new errors_1.LDUnexpectedResponseError((0, httpErrorMessage_1.default)({ status: res.status, message: 'some events were dropped' }, 'event posting'));
            if (!(0, errors_1.isHttpRecoverable)(res.status)) {
                tryRes.status = js_sdk_common_1.subsystem.LDDeliveryStatus.FailedAndMustShutDown;
                tryRes.error = error;
                return tryRes;
            }
        }
        catch (err) {
            error = err;
        }
        if (error && !canRetry) {
            tryRes.status = js_sdk_common_1.subsystem.LDDeliveryStatus.Failed;
            tryRes.error = error;
            return tryRes;
        }
        await new Promise((r) => {
            setTimeout(r, 1000);
        });
        return this.tryPostingEvents(events, this.eventsUri, payloadId, false);
    }
    async sendEventData(type, data) {
        const payloadId = type === js_sdk_common_1.subsystem.LDEventType.AnalyticsEvents ? this.crypto.randomUUID() : undefined;
        const uri = type === js_sdk_common_1.subsystem.LDEventType.AnalyticsEvents ? this.eventsUri : this.diagnosticEventsUri;
        return this.tryPostingEvents(data, uri, payloadId, true);
    }
}
exports.default = EventSender;
//# sourceMappingURL=EventSender.js.map