"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Configuration_1 = require("../options/Configuration");
function secondsToMillis(sec) {
    return Math.trunc(sec * 1000);
}
/**
 * Maintains information for diagnostic events.
 *
 * @internal
 */
class DiagnosticsManager {
    constructor(sdkKey, config, platform, featureStore) {
        this.config = config;
        this.platform = platform;
        this.featureStore = featureStore;
        this.streamInits = [];
        this.startTime = Date.now();
        this.dataSinceDate = this.startTime;
        this.id = {
            diagnosticId: platform.crypto.randomUUID(),
            sdkKeySuffix: sdkKey.length > 6 ? sdkKey.substring(sdkKey.length - 6) : sdkKey,
        };
    }
    /**
     * Creates the initial event that is sent by the event processor when the SDK starts up. This will
     * not be repeated during the lifetime of the SDK client.
     */
    createInitEvent() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const sdkData = this.platform.info.sdkData();
        const platformData = this.platform.info.platformData();
        return {
            kind: 'diagnostic-init',
            id: this.id,
            creationDate: this.startTime,
            sdk: sdkData,
            configuration: {
                customBaseURI: this.config.serviceEndpoints.polling !== Configuration_1.defaultValues.baseUri,
                customStreamURI: this.config.serviceEndpoints.streaming !== Configuration_1.defaultValues.streamUri,
                customEventsURI: this.config.serviceEndpoints.events !== Configuration_1.defaultValues.eventsUri,
                eventsCapacity: this.config.eventsCapacity,
                // Node doesn't distinguish between these two kinds of timeouts. It is unlikely other web
                // based implementations would be able to either.
                connectTimeoutMillis: secondsToMillis(this.config.timeout),
                socketTimeoutMillis: secondsToMillis(this.config.timeout),
                eventsFlushIntervalMillis: secondsToMillis(this.config.flushInterval),
                pollingIntervalMillis: secondsToMillis(this.config.pollInterval),
                reconnectTimeMillis: secondsToMillis(this.config.streamInitialReconnectDelay),
                streamingDisabled: !this.config.stream,
                usingRelayDaemon: this.config.useLdd,
                offline: this.config.offline,
                allAttributesPrivate: this.config.allAttributesPrivate,
                contextKeysCapacity: this.config.contextKeysCapacity,
                contextKeysFlushIntervalMillis: secondsToMillis(this.config.contextKeysFlushInterval),
                usingProxy: !!((_b = (_a = this.platform.requests).usingProxy) === null || _b === void 0 ? void 0 : _b.call(_a)),
                usingProxyAuthenticator: !!((_d = (_c = this.platform.requests).usingProxyAuth) === null || _d === void 0 ? void 0 : _d.call(_c)),
                diagnosticRecordingIntervalMillis: secondsToMillis(this.config.diagnosticRecordingInterval),
                dataStoreType: (_g = (_f = (_e = this.featureStore).getDescription) === null || _f === void 0 ? void 0 : _f.call(_e)) !== null && _g !== void 0 ? _g : 'memory',
            },
            platform: Object.assign({ name: platformData.name, osArch: (_h = platformData.os) === null || _h === void 0 ? void 0 : _h.arch, osName: (_j = platformData.os) === null || _j === void 0 ? void 0 : _j.name, osVersion: (_k = platformData.os) === null || _k === void 0 ? void 0 : _k.version }, (platformData.additional || {})),
        };
    }
    /**
     * Records a stream connection attempt (called by the stream processor).
     *
     * @param timestamp Time of the *beginning* of the connection attempt.
     * @param failed True if the connection failed, or we got a read timeout before receiving a "put".
     * @param durationMillis Elapsed time between starting timestamp and when we either gave up/lost
     * the connection or received a successful "put".
     */
    recordStreamInit(timestamp, failed, durationMillis) {
        const item = { timestamp, failed, durationMillis };
        this.streamInits.push(item);
    }
    /**
     * Creates a periodic event containing time-dependent stats, and resets the state of the manager
     * with regard to those stats.
     *
     * Note: the reason droppedEvents, deduplicatedUsers, and eventsInLastBatch are passed into this
     * function, instead of being properties of the DiagnosticsManager, is that the event processor is
     * the one who's calling this function and is also the one who's tracking those stats.
     */
    createStatsEventAndReset(droppedEvents, deduplicatedUsers, eventsInLastBatch) {
        const currentTime = Date.now();
        const evt = {
            kind: 'diagnostic',
            id: this.id,
            creationDate: currentTime,
            dataSinceDate: this.dataSinceDate,
            droppedEvents,
            deduplicatedUsers,
            eventsInLastBatch,
            streamInits: this.streamInits,
        };
        this.streamInits = [];
        this.dataSinceDate = currentTime;
        return evt;
    }
}
exports.default = DiagnosticsManager;
//# sourceMappingURL=DiagnosticsManager.js.map