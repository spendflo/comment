import { LDContext, LDEvaluationDetail, Platform } from '@launchdarkly/js-sdk-common';
import { LDClient, LDFlagsState, LDFlagsStateOptions, LDOptions } from './api';
import BigSegmentStoreStatusProvider from './BigSegmentStatusProviderImpl';
export interface LDClientCallbacks {
    onError: (err: Error) => void;
    onFailed: (err: Error) => void;
    onReady: () => void;
    onUpdate: (key: string) => void;
    hasEventListeners: () => boolean;
}
/**
 * @ignore
 */
export default class LDClientImpl implements LDClient {
    private sdkKey;
    private platform;
    private initState;
    private featureStore;
    private asyncFeatureStore;
    private updateProcessor;
    private eventFactoryDefault;
    private eventFactoryWithReasons;
    private eventProcessor;
    private evaluator;
    private initResolve?;
    private initReject?;
    private initializedPromise?;
    private logger?;
    private config;
    private bigSegmentsManager;
    private onError;
    private onFailed;
    private onReady;
    private diagnosticsManager?;
    /**
     * Intended for use by platform specific client implementations.
     *
     * It is not included in the main interface because it requires the use of
     * a platform event system. For node this would be an EventEmitter, for other
     * platforms it would likely be an EventTarget.
     */
    protected bigSegmentStatusProviderInternal: BigSegmentStoreStatusProvider;
    constructor(sdkKey: string, platform: Platform, options: LDOptions, callbacks: LDClientCallbacks);
    initialized(): boolean;
    waitForInitialization(): Promise<LDClient>;
    variation(key: string, context: LDContext, defaultValue: any, callback?: (err: any, res: any) => void): Promise<any>;
    variationDetail(key: string, context: LDContext, defaultValue: any, callback?: (err: any, res: LDEvaluationDetail) => void): Promise<LDEvaluationDetail>;
    allFlagsState(context: LDContext, options?: LDFlagsStateOptions, callback?: (err: Error | null, res: LDFlagsState) => void): Promise<LDFlagsState>;
    secureModeHash(context: LDContext): string;
    close(): void;
    isOffline(): boolean;
    track(key: string, context: LDContext, data?: any, metricValue?: number): void;
    identify(context: LDContext): void;
    flush(callback?: (err: Error | null, res: boolean) => void): Promise<void>;
    private variationInternal;
    private evaluateIfPossible;
}
//# sourceMappingURL=LDClientImpl.d.ts.map