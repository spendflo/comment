"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const serialization_1 = require("../store/serialization");
const VersionedDataKinds_1 = require("../store/VersionedDataKinds");
const httpErrorMessage_1 = require("./httpErrorMessage");
/**
 * @internal
 */
class PollingProcessor {
    constructor(config, requestor, featureStore) {
        this.requestor = requestor;
        this.featureStore = featureStore;
        this.stopped = false;
        this.logger = config.logger;
        this.pollInterval = config.pollInterval;
        this.featureStore = featureStore;
    }
    poll(fn) {
        var _a;
        if (this.stopped) {
            return;
        }
        const reportJsonError = (data) => {
            var _a, _b;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error('Polling received invalid data');
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`Invalid JSON follows: ${data}`);
            fn === null || fn === void 0 ? void 0 : fn(new errors_1.LDPollingError('Malformed JSON data in polling response'));
        };
        const startTime = Date.now();
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Polling LaunchDarkly for feature flag updates');
        this.requestor.requestAllData((err, body) => {
            var _a, _b, _c;
            const elapsed = Date.now() - startTime;
            const sleepFor = Math.max(this.pollInterval * 1000 - elapsed, 0);
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Elapsed: %d ms, sleeping for %d ms', elapsed, sleepFor);
            if (err) {
                if (err.status && !(0, errors_1.isHttpRecoverable)(err.status)) {
                    const message = (0, httpErrorMessage_1.default)(err, 'polling request');
                    (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(message);
                    fn === null || fn === void 0 ? void 0 : fn(new errors_1.LDPollingError(message));
                    // It is not recoverable, return and do not trigger another
                    // poll.
                    return;
                }
                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.warn((0, httpErrorMessage_1.default)(err, 'polling request', 'will retry'));
            }
            else if (body) {
                const parsed = (0, serialization_1.deserializePoll)(body);
                if (!parsed) {
                    // We could not parse this JSON. Report the problem and fallthrough to
                    // start another poll.
                    reportJsonError(body);
                }
                else {
                    const initData = {
                        [VersionedDataKinds_1.default.Features.namespace]: parsed.flags,
                        [VersionedDataKinds_1.default.Segments.namespace]: parsed.segments,
                    };
                    this.featureStore.init(initData, () => {
                        fn === null || fn === void 0 ? void 0 : fn();
                        // Triggering the next poll after the init has completed.
                        this.timeoutHandle = setTimeout(() => {
                            this.poll(fn);
                        }, sleepFor);
                    });
                    // The poll will be triggered by  the feature store initialization
                    // completing.
                    return;
                }
            }
            // Falling through, there was some type of error and we need to trigger
            // a new poll.
            this.timeoutHandle = setTimeout(() => {
                this.poll(fn);
            }, sleepFor);
        });
    }
    start(fn) {
        this.poll(fn);
    }
    stop() {
        if (this.timeoutHandle) {
            clearTimeout(this.timeoutHandle);
            this.timeoutHandle = undefined;
        }
        this.stopped = true;
    }
    close() {
        this.stop();
    }
}
exports.default = PollingProcessor;
//# sourceMappingURL=PollingProcessor.js.map