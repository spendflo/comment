"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = require("../errors");
const serialization_1 = require("../store/serialization");
const VersionedDataKinds_1 = require("../store/VersionedDataKinds");
const defaultHeaders_1 = require("./defaultHeaders");
const httpErrorMessage_1 = require("./httpErrorMessage");
const STREAM_READ_TIMEOUT_MS = 5 * 60 * 1000;
const RETRY_RESET_INTERVAL_MS = 60 * 1000;
function getKeyFromPath(kind, path) {
    return path.startsWith(kind.streamApiPath)
        ? path.substring(kind.streamApiPath.length)
        : undefined;
}
/**
 * @internal
 */
class StreamingProcessor {
    constructor(sdkKey, config, requests, info, featureStore, diagnosticsManager) {
        this.featureStore = featureStore;
        this.diagnosticsManager = diagnosticsManager;
        this.headers = (0, defaultHeaders_1.default)(sdkKey, config, info);
        this.logger = config.logger;
        this.streamInitialReconnectDelay = config.streamInitialReconnectDelay;
        this.requests = requests;
        this.streamUri = `${config.serviceEndpoints.streaming}/all`;
    }
    logConnectionStarted() {
        this.connectionAttemptStartTime = Date.now();
    }
    logConnectionResult(success) {
        if (this.connectionAttemptStartTime && this.diagnosticsManager) {
            this.diagnosticsManager.recordStreamInit(this.connectionAttemptStartTime, !success, Date.now() - this.connectionAttemptStartTime);
        }
        this.connectionAttemptStartTime = undefined;
    }
    start(fn) {
        this.logConnectionStarted();
        const errorFilter = (err) => {
            var _a, _b;
            if (err.status && !(0, errors_1.isHttpRecoverable)(err.status)) {
                this.logConnectionResult(false);
                fn === null || fn === void 0 ? void 0 : fn(new errors_1.LDStreamingError(err.message, err.status));
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error((0, httpErrorMessage_1.default)(err, 'streaming request'));
                return false;
            }
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warn((0, httpErrorMessage_1.default)(err, 'streaming request', 'will retry'));
            this.logConnectionResult(false);
            this.logConnectionStarted();
            return true;
        };
        const reportJsonError = (type, data) => {
            var _a, _b;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`Stream received invalid data in "${type}" message`);
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`Invalid JSON follows: ${data}`);
            fn === null || fn === void 0 ? void 0 : fn(new errors_1.LDStreamingError('Malformed JSON data in event stream'));
        };
        // TLS is handled by the platform implementation.
        const eventSource = this.requests.createEventSource(this.streamUri, {
            headers: this.headers,
            errorFilter,
            initialRetryDelayMillis: 1000 * this.streamInitialReconnectDelay,
            readTimeoutMillis: STREAM_READ_TIMEOUT_MS,
            retryResetIntervalMillis: RETRY_RESET_INTERVAL_MS,
        });
        this.eventSource = eventSource;
        eventSource.onclose = () => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('Closed LaunchDarkly stream connection');
        };
        eventSource.onerror = () => {
            // The work is done by `errorFilter`.
        };
        eventSource.onopen = () => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info('Opened LaunchDarkly stream connection');
        };
        eventSource.onretrying = (e) => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`Will retry stream connection in ${e.delayMillis} milliseconds`);
        };
        eventSource.addEventListener('put', (event) => {
            var _a;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Received put event');
            if (event && event.data) {
                this.logConnectionResult(true);
                const parsed = (0, serialization_1.deserializeAll)(event.data);
                if (!parsed) {
                    reportJsonError('put', event.data);
                    return;
                }
                const initData = {
                    [VersionedDataKinds_1.default.Features.namespace]: parsed.data.flags,
                    [VersionedDataKinds_1.default.Segments.namespace]: parsed.data.segments,
                };
                this.featureStore.init(initData, () => fn === null || fn === void 0 ? void 0 : fn());
            }
            else {
                fn === null || fn === void 0 ? void 0 : fn(new errors_1.LDStreamingError('Unexpected payload from event stream'));
            }
        });
        eventSource.addEventListener('patch', (event) => {
            var _a, _b;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Received patch event');
            if (event && event.data) {
                const parsed = (0, serialization_1.deserializePatch)(event.data);
                if (!parsed) {
                    reportJsonError('patch', event.data);
                    return;
                }
                if (parsed.kind) {
                    const key = getKeyFromPath(parsed.kind, parsed.path);
                    if (key) {
                        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`Updating ${key} in ${parsed.kind.namespace}`);
                        this.featureStore.upsert(parsed.kind, parsed.data, () => { });
                    }
                }
            }
            else {
                fn === null || fn === void 0 ? void 0 : fn(new errors_1.LDStreamingError('Unexpected payload from event stream'));
            }
        });
        eventSource.addEventListener('delete', (event) => {
            var _a, _b;
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Received delete event');
            if (event && event.data) {
                const parsed = (0, serialization_1.deserializeDelete)(event.data);
                if (!parsed) {
                    reportJsonError('delete', event.data);
                    return;
                }
                if (parsed.kind) {
                    const key = getKeyFromPath(parsed.kind, parsed.path);
                    if (key) {
                        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`Deleting ${key} in ${parsed.kind.namespace}`);
                        this.featureStore.upsert(parsed.kind, {
                            key,
                            version: parsed.version,
                            deleted: true,
                        }, () => { });
                    }
                }
            }
            else {
                fn === null || fn === void 0 ? void 0 : fn(new errors_1.LDStreamingError('Unexpected payload from event stream'));
            }
        });
    }
    stop() {
        var _a;
        (_a = this.eventSource) === null || _a === void 0 ? void 0 : _a.close();
        this.eventSource = undefined;
    }
    close() {
        this.stop();
    }
}
exports.default = StreamingProcessor;
//# sourceMappingURL=StreamingProcessor.js.map