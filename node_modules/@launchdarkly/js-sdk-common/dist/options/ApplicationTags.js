"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const validators_1 = require("../validators");
const OptionMessages_1 = require("./OptionMessages");
/**
 * Expression to validate characters that are allowed in tag keys and values.
 */
const allowedTagCharacters = /^(\w|\.|-)+$/;
const regexValidator = validators_1.TypeValidators.stringMatchingRegex(allowedTagCharacters);
const tagValidator = {
    is: (u, name) => {
        if (regexValidator.is(u)) {
            if (u.length > 64) {
                return { valid: false, message: OptionMessages_1.default.tagValueTooLong(name) };
            }
            return { valid: true };
        }
        return { valid: false, message: OptionMessages_1.default.invalidTagValue(name) };
    },
};
/**
 * Class for managing tags.
 */
class ApplicationTags {
    constructor(options) {
        var _a, _b;
        const tags = {};
        const application = options === null || options === void 0 ? void 0 : options.application;
        if ((application === null || application === void 0 ? void 0 : application.id) !== null && (application === null || application === void 0 ? void 0 : application.id) !== undefined) {
            const { valid, message } = tagValidator.is(application.id, 'application.id');
            if (!valid) {
                (_a = options.logger) === null || _a === void 0 ? void 0 : _a.warn(message);
            }
            else {
                tags['application-id'] = [application.id];
            }
        }
        if ((application === null || application === void 0 ? void 0 : application.version) !== null && (application === null || application === void 0 ? void 0 : application.version) !== undefined) {
            const { valid, message } = tagValidator.is(application.version, 'application.version');
            if (!valid) {
                (_b = options.logger) === null || _b === void 0 ? void 0 : _b.warn(message);
            }
            else {
                tags['application-version'] = [application.version];
            }
        }
        const tagKeys = Object.keys(tags);
        if (tagKeys.length) {
            this.value = tagKeys
                .sort()
                .flatMap((key) => tags[key].sort().map((value) => `${key}/${value}`))
                .join(' ');
        }
    }
}
exports.default = ApplicationTags;
//# sourceMappingURL=ApplicationTags.js.map