import LDContextDeduplicator from '../../api/subsystem/LDContextDeduplicator';
import LDEventProcessor from '../../api/subsystem/LDEventProcessor';
import LDEventSender from '../../api/subsystem/LDEventSender';
import ClientContext from '../../options/ClientContext';
import InputEvent from './InputEvent';
/**
 * The event processor doesn't need to know anything about the shape of the
 * diagnostic events.
 */
type DiagnosticEvent = any;
export interface EventProcessorOptions {
    allAttributesPrivate: boolean;
    privateAttributes: string[];
    eventsCapacity: number;
    flushInterval: number;
    diagnosticRecordingInterval: number;
}
interface LDDiagnosticsManager {
    createInitEvent(): DiagnosticEvent;
    createStatsEventAndReset(droppedEvents: number, deduplicatedUsers: number, eventsInLastBatch: number): DiagnosticEvent;
}
export default class EventProcessor implements LDEventProcessor {
    private readonly eventSender;
    private readonly contextDeduplicator;
    private readonly diagnosticsManager?;
    private summarizer;
    private queue;
    private lastKnownPastTime;
    private droppedEvents;
    private deduplicatedUsers;
    private exceededCapacity;
    private eventsInLastBatch;
    private shutdown;
    private capacity;
    private logger?;
    private contextFilter;
    private diagnosticsTimer;
    private flushTimer;
    private flushUsersTimer;
    constructor(config: EventProcessorOptions, clientContext: ClientContext, eventSender: LDEventSender, contextDeduplicator: LDContextDeduplicator, diagnosticsManager?: LDDiagnosticsManager | undefined);
    private postDiagnosticEvent;
    close(): void;
    flush(): Promise<void>;
    sendEvent(inputEvent: InputEvent): void;
    private makeOutputEvent;
    private enqueue;
    private shouldDebugEvent;
    private tryPostingEvents;
}
export {};
//# sourceMappingURL=EventProcessor.d.ts.map