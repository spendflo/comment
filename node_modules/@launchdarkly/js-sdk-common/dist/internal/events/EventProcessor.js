"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LDEventSender_1 = require("../../api/subsystem/LDEventSender");
const AttributeReference_1 = require("../../AttributeReference");
const ContextFilter_1 = require("../../ContextFilter");
const EventSummarizer_1 = require("./EventSummarizer");
const guards_1 = require("./guards");
const LDInvalidSDKKeyError_1 = require("./LDInvalidSDKKeyError");
class EventProcessor {
    constructor(config, clientContext, eventSender, contextDeduplicator, diagnosticsManager) {
        this.eventSender = eventSender;
        this.contextDeduplicator = contextDeduplicator;
        this.diagnosticsManager = diagnosticsManager;
        this.summarizer = new EventSummarizer_1.default();
        this.queue = [];
        this.lastKnownPastTime = 0;
        this.droppedEvents = 0;
        this.deduplicatedUsers = 0;
        this.exceededCapacity = false;
        this.eventsInLastBatch = 0;
        this.shutdown = false;
        this.flushUsersTimer = null;
        this.capacity = config.eventsCapacity;
        this.logger = clientContext.basicConfiguration.logger;
        this.contextFilter = new ContextFilter_1.default(config.allAttributesPrivate, config.privateAttributes.map((ref) => new AttributeReference_1.default(ref)));
        if (this.contextDeduplicator.flushInterval !== undefined) {
            this.flushUsersTimer = setInterval(() => {
                this.contextDeduplicator.flush();
            }, this.contextDeduplicator.flushInterval * 1000);
        }
        this.flushTimer = setInterval(async () => {
            try {
                await this.flush();
            }
            catch (_a) {
                // Eat the errors.
            }
        }, config.flushInterval * 1000);
        if (this.diagnosticsManager) {
            const initEvent = diagnosticsManager.createInitEvent();
            this.postDiagnosticEvent(initEvent);
            this.diagnosticsTimer = setInterval(() => {
                const statsEvent = this.diagnosticsManager.createStatsEventAndReset(this.droppedEvents, this.deduplicatedUsers, this.eventsInLastBatch);
                this.droppedEvents = 0;
                this.deduplicatedUsers = 0;
                this.postDiagnosticEvent(statsEvent);
            }, config.diagnosticRecordingInterval * 1000);
        }
    }
    postDiagnosticEvent(event) {
        this.eventSender.sendEventData(LDEventSender_1.LDEventType.DiagnosticEvent, event);
    }
    close() {
        clearInterval(this.flushTimer);
        if (this.flushUsersTimer) {
            clearInterval(this.flushUsersTimer);
        }
        if (this.diagnosticsTimer) {
            clearInterval(this.diagnosticsTimer);
        }
    }
    async flush() {
        var _a;
        if (this.shutdown) {
            throw new LDInvalidSDKKeyError_1.default('Events cannot be posted because SDK key is invalid');
        }
        const eventsToFlush = this.queue;
        this.queue = [];
        const summary = this.summarizer.getSummary();
        this.summarizer.clearSummary();
        if (Object.keys(summary.features).length) {
            eventsToFlush.push(summary);
        }
        if (!eventsToFlush.length) {
            return;
        }
        this.eventsInLastBatch = eventsToFlush.length;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Flushing %d events', eventsToFlush.length);
        await this.tryPostingEvents(eventsToFlush);
    }
    sendEvent(inputEvent) {
        if (this.shutdown) {
            return;
        }
        this.summarizer.summarizeEvent(inputEvent);
        const isFeatureEvent = (0, guards_1.isFeature)(inputEvent);
        const addFullEvent = (isFeatureEvent && inputEvent.trackEvents) || !isFeatureEvent;
        const addDebugEvent = this.shouldDebugEvent(inputEvent);
        const isIdentifyEvent = (0, guards_1.isIdentify)(inputEvent);
        const shouldNotDeduplicate = this.contextDeduplicator.processContext(inputEvent.context);
        // If there is no cache, then it will never be in the cache.
        if (!shouldNotDeduplicate) {
            if (!isIdentifyEvent) {
                this.deduplicatedUsers += 1;
            }
        }
        const addIndexEvent = shouldNotDeduplicate && !isIdentifyEvent;
        if (addIndexEvent) {
            this.enqueue({
                kind: 'index',
                creationDate: inputEvent.creationDate,
                context: this.contextFilter.filter(inputEvent.context),
            });
        }
        if (addFullEvent) {
            this.enqueue(this.makeOutputEvent(inputEvent, false));
        }
        if (addDebugEvent) {
            this.enqueue(this.makeOutputEvent(inputEvent, true));
        }
    }
    makeOutputEvent(event, debug) {
        switch (event.kind) {
            case 'feature': {
                const out = {
                    kind: debug ? 'debug' : 'feature',
                    creationDate: event.creationDate,
                    key: event.key,
                    value: event.value,
                    default: event.default,
                    prereqOf: event.prereqOf,
                };
                if (event.variation !== undefined) {
                    out.variation = event.variation;
                }
                if (event.version !== undefined) {
                    out.version = event.version;
                }
                if (event.reason) {
                    out.reason = event.reason;
                }
                if (debug) {
                    out.context = this.contextFilter.filter(event.context);
                }
                else {
                    out.contextKeys = event.context.kindsAndKeys;
                }
                return out;
            }
            case 'identify': {
                return {
                    kind: 'identify',
                    creationDate: event.creationDate,
                    context: this.contextFilter.filter(event.context),
                };
            }
            case 'custom': {
                const out = {
                    kind: 'custom',
                    creationDate: event.creationDate,
                    key: event.key,
                    contextKeys: event.context.kindsAndKeys,
                };
                if (event.data !== undefined) {
                    out.data = event.data;
                }
                if (event.metricValue !== undefined) {
                    out.metricValue = event.metricValue;
                }
                return out;
            }
            default:
                // This would happen during the addition of a new event type to the SDK.
                return event;
        }
    }
    enqueue(event) {
        var _a;
        if (this.queue.length < this.capacity) {
            this.queue.push(event);
            this.exceededCapacity = false;
        }
        else {
            if (!this.exceededCapacity) {
                this.exceededCapacity = true;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn('Exceeded event queue capacity. Increase capacity to avoid dropping events.');
            }
            this.droppedEvents += 1;
        }
    }
    shouldDebugEvent(event) {
        return ((0, guards_1.isFeature)(event) &&
            event.debugEventsUntilDate &&
            event.debugEventsUntilDate > this.lastKnownPastTime &&
            event.debugEventsUntilDate > Date.now());
    }
    async tryPostingEvents(events) {
        const res = await this.eventSender.sendEventData(LDEventSender_1.LDEventType.AnalyticsEvents, events);
        if (res.status === LDEventSender_1.LDDeliveryStatus.FailedAndMustShutDown) {
            this.shutdown = true;
        }
        if (res.serverTime) {
            this.lastKnownPastTime = res.serverTime;
        }
        if (res.error) {
            throw res.error;
        }
    }
}
exports.default = EventProcessor;
//# sourceMappingURL=EventProcessor.js.map