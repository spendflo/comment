import { jsx } from 'react/jsx-runtime';
import { createContext, useRef, useContext, useState } from 'react';
import { createStore } from 'jotai/vanilla';
import { useAtom, useAtomValue, useSetAtom, useStore, Provider } from 'jotai/react';
import { useHydrateAtoms } from 'jotai/react/utils';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

function createIsolation() {
  const StoreContext = createContext(null);
  const Provider = ({
    store,
    initialValues: _initialValues = [],
    children
  }) => {
    const storeRef = useRef(store);
    if (!storeRef.current) {
      storeRef.current = createStore();
    }
    useHydrateAtoms(_initialValues, {
      store: storeRef.current
    });
    return jsx(StoreContext.Provider, {
      value: storeRef.current,
      children: children
    });
  };
  const useAtom$1 = (anAtom, options) => {
    const store = useContext(StoreContext);
    if (!store) {
      throw new Error('Missing Provider from createIsolation');
    }
    return useAtom(anAtom, _extends({
      store
    }, options));
  };
  const useAtomValue$1 = (anAtom, options) => {
    const store = useContext(StoreContext);
    if (!store) {
      throw new Error('Missing Provider from createIsolation');
    }
    return useAtomValue(anAtom, _extends({
      store
    }, options));
  };
  const useSetAtom$1 = (anAtom, options) => {
    const store = useContext(StoreContext);
    if (!store) {
      throw new Error('Missing Provider from createIsolation');
    }
    return useSetAtom(anAtom, _extends({
      store
    }, options));
  };
  return {
    Provider,
    useAtom: useAtom$1,
    useAtomValue: useAtomValue$1,
    useSetAtom: useSetAtom$1
  };
}

const isEqualSet = (a, b) => a === b || a.size === b.size && Array.from(a).every(v => b.has(v));
const ScopeContext = createContext(a => a);
const ScopeProvider = ({
  atoms,
  children
}) => {
  const store = useStore();
  const getParentScopedAtom = useContext(ScopeContext);
  const atomSet = new Set(atoms);
  const initialize = () => {
    const mapping = new WeakMap();
    const createScopedAtom = (anAtom, delegate) => {
      const getAtom = (thisArg, orig, target) => {
        if (target === thisArg) {
          return delegate ? getParentScopedAtom(orig) : target;
        }
        return getScopedAtom(target);
      };
      const scopedAtom = _extends({}, anAtom, 'read' in anAtom && {
        read(get, opts) {
          return anAtom.read.call(this, a => get(getAtom(this, anAtom, a)), opts);
        }
      }, 'write' in anAtom && {
        write(get, set, ...args) {
          return anAtom.write.call(this, a => get(getAtom(this, anAtom, a)), (a, ...v) => set(getAtom(this, anAtom, a), ...v), ...args);
        }
      });
      return scopedAtom;
    };
    const getScopedAtom = anAtom => {
      let scopedAtom = mapping.get(anAtom);
      if (!scopedAtom) {
        scopedAtom = atomSet.has(anAtom) ? createScopedAtom(anAtom, false) : createScopedAtom(anAtom, true);
        mapping.set(anAtom, scopedAtom);
      }
      return scopedAtom;
    };
    const patchedStore = _extends({}, store, {
      get: (anAtom, ...args) => store.get(getScopedAtom(anAtom), ...args),
      set: (anAtom, ...args) => store.set(getScopedAtom(anAtom), ...args),
      sub: (anAtom, ...args) => store.sub(getScopedAtom(anAtom), ...args)
    });
    return [patchedStore, getScopedAtom, store, getParentScopedAtom, atomSet];
  };
  const [state, setState] = useState(initialize);
  if (store !== state[2] || getParentScopedAtom !== state[3] || !isEqualSet(atomSet, state[4])) {
    setState(initialize);
  }
  const [patchedStore, getScopedAtom] = state;
  return jsx(ScopeContext.Provider, {
    value: getScopedAtom,
    children: jsx(Provider, {
      store: patchedStore,
      children: children
    })
  });
};

export { ScopeContext as INTERNAL_ScopeContext, ScopeProvider, createIsolation };
//# sourceMappingURL=index.modern.mjs.map
