(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react/jsx-runtime'), require('react'), require('jotai/vanilla'), require('jotai/react'), require('jotai/react/utils')) :
  typeof define === 'function' && define.amd ? define(['exports', 'react/jsx-runtime', 'react', 'jotai/vanilla', 'jotai/react', 'jotai/react/utils'], factory) :
  (global = global || self, factory(global.jotaiScope = {}, global.jsxRuntime, global.React, global.vanilla, global.react$1, global.utils));
})(this, (function (exports, jsxRuntime, react, vanilla, react$1, utils) {
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  function createIsolation() {
    var StoreContext = react.createContext(null);
    var Provider = function Provider(_ref) {
      var store = _ref.store,
        _ref$initialValues = _ref.initialValues,
        initialValues = _ref$initialValues === void 0 ? [] : _ref$initialValues,
        children = _ref.children;
      var storeRef = react.useRef(store);
      if (!storeRef.current) {
        storeRef.current = vanilla.createStore();
      }
      utils.useHydrateAtoms(initialValues, {
        store: storeRef.current
      });
      return jsxRuntime.jsx(StoreContext.Provider, {
        value: storeRef.current,
        children: children
      });
    };
    var useAtom = function useAtom(anAtom, options) {
      var store = react.useContext(StoreContext);
      if (!store) {
        throw new Error('Missing Provider from createIsolation');
      }
      return react$1.useAtom(anAtom, _extends({
        store: store
      }, options));
    };
    var useAtomValue = function useAtomValue(anAtom, options) {
      var store = react.useContext(StoreContext);
      if (!store) {
        throw new Error('Missing Provider from createIsolation');
      }
      return react$1.useAtomValue(anAtom, _extends({
        store: store
      }, options));
    };
    var useSetAtom = function useSetAtom(anAtom, options) {
      var store = react.useContext(StoreContext);
      if (!store) {
        throw new Error('Missing Provider from createIsolation');
      }
      return react$1.useSetAtom(anAtom, _extends({
        store: store
      }, options));
    };
    return {
      Provider: Provider,
      useAtom: useAtom,
      useAtomValue: useAtomValue,
      useSetAtom: useSetAtom
    };
  }

  var isEqualSet = function isEqualSet(a, b) {
    return a === b || a.size === b.size && Array.from(a).every(function (v) {
      return b.has(v);
    });
  };
  var ScopeContext = react.createContext(function (a) {
    return a;
  });
  var ScopeProvider = function ScopeProvider(_ref) {
    var atoms = _ref.atoms,
      children = _ref.children;
    var store = react$1.useStore();
    var getParentScopedAtom = react.useContext(ScopeContext);
    var atomSet = new Set(atoms);
    var initialize = function initialize() {
      var mapping = new WeakMap();
      var createScopedAtom = function createScopedAtom(anAtom, delegate) {
        var getAtom = function getAtom(thisArg, orig, target) {
          if (target === thisArg) {
            return delegate ? getParentScopedAtom(orig) : target;
          }
          return getScopedAtom(target);
        };
        var scopedAtom = _extends({}, anAtom, 'read' in anAtom && {
          read: function read(get, opts) {
            var _this2 = this;
            return anAtom.read.call(this, function (a) {
              return get(getAtom(_this2, anAtom, a));
            }, opts);
          }
        }, 'write' in anAtom && {
          write: function write(get, set) {
            var _anAtom$write,
              _this3 = this;
            var _this = this;
            return (_anAtom$write = anAtom.write).call.apply(_anAtom$write, [this, function (a) {
              return get(getAtom(_this3, anAtom, a));
            }, function (a) {
              return set.apply(void 0, [getAtom(_this, anAtom, a)].concat([].slice.call(arguments, 1)));
            }].concat([].slice.call(arguments, 2)));
          }
        });
        return scopedAtom;
      };
      var getScopedAtom = function getScopedAtom(anAtom) {
        var scopedAtom = mapping.get(anAtom);
        if (!scopedAtom) {
          scopedAtom = atomSet.has(anAtom) ? createScopedAtom(anAtom, false) : createScopedAtom(anAtom, true);
          mapping.set(anAtom, scopedAtom);
        }
        return scopedAtom;
      };
      var patchedStore = _extends({}, store, {
        get: function get(anAtom) {
          return store.get.apply(store, [getScopedAtom(anAtom)].concat([].slice.call(arguments, 1)));
        },
        set: function set(anAtom) {
          return store.set.apply(store, [getScopedAtom(anAtom)].concat([].slice.call(arguments, 1)));
        },
        sub: function sub(anAtom) {
          return store.sub.apply(store, [getScopedAtom(anAtom)].concat([].slice.call(arguments, 1)));
        }
      });
      return [patchedStore, getScopedAtom, store, getParentScopedAtom, atomSet];
    };
    var _useState = react.useState(initialize),
      state = _useState[0],
      setState = _useState[1];
    if (store !== state[2] || getParentScopedAtom !== state[3] || !isEqualSet(atomSet, state[4])) {
      setState(initialize);
    }
    var patchedStore = state[0],
      getScopedAtom = state[1];
    return jsxRuntime.jsx(ScopeContext.Provider, {
      value: getScopedAtom,
      children: jsxRuntime.jsx(react$1.Provider, {
        store: patchedStore,
        children: children
      })
    });
  };

  exports.INTERNAL_ScopeContext = ScopeContext;
  exports.ScopeProvider = ScopeProvider;
  exports.createIsolation = createIsolation;

}));
//# sourceMappingURL=index.umd.js.map
