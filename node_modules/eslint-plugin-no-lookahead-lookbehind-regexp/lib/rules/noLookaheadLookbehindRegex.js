"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noLookaheadLookbehindRegexp = exports.getExpressionsToCheckFromConfiguration = exports.DEFAULT_OPTIONS = void 0;
const analyzeRegExpForLookAheadAndLookbehind_1 = require("./../helpers/analyzeRegExpForLookAheadAndLookbehind");
const caniuse_1 = require("./../helpers/caniuse");
const ast_1 = require("./../helpers/ast");
const createReport_1 = require("../helpers/createReport");
exports.DEFAULT_OPTIONS = {
    "no-lookahead": 1,
    "no-lookbehind": 1,
    "no-negative-lookahead": 1,
    "no-negative-lookbehind": 1,
};
const getExpressionsToCheckFromConfiguration = (options) => {
    if (!options.length)
        return exports.DEFAULT_OPTIONS;
    const validOptions = options.filter((option) => {
        if (typeof option !== "string")
            return false;
        return exports.DEFAULT_OPTIONS[option];
    });
    if (!validOptions.length) {
        return exports.DEFAULT_OPTIONS;
    }
    return validOptions.reduce((acc, opt) => {
        acc[opt] = 1;
        return acc;
    }, {
        "no-lookahead": 0,
        "no-lookbehind": 0,
        "no-negative-lookahead": 0,
        "no-negative-lookbehind": 0,
    });
};
exports.getExpressionsToCheckFromConfiguration = getExpressionsToCheckFromConfiguration;
const noLookaheadLookbehindRegexp = {
    meta: {
        docs: {
            description: "disallow the use of lookahead and lookbehind regexes if unsupported by browser",
            category: "Compatibility",
            recommended: true,
        },
        type: "problem",
    },
    create(context) {
        const browsers = context.settings.browsers || context.settings.targets;
        const { targets, hasConfig } = (0, caniuse_1.collectBrowserTargets)(context.getFilename(), browsers);
        const unsupportedTargets = (0, caniuse_1.collectUnsupportedTargets)("js-regexp-lookbehind", targets);
        const rules = (0, exports.getExpressionsToCheckFromConfiguration)(context.options);
        // If there are no unsupported targets resolved from the browserlist config, then we can skip this rule
        if (!unsupportedTargets.length && hasConfig)
            return {};
        return {
            Literal(node) {
                if ((0, ast_1.isStringLiteralRegExp)(node) && typeof node.raw === "string") {
                    const unsupportedGroups = (0, analyzeRegExpForLookAheadAndLookbehind_1.analyzeRegExpForLookaheadAndLookbehind)(node.raw, { rules } // For string literals, we need to pass the raw value which includes escape characters.
                    );
                    if (unsupportedGroups.length > 0) {
                        (0, createReport_1.createContextReport)(node, context, unsupportedGroups, unsupportedTargets);
                    }
                }
                else if ((0, ast_1.isRegExpLiteral)(node)) {
                    const unsupportedGroups = (0, analyzeRegExpForLookAheadAndLookbehind_1.analyzeRegExpForLookaheadAndLookbehind)(node.regex.pattern, {
                        rules,
                    });
                    if (unsupportedGroups.length > 0) {
                        (0, createReport_1.createContextReport)(node, context, unsupportedGroups, unsupportedTargets);
                    }
                }
            },
        };
    },
};
exports.noLookaheadLookbehindRegexp = noLookaheadLookbehindRegexp;
