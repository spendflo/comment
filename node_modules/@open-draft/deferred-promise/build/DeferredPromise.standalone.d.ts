/**
 * This is a standalone implementation of `DeferredPromise` that
 * doesn't rely on the Promise class at all.
 * @author https://github.com/jonaskuske
 */
export declare type Executor<T> = ConstructorParameters<typeof Promise<T>>[0];
export declare type ResolveFn<T> = Parameters<Executor<T>>[0];
export declare type RejectFn<T> = Parameters<Executor<T>>[1];
export declare class DeferredPromise<T, ResolveT = T> implements Promise<T> {
    #private;
    get [Symbol.toStringTag](): string;
    resolve: ResolveFn<ResolveT>;
    reject: RejectFn<ResolveT>;
    get state(): "pending" | "fulfilled" | "rejected";
    get rejectionReason(): unknown;
    constructor(executor?: Executor<T> | null);
    then<ThenResult = T, CatchResult = never>(onFulfill?: (value: T) => ThenResult | PromiseLike<ThenResult>, onReject?: (reason: any) => CatchResult | PromiseLike<CatchResult>): DeferredPromise<ThenResult | CatchResult, ResolveT>;
    catch<CatchResult = never>(onReject?: (reason: any) => CatchResult | PromiseLike<CatchResult>): DeferredPromise<T | CatchResult, ResolveT>;
    finally(onFinally?: () => void | Promise<any>): DeferredPromise<T, ResolveT>;
}
