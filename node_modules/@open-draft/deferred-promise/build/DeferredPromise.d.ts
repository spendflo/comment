import { type Executor, type RejectFunction, type ResolveFunction } from './createDeferredExecutor';
export declare class DeferredPromise<Input, Output = Input> extends Promise<Input> {
    #private;
    resolve: ResolveFunction<Output>;
    reject: RejectFunction<Output>;
    constructor(executor?: Executor<Input> | null);
    get state(): import("./createDeferredExecutor").PromiseState;
    get rejectionReason(): unknown;
    then<ThenResult = Input, CatchResult = never>(onFulfilled?: (value: Input) => ThenResult | PromiseLike<ThenResult>, onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>): DeferredPromise<ThenResult | CatchResult, Output>;
    catch<CatchResult = never>(onRejected?: (reason: any) => CatchResult | PromiseLike<CatchResult>): DeferredPromise<Input | CatchResult, Output>;
    finally(onfinally?: () => void | Promise<any>): DeferredPromise<Input, Output>;
}
