"use strict";
/**
 * This is a standalone implementation of `DeferredPromise` that
 * doesn't rely on the Promise class at all.
 * @author https://github.com/jonaskuske
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeferredPromise = void 0;
class DeferredPromise {
    get [Symbol.toStringTag]() {
        return 'DeferredPromise';
    }
    #state = 'pending';
    #value = undefined;
    #queue = [];
    resolve;
    reject;
    get state() {
        return this.#state;
    }
    get rejectionReason() {
        return this.#state === 'rejected' ? this.#value : undefined;
    }
    constructor(executor = null) {
        let handled = false;
        const resolve = (value) => {
            !handled && (handled = true) && queueMicrotask(() => this.#fulfill(value));
        };
        const reject = (reason) => {
            !handled && (handled = true) && queueMicrotask(() => this.#reject(reason));
        };
        try {
            executor?.(resolve, reject);
        }
        catch (reason) {
            reject(reason);
        }
        this.resolve = resolve;
        this.reject = reject;
    }
    then(onFulfill, onReject) {
        if (typeof onFulfill !== 'function')
            onFulfill = (x) => x;
        if (typeof onReject !== 'function') {
            onReject = (x) => {
                throw x;
            };
        }
        const childPromise = new DeferredPromise();
        const childResolve = childPromise.resolve;
        const childReject = childPromise.reject;
        const onParentResolved = () => {
            try {
                childResolve((this.#state === 'rejected' ? onReject : onFulfill)(this.#value));
            }
            catch (reason) {
                childReject(reason);
            }
        };
        // If parent promise is already done, resolve the child in the next microtask.
        if (this.#state !== 'pending')
            queueMicrotask(onParentResolved);
        // Otherwise we register a callback. Once the parent is done, its callbacks
        // run so the child promise will resolve. Unshift so that the queue pops in order.
        else
            this.#queue.unshift(onParentResolved);
        childPromise.resolve = this.resolve;
        childPromise.reject = this.reject;
        return childPromise;
    }
    catch(onReject) {
        return this.then(undefined, onReject);
    }
    finally(onFinally) {
        const resolveValueIfFinallyFulfills = (value) => {
            const resolveFinally = (resolve) => resolve(onFinally?.());
            return new DeferredPromise(resolveFinally).then(() => value);
        };
        return this.then(resolveValueIfFinallyFulfills, (reason) => {
            return resolveValueIfFinallyFulfills(reason).then(() => {
                throw reason;
            });
        });
    }
    // Recursively unwrap promises until we reach a non-thenable value.
    // Fulfill with this value or reject if something in the chain throws/rejects.
    #fulfill(next) {
        // @ts-ignore
        if (next === this) {
            // @ts-ignore
            return this.#reject(new TypeError(`Chaining cycle detected for promise: ${next}`));
        }
        // If next could be a thenable (object or function), check for a .then method.
        // It could be a getter that throws - catch and reject promise in that case.
        let then;
        if (typeof next === 'object' || typeof next === 'function') {
            try {
                then = next?.then;
            }
            catch (error) {
                return this.#reject(error);
            }
        }
        // If next is a thenable, unwrap it: add onResolve and onReject callbacks
        // that recursively call #fulfill, which will then check for the next thenable.
        if (typeof then === 'function') {
            let handled = false;
            const onResolve = (value) => {
                !handled && (handled = true) && this.#fulfill(value);
            };
            const onReject = (reason) => {
                !handled && (handled = true) && this.#reject(reason);
            };
            try {
                then.call(next, onResolve, onReject);
            }
            catch (reason) {
                onReject(reason);
            }
        }
        else {
            // If next isn't a thenable, the chain is fully unwrapped to its final value.
            // Settle (change state & set value), then run the queued .then callbacks.
            this.#value = next;
            this.#state = 'fulfilled';
            let callback;
            while ((callback = this.#queue.pop()))
                callback();
        }
    }
    // Rejecting has no unwrapping behavior, so we can settle immediately.
    #reject(reason) {
        this.#value = reason;
        this.#state = 'rejected';
        let callback;
        while ((callback = this.#queue.pop()))
            callback();
    }
}
exports.DeferredPromise = DeferredPromise;
//# sourceMappingURL=DeferredPromise.standalone.js.map