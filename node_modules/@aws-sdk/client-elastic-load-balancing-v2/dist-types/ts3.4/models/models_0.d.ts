import { ExceptionOptionType as __ExceptionOptionType } from "@smithy/smithy-client";
import { ElasticLoadBalancingV2ServiceException as __BaseException } from "./ElasticLoadBalancingV2ServiceException";
export declare const AuthenticateCognitoActionConditionalBehaviorEnum: {
  readonly ALLOW: "allow";
  readonly AUTHENTICATE: "authenticate";
  readonly DENY: "deny";
};
export type AuthenticateCognitoActionConditionalBehaviorEnum =
  (typeof AuthenticateCognitoActionConditionalBehaviorEnum)[keyof typeof AuthenticateCognitoActionConditionalBehaviorEnum];
export interface AuthenticateCognitoActionConfig {
  UserPoolArn: string | undefined;
  UserPoolClientId: string | undefined;
  UserPoolDomain: string | undefined;
  SessionCookieName?: string;
  Scope?: string;
  SessionTimeout?: number;
  AuthenticationRequestExtraParams?: Record<string, string>;
  OnUnauthenticatedRequest?:
    | AuthenticateCognitoActionConditionalBehaviorEnum
    | string;
}
export declare const AuthenticateOidcActionConditionalBehaviorEnum: {
  readonly ALLOW: "allow";
  readonly AUTHENTICATE: "authenticate";
  readonly DENY: "deny";
};
export type AuthenticateOidcActionConditionalBehaviorEnum =
  (typeof AuthenticateOidcActionConditionalBehaviorEnum)[keyof typeof AuthenticateOidcActionConditionalBehaviorEnum];
export interface AuthenticateOidcActionConfig {
  Issuer: string | undefined;
  AuthorizationEndpoint: string | undefined;
  TokenEndpoint: string | undefined;
  UserInfoEndpoint: string | undefined;
  ClientId: string | undefined;
  ClientSecret?: string;
  SessionCookieName?: string;
  Scope?: string;
  SessionTimeout?: number;
  AuthenticationRequestExtraParams?: Record<string, string>;
  OnUnauthenticatedRequest?:
    | AuthenticateOidcActionConditionalBehaviorEnum
    | string;
  UseExistingClientSecret?: boolean;
}
export interface FixedResponseActionConfig {
  MessageBody?: string;
  StatusCode: string | undefined;
  ContentType?: string;
}
export interface TargetGroupTuple {
  TargetGroupArn?: string;
  Weight?: number;
}
export interface TargetGroupStickinessConfig {
  Enabled?: boolean;
  DurationSeconds?: number;
}
export interface ForwardActionConfig {
  TargetGroups?: TargetGroupTuple[];
  TargetGroupStickinessConfig?: TargetGroupStickinessConfig;
}
export declare const RedirectActionStatusCodeEnum: {
  readonly HTTP_301: "HTTP_301";
  readonly HTTP_302: "HTTP_302";
};
export type RedirectActionStatusCodeEnum =
  (typeof RedirectActionStatusCodeEnum)[keyof typeof RedirectActionStatusCodeEnum];
export interface RedirectActionConfig {
  Protocol?: string;
  Port?: string;
  Host?: string;
  Path?: string;
  Query?: string;
  StatusCode: RedirectActionStatusCodeEnum | string | undefined;
}
export declare const ActionTypeEnum: {
  readonly AUTHENTICATE_COGNITO: "authenticate-cognito";
  readonly AUTHENTICATE_OIDC: "authenticate-oidc";
  readonly FIXED_RESPONSE: "fixed-response";
  readonly FORWARD: "forward";
  readonly REDIRECT: "redirect";
};
export type ActionTypeEnum =
  (typeof ActionTypeEnum)[keyof typeof ActionTypeEnum];
export interface Action {
  Type: ActionTypeEnum | string | undefined;
  TargetGroupArn?: string;
  AuthenticateOidcConfig?: AuthenticateOidcActionConfig;
  AuthenticateCognitoConfig?: AuthenticateCognitoActionConfig;
  Order?: number;
  RedirectConfig?: RedirectActionConfig;
  FixedResponseConfig?: FixedResponseActionConfig;
  ForwardConfig?: ForwardActionConfig;
}
export interface Certificate {
  CertificateArn?: string;
  IsDefault?: boolean;
}
export interface AddListenerCertificatesInput {
  ListenerArn: string | undefined;
  Certificates: Certificate[] | undefined;
}
export interface AddListenerCertificatesOutput {
  Certificates?: Certificate[];
}
export declare class CertificateNotFoundException extends __BaseException {
  readonly name: "CertificateNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<CertificateNotFoundException, __BaseException>
  );
}
export declare class ListenerNotFoundException extends __BaseException {
  readonly name: "ListenerNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ListenerNotFoundException, __BaseException>
  );
}
export declare class TooManyCertificatesException extends __BaseException {
  readonly name: "TooManyCertificatesException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyCertificatesException, __BaseException>
  );
}
export interface Tag {
  Key: string | undefined;
  Value?: string;
}
export interface AddTagsInput {
  ResourceArns: string[] | undefined;
  Tags: Tag[] | undefined;
}
export interface AddTagsOutput {}
export declare class DuplicateTagKeysException extends __BaseException {
  readonly name: "DuplicateTagKeysException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<DuplicateTagKeysException, __BaseException>
  );
}
export declare class LoadBalancerNotFoundException extends __BaseException {
  readonly name: "LoadBalancerNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<LoadBalancerNotFoundException, __BaseException>
  );
}
export declare class RuleNotFoundException extends __BaseException {
  readonly name: "RuleNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<RuleNotFoundException, __BaseException>
  );
}
export declare class TargetGroupNotFoundException extends __BaseException {
  readonly name: "TargetGroupNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TargetGroupNotFoundException, __BaseException>
  );
}
export declare class TooManyTagsException extends __BaseException {
  readonly name: "TooManyTagsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyTagsException, __BaseException>
  );
}
export declare class AllocationIdNotFoundException extends __BaseException {
  readonly name: "AllocationIdNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<AllocationIdNotFoundException, __BaseException>
  );
}
export declare class ALPNPolicyNotSupportedException extends __BaseException {
  readonly name: "ALPNPolicyNotSupportedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      ALPNPolicyNotSupportedException,
      __BaseException
    >
  );
}
export interface LoadBalancerAddress {
  IpAddress?: string;
  AllocationId?: string;
  PrivateIPv4Address?: string;
  IPv6Address?: string;
}
export interface AvailabilityZone {
  ZoneName?: string;
  SubnetId?: string;
  OutpostId?: string;
  LoadBalancerAddresses?: LoadBalancerAddress[];
}
export declare class AvailabilityZoneNotSupportedException extends __BaseException {
  readonly name: "AvailabilityZoneNotSupportedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      AvailabilityZoneNotSupportedException,
      __BaseException
    >
  );
}
export interface Cipher {
  Name?: string;
  Priority?: number;
}
export declare const ProtocolEnum: {
  readonly GENEVE: "GENEVE";
  readonly HTTP: "HTTP";
  readonly HTTPS: "HTTPS";
  readonly TCP: "TCP";
  readonly TCP_UDP: "TCP_UDP";
  readonly TLS: "TLS";
  readonly UDP: "UDP";
};
export type ProtocolEnum = (typeof ProtocolEnum)[keyof typeof ProtocolEnum];
export interface CreateListenerInput {
  LoadBalancerArn: string | undefined;
  Protocol?: ProtocolEnum | string;
  Port?: number;
  SslPolicy?: string;
  Certificates?: Certificate[];
  DefaultActions: Action[] | undefined;
  AlpnPolicy?: string[];
  Tags?: Tag[];
}
export interface Listener {
  ListenerArn?: string;
  LoadBalancerArn?: string;
  Port?: number;
  Protocol?: ProtocolEnum | string;
  Certificates?: Certificate[];
  SslPolicy?: string;
  DefaultActions?: Action[];
  AlpnPolicy?: string[];
}
export interface CreateListenerOutput {
  Listeners?: Listener[];
}
export declare class DuplicateListenerException extends __BaseException {
  readonly name: "DuplicateListenerException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<DuplicateListenerException, __BaseException>
  );
}
export declare class IncompatibleProtocolsException extends __BaseException {
  readonly name: "IncompatibleProtocolsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<IncompatibleProtocolsException, __BaseException>
  );
}
export declare class InvalidConfigurationRequestException extends __BaseException {
  readonly name: "InvalidConfigurationRequestException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      InvalidConfigurationRequestException,
      __BaseException
    >
  );
}
export declare class InvalidLoadBalancerActionException extends __BaseException {
  readonly name: "InvalidLoadBalancerActionException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      InvalidLoadBalancerActionException,
      __BaseException
    >
  );
}
export declare class SSLPolicyNotFoundException extends __BaseException {
  readonly name: "SSLPolicyNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<SSLPolicyNotFoundException, __BaseException>
  );
}
export declare class TargetGroupAssociationLimitException extends __BaseException {
  readonly name: "TargetGroupAssociationLimitException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      TargetGroupAssociationLimitException,
      __BaseException
    >
  );
}
export declare class TooManyActionsException extends __BaseException {
  readonly name: "TooManyActionsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyActionsException, __BaseException>
  );
}
export declare class TooManyListenersException extends __BaseException {
  readonly name: "TooManyListenersException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyListenersException, __BaseException>
  );
}
export declare class TooManyRegistrationsForTargetIdException extends __BaseException {
  readonly name: "TooManyRegistrationsForTargetIdException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      TooManyRegistrationsForTargetIdException,
      __BaseException
    >
  );
}
export declare class TooManyTargetsException extends __BaseException {
  readonly name: "TooManyTargetsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyTargetsException, __BaseException>
  );
}
export declare class TooManyUniqueTargetGroupsPerLoadBalancerException extends __BaseException {
  readonly name: "TooManyUniqueTargetGroupsPerLoadBalancerException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      TooManyUniqueTargetGroupsPerLoadBalancerException,
      __BaseException
    >
  );
}
export declare class UnsupportedProtocolException extends __BaseException {
  readonly name: "UnsupportedProtocolException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<UnsupportedProtocolException, __BaseException>
  );
}
export declare const IpAddressType: {
  readonly DUALSTACK: "dualstack";
  readonly IPV4: "ipv4";
};
export type IpAddressType = (typeof IpAddressType)[keyof typeof IpAddressType];
export declare const LoadBalancerSchemeEnum: {
  readonly INTERNAL: "internal";
  readonly INTERNET_FACING: "internet-facing";
};
export type LoadBalancerSchemeEnum =
  (typeof LoadBalancerSchemeEnum)[keyof typeof LoadBalancerSchemeEnum];
export interface SubnetMapping {
  SubnetId?: string;
  AllocationId?: string;
  PrivateIPv4Address?: string;
  IPv6Address?: string;
}
export declare const LoadBalancerTypeEnum: {
  readonly APPLICATION: "application";
  readonly GATEWAY: "gateway";
  readonly NETWORK: "network";
};
export type LoadBalancerTypeEnum =
  (typeof LoadBalancerTypeEnum)[keyof typeof LoadBalancerTypeEnum];
export interface CreateLoadBalancerInput {
  Name: string | undefined;
  Subnets?: string[];
  SubnetMappings?: SubnetMapping[];
  SecurityGroups?: string[];
  Scheme?: LoadBalancerSchemeEnum | string;
  Tags?: Tag[];
  Type?: LoadBalancerTypeEnum | string;
  IpAddressType?: IpAddressType | string;
  CustomerOwnedIpv4Pool?: string;
}
export declare const LoadBalancerStateEnum: {
  readonly ACTIVE: "active";
  readonly ACTIVE_IMPAIRED: "active_impaired";
  readonly FAILED: "failed";
  readonly PROVISIONING: "provisioning";
};
export type LoadBalancerStateEnum =
  (typeof LoadBalancerStateEnum)[keyof typeof LoadBalancerStateEnum];
export interface LoadBalancerState {
  Code?: LoadBalancerStateEnum | string;
  Reason?: string;
}
export interface LoadBalancer {
  LoadBalancerArn?: string;
  DNSName?: string;
  CanonicalHostedZoneId?: string;
  CreatedTime?: Date;
  LoadBalancerName?: string;
  Scheme?: LoadBalancerSchemeEnum | string;
  VpcId?: string;
  State?: LoadBalancerState;
  Type?: LoadBalancerTypeEnum | string;
  AvailabilityZones?: AvailabilityZone[];
  SecurityGroups?: string[];
  IpAddressType?: IpAddressType | string;
  CustomerOwnedIpv4Pool?: string;
}
export interface CreateLoadBalancerOutput {
  LoadBalancers?: LoadBalancer[];
}
export declare class DuplicateLoadBalancerNameException extends __BaseException {
  readonly name: "DuplicateLoadBalancerNameException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      DuplicateLoadBalancerNameException,
      __BaseException
    >
  );
}
export declare class InvalidSchemeException extends __BaseException {
  readonly name: "InvalidSchemeException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidSchemeException, __BaseException>
  );
}
export declare class InvalidSecurityGroupException extends __BaseException {
  readonly name: "InvalidSecurityGroupException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidSecurityGroupException, __BaseException>
  );
}
export declare class InvalidSubnetException extends __BaseException {
  readonly name: "InvalidSubnetException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidSubnetException, __BaseException>
  );
}
export declare class OperationNotPermittedException extends __BaseException {
  readonly name: "OperationNotPermittedException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<OperationNotPermittedException, __BaseException>
  );
}
export declare class ResourceInUseException extends __BaseException {
  readonly name: "ResourceInUseException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<ResourceInUseException, __BaseException>
  );
}
export declare class SubnetNotFoundException extends __BaseException {
  readonly name: "SubnetNotFoundException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<SubnetNotFoundException, __BaseException>
  );
}
export declare class TooManyLoadBalancersException extends __BaseException {
  readonly name: "TooManyLoadBalancersException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyLoadBalancersException, __BaseException>
  );
}
export interface HostHeaderConditionConfig {
  Values?: string[];
}
export interface HttpHeaderConditionConfig {
  HttpHeaderName?: string;
  Values?: string[];
}
export interface HttpRequestMethodConditionConfig {
  Values?: string[];
}
export interface PathPatternConditionConfig {
  Values?: string[];
}
export interface QueryStringKeyValuePair {
  Key?: string;
  Value?: string;
}
export interface QueryStringConditionConfig {
  Values?: QueryStringKeyValuePair[];
}
export interface SourceIpConditionConfig {
  Values?: string[];
}
export interface RuleCondition {
  Field?: string;
  Values?: string[];
  HostHeaderConfig?: HostHeaderConditionConfig;
  PathPatternConfig?: PathPatternConditionConfig;
  HttpHeaderConfig?: HttpHeaderConditionConfig;
  QueryStringConfig?: QueryStringConditionConfig;
  HttpRequestMethodConfig?: HttpRequestMethodConditionConfig;
  SourceIpConfig?: SourceIpConditionConfig;
}
export interface CreateRuleInput {
  ListenerArn: string | undefined;
  Conditions: RuleCondition[] | undefined;
  Priority: number | undefined;
  Actions: Action[] | undefined;
  Tags?: Tag[];
}
export interface Rule {
  RuleArn?: string;
  Priority?: string;
  Conditions?: RuleCondition[];
  Actions?: Action[];
  IsDefault?: boolean;
}
export interface CreateRuleOutput {
  Rules?: Rule[];
}
export declare class PriorityInUseException extends __BaseException {
  readonly name: "PriorityInUseException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<PriorityInUseException, __BaseException>
  );
}
export declare class TooManyRulesException extends __BaseException {
  readonly name: "TooManyRulesException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyRulesException, __BaseException>
  );
}
export declare class TooManyTargetGroupsException extends __BaseException {
  readonly name: "TooManyTargetGroupsException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<TooManyTargetGroupsException, __BaseException>
  );
}
export declare const TargetGroupIpAddressTypeEnum: {
  readonly IPV4: "ipv4";
  readonly IPV6: "ipv6";
};
export type TargetGroupIpAddressTypeEnum =
  (typeof TargetGroupIpAddressTypeEnum)[keyof typeof TargetGroupIpAddressTypeEnum];
export interface Matcher {
  HttpCode?: string;
  GrpcCode?: string;
}
export declare const TargetTypeEnum: {
  readonly ALB: "alb";
  readonly INSTANCE: "instance";
  readonly IP: "ip";
  readonly LAMBDA: "lambda";
};
export type TargetTypeEnum =
  (typeof TargetTypeEnum)[keyof typeof TargetTypeEnum];
export interface CreateTargetGroupInput {
  Name: string | undefined;
  Protocol?: ProtocolEnum | string;
  ProtocolVersion?: string;
  Port?: number;
  VpcId?: string;
  HealthCheckProtocol?: ProtocolEnum | string;
  HealthCheckPort?: string;
  HealthCheckEnabled?: boolean;
  HealthCheckPath?: string;
  HealthCheckIntervalSeconds?: number;
  HealthCheckTimeoutSeconds?: number;
  HealthyThresholdCount?: number;
  UnhealthyThresholdCount?: number;
  Matcher?: Matcher;
  TargetType?: TargetTypeEnum | string;
  Tags?: Tag[];
  IpAddressType?: TargetGroupIpAddressTypeEnum | string;
}
export interface TargetGroup {
  TargetGroupArn?: string;
  TargetGroupName?: string;
  Protocol?: ProtocolEnum | string;
  Port?: number;
  VpcId?: string;
  HealthCheckProtocol?: ProtocolEnum | string;
  HealthCheckPort?: string;
  HealthCheckEnabled?: boolean;
  HealthCheckIntervalSeconds?: number;
  HealthCheckTimeoutSeconds?: number;
  HealthyThresholdCount?: number;
  UnhealthyThresholdCount?: number;
  HealthCheckPath?: string;
  Matcher?: Matcher;
  LoadBalancerArns?: string[];
  TargetType?: TargetTypeEnum | string;
  ProtocolVersion?: string;
  IpAddressType?: TargetGroupIpAddressTypeEnum | string;
}
export interface CreateTargetGroupOutput {
  TargetGroups?: TargetGroup[];
}
export declare class DuplicateTargetGroupNameException extends __BaseException {
  readonly name: "DuplicateTargetGroupNameException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<
      DuplicateTargetGroupNameException,
      __BaseException
    >
  );
}
export interface DeleteListenerInput {
  ListenerArn: string | undefined;
}
export interface DeleteListenerOutput {}
export interface DeleteLoadBalancerInput {
  LoadBalancerArn: string | undefined;
}
export interface DeleteLoadBalancerOutput {}
export interface DeleteRuleInput {
  RuleArn: string | undefined;
}
export interface DeleteRuleOutput {}
export interface DeleteTargetGroupInput {
  TargetGroupArn: string | undefined;
}
export interface DeleteTargetGroupOutput {}
export interface TargetDescription {
  Id: string | undefined;
  Port?: number;
  AvailabilityZone?: string;
}
export interface DeregisterTargetsInput {
  TargetGroupArn: string | undefined;
  Targets: TargetDescription[] | undefined;
}
export interface DeregisterTargetsOutput {}
export declare class InvalidTargetException extends __BaseException {
  readonly name: "InvalidTargetException";
  readonly $fault: "client";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<InvalidTargetException, __BaseException>
  );
}
export interface DescribeAccountLimitsInput {
  Marker?: string;
  PageSize?: number;
}
export interface Limit {
  Name?: string;
  Max?: string;
}
export interface DescribeAccountLimitsOutput {
  Limits?: Limit[];
  NextMarker?: string;
}
export interface DescribeListenerCertificatesInput {
  ListenerArn: string | undefined;
  Marker?: string;
  PageSize?: number;
}
export interface DescribeListenerCertificatesOutput {
  Certificates?: Certificate[];
  NextMarker?: string;
}
export interface DescribeListenersInput {
  LoadBalancerArn?: string;
  ListenerArns?: string[];
  Marker?: string;
  PageSize?: number;
}
export interface DescribeListenersOutput {
  Listeners?: Listener[];
  NextMarker?: string;
}
export interface DescribeLoadBalancerAttributesInput {
  LoadBalancerArn: string | undefined;
}
export interface LoadBalancerAttribute {
  Key?: string;
  Value?: string;
}
export interface DescribeLoadBalancerAttributesOutput {
  Attributes?: LoadBalancerAttribute[];
}
export interface DescribeLoadBalancersInput {
  LoadBalancerArns?: string[];
  Names?: string[];
  Marker?: string;
  PageSize?: number;
}
export interface DescribeLoadBalancersOutput {
  LoadBalancers?: LoadBalancer[];
  NextMarker?: string;
}
export interface DescribeRulesInput {
  ListenerArn?: string;
  RuleArns?: string[];
  Marker?: string;
  PageSize?: number;
}
export interface DescribeRulesOutput {
  Rules?: Rule[];
  NextMarker?: string;
}
export interface DescribeSSLPoliciesInput {
  Names?: string[];
  Marker?: string;
  PageSize?: number;
  LoadBalancerType?: LoadBalancerTypeEnum | string;
}
export interface SslPolicy {
  SslProtocols?: string[];
  Ciphers?: Cipher[];
  Name?: string;
  SupportedLoadBalancerTypes?: string[];
}
export interface DescribeSSLPoliciesOutput {
  SslPolicies?: SslPolicy[];
  NextMarker?: string;
}
export interface DescribeTagsInput {
  ResourceArns: string[] | undefined;
}
export interface TagDescription {
  ResourceArn?: string;
  Tags?: Tag[];
}
export interface DescribeTagsOutput {
  TagDescriptions?: TagDescription[];
}
export interface DescribeTargetGroupAttributesInput {
  TargetGroupArn: string | undefined;
}
export interface TargetGroupAttribute {
  Key?: string;
  Value?: string;
}
export interface DescribeTargetGroupAttributesOutput {
  Attributes?: TargetGroupAttribute[];
}
export interface DescribeTargetGroupsInput {
  LoadBalancerArn?: string;
  TargetGroupArns?: string[];
  Names?: string[];
  Marker?: string;
  PageSize?: number;
}
export interface DescribeTargetGroupsOutput {
  TargetGroups?: TargetGroup[];
  NextMarker?: string;
}
export interface DescribeTargetHealthInput {
  TargetGroupArn: string | undefined;
  Targets?: TargetDescription[];
}
export declare const TargetHealthReasonEnum: {
  readonly DEREGISTRATION_IN_PROGRESS: "Target.DeregistrationInProgress";
  readonly FAILED_HEALTH_CHECKS: "Target.FailedHealthChecks";
  readonly HEALTH_CHECK_DISABLED: "Target.HealthCheckDisabled";
  readonly INITIAL_HEALTH_CHECKING: "Elb.InitialHealthChecking";
  readonly INTERNAL_ERROR: "Elb.InternalError";
  readonly INVALID_STATE: "Target.InvalidState";
  readonly IP_UNUSABLE: "Target.IpUnusable";
  readonly NOT_IN_USE: "Target.NotInUse";
  readonly NOT_REGISTERED: "Target.NotRegistered";
  readonly REGISTRATION_IN_PROGRESS: "Elb.RegistrationInProgress";
  readonly RESPONSE_CODE_MISMATCH: "Target.ResponseCodeMismatch";
  readonly TIMEOUT: "Target.Timeout";
};
export type TargetHealthReasonEnum =
  (typeof TargetHealthReasonEnum)[keyof typeof TargetHealthReasonEnum];
export declare const TargetHealthStateEnum: {
  readonly DRAINING: "draining";
  readonly HEALTHY: "healthy";
  readonly INITIAL: "initial";
  readonly UNAVAILABLE: "unavailable";
  readonly UNHEALTHY: "unhealthy";
  readonly UNUSED: "unused";
};
export type TargetHealthStateEnum =
  (typeof TargetHealthStateEnum)[keyof typeof TargetHealthStateEnum];
export interface TargetHealth {
  State?: TargetHealthStateEnum | string;
  Reason?: TargetHealthReasonEnum | string;
  Description?: string;
}
export interface TargetHealthDescription {
  Target?: TargetDescription;
  HealthCheckPort?: string;
  TargetHealth?: TargetHealth;
}
export interface DescribeTargetHealthOutput {
  TargetHealthDescriptions?: TargetHealthDescription[];
}
export declare class HealthUnavailableException extends __BaseException {
  readonly name: "HealthUnavailableException";
  readonly $fault: "server";
  Message?: string;
  constructor(
    opts: __ExceptionOptionType<HealthUnavailableException, __BaseException>
  );
}
export interface ModifyListenerInput {
  ListenerArn: string | undefined;
  Port?: number;
  Protocol?: ProtocolEnum | string;
  SslPolicy?: string;
  Certificates?: Certificate[];
  DefaultActions?: Action[];
  AlpnPolicy?: string[];
}
export interface ModifyListenerOutput {
  Listeners?: Listener[];
}
export interface ModifyLoadBalancerAttributesInput {
  LoadBalancerArn: string | undefined;
  Attributes: LoadBalancerAttribute[] | undefined;
}
export interface ModifyLoadBalancerAttributesOutput {
  Attributes?: LoadBalancerAttribute[];
}
export interface ModifyRuleInput {
  RuleArn: string | undefined;
  Conditions?: RuleCondition[];
  Actions?: Action[];
}
export interface ModifyRuleOutput {
  Rules?: Rule[];
}
export interface ModifyTargetGroupInput {
  TargetGroupArn: string | undefined;
  HealthCheckProtocol?: ProtocolEnum | string;
  HealthCheckPort?: string;
  HealthCheckPath?: string;
  HealthCheckEnabled?: boolean;
  HealthCheckIntervalSeconds?: number;
  HealthCheckTimeoutSeconds?: number;
  HealthyThresholdCount?: number;
  UnhealthyThresholdCount?: number;
  Matcher?: Matcher;
}
export interface ModifyTargetGroupOutput {
  TargetGroups?: TargetGroup[];
}
export interface ModifyTargetGroupAttributesInput {
  TargetGroupArn: string | undefined;
  Attributes: TargetGroupAttribute[] | undefined;
}
export interface ModifyTargetGroupAttributesOutput {
  Attributes?: TargetGroupAttribute[];
}
export interface RegisterTargetsInput {
  TargetGroupArn: string | undefined;
  Targets: TargetDescription[] | undefined;
}
export interface RegisterTargetsOutput {}
export interface RemoveListenerCertificatesInput {
  ListenerArn: string | undefined;
  Certificates: Certificate[] | undefined;
}
export interface RemoveListenerCertificatesOutput {}
export interface RemoveTagsInput {
  ResourceArns: string[] | undefined;
  TagKeys: string[] | undefined;
}
export interface RemoveTagsOutput {}
export interface SetIpAddressTypeInput {
  LoadBalancerArn: string | undefined;
  IpAddressType: IpAddressType | string | undefined;
}
export interface SetIpAddressTypeOutput {
  IpAddressType?: IpAddressType | string;
}
export interface RulePriorityPair {
  RuleArn?: string;
  Priority?: number;
}
export interface SetRulePrioritiesInput {
  RulePriorities: RulePriorityPair[] | undefined;
}
export interface SetRulePrioritiesOutput {
  Rules?: Rule[];
}
export interface SetSecurityGroupsInput {
  LoadBalancerArn: string | undefined;
  SecurityGroups: string[] | undefined;
}
export interface SetSecurityGroupsOutput {
  SecurityGroupIds?: string[];
}
export interface SetSubnetsInput {
  LoadBalancerArn: string | undefined;
  Subnets?: string[];
  SubnetMappings?: SubnetMapping[];
  IpAddressType?: IpAddressType | string;
}
export interface SetSubnetsOutput {
  AvailabilityZones?: AvailabilityZone[];
  IpAddressType?: IpAddressType | string;
}
