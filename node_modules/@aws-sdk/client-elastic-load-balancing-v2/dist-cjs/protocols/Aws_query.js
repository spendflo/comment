"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.de_DescribeLoadBalancersCommand = exports.de_DescribeLoadBalancerAttributesCommand = exports.de_DescribeListenersCommand = exports.de_DescribeListenerCertificatesCommand = exports.de_DescribeAccountLimitsCommand = exports.de_DeregisterTargetsCommand = exports.de_DeleteTargetGroupCommand = exports.de_DeleteRuleCommand = exports.de_DeleteLoadBalancerCommand = exports.de_DeleteListenerCommand = exports.de_CreateTargetGroupCommand = exports.de_CreateRuleCommand = exports.de_CreateLoadBalancerCommand = exports.de_CreateListenerCommand = exports.de_AddTagsCommand = exports.de_AddListenerCertificatesCommand = exports.se_SetSubnetsCommand = exports.se_SetSecurityGroupsCommand = exports.se_SetRulePrioritiesCommand = exports.se_SetIpAddressTypeCommand = exports.se_RemoveTagsCommand = exports.se_RemoveListenerCertificatesCommand = exports.se_RegisterTargetsCommand = exports.se_ModifyTargetGroupAttributesCommand = exports.se_ModifyTargetGroupCommand = exports.se_ModifyRuleCommand = exports.se_ModifyLoadBalancerAttributesCommand = exports.se_ModifyListenerCommand = exports.se_DescribeTargetHealthCommand = exports.se_DescribeTargetGroupsCommand = exports.se_DescribeTargetGroupAttributesCommand = exports.se_DescribeTagsCommand = exports.se_DescribeSSLPoliciesCommand = exports.se_DescribeRulesCommand = exports.se_DescribeLoadBalancersCommand = exports.se_DescribeLoadBalancerAttributesCommand = exports.se_DescribeListenersCommand = exports.se_DescribeListenerCertificatesCommand = exports.se_DescribeAccountLimitsCommand = exports.se_DeregisterTargetsCommand = exports.se_DeleteTargetGroupCommand = exports.se_DeleteRuleCommand = exports.se_DeleteLoadBalancerCommand = exports.se_DeleteListenerCommand = exports.se_CreateTargetGroupCommand = exports.se_CreateRuleCommand = exports.se_CreateLoadBalancerCommand = exports.se_CreateListenerCommand = exports.se_AddTagsCommand = exports.se_AddListenerCertificatesCommand = void 0;
exports.de_SetSubnetsCommand = exports.de_SetSecurityGroupsCommand = exports.de_SetRulePrioritiesCommand = exports.de_SetIpAddressTypeCommand = exports.de_RemoveTagsCommand = exports.de_RemoveListenerCertificatesCommand = exports.de_RegisterTargetsCommand = exports.de_ModifyTargetGroupAttributesCommand = exports.de_ModifyTargetGroupCommand = exports.de_ModifyRuleCommand = exports.de_ModifyLoadBalancerAttributesCommand = exports.de_ModifyListenerCommand = exports.de_DescribeTargetHealthCommand = exports.de_DescribeTargetGroupsCommand = exports.de_DescribeTargetGroupAttributesCommand = exports.de_DescribeTagsCommand = exports.de_DescribeSSLPoliciesCommand = exports.de_DescribeRulesCommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const fast_xml_parser_1 = require("fast-xml-parser");
const ElasticLoadBalancingV2ServiceException_1 = require("../models/ElasticLoadBalancingV2ServiceException");
const models_0_1 = require("../models/models_0");
const se_AddListenerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddListenerCertificatesInput(input, context),
        Action: "AddListenerCertificates",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AddListenerCertificatesCommand = se_AddListenerCertificatesCommand;
const se_AddTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddTagsInput(input, context),
        Action: "AddTags",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AddTagsCommand = se_AddTagsCommand;
const se_CreateListenerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateListenerInput(input, context),
        Action: "CreateListener",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateListenerCommand = se_CreateListenerCommand;
const se_CreateLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLoadBalancerInput(input, context),
        Action: "CreateLoadBalancer",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateLoadBalancerCommand = se_CreateLoadBalancerCommand;
const se_CreateRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRuleInput(input, context),
        Action: "CreateRule",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateRuleCommand = se_CreateRuleCommand;
const se_CreateTargetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateTargetGroupInput(input, context),
        Action: "CreateTargetGroup",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateTargetGroupCommand = se_CreateTargetGroupCommand;
const se_DeleteListenerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteListenerInput(input, context),
        Action: "DeleteListener",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteListenerCommand = se_DeleteListenerCommand;
const se_DeleteLoadBalancerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLoadBalancerInput(input, context),
        Action: "DeleteLoadBalancer",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteLoadBalancerCommand = se_DeleteLoadBalancerCommand;
const se_DeleteRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRuleInput(input, context),
        Action: "DeleteRule",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteRuleCommand = se_DeleteRuleCommand;
const se_DeleteTargetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteTargetGroupInput(input, context),
        Action: "DeleteTargetGroup",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteTargetGroupCommand = se_DeleteTargetGroupCommand;
const se_DeregisterTargetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeregisterTargetsInput(input, context),
        Action: "DeregisterTargets",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeregisterTargetsCommand = se_DeregisterTargetsCommand;
const se_DescribeAccountLimitsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeAccountLimitsInput(input, context),
        Action: "DescribeAccountLimits",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeAccountLimitsCommand = se_DescribeAccountLimitsCommand;
const se_DescribeListenerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeListenerCertificatesInput(input, context),
        Action: "DescribeListenerCertificates",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeListenerCertificatesCommand = se_DescribeListenerCertificatesCommand;
const se_DescribeListenersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeListenersInput(input, context),
        Action: "DescribeListeners",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeListenersCommand = se_DescribeListenersCommand;
const se_DescribeLoadBalancerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancerAttributesInput(input, context),
        Action: "DescribeLoadBalancerAttributes",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeLoadBalancerAttributesCommand = se_DescribeLoadBalancerAttributesCommand;
const se_DescribeLoadBalancersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeLoadBalancersInput(input, context),
        Action: "DescribeLoadBalancers",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeLoadBalancersCommand = se_DescribeLoadBalancersCommand;
const se_DescribeRulesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeRulesInput(input, context),
        Action: "DescribeRules",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeRulesCommand = se_DescribeRulesCommand;
const se_DescribeSSLPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeSSLPoliciesInput(input, context),
        Action: "DescribeSSLPolicies",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeSSLPoliciesCommand = se_DescribeSSLPoliciesCommand;
const se_DescribeTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTagsInput(input, context),
        Action: "DescribeTags",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeTagsCommand = se_DescribeTagsCommand;
const se_DescribeTargetGroupAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTargetGroupAttributesInput(input, context),
        Action: "DescribeTargetGroupAttributes",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeTargetGroupAttributesCommand = se_DescribeTargetGroupAttributesCommand;
const se_DescribeTargetGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTargetGroupsInput(input, context),
        Action: "DescribeTargetGroups",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeTargetGroupsCommand = se_DescribeTargetGroupsCommand;
const se_DescribeTargetHealthCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DescribeTargetHealthInput(input, context),
        Action: "DescribeTargetHealth",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeTargetHealthCommand = se_DescribeTargetHealthCommand;
const se_ModifyListenerCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyListenerInput(input, context),
        Action: "ModifyListener",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ModifyListenerCommand = se_ModifyListenerCommand;
const se_ModifyLoadBalancerAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyLoadBalancerAttributesInput(input, context),
        Action: "ModifyLoadBalancerAttributes",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ModifyLoadBalancerAttributesCommand = se_ModifyLoadBalancerAttributesCommand;
const se_ModifyRuleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyRuleInput(input, context),
        Action: "ModifyRule",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ModifyRuleCommand = se_ModifyRuleCommand;
const se_ModifyTargetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTargetGroupInput(input, context),
        Action: "ModifyTargetGroup",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ModifyTargetGroupCommand = se_ModifyTargetGroupCommand;
const se_ModifyTargetGroupAttributesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ModifyTargetGroupAttributesInput(input, context),
        Action: "ModifyTargetGroupAttributes",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ModifyTargetGroupAttributesCommand = se_ModifyTargetGroupAttributesCommand;
const se_RegisterTargetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RegisterTargetsInput(input, context),
        Action: "RegisterTargets",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RegisterTargetsCommand = se_RegisterTargetsCommand;
const se_RemoveListenerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveListenerCertificatesInput(input, context),
        Action: "RemoveListenerCertificates",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RemoveListenerCertificatesCommand = se_RemoveListenerCertificatesCommand;
const se_RemoveTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveTagsInput(input, context),
        Action: "RemoveTags",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RemoveTagsCommand = se_RemoveTagsCommand;
const se_SetIpAddressTypeCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetIpAddressTypeInput(input, context),
        Action: "SetIpAddressType",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetIpAddressTypeCommand = se_SetIpAddressTypeCommand;
const se_SetRulePrioritiesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetRulePrioritiesInput(input, context),
        Action: "SetRulePriorities",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetRulePrioritiesCommand = se_SetRulePrioritiesCommand;
const se_SetSecurityGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetSecurityGroupsInput(input, context),
        Action: "SetSecurityGroups",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetSecurityGroupsCommand = se_SetSecurityGroupsCommand;
const se_SetSubnetsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetSubnetsInput(input, context),
        Action: "SetSubnets",
        Version: "2015-12-01",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetSubnetsCommand = se_SetSubnetsCommand;
const de_AddListenerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddListenerCertificatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddListenerCertificatesOutput(data.AddListenerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AddListenerCertificatesCommand = de_AddListenerCertificatesCommand;
const de_AddListenerCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateNotFound":
        case "com.amazonaws.elasticloadbalancingv2#CertificateNotFoundException":
            throw await de_CertificateNotFoundExceptionRes(parsedOutput, context);
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.elasticloadbalancingv2#TooManyCertificatesException":
            throw await de_TooManyCertificatesExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AddTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AddTagsOutput(data.AddTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_AddTagsCommand = de_AddTagsCommand;
const de_AddTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DuplicateTagKeys":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateTagKeysException":
            throw await de_DuplicateTagKeysExceptionRes(parsedOutput, context);
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateListenerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateListenerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateListenerOutput(data.CreateListenerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateListenerCommand = de_CreateListenerCommand;
const de_CreateListenerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ALPNPolicyNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ALPNPolicyNotSupportedException":
            throw await de_ALPNPolicyNotSupportedExceptionRes(parsedOutput, context);
        case "CertificateNotFound":
        case "com.amazonaws.elasticloadbalancingv2#CertificateNotFoundException":
            throw await de_CertificateNotFoundExceptionRes(parsedOutput, context);
        case "DuplicateListener":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateListenerException":
            throw await de_DuplicateListenerExceptionRes(parsedOutput, context);
        case "IncompatibleProtocols":
        case "com.amazonaws.elasticloadbalancingv2#IncompatibleProtocolsException":
            throw await de_IncompatibleProtocolsExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerAction":
        case "com.amazonaws.elasticloadbalancingv2#InvalidLoadBalancerActionException":
            throw await de_InvalidLoadBalancerActionExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "SSLPolicyNotFound":
        case "com.amazonaws.elasticloadbalancingv2#SSLPolicyNotFoundException":
            throw await de_SSLPolicyNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupAssociationLimit":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupAssociationLimitException":
            throw await de_TargetGroupAssociationLimitExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyActions":
        case "com.amazonaws.elasticloadbalancingv2#TooManyActionsException":
            throw await de_TooManyActionsExceptionRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.elasticloadbalancingv2#TooManyCertificatesException":
            throw await de_TooManyCertificatesExceptionRes(parsedOutput, context);
        case "TooManyListeners":
        case "com.amazonaws.elasticloadbalancingv2#TooManyListenersException":
            throw await de_TooManyListenersExceptionRes(parsedOutput, context);
        case "TooManyRegistrationsForTargetId":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRegistrationsForTargetIdException":
            throw await de_TooManyRegistrationsForTargetIdExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        case "TooManyTargets":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetsException":
            throw await de_TooManyTargetsExceptionRes(parsedOutput, context);
        case "TooManyUniqueTargetGroupsPerLoadBalancer":
        case "com.amazonaws.elasticloadbalancingv2#TooManyUniqueTargetGroupsPerLoadBalancerException":
            throw await de_TooManyUniqueTargetGroupsPerLoadBalancerExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancingv2#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateLoadBalancerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLoadBalancerOutput(data.CreateLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateLoadBalancerCommand = de_CreateLoadBalancerCommand;
const de_CreateLoadBalancerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AllocationIdNotFound":
        case "com.amazonaws.elasticloadbalancingv2#AllocationIdNotFoundException":
            throw await de_AllocationIdNotFoundExceptionRes(parsedOutput, context);
        case "AvailabilityZoneNotSupported":
        case "com.amazonaws.elasticloadbalancingv2#AvailabilityZoneNotSupportedException":
            throw await de_AvailabilityZoneNotSupportedExceptionRes(parsedOutput, context);
        case "DuplicateLoadBalancerName":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateLoadBalancerNameException":
            throw await de_DuplicateLoadBalancerNameExceptionRes(parsedOutput, context);
        case "DuplicateTagKeys":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateTagKeysException":
            throw await de_DuplicateTagKeysExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidScheme":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSchemeException":
            throw await de_InvalidSchemeExceptionRes(parsedOutput, context);
        case "InvalidSecurityGroup":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSecurityGroupException":
            throw await de_InvalidSecurityGroupExceptionRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSubnetException":
            throw await de_InvalidSubnetExceptionRes(parsedOutput, context);
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancingv2#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.elasticloadbalancingv2#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        case "SubnetNotFound":
        case "com.amazonaws.elasticloadbalancingv2#SubnetNotFoundException":
            throw await de_SubnetNotFoundExceptionRes(parsedOutput, context);
        case "TooManyLoadBalancers":
        case "com.amazonaws.elasticloadbalancingv2#TooManyLoadBalancersException":
            throw await de_TooManyLoadBalancersExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRuleOutput(data.CreateRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateRuleCommand = de_CreateRuleCommand;
const de_CreateRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IncompatibleProtocols":
        case "com.amazonaws.elasticloadbalancingv2#IncompatibleProtocolsException":
            throw await de_IncompatibleProtocolsExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerAction":
        case "com.amazonaws.elasticloadbalancingv2#InvalidLoadBalancerActionException":
            throw await de_InvalidLoadBalancerActionExceptionRes(parsedOutput, context);
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "PriorityInUse":
        case "com.amazonaws.elasticloadbalancingv2#PriorityInUseException":
            throw await de_PriorityInUseExceptionRes(parsedOutput, context);
        case "TargetGroupAssociationLimit":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupAssociationLimitException":
            throw await de_TargetGroupAssociationLimitExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyActions":
        case "com.amazonaws.elasticloadbalancingv2#TooManyActionsException":
            throw await de_TooManyActionsExceptionRes(parsedOutput, context);
        case "TooManyRegistrationsForTargetId":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRegistrationsForTargetIdException":
            throw await de_TooManyRegistrationsForTargetIdExceptionRes(parsedOutput, context);
        case "TooManyRules":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRulesException":
            throw await de_TooManyRulesExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        case "TooManyTargetGroups":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetGroupsException":
            throw await de_TooManyTargetGroupsExceptionRes(parsedOutput, context);
        case "TooManyTargets":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetsException":
            throw await de_TooManyTargetsExceptionRes(parsedOutput, context);
        case "TooManyUniqueTargetGroupsPerLoadBalancer":
        case "com.amazonaws.elasticloadbalancingv2#TooManyUniqueTargetGroupsPerLoadBalancerException":
            throw await de_TooManyUniqueTargetGroupsPerLoadBalancerExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancingv2#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_CreateTargetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateTargetGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateTargetGroupOutput(data.CreateTargetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_CreateTargetGroupCommand = de_CreateTargetGroupCommand;
const de_CreateTargetGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DuplicateTargetGroupName":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateTargetGroupNameException":
            throw await de_DuplicateTargetGroupNameExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        case "TooManyTargetGroups":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetGroupsException":
            throw await de_TooManyTargetGroupsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteListenerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteListenerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteListenerOutput(data.DeleteListenerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteListenerCommand = de_DeleteListenerCommand;
const de_DeleteListenerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.elasticloadbalancingv2#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteLoadBalancerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteLoadBalancerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteLoadBalancerOutput(data.DeleteLoadBalancerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteLoadBalancerCommand = de_DeleteLoadBalancerCommand;
const de_DeleteLoadBalancerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancingv2#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        case "ResourceInUse":
        case "com.amazonaws.elasticloadbalancingv2#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteRuleOutput(data.DeleteRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteRuleCommand = de_DeleteRuleCommand;
const de_DeleteRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancingv2#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeleteTargetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteTargetGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteTargetGroupOutput(data.DeleteTargetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeleteTargetGroupCommand = de_DeleteTargetGroupCommand;
const de_DeleteTargetGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ResourceInUse":
        case "com.amazonaws.elasticloadbalancingv2#ResourceInUseException":
            throw await de_ResourceInUseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DeregisterTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeregisterTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeregisterTargetsOutput(data.DeregisterTargetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DeregisterTargetsCommand = de_DeregisterTargetsCommand;
const de_DeregisterTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidTarget":
        case "com.amazonaws.elasticloadbalancingv2#InvalidTargetException":
            throw await de_InvalidTargetExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeAccountLimitsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeAccountLimitsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeAccountLimitsOutput(data.DescribeAccountLimitsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeAccountLimitsCommand = de_DescribeAccountLimitsCommand;
const de_DescribeAccountLimitsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
const de_DescribeListenerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeListenerCertificatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeListenerCertificatesOutput(data.DescribeListenerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeListenerCertificatesCommand = de_DescribeListenerCertificatesCommand;
const de_DescribeListenerCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeListenersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeListenersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeListenersOutput(data.DescribeListenersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeListenersCommand = de_DescribeListenersCommand;
const de_DescribeListenersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancingv2#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeLoadBalancerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLoadBalancerAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancerAttributesOutput(data.DescribeLoadBalancerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeLoadBalancerAttributesCommand = de_DescribeLoadBalancerAttributesCommand;
const de_DescribeLoadBalancerAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeLoadBalancersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeLoadBalancersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeLoadBalancersOutput(data.DescribeLoadBalancersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeLoadBalancersCommand = de_DescribeLoadBalancersCommand;
const de_DescribeLoadBalancersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeRulesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeRulesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRulesOutput(data.DescribeRulesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeRulesCommand = de_DescribeRulesCommand;
const de_DescribeRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancingv2#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeSSLPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeSSLPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeSSLPoliciesOutput(data.DescribeSSLPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeSSLPoliciesCommand = de_DescribeSSLPoliciesCommand;
const de_DescribeSSLPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "SSLPolicyNotFound":
        case "com.amazonaws.elasticloadbalancingv2#SSLPolicyNotFoundException":
            throw await de_SSLPolicyNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTagsOutput(data.DescribeTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeTagsCommand = de_DescribeTagsCommand;
const de_DescribeTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeTargetGroupAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTargetGroupAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTargetGroupAttributesOutput(data.DescribeTargetGroupAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeTargetGroupAttributesCommand = de_DescribeTargetGroupAttributesCommand;
const de_DescribeTargetGroupAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeTargetGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTargetGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTargetGroupsOutput(data.DescribeTargetGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeTargetGroupsCommand = de_DescribeTargetGroupsCommand;
const de_DescribeTargetGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_DescribeTargetHealthCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DescribeTargetHealthCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeTargetHealthOutput(data.DescribeTargetHealthResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_DescribeTargetHealthCommand = de_DescribeTargetHealthCommand;
const de_DescribeTargetHealthCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "HealthUnavailable":
        case "com.amazonaws.elasticloadbalancingv2#HealthUnavailableException":
            throw await de_HealthUnavailableExceptionRes(parsedOutput, context);
        case "InvalidTarget":
        case "com.amazonaws.elasticloadbalancingv2#InvalidTargetException":
            throw await de_InvalidTargetExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ModifyListenerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ModifyListenerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyListenerOutput(data.ModifyListenerResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ModifyListenerCommand = de_ModifyListenerCommand;
const de_ModifyListenerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ALPNPolicyNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ALPNPolicyNotSupportedException":
            throw await de_ALPNPolicyNotSupportedExceptionRes(parsedOutput, context);
        case "CertificateNotFound":
        case "com.amazonaws.elasticloadbalancingv2#CertificateNotFoundException":
            throw await de_CertificateNotFoundExceptionRes(parsedOutput, context);
        case "DuplicateListener":
        case "com.amazonaws.elasticloadbalancingv2#DuplicateListenerException":
            throw await de_DuplicateListenerExceptionRes(parsedOutput, context);
        case "IncompatibleProtocols":
        case "com.amazonaws.elasticloadbalancingv2#IncompatibleProtocolsException":
            throw await de_IncompatibleProtocolsExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerAction":
        case "com.amazonaws.elasticloadbalancingv2#InvalidLoadBalancerActionException":
            throw await de_InvalidLoadBalancerActionExceptionRes(parsedOutput, context);
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "SSLPolicyNotFound":
        case "com.amazonaws.elasticloadbalancingv2#SSLPolicyNotFoundException":
            throw await de_SSLPolicyNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupAssociationLimit":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupAssociationLimitException":
            throw await de_TargetGroupAssociationLimitExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyActions":
        case "com.amazonaws.elasticloadbalancingv2#TooManyActionsException":
            throw await de_TooManyActionsExceptionRes(parsedOutput, context);
        case "TooManyCertificates":
        case "com.amazonaws.elasticloadbalancingv2#TooManyCertificatesException":
            throw await de_TooManyCertificatesExceptionRes(parsedOutput, context);
        case "TooManyListeners":
        case "com.amazonaws.elasticloadbalancingv2#TooManyListenersException":
            throw await de_TooManyListenersExceptionRes(parsedOutput, context);
        case "TooManyRegistrationsForTargetId":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRegistrationsForTargetIdException":
            throw await de_TooManyRegistrationsForTargetIdExceptionRes(parsedOutput, context);
        case "TooManyTargets":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetsException":
            throw await de_TooManyTargetsExceptionRes(parsedOutput, context);
        case "TooManyUniqueTargetGroupsPerLoadBalancer":
        case "com.amazonaws.elasticloadbalancingv2#TooManyUniqueTargetGroupsPerLoadBalancerException":
            throw await de_TooManyUniqueTargetGroupsPerLoadBalancerExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancingv2#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ModifyLoadBalancerAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ModifyLoadBalancerAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyLoadBalancerAttributesOutput(data.ModifyLoadBalancerAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ModifyLoadBalancerAttributesCommand = de_ModifyLoadBalancerAttributesCommand;
const de_ModifyLoadBalancerAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ModifyRuleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ModifyRuleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyRuleOutput(data.ModifyRuleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ModifyRuleCommand = de_ModifyRuleCommand;
const de_ModifyRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IncompatibleProtocols":
        case "com.amazonaws.elasticloadbalancingv2#IncompatibleProtocolsException":
            throw await de_IncompatibleProtocolsExceptionRes(parsedOutput, context);
        case "InvalidLoadBalancerAction":
        case "com.amazonaws.elasticloadbalancingv2#InvalidLoadBalancerActionException":
            throw await de_InvalidLoadBalancerActionExceptionRes(parsedOutput, context);
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancingv2#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupAssociationLimit":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupAssociationLimitException":
            throw await de_TargetGroupAssociationLimitExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyActions":
        case "com.amazonaws.elasticloadbalancingv2#TooManyActionsException":
            throw await de_TooManyActionsExceptionRes(parsedOutput, context);
        case "TooManyRegistrationsForTargetId":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRegistrationsForTargetIdException":
            throw await de_TooManyRegistrationsForTargetIdExceptionRes(parsedOutput, context);
        case "TooManyTargets":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetsException":
            throw await de_TooManyTargetsExceptionRes(parsedOutput, context);
        case "TooManyUniqueTargetGroupsPerLoadBalancer":
        case "com.amazonaws.elasticloadbalancingv2#TooManyUniqueTargetGroupsPerLoadBalancerException":
            throw await de_TooManyUniqueTargetGroupsPerLoadBalancerExceptionRes(parsedOutput, context);
        case "UnsupportedProtocol":
        case "com.amazonaws.elasticloadbalancingv2#UnsupportedProtocolException":
            throw await de_UnsupportedProtocolExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ModifyTargetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ModifyTargetGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTargetGroupOutput(data.ModifyTargetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ModifyTargetGroupCommand = de_ModifyTargetGroupCommand;
const de_ModifyTargetGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ModifyTargetGroupAttributesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ModifyTargetGroupAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ModifyTargetGroupAttributesOutput(data.ModifyTargetGroupAttributesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_ModifyTargetGroupAttributesCommand = de_ModifyTargetGroupAttributesCommand;
const de_ModifyTargetGroupAttributesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_RegisterTargetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RegisterTargetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RegisterTargetsOutput(data.RegisterTargetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_RegisterTargetsCommand = de_RegisterTargetsCommand;
const de_RegisterTargetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidTarget":
        case "com.amazonaws.elasticloadbalancingv2#InvalidTargetException":
            throw await de_InvalidTargetExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRegistrationsForTargetId":
        case "com.amazonaws.elasticloadbalancingv2#TooManyRegistrationsForTargetIdException":
            throw await de_TooManyRegistrationsForTargetIdExceptionRes(parsedOutput, context);
        case "TooManyTargets":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTargetsException":
            throw await de_TooManyTargetsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_RemoveListenerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveListenerCertificatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveListenerCertificatesOutput(data.RemoveListenerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_RemoveListenerCertificatesCommand = de_RemoveListenerCertificatesCommand;
const de_RemoveListenerCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancingv2#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_RemoveTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_RemoveTagsOutput(data.RemoveTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_RemoveTagsCommand = de_RemoveTagsCommand;
const de_RemoveTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ListenerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#ListenerNotFoundException":
            throw await de_ListenerNotFoundExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        case "TargetGroupNotFound":
        case "com.amazonaws.elasticloadbalancingv2#TargetGroupNotFoundException":
            throw await de_TargetGroupNotFoundExceptionRes(parsedOutput, context);
        case "TooManyTags":
        case "com.amazonaws.elasticloadbalancingv2#TooManyTagsException":
            throw await de_TooManyTagsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SetIpAddressTypeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetIpAddressTypeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetIpAddressTypeOutput(data.SetIpAddressTypeResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_SetIpAddressTypeCommand = de_SetIpAddressTypeCommand;
const de_SetIpAddressTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSubnetException":
            throw await de_InvalidSubnetExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SetRulePrioritiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetRulePrioritiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetRulePrioritiesOutput(data.SetRulePrioritiesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_SetRulePrioritiesCommand = de_SetRulePrioritiesCommand;
const de_SetRulePrioritiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "OperationNotPermitted":
        case "com.amazonaws.elasticloadbalancingv2#OperationNotPermittedException":
            throw await de_OperationNotPermittedExceptionRes(parsedOutput, context);
        case "PriorityInUse":
        case "com.amazonaws.elasticloadbalancingv2#PriorityInUseException":
            throw await de_PriorityInUseExceptionRes(parsedOutput, context);
        case "RuleNotFound":
        case "com.amazonaws.elasticloadbalancingv2#RuleNotFoundException":
            throw await de_RuleNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SetSecurityGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetSecurityGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetSecurityGroupsOutput(data.SetSecurityGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_SetSecurityGroupsCommand = de_SetSecurityGroupsCommand;
const de_SetSecurityGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidSecurityGroup":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSecurityGroupException":
            throw await de_InvalidSecurityGroupExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_SetSubnetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetSubnetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetSubnetsOutput(data.SetSubnetsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
exports.de_SetSubnetsCommand = de_SetSubnetsCommand;
const de_SetSubnetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AllocationIdNotFound":
        case "com.amazonaws.elasticloadbalancingv2#AllocationIdNotFoundException":
            throw await de_AllocationIdNotFoundExceptionRes(parsedOutput, context);
        case "AvailabilityZoneNotSupported":
        case "com.amazonaws.elasticloadbalancingv2#AvailabilityZoneNotSupportedException":
            throw await de_AvailabilityZoneNotSupportedExceptionRes(parsedOutput, context);
        case "InvalidConfigurationRequest":
        case "com.amazonaws.elasticloadbalancingv2#InvalidConfigurationRequestException":
            throw await de_InvalidConfigurationRequestExceptionRes(parsedOutput, context);
        case "InvalidSubnet":
        case "com.amazonaws.elasticloadbalancingv2#InvalidSubnetException":
            throw await de_InvalidSubnetExceptionRes(parsedOutput, context);
        case "LoadBalancerNotFound":
        case "com.amazonaws.elasticloadbalancingv2#LoadBalancerNotFoundException":
            throw await de_LoadBalancerNotFoundExceptionRes(parsedOutput, context);
        case "SubnetNotFound":
        case "com.amazonaws.elasticloadbalancingv2#SubnetNotFoundException":
            throw await de_SubnetNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_AllocationIdNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AllocationIdNotFoundException(body.Error, context);
    const exception = new models_0_1.AllocationIdNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ALPNPolicyNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ALPNPolicyNotSupportedException(body.Error, context);
    const exception = new models_0_1.ALPNPolicyNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_AvailabilityZoneNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_AvailabilityZoneNotSupportedException(body.Error, context);
    const exception = new models_0_1.AvailabilityZoneNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CertificateNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CertificateNotFoundException(body.Error, context);
    const exception = new models_0_1.CertificateNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateListenerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateListenerException(body.Error, context);
    const exception = new models_0_1.DuplicateListenerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateLoadBalancerNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateLoadBalancerNameException(body.Error, context);
    const exception = new models_0_1.DuplicateLoadBalancerNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateTagKeysExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateTagKeysException(body.Error, context);
    const exception = new models_0_1.DuplicateTagKeysException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateTargetGroupNameExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateTargetGroupNameException(body.Error, context);
    const exception = new models_0_1.DuplicateTargetGroupNameException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_HealthUnavailableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_HealthUnavailableException(body.Error, context);
    const exception = new models_0_1.HealthUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IncompatibleProtocolsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_IncompatibleProtocolsException(body.Error, context);
    const exception = new models_0_1.IncompatibleProtocolsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidConfigurationRequestExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidConfigurationRequestException(body.Error, context);
    const exception = new models_0_1.InvalidConfigurationRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidLoadBalancerActionExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidLoadBalancerActionException(body.Error, context);
    const exception = new models_0_1.InvalidLoadBalancerActionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSchemeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSchemeException(body.Error, context);
    const exception = new models_0_1.InvalidSchemeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSecurityGroupExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSecurityGroupException(body.Error, context);
    const exception = new models_0_1.InvalidSecurityGroupException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSubnetExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidSubnetException(body.Error, context);
    const exception = new models_0_1.InvalidSubnetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidTargetExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidTargetException(body.Error, context);
    const exception = new models_0_1.InvalidTargetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ListenerNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ListenerNotFoundException(body.Error, context);
    const exception = new models_0_1.ListenerNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LoadBalancerNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LoadBalancerNotFoundException(body.Error, context);
    const exception = new models_0_1.LoadBalancerNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_OperationNotPermittedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_OperationNotPermittedException(body.Error, context);
    const exception = new models_0_1.OperationNotPermittedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PriorityInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PriorityInUseException(body.Error, context);
    const exception = new models_0_1.PriorityInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceInUseExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ResourceInUseException(body.Error, context);
    const exception = new models_0_1.ResourceInUseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RuleNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_RuleNotFoundException(body.Error, context);
    const exception = new models_0_1.RuleNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_SSLPolicyNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SSLPolicyNotFoundException(body.Error, context);
    const exception = new models_0_1.SSLPolicyNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_SubnetNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_SubnetNotFoundException(body.Error, context);
    const exception = new models_0_1.SubnetNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TargetGroupAssociationLimitExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TargetGroupAssociationLimitException(body.Error, context);
    const exception = new models_0_1.TargetGroupAssociationLimitException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TargetGroupNotFoundExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TargetGroupNotFoundException(body.Error, context);
    const exception = new models_0_1.TargetGroupNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyActionsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyActionsException(body.Error, context);
    const exception = new models_0_1.TooManyActionsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyCertificatesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyCertificatesException(body.Error, context);
    const exception = new models_0_1.TooManyCertificatesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyListenersExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyListenersException(body.Error, context);
    const exception = new models_0_1.TooManyListenersException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyLoadBalancersExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyLoadBalancersException(body.Error, context);
    const exception = new models_0_1.TooManyLoadBalancersException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyRegistrationsForTargetIdExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyRegistrationsForTargetIdException(body.Error, context);
    const exception = new models_0_1.TooManyRegistrationsForTargetIdException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyRulesExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyRulesException(body.Error, context);
    const exception = new models_0_1.TooManyRulesException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyTagsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTagsException(body.Error, context);
    const exception = new models_0_1.TooManyTagsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyTargetGroupsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTargetGroupsException(body.Error, context);
    const exception = new models_0_1.TooManyTargetGroupsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyTargetsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyTargetsException(body.Error, context);
    const exception = new models_0_1.TooManyTargetsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyUniqueTargetGroupsPerLoadBalancerExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_TooManyUniqueTargetGroupsPerLoadBalancerException(body.Error, context);
    const exception = new models_0_1.TooManyUniqueTargetGroupsPerLoadBalancerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedProtocolExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnsupportedProtocolException(body.Error, context);
    const exception = new models_0_1.UnsupportedProtocolException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_Action = (input, context) => {
    const entries = {};
    if (input.Type != null) {
        entries["Type"] = input.Type;
    }
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    if (input.AuthenticateOidcConfig != null) {
        const memberEntries = se_AuthenticateOidcActionConfig(input.AuthenticateOidcConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticateOidcConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AuthenticateCognitoConfig != null) {
        const memberEntries = se_AuthenticateCognitoActionConfig(input.AuthenticateCognitoConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticateCognitoConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Order != null) {
        entries["Order"] = input.Order;
    }
    if (input.RedirectConfig != null) {
        const memberEntries = se_RedirectActionConfig(input.RedirectConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RedirectConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.FixedResponseConfig != null) {
        const memberEntries = se_FixedResponseActionConfig(input.FixedResponseConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `FixedResponseConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ForwardConfig != null) {
        const memberEntries = se_ForwardActionConfig(input.ForwardConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ForwardConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_Actions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Action(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_AddListenerCertificatesInput = (input, context) => {
    const entries = {};
    if (input.ListenerArn != null) {
        entries["ListenerArn"] = input.ListenerArn;
    }
    if (input.Certificates != null) {
        const memberEntries = se_CertificateList(input.Certificates, context);
        if (input.Certificates?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AddTagsInput = (input, context) => {
    const entries = {};
    if (input.ResourceArns != null) {
        const memberEntries = se_ResourceArns(input.ResourceArns, context);
        if (input.ResourceArns?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AlpnPolicyName = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AuthenticateCognitoActionAuthenticationRequestExtraParams = (input, context) => {
    const entries = {};
    let counter = 1;
    Object.keys(input)
        .filter((key) => input[key] != null)
        .forEach((key) => {
        entries[`entry.${counter}.key`] = key;
        entries[`entry.${counter}.value`] = input[key];
        counter++;
    });
    return entries;
};
const se_AuthenticateCognitoActionConfig = (input, context) => {
    const entries = {};
    if (input.UserPoolArn != null) {
        entries["UserPoolArn"] = input.UserPoolArn;
    }
    if (input.UserPoolClientId != null) {
        entries["UserPoolClientId"] = input.UserPoolClientId;
    }
    if (input.UserPoolDomain != null) {
        entries["UserPoolDomain"] = input.UserPoolDomain;
    }
    if (input.SessionCookieName != null) {
        entries["SessionCookieName"] = input.SessionCookieName;
    }
    if (input.Scope != null) {
        entries["Scope"] = input.Scope;
    }
    if (input.SessionTimeout != null) {
        entries["SessionTimeout"] = input.SessionTimeout;
    }
    if (input.AuthenticationRequestExtraParams != null) {
        const memberEntries = se_AuthenticateCognitoActionAuthenticationRequestExtraParams(input.AuthenticationRequestExtraParams, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticationRequestExtraParams.${key}`;
            entries[loc] = value;
        });
    }
    if (input.OnUnauthenticatedRequest != null) {
        entries["OnUnauthenticatedRequest"] = input.OnUnauthenticatedRequest;
    }
    return entries;
};
const se_AuthenticateOidcActionAuthenticationRequestExtraParams = (input, context) => {
    const entries = {};
    let counter = 1;
    Object.keys(input)
        .filter((key) => input[key] != null)
        .forEach((key) => {
        entries[`entry.${counter}.key`] = key;
        entries[`entry.${counter}.value`] = input[key];
        counter++;
    });
    return entries;
};
const se_AuthenticateOidcActionConfig = (input, context) => {
    const entries = {};
    if (input.Issuer != null) {
        entries["Issuer"] = input.Issuer;
    }
    if (input.AuthorizationEndpoint != null) {
        entries["AuthorizationEndpoint"] = input.AuthorizationEndpoint;
    }
    if (input.TokenEndpoint != null) {
        entries["TokenEndpoint"] = input.TokenEndpoint;
    }
    if (input.UserInfoEndpoint != null) {
        entries["UserInfoEndpoint"] = input.UserInfoEndpoint;
    }
    if (input.ClientId != null) {
        entries["ClientId"] = input.ClientId;
    }
    if (input.ClientSecret != null) {
        entries["ClientSecret"] = input.ClientSecret;
    }
    if (input.SessionCookieName != null) {
        entries["SessionCookieName"] = input.SessionCookieName;
    }
    if (input.Scope != null) {
        entries["Scope"] = input.Scope;
    }
    if (input.SessionTimeout != null) {
        entries["SessionTimeout"] = input.SessionTimeout;
    }
    if (input.AuthenticationRequestExtraParams != null) {
        const memberEntries = se_AuthenticateOidcActionAuthenticationRequestExtraParams(input.AuthenticationRequestExtraParams, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AuthenticationRequestExtraParams.${key}`;
            entries[loc] = value;
        });
    }
    if (input.OnUnauthenticatedRequest != null) {
        entries["OnUnauthenticatedRequest"] = input.OnUnauthenticatedRequest;
    }
    if (input.UseExistingClientSecret != null) {
        entries["UseExistingClientSecret"] = input.UseExistingClientSecret;
    }
    return entries;
};
const se_Certificate = (input, context) => {
    const entries = {};
    if (input.CertificateArn != null) {
        entries["CertificateArn"] = input.CertificateArn;
    }
    if (input.IsDefault != null) {
        entries["IsDefault"] = input.IsDefault;
    }
    return entries;
};
const se_CertificateList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Certificate(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_CreateListenerInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    if (input.Protocol != null) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.Port != null) {
        entries["Port"] = input.Port;
    }
    if (input.SslPolicy != null) {
        entries["SslPolicy"] = input.SslPolicy;
    }
    if (input.Certificates != null) {
        const memberEntries = se_CertificateList(input.Certificates, context);
        if (input.Certificates?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    if (input.DefaultActions != null) {
        const memberEntries = se_Actions(input.DefaultActions, context);
        if (input.DefaultActions?.length === 0) {
            entries.DefaultActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DefaultActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AlpnPolicy != null) {
        const memberEntries = se_AlpnPolicyName(input.AlpnPolicy, context);
        if (input.AlpnPolicy?.length === 0) {
            entries.AlpnPolicy = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlpnPolicy.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLoadBalancerInput = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Subnets != null) {
        const memberEntries = se_Subnets(input.Subnets, context);
        if (input.Subnets?.length === 0) {
            entries.Subnets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Subnets.${key}`;
            entries[loc] = value;
        });
    }
    if (input.SubnetMappings != null) {
        const memberEntries = se_SubnetMappings(input.SubnetMappings, context);
        if (input.SubnetMappings?.length === 0) {
            entries.SubnetMappings = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetMappings.${key}`;
            entries[loc] = value;
        });
    }
    if (input.SecurityGroups != null) {
        const memberEntries = se_SecurityGroups(input.SecurityGroups, context);
        if (input.SecurityGroups?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Scheme != null) {
        entries["Scheme"] = input.Scheme;
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Type != null) {
        entries["Type"] = input.Type;
    }
    if (input.IpAddressType != null) {
        entries["IpAddressType"] = input.IpAddressType;
    }
    if (input.CustomerOwnedIpv4Pool != null) {
        entries["CustomerOwnedIpv4Pool"] = input.CustomerOwnedIpv4Pool;
    }
    return entries;
};
const se_CreateRuleInput = (input, context) => {
    const entries = {};
    if (input.ListenerArn != null) {
        entries["ListenerArn"] = input.ListenerArn;
    }
    if (input.Conditions != null) {
        const memberEntries = se_RuleConditionList(input.Conditions, context);
        if (input.Conditions?.length === 0) {
            entries.Conditions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Conditions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Priority != null) {
        entries["Priority"] = input.Priority;
    }
    if (input.Actions != null) {
        const memberEntries = se_Actions(input.Actions, context);
        if (input.Actions?.length === 0) {
            entries.Actions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Actions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateTargetGroupInput = (input, context) => {
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Protocol != null) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.ProtocolVersion != null) {
        entries["ProtocolVersion"] = input.ProtocolVersion;
    }
    if (input.Port != null) {
        entries["Port"] = input.Port;
    }
    if (input.VpcId != null) {
        entries["VpcId"] = input.VpcId;
    }
    if (input.HealthCheckProtocol != null) {
        entries["HealthCheckProtocol"] = input.HealthCheckProtocol;
    }
    if (input.HealthCheckPort != null) {
        entries["HealthCheckPort"] = input.HealthCheckPort;
    }
    if (input.HealthCheckEnabled != null) {
        entries["HealthCheckEnabled"] = input.HealthCheckEnabled;
    }
    if (input.HealthCheckPath != null) {
        entries["HealthCheckPath"] = input.HealthCheckPath;
    }
    if (input.HealthCheckIntervalSeconds != null) {
        entries["HealthCheckIntervalSeconds"] = input.HealthCheckIntervalSeconds;
    }
    if (input.HealthCheckTimeoutSeconds != null) {
        entries["HealthCheckTimeoutSeconds"] = input.HealthCheckTimeoutSeconds;
    }
    if (input.HealthyThresholdCount != null) {
        entries["HealthyThresholdCount"] = input.HealthyThresholdCount;
    }
    if (input.UnhealthyThresholdCount != null) {
        entries["UnhealthyThresholdCount"] = input.UnhealthyThresholdCount;
    }
    if (input.Matcher != null) {
        const memberEntries = se_Matcher(input.Matcher, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Matcher.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TargetType != null) {
        entries["TargetType"] = input.TargetType;
    }
    if (input.Tags != null) {
        const memberEntries = se_TagList(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.IpAddressType != null) {
        entries["IpAddressType"] = input.IpAddressType;
    }
    return entries;
};
const se_DeleteListenerInput = (input, context) => {
    const entries = {};
    if (input.ListenerArn != null) {
        entries["ListenerArn"] = input.ListenerArn;
    }
    return entries;
};
const se_DeleteLoadBalancerInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    return entries;
};
const se_DeleteRuleInput = (input, context) => {
    const entries = {};
    if (input.RuleArn != null) {
        entries["RuleArn"] = input.RuleArn;
    }
    return entries;
};
const se_DeleteTargetGroupInput = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    return entries;
};
const se_DeregisterTargetsInput = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    if (input.Targets != null) {
        const memberEntries = se_TargetDescriptions(input.Targets, context);
        if (input.Targets?.length === 0) {
            entries.Targets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Targets.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeAccountLimitsInput = (input, context) => {
    const entries = {};
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.PageSize != null) {
        entries["PageSize"] = input.PageSize;
    }
    return entries;
};
const se_DescribeListenerCertificatesInput = (input, context) => {
    const entries = {};
    if (input.ListenerArn != null) {
        entries["ListenerArn"] = input.ListenerArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.PageSize != null) {
        entries["PageSize"] = input.PageSize;
    }
    return entries;
};
const se_DescribeListenersInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    if (input.ListenerArns != null) {
        const memberEntries = se_ListenerArns(input.ListenerArns, context);
        if (input.ListenerArns?.length === 0) {
            entries.ListenerArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ListenerArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.PageSize != null) {
        entries["PageSize"] = input.PageSize;
    }
    return entries;
};
const se_DescribeLoadBalancerAttributesInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    return entries;
};
const se_DescribeLoadBalancersInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArns != null) {
        const memberEntries = se_LoadBalancerArns(input.LoadBalancerArns, context);
        if (input.LoadBalancerArns?.length === 0) {
            entries.LoadBalancerArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `LoadBalancerArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Names != null) {
        const memberEntries = se_LoadBalancerNames(input.Names, context);
        if (input.Names?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.PageSize != null) {
        entries["PageSize"] = input.PageSize;
    }
    return entries;
};
const se_DescribeRulesInput = (input, context) => {
    const entries = {};
    if (input.ListenerArn != null) {
        entries["ListenerArn"] = input.ListenerArn;
    }
    if (input.RuleArns != null) {
        const memberEntries = se_RuleArns(input.RuleArns, context);
        if (input.RuleArns?.length === 0) {
            entries.RuleArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RuleArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.PageSize != null) {
        entries["PageSize"] = input.PageSize;
    }
    return entries;
};
const se_DescribeSSLPoliciesInput = (input, context) => {
    const entries = {};
    if (input.Names != null) {
        const memberEntries = se_SslPolicyNames(input.Names, context);
        if (input.Names?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.PageSize != null) {
        entries["PageSize"] = input.PageSize;
    }
    if (input.LoadBalancerType != null) {
        entries["LoadBalancerType"] = input.LoadBalancerType;
    }
    return entries;
};
const se_DescribeTagsInput = (input, context) => {
    const entries = {};
    if (input.ResourceArns != null) {
        const memberEntries = se_ResourceArns(input.ResourceArns, context);
        if (input.ResourceArns?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DescribeTargetGroupAttributesInput = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    return entries;
};
const se_DescribeTargetGroupsInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    if (input.TargetGroupArns != null) {
        const memberEntries = se_TargetGroupArns(input.TargetGroupArns, context);
        if (input.TargetGroupArns?.length === 0) {
            entries.TargetGroupArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Names != null) {
        const memberEntries = se_TargetGroupNames(input.Names, context);
        if (input.Names?.length === 0) {
            entries.Names = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Names.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.PageSize != null) {
        entries["PageSize"] = input.PageSize;
    }
    return entries;
};
const se_DescribeTargetHealthInput = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    if (input.Targets != null) {
        const memberEntries = se_TargetDescriptions(input.Targets, context);
        if (input.Targets?.length === 0) {
            entries.Targets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Targets.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_FixedResponseActionConfig = (input, context) => {
    const entries = {};
    if (input.MessageBody != null) {
        entries["MessageBody"] = input.MessageBody;
    }
    if (input.StatusCode != null) {
        entries["StatusCode"] = input.StatusCode;
    }
    if (input.ContentType != null) {
        entries["ContentType"] = input.ContentType;
    }
    return entries;
};
const se_ForwardActionConfig = (input, context) => {
    const entries = {};
    if (input.TargetGroups != null) {
        const memberEntries = se_TargetGroupList(input.TargetGroups, context);
        if (input.TargetGroups?.length === 0) {
            entries.TargetGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroups.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TargetGroupStickinessConfig != null) {
        const memberEntries = se_TargetGroupStickinessConfig(input.TargetGroupStickinessConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TargetGroupStickinessConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_HostHeaderConditionConfig = (input, context) => {
    const entries = {};
    if (input.Values != null) {
        const memberEntries = se_ListOfString(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_HttpHeaderConditionConfig = (input, context) => {
    const entries = {};
    if (input.HttpHeaderName != null) {
        entries["HttpHeaderName"] = input.HttpHeaderName;
    }
    if (input.Values != null) {
        const memberEntries = se_ListOfString(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_HttpRequestMethodConditionConfig = (input, context) => {
    const entries = {};
    if (input.Values != null) {
        const memberEntries = se_ListOfString(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ListenerArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ListOfString = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LoadBalancerArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_LoadBalancerAttribute = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_LoadBalancerAttributes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_LoadBalancerAttribute(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_LoadBalancerNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Matcher = (input, context) => {
    const entries = {};
    if (input.HttpCode != null) {
        entries["HttpCode"] = input.HttpCode;
    }
    if (input.GrpcCode != null) {
        entries["GrpcCode"] = input.GrpcCode;
    }
    return entries;
};
const se_ModifyListenerInput = (input, context) => {
    const entries = {};
    if (input.ListenerArn != null) {
        entries["ListenerArn"] = input.ListenerArn;
    }
    if (input.Port != null) {
        entries["Port"] = input.Port;
    }
    if (input.Protocol != null) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.SslPolicy != null) {
        entries["SslPolicy"] = input.SslPolicy;
    }
    if (input.Certificates != null) {
        const memberEntries = se_CertificateList(input.Certificates, context);
        if (input.Certificates?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    if (input.DefaultActions != null) {
        const memberEntries = se_Actions(input.DefaultActions, context);
        if (input.DefaultActions?.length === 0) {
            entries.DefaultActions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `DefaultActions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.AlpnPolicy != null) {
        const memberEntries = se_AlpnPolicyName(input.AlpnPolicy, context);
        if (input.AlpnPolicy?.length === 0) {
            entries.AlpnPolicy = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `AlpnPolicy.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyLoadBalancerAttributesInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    if (input.Attributes != null) {
        const memberEntries = se_LoadBalancerAttributes(input.Attributes, context);
        if (input.Attributes?.length === 0) {
            entries.Attributes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Attributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyRuleInput = (input, context) => {
    const entries = {};
    if (input.RuleArn != null) {
        entries["RuleArn"] = input.RuleArn;
    }
    if (input.Conditions != null) {
        const memberEntries = se_RuleConditionList(input.Conditions, context);
        if (input.Conditions?.length === 0) {
            entries.Conditions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Conditions.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Actions != null) {
        const memberEntries = se_Actions(input.Actions, context);
        if (input.Actions?.length === 0) {
            entries.Actions = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Actions.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyTargetGroupAttributesInput = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    if (input.Attributes != null) {
        const memberEntries = se_TargetGroupAttributes(input.Attributes, context);
        if (input.Attributes?.length === 0) {
            entries.Attributes = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Attributes.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ModifyTargetGroupInput = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    if (input.HealthCheckProtocol != null) {
        entries["HealthCheckProtocol"] = input.HealthCheckProtocol;
    }
    if (input.HealthCheckPort != null) {
        entries["HealthCheckPort"] = input.HealthCheckPort;
    }
    if (input.HealthCheckPath != null) {
        entries["HealthCheckPath"] = input.HealthCheckPath;
    }
    if (input.HealthCheckEnabled != null) {
        entries["HealthCheckEnabled"] = input.HealthCheckEnabled;
    }
    if (input.HealthCheckIntervalSeconds != null) {
        entries["HealthCheckIntervalSeconds"] = input.HealthCheckIntervalSeconds;
    }
    if (input.HealthCheckTimeoutSeconds != null) {
        entries["HealthCheckTimeoutSeconds"] = input.HealthCheckTimeoutSeconds;
    }
    if (input.HealthyThresholdCount != null) {
        entries["HealthyThresholdCount"] = input.HealthyThresholdCount;
    }
    if (input.UnhealthyThresholdCount != null) {
        entries["UnhealthyThresholdCount"] = input.UnhealthyThresholdCount;
    }
    if (input.Matcher != null) {
        const memberEntries = se_Matcher(input.Matcher, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Matcher.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_PathPatternConditionConfig = (input, context) => {
    const entries = {};
    if (input.Values != null) {
        const memberEntries = se_ListOfString(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_QueryStringConditionConfig = (input, context) => {
    const entries = {};
    if (input.Values != null) {
        const memberEntries = se_QueryStringKeyValuePairList(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_QueryStringKeyValuePair = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_QueryStringKeyValuePairList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_QueryStringKeyValuePair(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RedirectActionConfig = (input, context) => {
    const entries = {};
    if (input.Protocol != null) {
        entries["Protocol"] = input.Protocol;
    }
    if (input.Port != null) {
        entries["Port"] = input.Port;
    }
    if (input.Host != null) {
        entries["Host"] = input.Host;
    }
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.Query != null) {
        entries["Query"] = input.Query;
    }
    if (input.StatusCode != null) {
        entries["StatusCode"] = input.StatusCode;
    }
    return entries;
};
const se_RegisterTargetsInput = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    if (input.Targets != null) {
        const memberEntries = se_TargetDescriptions(input.Targets, context);
        if (input.Targets?.length === 0) {
            entries.Targets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Targets.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RemoveListenerCertificatesInput = (input, context) => {
    const entries = {};
    if (input.ListenerArn != null) {
        entries["ListenerArn"] = input.ListenerArn;
    }
    if (input.Certificates != null) {
        const memberEntries = se_CertificateList(input.Certificates, context);
        if (input.Certificates?.length === 0) {
            entries.Certificates = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Certificates.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RemoveTagsInput = (input, context) => {
    const entries = {};
    if (input.ResourceArns != null) {
        const memberEntries = se_ResourceArns(input.ResourceArns, context);
        if (input.ResourceArns?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TagKeys != null) {
        const memberEntries = se_TagKeys(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ResourceArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RuleArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_RuleCondition = (input, context) => {
    const entries = {};
    if (input.Field != null) {
        entries["Field"] = input.Field;
    }
    if (input.Values != null) {
        const memberEntries = se_ListOfString(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    if (input.HostHeaderConfig != null) {
        const memberEntries = se_HostHeaderConditionConfig(input.HostHeaderConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HostHeaderConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PathPatternConfig != null) {
        const memberEntries = se_PathPatternConditionConfig(input.PathPatternConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PathPatternConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.HttpHeaderConfig != null) {
        const memberEntries = se_HttpHeaderConditionConfig(input.HttpHeaderConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HttpHeaderConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.QueryStringConfig != null) {
        const memberEntries = se_QueryStringConditionConfig(input.QueryStringConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `QueryStringConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.HttpRequestMethodConfig != null) {
        const memberEntries = se_HttpRequestMethodConditionConfig(input.HttpRequestMethodConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `HttpRequestMethodConfig.${key}`;
            entries[loc] = value;
        });
    }
    if (input.SourceIpConfig != null) {
        const memberEntries = se_SourceIpConditionConfig(input.SourceIpConfig, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SourceIpConfig.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_RuleConditionList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RuleCondition(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RulePriorityList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_RulePriorityPair(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_RulePriorityPair = (input, context) => {
    const entries = {};
    if (input.RuleArn != null) {
        entries["RuleArn"] = input.RuleArn;
    }
    if (input.Priority != null) {
        entries["Priority"] = input.Priority;
    }
    return entries;
};
const se_SecurityGroups = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetIpAddressTypeInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    if (input.IpAddressType != null) {
        entries["IpAddressType"] = input.IpAddressType;
    }
    return entries;
};
const se_SetRulePrioritiesInput = (input, context) => {
    const entries = {};
    if (input.RulePriorities != null) {
        const memberEntries = se_RulePriorityList(input.RulePriorities, context);
        if (input.RulePriorities?.length === 0) {
            entries.RulePriorities = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `RulePriorities.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SetSecurityGroupsInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    if (input.SecurityGroups != null) {
        const memberEntries = se_SecurityGroups(input.SecurityGroups, context);
        if (input.SecurityGroups?.length === 0) {
            entries.SecurityGroups = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SecurityGroups.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SetSubnetsInput = (input, context) => {
    const entries = {};
    if (input.LoadBalancerArn != null) {
        entries["LoadBalancerArn"] = input.LoadBalancerArn;
    }
    if (input.Subnets != null) {
        const memberEntries = se_Subnets(input.Subnets, context);
        if (input.Subnets?.length === 0) {
            entries.Subnets = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Subnets.${key}`;
            entries[loc] = value;
        });
    }
    if (input.SubnetMappings != null) {
        const memberEntries = se_SubnetMappings(input.SubnetMappings, context);
        if (input.SubnetMappings?.length === 0) {
            entries.SubnetMappings = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `SubnetMappings.${key}`;
            entries[loc] = value;
        });
    }
    if (input.IpAddressType != null) {
        entries["IpAddressType"] = input.IpAddressType;
    }
    return entries;
};
const se_SourceIpConditionConfig = (input, context) => {
    const entries = {};
    if (input.Values != null) {
        const memberEntries = se_ListOfString(input.Values, context);
        if (input.Values?.length === 0) {
            entries.Values = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Values.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_SslPolicyNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SubnetMapping = (input, context) => {
    const entries = {};
    if (input.SubnetId != null) {
        entries["SubnetId"] = input.SubnetId;
    }
    if (input.AllocationId != null) {
        entries["AllocationId"] = input.AllocationId;
    }
    if (input.PrivateIPv4Address != null) {
        entries["PrivateIPv4Address"] = input.PrivateIPv4Address;
    }
    if (input.IPv6Address != null) {
        entries["IPv6Address"] = input.IPv6Address;
    }
    return entries;
};
const se_SubnetMappings = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_SubnetMapping(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Subnets = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_TagKeys = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TagList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetDescription = (input, context) => {
    const entries = {};
    if (input.Id != null) {
        entries["Id"] = input.Id;
    }
    if (input.Port != null) {
        entries["Port"] = input.Port;
    }
    if (input.AvailabilityZone != null) {
        entries["AvailabilityZone"] = input.AvailabilityZone;
    }
    return entries;
};
const se_TargetDescriptions = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetDescription(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupArns = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TargetGroupAttribute = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_TargetGroupAttributes = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetGroupAttribute(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupList = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_TargetGroupTuple(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TargetGroupNames = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_TargetGroupStickinessConfig = (input, context) => {
    const entries = {};
    if (input.Enabled != null) {
        entries["Enabled"] = input.Enabled;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    return entries;
};
const se_TargetGroupTuple = (input, context) => {
    const entries = {};
    if (input.TargetGroupArn != null) {
        entries["TargetGroupArn"] = input.TargetGroupArn;
    }
    if (input.Weight != null) {
        entries["Weight"] = input.Weight;
    }
    return entries;
};
const de_Action = (output, context) => {
    const contents = {};
    if (output["Type"] !== undefined) {
        contents.Type = (0, smithy_client_1.expectString)(output["Type"]);
    }
    if (output["TargetGroupArn"] !== undefined) {
        contents.TargetGroupArn = (0, smithy_client_1.expectString)(output["TargetGroupArn"]);
    }
    if (output["AuthenticateOidcConfig"] !== undefined) {
        contents.AuthenticateOidcConfig = de_AuthenticateOidcActionConfig(output["AuthenticateOidcConfig"], context);
    }
    if (output["AuthenticateCognitoConfig"] !== undefined) {
        contents.AuthenticateCognitoConfig = de_AuthenticateCognitoActionConfig(output["AuthenticateCognitoConfig"], context);
    }
    if (output["Order"] !== undefined) {
        contents.Order = (0, smithy_client_1.strictParseInt32)(output["Order"]);
    }
    if (output["RedirectConfig"] !== undefined) {
        contents.RedirectConfig = de_RedirectActionConfig(output["RedirectConfig"], context);
    }
    if (output["FixedResponseConfig"] !== undefined) {
        contents.FixedResponseConfig = de_FixedResponseActionConfig(output["FixedResponseConfig"], context);
    }
    if (output["ForwardConfig"] !== undefined) {
        contents.ForwardConfig = de_ForwardActionConfig(output["ForwardConfig"], context);
    }
    return contents;
};
const de_Actions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Action(entry, context);
    });
};
const de_AddListenerCertificatesOutput = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents.Certificates = [];
    }
    else if (output["Certificates"] !== undefined && output["Certificates"]["member"] !== undefined) {
        contents.Certificates = de_CertificateList((0, smithy_client_1.getArrayIfSingleItem)(output["Certificates"]["member"]), context);
    }
    return contents;
};
const de_AddTagsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_AllocationIdNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_AlpnPolicyName = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_ALPNPolicyNotSupportedException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_AuthenticateCognitoActionAuthenticationRequestExtraParams = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = (0, smithy_client_1.expectString)(pair["value"]);
        return acc;
    }, {});
};
const de_AuthenticateCognitoActionConfig = (output, context) => {
    const contents = {};
    if (output["UserPoolArn"] !== undefined) {
        contents.UserPoolArn = (0, smithy_client_1.expectString)(output["UserPoolArn"]);
    }
    if (output["UserPoolClientId"] !== undefined) {
        contents.UserPoolClientId = (0, smithy_client_1.expectString)(output["UserPoolClientId"]);
    }
    if (output["UserPoolDomain"] !== undefined) {
        contents.UserPoolDomain = (0, smithy_client_1.expectString)(output["UserPoolDomain"]);
    }
    if (output["SessionCookieName"] !== undefined) {
        contents.SessionCookieName = (0, smithy_client_1.expectString)(output["SessionCookieName"]);
    }
    if (output["Scope"] !== undefined) {
        contents.Scope = (0, smithy_client_1.expectString)(output["Scope"]);
    }
    if (output["SessionTimeout"] !== undefined) {
        contents.SessionTimeout = (0, smithy_client_1.strictParseLong)(output["SessionTimeout"]);
    }
    if (output.AuthenticationRequestExtraParams === "") {
        contents.AuthenticationRequestExtraParams = {};
    }
    else if (output["AuthenticationRequestExtraParams"] !== undefined &&
        output["AuthenticationRequestExtraParams"]["entry"] !== undefined) {
        contents.AuthenticationRequestExtraParams = de_AuthenticateCognitoActionAuthenticationRequestExtraParams((0, smithy_client_1.getArrayIfSingleItem)(output["AuthenticationRequestExtraParams"]["entry"]), context);
    }
    if (output["OnUnauthenticatedRequest"] !== undefined) {
        contents.OnUnauthenticatedRequest = (0, smithy_client_1.expectString)(output["OnUnauthenticatedRequest"]);
    }
    return contents;
};
const de_AuthenticateOidcActionAuthenticationRequestExtraParams = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = (0, smithy_client_1.expectString)(pair["value"]);
        return acc;
    }, {});
};
const de_AuthenticateOidcActionConfig = (output, context) => {
    const contents = {};
    if (output["Issuer"] !== undefined) {
        contents.Issuer = (0, smithy_client_1.expectString)(output["Issuer"]);
    }
    if (output["AuthorizationEndpoint"] !== undefined) {
        contents.AuthorizationEndpoint = (0, smithy_client_1.expectString)(output["AuthorizationEndpoint"]);
    }
    if (output["TokenEndpoint"] !== undefined) {
        contents.TokenEndpoint = (0, smithy_client_1.expectString)(output["TokenEndpoint"]);
    }
    if (output["UserInfoEndpoint"] !== undefined) {
        contents.UserInfoEndpoint = (0, smithy_client_1.expectString)(output["UserInfoEndpoint"]);
    }
    if (output["ClientId"] !== undefined) {
        contents.ClientId = (0, smithy_client_1.expectString)(output["ClientId"]);
    }
    if (output["ClientSecret"] !== undefined) {
        contents.ClientSecret = (0, smithy_client_1.expectString)(output["ClientSecret"]);
    }
    if (output["SessionCookieName"] !== undefined) {
        contents.SessionCookieName = (0, smithy_client_1.expectString)(output["SessionCookieName"]);
    }
    if (output["Scope"] !== undefined) {
        contents.Scope = (0, smithy_client_1.expectString)(output["Scope"]);
    }
    if (output["SessionTimeout"] !== undefined) {
        contents.SessionTimeout = (0, smithy_client_1.strictParseLong)(output["SessionTimeout"]);
    }
    if (output.AuthenticationRequestExtraParams === "") {
        contents.AuthenticationRequestExtraParams = {};
    }
    else if (output["AuthenticationRequestExtraParams"] !== undefined &&
        output["AuthenticationRequestExtraParams"]["entry"] !== undefined) {
        contents.AuthenticationRequestExtraParams = de_AuthenticateOidcActionAuthenticationRequestExtraParams((0, smithy_client_1.getArrayIfSingleItem)(output["AuthenticationRequestExtraParams"]["entry"]), context);
    }
    if (output["OnUnauthenticatedRequest"] !== undefined) {
        contents.OnUnauthenticatedRequest = (0, smithy_client_1.expectString)(output["OnUnauthenticatedRequest"]);
    }
    if (output["UseExistingClientSecret"] !== undefined) {
        contents.UseExistingClientSecret = (0, smithy_client_1.parseBoolean)(output["UseExistingClientSecret"]);
    }
    return contents;
};
const de_AvailabilityZone = (output, context) => {
    const contents = {};
    if (output["ZoneName"] !== undefined) {
        contents.ZoneName = (0, smithy_client_1.expectString)(output["ZoneName"]);
    }
    if (output["SubnetId"] !== undefined) {
        contents.SubnetId = (0, smithy_client_1.expectString)(output["SubnetId"]);
    }
    if (output["OutpostId"] !== undefined) {
        contents.OutpostId = (0, smithy_client_1.expectString)(output["OutpostId"]);
    }
    if (output.LoadBalancerAddresses === "") {
        contents.LoadBalancerAddresses = [];
    }
    else if (output["LoadBalancerAddresses"] !== undefined && output["LoadBalancerAddresses"]["member"] !== undefined) {
        contents.LoadBalancerAddresses = de_LoadBalancerAddresses((0, smithy_client_1.getArrayIfSingleItem)(output["LoadBalancerAddresses"]["member"]), context);
    }
    return contents;
};
const de_AvailabilityZoneNotSupportedException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_AvailabilityZones = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AvailabilityZone(entry, context);
    });
};
const de_Certificate = (output, context) => {
    const contents = {};
    if (output["CertificateArn"] !== undefined) {
        contents.CertificateArn = (0, smithy_client_1.expectString)(output["CertificateArn"]);
    }
    if (output["IsDefault"] !== undefined) {
        contents.IsDefault = (0, smithy_client_1.parseBoolean)(output["IsDefault"]);
    }
    return contents;
};
const de_CertificateList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Certificate(entry, context);
    });
};
const de_CertificateNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_Cipher = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["Priority"] !== undefined) {
        contents.Priority = (0, smithy_client_1.strictParseInt32)(output["Priority"]);
    }
    return contents;
};
const de_Ciphers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Cipher(entry, context);
    });
};
const de_CreateListenerOutput = (output, context) => {
    const contents = {};
    if (output.Listeners === "") {
        contents.Listeners = [];
    }
    else if (output["Listeners"] !== undefined && output["Listeners"]["member"] !== undefined) {
        contents.Listeners = de_Listeners((0, smithy_client_1.getArrayIfSingleItem)(output["Listeners"]["member"]), context);
    }
    return contents;
};
const de_CreateLoadBalancerOutput = (output, context) => {
    const contents = {};
    if (output.LoadBalancers === "") {
        contents.LoadBalancers = [];
    }
    else if (output["LoadBalancers"] !== undefined && output["LoadBalancers"]["member"] !== undefined) {
        contents.LoadBalancers = de_LoadBalancers((0, smithy_client_1.getArrayIfSingleItem)(output["LoadBalancers"]["member"]), context);
    }
    return contents;
};
const de_CreateRuleOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents.Rules = [];
    }
    else if (output["Rules"] !== undefined && output["Rules"]["member"] !== undefined) {
        contents.Rules = de_Rules((0, smithy_client_1.getArrayIfSingleItem)(output["Rules"]["member"]), context);
    }
    return contents;
};
const de_CreateTargetGroupOutput = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents.TargetGroups = [];
    }
    else if (output["TargetGroups"] !== undefined && output["TargetGroups"]["member"] !== undefined) {
        contents.TargetGroups = de_TargetGroups((0, smithy_client_1.getArrayIfSingleItem)(output["TargetGroups"]["member"]), context);
    }
    return contents;
};
const de_DeleteListenerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteLoadBalancerOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteRuleOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeleteTargetGroupOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DeregisterTargetsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_DescribeAccountLimitsOutput = (output, context) => {
    const contents = {};
    if (output.Limits === "") {
        contents.Limits = [];
    }
    else if (output["Limits"] !== undefined && output["Limits"]["member"] !== undefined) {
        contents.Limits = de_Limits((0, smithy_client_1.getArrayIfSingleItem)(output["Limits"]["member"]), context);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const de_DescribeListenerCertificatesOutput = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents.Certificates = [];
    }
    else if (output["Certificates"] !== undefined && output["Certificates"]["member"] !== undefined) {
        contents.Certificates = de_CertificateList((0, smithy_client_1.getArrayIfSingleItem)(output["Certificates"]["member"]), context);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const de_DescribeListenersOutput = (output, context) => {
    const contents = {};
    if (output.Listeners === "") {
        contents.Listeners = [];
    }
    else if (output["Listeners"] !== undefined && output["Listeners"]["member"] !== undefined) {
        contents.Listeners = de_Listeners((0, smithy_client_1.getArrayIfSingleItem)(output["Listeners"]["member"]), context);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const de_DescribeLoadBalancerAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents.Attributes = [];
    }
    else if (output["Attributes"] !== undefined && output["Attributes"]["member"] !== undefined) {
        contents.Attributes = de_LoadBalancerAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["Attributes"]["member"]), context);
    }
    return contents;
};
const de_DescribeLoadBalancersOutput = (output, context) => {
    const contents = {};
    if (output.LoadBalancers === "") {
        contents.LoadBalancers = [];
    }
    else if (output["LoadBalancers"] !== undefined && output["LoadBalancers"]["member"] !== undefined) {
        contents.LoadBalancers = de_LoadBalancers((0, smithy_client_1.getArrayIfSingleItem)(output["LoadBalancers"]["member"]), context);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const de_DescribeRulesOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents.Rules = [];
    }
    else if (output["Rules"] !== undefined && output["Rules"]["member"] !== undefined) {
        contents.Rules = de_Rules((0, smithy_client_1.getArrayIfSingleItem)(output["Rules"]["member"]), context);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const de_DescribeSSLPoliciesOutput = (output, context) => {
    const contents = {};
    if (output.SslPolicies === "") {
        contents.SslPolicies = [];
    }
    else if (output["SslPolicies"] !== undefined && output["SslPolicies"]["member"] !== undefined) {
        contents.SslPolicies = de_SslPolicies((0, smithy_client_1.getArrayIfSingleItem)(output["SslPolicies"]["member"]), context);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const de_DescribeTagsOutput = (output, context) => {
    const contents = {};
    if (output.TagDescriptions === "") {
        contents.TagDescriptions = [];
    }
    else if (output["TagDescriptions"] !== undefined && output["TagDescriptions"]["member"] !== undefined) {
        contents.TagDescriptions = de_TagDescriptions((0, smithy_client_1.getArrayIfSingleItem)(output["TagDescriptions"]["member"]), context);
    }
    return contents;
};
const de_DescribeTargetGroupAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents.Attributes = [];
    }
    else if (output["Attributes"] !== undefined && output["Attributes"]["member"] !== undefined) {
        contents.Attributes = de_TargetGroupAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["Attributes"]["member"]), context);
    }
    return contents;
};
const de_DescribeTargetGroupsOutput = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents.TargetGroups = [];
    }
    else if (output["TargetGroups"] !== undefined && output["TargetGroups"]["member"] !== undefined) {
        contents.TargetGroups = de_TargetGroups((0, smithy_client_1.getArrayIfSingleItem)(output["TargetGroups"]["member"]), context);
    }
    if (output["NextMarker"] !== undefined) {
        contents.NextMarker = (0, smithy_client_1.expectString)(output["NextMarker"]);
    }
    return contents;
};
const de_DescribeTargetHealthOutput = (output, context) => {
    const contents = {};
    if (output.TargetHealthDescriptions === "") {
        contents.TargetHealthDescriptions = [];
    }
    else if (output["TargetHealthDescriptions"] !== undefined &&
        output["TargetHealthDescriptions"]["member"] !== undefined) {
        contents.TargetHealthDescriptions = de_TargetHealthDescriptions((0, smithy_client_1.getArrayIfSingleItem)(output["TargetHealthDescriptions"]["member"]), context);
    }
    return contents;
};
const de_DuplicateListenerException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_DuplicateLoadBalancerNameException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_DuplicateTagKeysException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_DuplicateTargetGroupNameException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_FixedResponseActionConfig = (output, context) => {
    const contents = {};
    if (output["MessageBody"] !== undefined) {
        contents.MessageBody = (0, smithy_client_1.expectString)(output["MessageBody"]);
    }
    if (output["StatusCode"] !== undefined) {
        contents.StatusCode = (0, smithy_client_1.expectString)(output["StatusCode"]);
    }
    if (output["ContentType"] !== undefined) {
        contents.ContentType = (0, smithy_client_1.expectString)(output["ContentType"]);
    }
    return contents;
};
const de_ForwardActionConfig = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents.TargetGroups = [];
    }
    else if (output["TargetGroups"] !== undefined && output["TargetGroups"]["member"] !== undefined) {
        contents.TargetGroups = de_TargetGroupList((0, smithy_client_1.getArrayIfSingleItem)(output["TargetGroups"]["member"]), context);
    }
    if (output["TargetGroupStickinessConfig"] !== undefined) {
        contents.TargetGroupStickinessConfig = de_TargetGroupStickinessConfig(output["TargetGroupStickinessConfig"], context);
    }
    return contents;
};
const de_HealthUnavailableException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_HostHeaderConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_ListOfString((0, smithy_client_1.getArrayIfSingleItem)(output["Values"]["member"]), context);
    }
    return contents;
};
const de_HttpHeaderConditionConfig = (output, context) => {
    const contents = {};
    if (output["HttpHeaderName"] !== undefined) {
        contents.HttpHeaderName = (0, smithy_client_1.expectString)(output["HttpHeaderName"]);
    }
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_ListOfString((0, smithy_client_1.getArrayIfSingleItem)(output["Values"]["member"]), context);
    }
    return contents;
};
const de_HttpRequestMethodConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_ListOfString((0, smithy_client_1.getArrayIfSingleItem)(output["Values"]["member"]), context);
    }
    return contents;
};
const de_IncompatibleProtocolsException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_InvalidConfigurationRequestException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_InvalidLoadBalancerActionException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_InvalidSchemeException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_InvalidSecurityGroupException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_InvalidSubnetException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_InvalidTargetException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_Limit = (output, context) => {
    const contents = {};
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output["Max"] !== undefined) {
        contents.Max = (0, smithy_client_1.expectString)(output["Max"]);
    }
    return contents;
};
const de_Limits = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Limit(entry, context);
    });
};
const de_Listener = (output, context) => {
    const contents = {};
    if (output["ListenerArn"] !== undefined) {
        contents.ListenerArn = (0, smithy_client_1.expectString)(output["ListenerArn"]);
    }
    if (output["LoadBalancerArn"] !== undefined) {
        contents.LoadBalancerArn = (0, smithy_client_1.expectString)(output["LoadBalancerArn"]);
    }
    if (output["Port"] !== undefined) {
        contents.Port = (0, smithy_client_1.strictParseInt32)(output["Port"]);
    }
    if (output["Protocol"] !== undefined) {
        contents.Protocol = (0, smithy_client_1.expectString)(output["Protocol"]);
    }
    if (output.Certificates === "") {
        contents.Certificates = [];
    }
    else if (output["Certificates"] !== undefined && output["Certificates"]["member"] !== undefined) {
        contents.Certificates = de_CertificateList((0, smithy_client_1.getArrayIfSingleItem)(output["Certificates"]["member"]), context);
    }
    if (output["SslPolicy"] !== undefined) {
        contents.SslPolicy = (0, smithy_client_1.expectString)(output["SslPolicy"]);
    }
    if (output.DefaultActions === "") {
        contents.DefaultActions = [];
    }
    else if (output["DefaultActions"] !== undefined && output["DefaultActions"]["member"] !== undefined) {
        contents.DefaultActions = de_Actions((0, smithy_client_1.getArrayIfSingleItem)(output["DefaultActions"]["member"]), context);
    }
    if (output.AlpnPolicy === "") {
        contents.AlpnPolicy = [];
    }
    else if (output["AlpnPolicy"] !== undefined && output["AlpnPolicy"]["member"] !== undefined) {
        contents.AlpnPolicy = de_AlpnPolicyName((0, smithy_client_1.getArrayIfSingleItem)(output["AlpnPolicy"]["member"]), context);
    }
    return contents;
};
const de_ListenerNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_Listeners = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Listener(entry, context);
    });
};
const de_ListOfString = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_LoadBalancer = (output, context) => {
    const contents = {};
    if (output["LoadBalancerArn"] !== undefined) {
        contents.LoadBalancerArn = (0, smithy_client_1.expectString)(output["LoadBalancerArn"]);
    }
    if (output["DNSName"] !== undefined) {
        contents.DNSName = (0, smithy_client_1.expectString)(output["DNSName"]);
    }
    if (output["CanonicalHostedZoneId"] !== undefined) {
        contents.CanonicalHostedZoneId = (0, smithy_client_1.expectString)(output["CanonicalHostedZoneId"]);
    }
    if (output["CreatedTime"] !== undefined) {
        contents.CreatedTime = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["CreatedTime"]));
    }
    if (output["LoadBalancerName"] !== undefined) {
        contents.LoadBalancerName = (0, smithy_client_1.expectString)(output["LoadBalancerName"]);
    }
    if (output["Scheme"] !== undefined) {
        contents.Scheme = (0, smithy_client_1.expectString)(output["Scheme"]);
    }
    if (output["VpcId"] !== undefined) {
        contents.VpcId = (0, smithy_client_1.expectString)(output["VpcId"]);
    }
    if (output["State"] !== undefined) {
        contents.State = de_LoadBalancerState(output["State"], context);
    }
    if (output["Type"] !== undefined) {
        contents.Type = (0, smithy_client_1.expectString)(output["Type"]);
    }
    if (output.AvailabilityZones === "") {
        contents.AvailabilityZones = [];
    }
    else if (output["AvailabilityZones"] !== undefined && output["AvailabilityZones"]["member"] !== undefined) {
        contents.AvailabilityZones = de_AvailabilityZones((0, smithy_client_1.getArrayIfSingleItem)(output["AvailabilityZones"]["member"]), context);
    }
    if (output.SecurityGroups === "") {
        contents.SecurityGroups = [];
    }
    else if (output["SecurityGroups"] !== undefined && output["SecurityGroups"]["member"] !== undefined) {
        contents.SecurityGroups = de_SecurityGroups((0, smithy_client_1.getArrayIfSingleItem)(output["SecurityGroups"]["member"]), context);
    }
    if (output["IpAddressType"] !== undefined) {
        contents.IpAddressType = (0, smithy_client_1.expectString)(output["IpAddressType"]);
    }
    if (output["CustomerOwnedIpv4Pool"] !== undefined) {
        contents.CustomerOwnedIpv4Pool = (0, smithy_client_1.expectString)(output["CustomerOwnedIpv4Pool"]);
    }
    return contents;
};
const de_LoadBalancerAddress = (output, context) => {
    const contents = {};
    if (output["IpAddress"] !== undefined) {
        contents.IpAddress = (0, smithy_client_1.expectString)(output["IpAddress"]);
    }
    if (output["AllocationId"] !== undefined) {
        contents.AllocationId = (0, smithy_client_1.expectString)(output["AllocationId"]);
    }
    if (output["PrivateIPv4Address"] !== undefined) {
        contents.PrivateIPv4Address = (0, smithy_client_1.expectString)(output["PrivateIPv4Address"]);
    }
    if (output["IPv6Address"] !== undefined) {
        contents.IPv6Address = (0, smithy_client_1.expectString)(output["IPv6Address"]);
    }
    return contents;
};
const de_LoadBalancerAddresses = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerAddress(entry, context);
    });
};
const de_LoadBalancerArns = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_LoadBalancerAttribute = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
};
const de_LoadBalancerAttributes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancerAttribute(entry, context);
    });
};
const de_LoadBalancerNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_LoadBalancers = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_LoadBalancer(entry, context);
    });
};
const de_LoadBalancerState = (output, context) => {
    const contents = {};
    if (output["Code"] !== undefined) {
        contents.Code = (0, smithy_client_1.expectString)(output["Code"]);
    }
    if (output["Reason"] !== undefined) {
        contents.Reason = (0, smithy_client_1.expectString)(output["Reason"]);
    }
    return contents;
};
const de_Matcher = (output, context) => {
    const contents = {};
    if (output["HttpCode"] !== undefined) {
        contents.HttpCode = (0, smithy_client_1.expectString)(output["HttpCode"]);
    }
    if (output["GrpcCode"] !== undefined) {
        contents.GrpcCode = (0, smithy_client_1.expectString)(output["GrpcCode"]);
    }
    return contents;
};
const de_ModifyListenerOutput = (output, context) => {
    const contents = {};
    if (output.Listeners === "") {
        contents.Listeners = [];
    }
    else if (output["Listeners"] !== undefined && output["Listeners"]["member"] !== undefined) {
        contents.Listeners = de_Listeners((0, smithy_client_1.getArrayIfSingleItem)(output["Listeners"]["member"]), context);
    }
    return contents;
};
const de_ModifyLoadBalancerAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents.Attributes = [];
    }
    else if (output["Attributes"] !== undefined && output["Attributes"]["member"] !== undefined) {
        contents.Attributes = de_LoadBalancerAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["Attributes"]["member"]), context);
    }
    return contents;
};
const de_ModifyRuleOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents.Rules = [];
    }
    else if (output["Rules"] !== undefined && output["Rules"]["member"] !== undefined) {
        contents.Rules = de_Rules((0, smithy_client_1.getArrayIfSingleItem)(output["Rules"]["member"]), context);
    }
    return contents;
};
const de_ModifyTargetGroupAttributesOutput = (output, context) => {
    const contents = {};
    if (output.Attributes === "") {
        contents.Attributes = [];
    }
    else if (output["Attributes"] !== undefined && output["Attributes"]["member"] !== undefined) {
        contents.Attributes = de_TargetGroupAttributes((0, smithy_client_1.getArrayIfSingleItem)(output["Attributes"]["member"]), context);
    }
    return contents;
};
const de_ModifyTargetGroupOutput = (output, context) => {
    const contents = {};
    if (output.TargetGroups === "") {
        contents.TargetGroups = [];
    }
    else if (output["TargetGroups"] !== undefined && output["TargetGroups"]["member"] !== undefined) {
        contents.TargetGroups = de_TargetGroups((0, smithy_client_1.getArrayIfSingleItem)(output["TargetGroups"]["member"]), context);
    }
    return contents;
};
const de_OperationNotPermittedException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_PathPatternConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_ListOfString((0, smithy_client_1.getArrayIfSingleItem)(output["Values"]["member"]), context);
    }
    return contents;
};
const de_PriorityInUseException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_QueryStringConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_QueryStringKeyValuePairList((0, smithy_client_1.getArrayIfSingleItem)(output["Values"]["member"]), context);
    }
    return contents;
};
const de_QueryStringKeyValuePair = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
};
const de_QueryStringKeyValuePairList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_QueryStringKeyValuePair(entry, context);
    });
};
const de_RedirectActionConfig = (output, context) => {
    const contents = {};
    if (output["Protocol"] !== undefined) {
        contents.Protocol = (0, smithy_client_1.expectString)(output["Protocol"]);
    }
    if (output["Port"] !== undefined) {
        contents.Port = (0, smithy_client_1.expectString)(output["Port"]);
    }
    if (output["Host"] !== undefined) {
        contents.Host = (0, smithy_client_1.expectString)(output["Host"]);
    }
    if (output["Path"] !== undefined) {
        contents.Path = (0, smithy_client_1.expectString)(output["Path"]);
    }
    if (output["Query"] !== undefined) {
        contents.Query = (0, smithy_client_1.expectString)(output["Query"]);
    }
    if (output["StatusCode"] !== undefined) {
        contents.StatusCode = (0, smithy_client_1.expectString)(output["StatusCode"]);
    }
    return contents;
};
const de_RegisterTargetsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_RemoveListenerCertificatesOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_RemoveTagsOutput = (output, context) => {
    const contents = {};
    return contents;
};
const de_ResourceInUseException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_Rule = (output, context) => {
    const contents = {};
    if (output["RuleArn"] !== undefined) {
        contents.RuleArn = (0, smithy_client_1.expectString)(output["RuleArn"]);
    }
    if (output["Priority"] !== undefined) {
        contents.Priority = (0, smithy_client_1.expectString)(output["Priority"]);
    }
    if (output.Conditions === "") {
        contents.Conditions = [];
    }
    else if (output["Conditions"] !== undefined && output["Conditions"]["member"] !== undefined) {
        contents.Conditions = de_RuleConditionList((0, smithy_client_1.getArrayIfSingleItem)(output["Conditions"]["member"]), context);
    }
    if (output.Actions === "") {
        contents.Actions = [];
    }
    else if (output["Actions"] !== undefined && output["Actions"]["member"] !== undefined) {
        contents.Actions = de_Actions((0, smithy_client_1.getArrayIfSingleItem)(output["Actions"]["member"]), context);
    }
    if (output["IsDefault"] !== undefined) {
        contents.IsDefault = (0, smithy_client_1.parseBoolean)(output["IsDefault"]);
    }
    return contents;
};
const de_RuleCondition = (output, context) => {
    const contents = {};
    if (output["Field"] !== undefined) {
        contents.Field = (0, smithy_client_1.expectString)(output["Field"]);
    }
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_ListOfString((0, smithy_client_1.getArrayIfSingleItem)(output["Values"]["member"]), context);
    }
    if (output["HostHeaderConfig"] !== undefined) {
        contents.HostHeaderConfig = de_HostHeaderConditionConfig(output["HostHeaderConfig"], context);
    }
    if (output["PathPatternConfig"] !== undefined) {
        contents.PathPatternConfig = de_PathPatternConditionConfig(output["PathPatternConfig"], context);
    }
    if (output["HttpHeaderConfig"] !== undefined) {
        contents.HttpHeaderConfig = de_HttpHeaderConditionConfig(output["HttpHeaderConfig"], context);
    }
    if (output["QueryStringConfig"] !== undefined) {
        contents.QueryStringConfig = de_QueryStringConditionConfig(output["QueryStringConfig"], context);
    }
    if (output["HttpRequestMethodConfig"] !== undefined) {
        contents.HttpRequestMethodConfig = de_HttpRequestMethodConditionConfig(output["HttpRequestMethodConfig"], context);
    }
    if (output["SourceIpConfig"] !== undefined) {
        contents.SourceIpConfig = de_SourceIpConditionConfig(output["SourceIpConfig"], context);
    }
    return contents;
};
const de_RuleConditionList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RuleCondition(entry, context);
    });
};
const de_RuleNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_Rules = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Rule(entry, context);
    });
};
const de_SecurityGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_SetIpAddressTypeOutput = (output, context) => {
    const contents = {};
    if (output["IpAddressType"] !== undefined) {
        contents.IpAddressType = (0, smithy_client_1.expectString)(output["IpAddressType"]);
    }
    return contents;
};
const de_SetRulePrioritiesOutput = (output, context) => {
    const contents = {};
    if (output.Rules === "") {
        contents.Rules = [];
    }
    else if (output["Rules"] !== undefined && output["Rules"]["member"] !== undefined) {
        contents.Rules = de_Rules((0, smithy_client_1.getArrayIfSingleItem)(output["Rules"]["member"]), context);
    }
    return contents;
};
const de_SetSecurityGroupsOutput = (output, context) => {
    const contents = {};
    if (output.SecurityGroupIds === "") {
        contents.SecurityGroupIds = [];
    }
    else if (output["SecurityGroupIds"] !== undefined && output["SecurityGroupIds"]["member"] !== undefined) {
        contents.SecurityGroupIds = de_SecurityGroups((0, smithy_client_1.getArrayIfSingleItem)(output["SecurityGroupIds"]["member"]), context);
    }
    return contents;
};
const de_SetSubnetsOutput = (output, context) => {
    const contents = {};
    if (output.AvailabilityZones === "") {
        contents.AvailabilityZones = [];
    }
    else if (output["AvailabilityZones"] !== undefined && output["AvailabilityZones"]["member"] !== undefined) {
        contents.AvailabilityZones = de_AvailabilityZones((0, smithy_client_1.getArrayIfSingleItem)(output["AvailabilityZones"]["member"]), context);
    }
    if (output["IpAddressType"] !== undefined) {
        contents.IpAddressType = (0, smithy_client_1.expectString)(output["IpAddressType"]);
    }
    return contents;
};
const de_SourceIpConditionConfig = (output, context) => {
    const contents = {};
    if (output.Values === "") {
        contents.Values = [];
    }
    else if (output["Values"] !== undefined && output["Values"]["member"] !== undefined) {
        contents.Values = de_ListOfString((0, smithy_client_1.getArrayIfSingleItem)(output["Values"]["member"]), context);
    }
    return contents;
};
const de_SslPolicies = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SslPolicy(entry, context);
    });
};
const de_SslPolicy = (output, context) => {
    const contents = {};
    if (output.SslProtocols === "") {
        contents.SslProtocols = [];
    }
    else if (output["SslProtocols"] !== undefined && output["SslProtocols"]["member"] !== undefined) {
        contents.SslProtocols = de_SslProtocols((0, smithy_client_1.getArrayIfSingleItem)(output["SslProtocols"]["member"]), context);
    }
    if (output.Ciphers === "") {
        contents.Ciphers = [];
    }
    else if (output["Ciphers"] !== undefined && output["Ciphers"]["member"] !== undefined) {
        contents.Ciphers = de_Ciphers((0, smithy_client_1.getArrayIfSingleItem)(output["Ciphers"]["member"]), context);
    }
    if (output["Name"] !== undefined) {
        contents.Name = (0, smithy_client_1.expectString)(output["Name"]);
    }
    if (output.SupportedLoadBalancerTypes === "") {
        contents.SupportedLoadBalancerTypes = [];
    }
    else if (output["SupportedLoadBalancerTypes"] !== undefined &&
        output["SupportedLoadBalancerTypes"]["member"] !== undefined) {
        contents.SupportedLoadBalancerTypes = de_ListOfString((0, smithy_client_1.getArrayIfSingleItem)(output["SupportedLoadBalancerTypes"]["member"]), context);
    }
    return contents;
};
const de_SSLPolicyNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_SslProtocols = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.expectString)(entry);
    });
};
const de_SubnetNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
};
const de_TagDescription = (output, context) => {
    const contents = {};
    if (output["ResourceArn"] !== undefined) {
        contents.ResourceArn = (0, smithy_client_1.expectString)(output["ResourceArn"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_TagList((0, smithy_client_1.getArrayIfSingleItem)(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_TagDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TagDescription(entry, context);
    });
};
const de_TagList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_TargetDescription = (output, context) => {
    const contents = {};
    if (output["Id"] !== undefined) {
        contents.Id = (0, smithy_client_1.expectString)(output["Id"]);
    }
    if (output["Port"] !== undefined) {
        contents.Port = (0, smithy_client_1.strictParseInt32)(output["Port"]);
    }
    if (output["AvailabilityZone"] !== undefined) {
        contents.AvailabilityZone = (0, smithy_client_1.expectString)(output["AvailabilityZone"]);
    }
    return contents;
};
const de_TargetGroup = (output, context) => {
    const contents = {};
    if (output["TargetGroupArn"] !== undefined) {
        contents.TargetGroupArn = (0, smithy_client_1.expectString)(output["TargetGroupArn"]);
    }
    if (output["TargetGroupName"] !== undefined) {
        contents.TargetGroupName = (0, smithy_client_1.expectString)(output["TargetGroupName"]);
    }
    if (output["Protocol"] !== undefined) {
        contents.Protocol = (0, smithy_client_1.expectString)(output["Protocol"]);
    }
    if (output["Port"] !== undefined) {
        contents.Port = (0, smithy_client_1.strictParseInt32)(output["Port"]);
    }
    if (output["VpcId"] !== undefined) {
        contents.VpcId = (0, smithy_client_1.expectString)(output["VpcId"]);
    }
    if (output["HealthCheckProtocol"] !== undefined) {
        contents.HealthCheckProtocol = (0, smithy_client_1.expectString)(output["HealthCheckProtocol"]);
    }
    if (output["HealthCheckPort"] !== undefined) {
        contents.HealthCheckPort = (0, smithy_client_1.expectString)(output["HealthCheckPort"]);
    }
    if (output["HealthCheckEnabled"] !== undefined) {
        contents.HealthCheckEnabled = (0, smithy_client_1.parseBoolean)(output["HealthCheckEnabled"]);
    }
    if (output["HealthCheckIntervalSeconds"] !== undefined) {
        contents.HealthCheckIntervalSeconds = (0, smithy_client_1.strictParseInt32)(output["HealthCheckIntervalSeconds"]);
    }
    if (output["HealthCheckTimeoutSeconds"] !== undefined) {
        contents.HealthCheckTimeoutSeconds = (0, smithy_client_1.strictParseInt32)(output["HealthCheckTimeoutSeconds"]);
    }
    if (output["HealthyThresholdCount"] !== undefined) {
        contents.HealthyThresholdCount = (0, smithy_client_1.strictParseInt32)(output["HealthyThresholdCount"]);
    }
    if (output["UnhealthyThresholdCount"] !== undefined) {
        contents.UnhealthyThresholdCount = (0, smithy_client_1.strictParseInt32)(output["UnhealthyThresholdCount"]);
    }
    if (output["HealthCheckPath"] !== undefined) {
        contents.HealthCheckPath = (0, smithy_client_1.expectString)(output["HealthCheckPath"]);
    }
    if (output["Matcher"] !== undefined) {
        contents.Matcher = de_Matcher(output["Matcher"], context);
    }
    if (output.LoadBalancerArns === "") {
        contents.LoadBalancerArns = [];
    }
    else if (output["LoadBalancerArns"] !== undefined && output["LoadBalancerArns"]["member"] !== undefined) {
        contents.LoadBalancerArns = de_LoadBalancerArns((0, smithy_client_1.getArrayIfSingleItem)(output["LoadBalancerArns"]["member"]), context);
    }
    if (output["TargetType"] !== undefined) {
        contents.TargetType = (0, smithy_client_1.expectString)(output["TargetType"]);
    }
    if (output["ProtocolVersion"] !== undefined) {
        contents.ProtocolVersion = (0, smithy_client_1.expectString)(output["ProtocolVersion"]);
    }
    if (output["IpAddressType"] !== undefined) {
        contents.IpAddressType = (0, smithy_client_1.expectString)(output["IpAddressType"]);
    }
    return contents;
};
const de_TargetGroupAssociationLimitException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TargetGroupAttribute = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = (0, smithy_client_1.expectString)(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = (0, smithy_client_1.expectString)(output["Value"]);
    }
    return contents;
};
const de_TargetGroupAttributes = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGroupAttribute(entry, context);
    });
};
const de_TargetGroupList = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGroupTuple(entry, context);
    });
};
const de_TargetGroupNotFoundException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TargetGroups = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetGroup(entry, context);
    });
};
const de_TargetGroupStickinessConfig = (output, context) => {
    const contents = {};
    if (output["Enabled"] !== undefined) {
        contents.Enabled = (0, smithy_client_1.parseBoolean)(output["Enabled"]);
    }
    if (output["DurationSeconds"] !== undefined) {
        contents.DurationSeconds = (0, smithy_client_1.strictParseInt32)(output["DurationSeconds"]);
    }
    return contents;
};
const de_TargetGroupTuple = (output, context) => {
    const contents = {};
    if (output["TargetGroupArn"] !== undefined) {
        contents.TargetGroupArn = (0, smithy_client_1.expectString)(output["TargetGroupArn"]);
    }
    if (output["Weight"] !== undefined) {
        contents.Weight = (0, smithy_client_1.strictParseInt32)(output["Weight"]);
    }
    return contents;
};
const de_TargetHealth = (output, context) => {
    const contents = {};
    if (output["State"] !== undefined) {
        contents.State = (0, smithy_client_1.expectString)(output["State"]);
    }
    if (output["Reason"] !== undefined) {
        contents.Reason = (0, smithy_client_1.expectString)(output["Reason"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = (0, smithy_client_1.expectString)(output["Description"]);
    }
    return contents;
};
const de_TargetHealthDescription = (output, context) => {
    const contents = {};
    if (output["Target"] !== undefined) {
        contents.Target = de_TargetDescription(output["Target"], context);
    }
    if (output["HealthCheckPort"] !== undefined) {
        contents.HealthCheckPort = (0, smithy_client_1.expectString)(output["HealthCheckPort"]);
    }
    if (output["TargetHealth"] !== undefined) {
        contents.TargetHealth = de_TargetHealth(output["TargetHealth"], context);
    }
    return contents;
};
const de_TargetHealthDescriptions = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TargetHealthDescription(entry, context);
    });
};
const de_TooManyActionsException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyCertificatesException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyListenersException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyLoadBalancersException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyRegistrationsForTargetIdException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyRulesException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyTagsException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyTargetGroupsException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyTargetsException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_TooManyUniqueTargetGroupsPerLoadBalancerException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const de_UnsupportedProtocolException = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = (0, smithy_client_1.expectString)(output["Message"]);
    }
    return contents;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(ElasticLoadBalancingV2ServiceException_1.ElasticLoadBalancingV2ServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new fast_xml_parser_1.XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => (0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
