{"version":3,"file":"curry.mjs","sources":["../../src/curry.ts"],"sourcesContent":["export type Func<TArgs = any, KReturn = any | void> = (\n  ...args: TArgs[]\n) => KReturn\n\nexport const chain =\n  (...funcs: Func[]) =>\n  (...args: any[]) => {\n    return funcs.slice(1).reduce((acc, fn) => fn(acc), funcs[0](...args))\n  }\n\nexport const compose = (...funcs: Func[]) => {\n  return funcs.reverse().reduce((acc, fn) => fn(acc))\n}\n\nexport const partial = (fn: Func, ...args: any[]) => {\n  return (...rest: any[]) => fn(...args, ...rest)\n}\n\n/**\n * Like partial but for unary functions that accept\n * a single object argument\n */\nexport const partob = <T, K, PartialArgs extends Partial<T>>(\n  fn: (args: T) => K,\n  argobj: PartialArgs\n) => {\n  return (restobj: Omit<T, keyof PartialArgs>): K =>\n    fn({\n      ...(argobj as Partial<T>),\n      ...(restobj as Partial<T>)\n    } as T)\n}\n\n/**\n * Creates a Proxy object that will dynamically\n * call the handler argument when attributes are\n * accessed\n */\nexport const proxied = <T, K>(\n  handler: (propertyName: T) => K\n): Record<string, K> => {\n  return new Proxy(\n    {},\n    {\n      get: (target, propertyName: any) => handler(propertyName)\n    }\n  )\n}\n\ntype Cache<T> = Record<string, { exp: number | null; value: T }>\n\nconst memoize = <T>(\n  cache: Cache<T>,\n  func: Func<any, T>,\n  keyFunc: Func<string> | null,\n  ttl: number | null\n) => {\n  return function callWithMemo(...args: any): T {\n    const key = keyFunc ? keyFunc(...args) : JSON.stringify({ args })\n    const existing = cache[key]\n    if (existing !== undefined) {\n      if (!existing.exp) return existing.value\n      if (existing.exp > new Date().getTime()) {\n        return existing.value\n      }\n    }\n    const result = func(...args)\n    cache[key] = {\n      exp: ttl ? new Date().getTime() + ttl : null,\n      value: result\n    }\n    return result\n  }\n}\n\n/**\n * Creates a memoized function. The returned function\n * will only execute the source function when no value\n * has previously been computed. If a ttl (milliseconds)\n * is given previously computed values will be checked\n * for expiration before being returned.\n */\nexport const memo = <TFunc extends (...args: any) => any>(\n  func: TFunc,\n  options: {\n    key?: Func<any, string>\n    ttl?: number\n  } = {}\n) => {\n  return memoize({}, func, options.key ?? null, options.ttl ?? null) as TFunc\n}\n\nexport type DebounceFunction<TArgs extends any[]> = {\n  (...args: TArgs): void\n  /**\n   * Cancels the debounced function\n   */\n  cancel(): void\n  /**\n   * Checks if there is any invocation debounced\n   */\n  isPending(): boolean\n  /**\n   * Runs the debounced function immediately\n   */\n  flush(...args: TArgs): void\n}\n\nexport type ThrottledFunction<TArgs extends any[]> = {\n  (...args: TArgs): void\n  /**\n   * Checks if there is any invocation throttled\n   */\n  isThrottled(): boolean\n}\n\n/**\n * Given a delay and a function returns a new function\n * that will only call the source function after delay\n * milliseconds have passed without any invocations.\n *\n * The debounce function comes with a `cancel` method\n * to cancel delayed `func` invocations and a `flush`\n * method to invoke them immediately\n */\nexport const debounce = <TArgs extends any[]>(\n  { delay }: { delay: number },\n  func: (...args: TArgs) => any\n) => {\n  let timer: NodeJS.Timeout | undefined = undefined\n  let active = true\n\n  const debounced: DebounceFunction<TArgs> = (...args: TArgs) => {\n    if (active) {\n      clearTimeout(timer)\n      timer = setTimeout(() => {\n        active && func(...args)\n        timer = undefined\n      }, delay)\n    } else {\n      func(...args)\n    }\n  }\n  debounced.isPending = () => {\n    return timer !== undefined\n  }\n  debounced.cancel = () => {\n    active = false\n  }\n  debounced.flush = (...args: TArgs) => func(...args)\n\n  return debounced\n}\n\n/**\n * Given an interval and a function returns a new function\n * that will only call the source function if interval milliseconds\n * have passed since the last invocation\n */\nexport const throttle = <TArgs extends any[]>(\n  { interval }: { interval: number },\n  func: (...args: TArgs) => any\n) => {\n  let ready = true\n  let timer: NodeJS.Timeout | undefined = undefined\n\n  const throttled: ThrottledFunction<TArgs> = (...args: TArgs) => {\n    if (!ready) return\n    func(...args)\n    ready = false\n    timer = setTimeout(() => {\n      ready = true\n      timer = undefined\n    }, interval)\n  }\n  throttled.isThrottled = () => {\n    return timer !== undefined\n  }\n  return throttled\n}\n\n/**\n * Make an object callable. Given an object and a function\n * the returned object will be a function with all the\n * objects properties.\n *\n * @example\n * ```typescript\n * const car = callable({\n *   wheels: 2\n * }, self => () => {\n *   return 'driving'\n * })\n *\n * car.wheels // => 2\n * car() // => 'driving'\n * ```\n */\nexport const callable = <\n  TValue,\n  TObj extends Record<string | number | symbol, TValue>,\n  TFunc extends (...args: any) => any\n>(\n  obj: TObj,\n  fn: (self: TObj) => TFunc\n): TObj & TFunc => {\n  /* istanbul ignore next */\n  const FUNC = () => {}\n  return new Proxy(Object.assign(FUNC, obj), {\n    get: (target, key: string) => target[key],\n    set: (target, key: string, value: any) => {\n      ;(target as any)[key] = value\n      return true\n    },\n    apply: (target, self, args) => fn(Object.assign({}, target))(...args)\n  }) as unknown as TObj & TFunc\n}\n"],"names":[],"mappings":"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"}