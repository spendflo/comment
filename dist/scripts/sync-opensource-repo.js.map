{
  "version": 3,
  "sources": ["scripts/sync-opensource-repo.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\r\n\r\n// This script helps with syncing our opensource repositories with\r\n// subdirectories in monorepo.\r\n//\r\n// Syncing can go both ways: importing new commits from the subrepo into\r\n// monorepo, and exporting new commits touching the opensource folder from\r\n// monorepo to a subrepo.\r\n//\r\n// To sync one of the opensource project, e.g. `sdk-js`: build/index.mjs\r\n//    --target=scripts/sync-opensource-repo.ts &&\r\n//    dist/scripts/sync-opensource-repo.js --name sdk-js\r\n//\r\n// The script will:\r\n// * in your local monorepo repository, create a remote called\r\n//   `opensource-sdk-js` (unless one exists already)\r\n// * fetch from that remote, so we have the history of the opensource repo\r\n//   (there will be remote branches like `opensource-sdk-js/master`)\r\n// * compare the history of the `opensource/sdk-js` directory in monorepo and of\r\n//   the `sdk-js` repository\r\n// * find the most recent pair of commits in these two repos with matching file\r\n//   contents.\r\n// * for any commit that touches `opensource/sdk-js` in monorepo *after* the\r\n//   last time monorepo and sdk-js repo were in sync, it creates a matching\r\n//   commits in a local branch called `opensource/sdk-js/export-commits`. That\r\n//   branch is attached to the history of `sdk-js`, not monorepo. To be precise,\r\n//   it branches of the most recent commit in `sdk-js` which was in sync with\r\n//   monorepo. So, if there are any commits in monorepo that need exporting to\r\n//   `sdk-js`, this branch will contain them. You should check whether these\r\n//   commits (and their commit messages!) are safe to publish as opensource. You\r\n//   can amend them locally, and when ready, push them to `sdk-js`. Typically,\r\n//   you would only alter the commit messages. If you find you need to also\r\n//   alter the file contents, you will need to land the same changes in\r\n//   monorepo. After all, we want the repo and the directory in monorepo to be\r\n//   in sync!\r\n// * for any commit in the `sdk-js` repository, the script will create matching\r\n//   commits on a local monorepo branch called\r\n//   `opensource/sdk-js/import-commits`. If there any such commits, you can\r\n//   either just create pull requests for each (e.g. using `spr diff --all` on\r\n//   that branch), or you can squash them into one commit and have one PR for\r\n//   the whole sync. At the end, you just want to have all these changes landed\r\n//   so that the contents of monorepo and `sdk-js` repo are in sync.\r\n//\r\n// The script will tell you how many commits it created, if any, in the import\r\n// and export branches.\r\n//\r\n// Obviously, the above explanation applies to any of our opensource\r\n// repositories, not just `sdk-js`.\r\n//\r\n// The script takes one to three options:\r\n// * `--name` is required and must be set to the name of the opensource\r\n//   repository you want to sync. That name must also match the name of the\r\n//   subdirectory in `opensource` in monorepo.\r\n// * `--master-branch` is optional and can be set to the name of the default\r\n//   branch in the opensource repository (defaults to master)\r\n// * `--repo` is optional and will override the opensource repository name\r\n//   if specified.  If not specified, it will default to name.\r\n\r\nimport { promises as fs } from 'fs';\r\nimport * as readline from 'readline';\r\nimport { spawn } from 'child_process';\r\n\r\nimport yargs from 'yargs';\r\n\r\nconst EMPTY_COMMIT = '0000000000000000000000000000000000000000';\r\nconst EMPTY_TREE = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';\r\nconst filterOutCordPrefixedNames = (name: string) => !name.startsWith('CORD-');\r\n\r\nconst argv = yargs(process.argv.slice(2))\r\n  .option('name', { type: 'string', demandOption: true })\r\n  .option('master-branch', { type: 'string', default: 'master' })\r\n  .option('repo', { type: 'string' })\r\n  .strict()\r\n  .help()\r\n  .alias('help', 'h').argv;\r\n\r\nasync function main(\r\n  name: string,\r\n  masterBranch: string,\r\n  repo: string | undefined,\r\n) {\r\n  // If the repo is not specified, let's default it to the name\r\n  if (!repo) {\r\n    repo = name;\r\n  }\r\n  const pathWithinMainRepo = `opensource/${name}`;\r\n\r\n  // Make sure `pathWithinMainRepo` exists and is a directory\r\n  if (\r\n    !(await fs\r\n      .stat(pathWithinMainRepo)\r\n      .then((s) => s.isDirectory())\r\n      .catch(() => false))\r\n  ) {\r\n    throw new Error(\r\n      `'${pathWithinMainRepo}' does not exist or is not a directory`,\r\n    );\r\n  }\r\n\r\n  // Create git remote, if it does not exist yet\r\n  const gitRemoteName = `opensource-${repo}`;\r\n\r\n  if (\r\n    !(await getCommandOutput('git', ['remote']))\r\n      .split('\\n')\r\n      .map((l) => l.trim())\r\n      .includes(gitRemoteName)\r\n  ) {\r\n    // The git remote for the sub-repository is not registered yet.\r\n\r\n    await runCommand(\r\n      'git',\r\n      'remote',\r\n      'add',\r\n      gitRemoteName,\r\n      `git@github.com:getcord/${repo}`,\r\n    );\r\n  }\r\n\r\n  // Fetch from that remote, so we have the opensource repositories history\r\n  // available to work with\r\n  await runCommand('git', 'fetch', gitRemoteName);\r\n\r\n  // Get a list of monorepo and subrepo commits that need importing/exporting.\r\n  // Both `monorepoCommits` and `subrepoCommits` are arrays of commit hashes.\r\n  // The first item in each array is the last commit where monorepo and subrepo\r\n  // contents match. Any further items need importing/exporting.\r\n  const { monorepoCommits, subrepoCommits, monorepoTrees, subrepoTrees } =\r\n    await findCommonBase(\r\n      getMonorepoCommitsTouchingPath(pathWithinMainRepo),\r\n      getSubrepoCommits(gitRemoteName, masterBranch),\r\n    );\r\n\r\n  if (monorepoCommits.length > 1) {\r\n    // We need to export commits.\r\n    console.log(\r\n      `${monorepoCommits.length - 1} commit(s) need exporting into subrepo.`,\r\n    );\r\n    let newBranchCommit = subrepoCommits[0];\r\n    for (const newMonorepoCommit of monorepoCommits.slice(1)) {\r\n      // Get commit message and some meta data\r\n      const [authorName, authorEmail, authorDate, ...lines] = (\r\n        await getCommandOutput('git', [\r\n          'log',\r\n          '--format=%an%n%ae%n%aI%n%B',\r\n          '-n',\r\n          '1',\r\n          newMonorepoCommit,\r\n        ])\r\n      )\r\n        .trimRight()\r\n        .split('\\n');\r\n\r\n      // Create new commit for the subrepo\r\n      newBranchCommit = (\r\n        await getCommandOutput(\r\n          'git',\r\n          [\r\n            'commit-tree',\r\n            '-p',\r\n            newBranchCommit,\r\n            '-m',\r\n            prepareSubrepoMessage(lines.join('\\n'), newMonorepoCommit),\r\n            monorepoTrees.get(newMonorepoCommit)!,\r\n          ],\r\n          {\r\n            GIT_AUTHOR_NAME: authorName,\r\n            GIT_AUTHOR_EMAIL: authorEmail,\r\n            GIT_AUTHOR_DATE: authorDate,\r\n          },\r\n        )\r\n      ).trim();\r\n    }\r\n\r\n    // Create the \"export-commits\" branch\r\n    const branchName = `opensource/${repo}/export-commits`;\r\n    await runCommand('git', 'branch', '-f', branchName, newBranchCommit);\r\n    await runCommand(\r\n      'git',\r\n      'branch',\r\n      `--set-upstream-to=${gitRemoteName}/${masterBranch}`,\r\n      branchName,\r\n    );\r\n\r\n    console.log(`Prepared new commits in branch '${branchName}'`);\r\n  }\r\n\r\n  if (subrepoCommits.length > 1) {\r\n    // We need to import commits.\r\n    console.log(\r\n      `${subrepoCommits.length - 1} commit(s) need importing from subrepo.`,\r\n    );\r\n\r\n    // The `treeReplacer` replaces one subdirectory of a given tree with a\r\n    // different tree.\r\n    const treeReplacer = await makeTreeReplacer(monorepoCommits[0], [\r\n      'opensource',\r\n      name,\r\n    ]);\r\n\r\n    // Create new commit for monorepo\r\n    let newBranchCommit = monorepoCommits[0];\r\n    for (const newSubrepoCommit of subrepoCommits.slice(1)) {\r\n      const [authorName, authorEmail, authorDate, ...lines] = (\r\n        await getCommandOutput('git', [\r\n          'log',\r\n          '--format=%an%n%ae%n%aI%n%B',\r\n          '-n',\r\n          '1',\r\n          newSubrepoCommit,\r\n        ])\r\n      )\r\n        .trimRight()\r\n        .split('\\n');\r\n\r\n      newBranchCommit = (\r\n        await getCommandOutput(\r\n          'git',\r\n          [\r\n            'commit-tree',\r\n            '-p',\r\n            newBranchCommit,\r\n            '-m',\r\n            lines.join('\\n'),\r\n            await treeReplacer(subrepoTrees.get(newSubrepoCommit)!),\r\n          ],\r\n          {\r\n            GIT_AUTHOR_NAME: authorName,\r\n            GIT_AUTHOR_EMAIL: authorEmail,\r\n            GIT_AUTHOR_DATE: authorDate,\r\n          },\r\n        )\r\n      ).trim();\r\n    }\r\n\r\n    // Create the \"import-commits\" branch\r\n    const branchName = `opensource/${repo}/import-commits`;\r\n    await runCommand('git', 'branch', '-f', branchName, newBranchCommit);\r\n\r\n    console.log(`Prepared new commits in branch '${branchName}'`);\r\n  }\r\n}\r\n\r\n/**\r\n * Return `[commitHash, treeHash]` tuples for commits in monorepo that touch the\r\n * given path.\r\n *\r\n * The trees returned have all files and directories whose name begins with\r\n * 'CORD-' filtered out.\r\n *\r\n * Consequently, commits that touch the given directory, but only\r\n * adds/removes/modifies files beginning with 'CORD-' (and files in directories\r\n * beginning with 'CORD-') are omitted.\r\n */\r\nasync function* getMonorepoCommitsTouchingPath(\r\n  path: string,\r\n): AsyncGenerator<[string, string], void> {\r\n  let lastCommitHash: string | null = null;\r\n  let lastTreeHash: string | null = null;\r\n\r\n  // Iterate through all commits that touch `path`\r\n  for await (const line of streamLinesFromCommand(\r\n    'git',\r\n    'log',\r\n    '--format=tformat:%H',\r\n    '--',\r\n    path,\r\n  )) {\r\n    const commitHash = line.trim();\r\n    if (commitHash) {\r\n      // The `originalTreeish` is the git notation for `path` in the commit\r\n      // `commitHash`.\r\n      const originalTreeish = `${commitHash}:${path}`;\r\n\r\n      // `filterTreeByBane` filters out the files and directories whose name\r\n      // begin with 'CORD-'. It returnes either `originalTreeish` (if there was\r\n      // nothing to filter out), or a tree hash.\r\n      const filteredTreeish = await filterTreeByName(\r\n        originalTreeish,\r\n        filterOutCordPrefixedNames,\r\n      );\r\n\r\n      // `tree` is going to be the hash for the (filtered) tree. If\r\n      // `filteredTreeish` is `originalTreeish`, we have to turn it into a tree\r\n      // hash. Otherwise it's a hash already.\r\n      const tree =\r\n        filteredTreeish === originalTreeish\r\n          ? (\r\n              await getCommandOutput('git', [\r\n                'rev-parse',\r\n                `${commitHash}:${path}`,\r\n              ])\r\n            ).trim()\r\n          : filteredTreeish;\r\n\r\n      // If the previous commit we encountered had a different resulting tree,\r\n      // then that commit contained actual changes to the path (even after\r\n      // filtering out `CORD-`-prefixed files and directories). We can yield\r\n      // this now.\r\n      if (\r\n        lastCommitHash !== null &&\r\n        lastTreeHash !== null &&\r\n        lastTreeHash !== tree\r\n      ) {\r\n        yield [lastCommitHash, lastTreeHash];\r\n      }\r\n\r\n      // Update `lastCommitHash` and `lastTreeHash` to the commit/tree we\r\n      // encountered just now. We won't just yield it yet, because the next\r\n      // commit we get may have the same tree, and then we want to skip this\r\n      // one. The reason why we still have to skip commits at all here, is that\r\n      // `git log` gives us a list of all commits touching `path`, but some of\r\n      // those may only change files/directories prefixed with `CORD-`, and\r\n      // since we filter those out, such commits would result in no changes. We\r\n      // don't want to create empty commits, so we skip them.\r\n      lastCommitHash = commitHash;\r\n      lastTreeHash = tree;\r\n    }\r\n  }\r\n\r\n  if (lastCommitHash !== null && lastTreeHash !== null) {\r\n    // The last commit we encountered above is the first that ever touched `path`.\r\n\r\n    if (lastTreeHash !== EMPTY_TREE) {\r\n      // The tree is not empty after filtering, so this is a commit we want to\r\n      // emit.\r\n      yield [lastCommitHash, lastTreeHash];\r\n    }\r\n\r\n    // Finally, emit the empty tree, which represents the state before `path`\r\n    // was added to monorepo.\r\n    yield [`${lastCommitHash}~1`, EMPTY_TREE];\r\n  } else {\r\n    // We didn't find any commits at all, so let's just say the current state of\r\n    // monorepo corresponds to `path` being empty.\r\n    yield ['HEAD', EMPTY_TREE];\r\n  }\r\n}\r\n\r\nasync function* getSubrepoCommits(remote: string, branch: string) {\r\n  for await (const line of streamLinesFromCommand(\r\n    'git',\r\n    'log',\r\n    '--format=tformat:%H %T',\r\n    `refs/remotes/${remote}/${branch}`,\r\n  )) {\r\n    const fields = line.trim().split(/\\s+/);\r\n    if (fields.length === 2) {\r\n      yield fields as [string, string];\r\n    }\r\n  }\r\n  yield [EMPTY_COMMIT, EMPTY_TREE] as const;\r\n}\r\n\r\nasync function findCommonBase(\r\n  monorepoCommitIter: AsyncGenerator<readonly [string, string]>,\r\n  subrepoCommitIter: AsyncGenerator<readonly [string, string]>,\r\n) {\r\n  const commits: string[][] = [[], []];\r\n  const treePositions: Map<string, number>[] = [new Map(), new Map()];\r\n  const monorepoTrees = new Map<string, string>();\r\n  const subrepoTrees = new Map<string, string>();\r\n\r\n  for await (const [repoID, [commitID, treeID]] of zipIterators(\r\n    monorepoCommitIter,\r\n    subrepoCommitIter,\r\n  )) {\r\n    (repoID === 0 ? monorepoTrees : subrepoTrees).set(commitID, treeID);\r\n\r\n    commits[repoID].push(commitID);\r\n\r\n    const otherRepo = 1 - repoID;\r\n    const treeInOtherRepo = treePositions[otherRepo].get(treeID);\r\n    if (treeInOtherRepo !== undefined) {\r\n      commits[otherRepo] = commits[otherRepo].slice(0, treeInOtherRepo + 1);\r\n      break;\r\n    }\r\n\r\n    if (!treePositions[repoID].has(treeID)) {\r\n      treePositions[repoID].set(treeID, commits[repoID].length - 1);\r\n    }\r\n  }\r\n\r\n  return {\r\n    monorepoCommits: commits[0].reverse(),\r\n    subrepoCommits: commits[1].reverse(),\r\n    monorepoTrees,\r\n    subrepoTrees,\r\n  };\r\n}\r\n\r\nasync function makeTreeReplacer(\r\n  treeish: string,\r\n  path: string[],\r\n): Promise<(treeID: string) => Promise<string>> {\r\n  if (path.length === 0) {\r\n    return (treeID: string) => Promise.resolve(treeID);\r\n  }\r\n\r\n  const path0 = path[0]!;\r\n  let subtree = EMPTY_TREE;\r\n\r\n  const lines: string[] = [];\r\n  for await (const line of streamLinesFromCommand('git', 'ls-tree', treeish)) {\r\n    const match = /^\\d+ (\\w+) (\\w+)\\t(.*?)$/.exec(line);\r\n    if (match) {\r\n      const [_, type, hash, name] = match;\r\n\r\n      if (name === path0) {\r\n        if (type === 'tree') {\r\n          subtree = hash;\r\n        }\r\n      } else {\r\n        lines.push(line);\r\n      }\r\n    }\r\n  }\r\n\r\n  const rest = lines.join('\\n') + (lines.length ? '\\n' : '');\r\n  const innerReplacer = await makeTreeReplacer(subtree, path.slice(1));\r\n\r\n  return async (treeID: string) => {\r\n    const input = `${rest}040000 tree ${await innerReplacer(\r\n      treeID,\r\n    )}\\t${path0}\\n`;\r\n    return (await getCommandOutput('git', ['mktree'], undefined, input)).trim();\r\n  };\r\n}\r\n\r\nasync function filterTreeByName(\r\n  treeish: string,\r\n  func: (name: string) => boolean,\r\n) {\r\n  let anyChanges = false;\r\n\r\n  const lines: string[] = [];\r\n  // Iterate through all items in the treeish.\r\n  for await (const line of streamLinesFromCommand('git', 'ls-tree', treeish)) {\r\n    const match = /^(\\d+) (\\w+) (\\w+)\\t(.*?)$/.exec(line);\r\n    if (match) {\r\n      const [_, stat, type, hash, name] = match;\r\n\r\n      if (!func(name)) {\r\n        // we filter out this entry\r\n        anyChanges = true;\r\n        continue;\r\n      }\r\n\r\n      if (type === 'tree') {\r\n        // We have to descend this tree, too.\r\n\r\n        const filteredHash = await filterTreeByName(hash, func);\r\n\r\n        if (filteredHash !== hash) {\r\n          // The filtering produced a change\r\n          anyChanges = true;\r\n\r\n          if (filteredHash !== EMPTY_TREE) {\r\n            // The tree came back non-empty from filtering, so we add a line for\r\n            // the tree after filtering.\r\n            lines.push(`${stat} ${type} ${filteredHash}\\t${name}`);\r\n          }\r\n\r\n          // Either way, we have dealt with this entry. We `continue` so we do\r\n          // not push the original into the output array below.\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // If we haven't `continue`d above, then we just add the line back unchanged\r\n      lines.push(line);\r\n    }\r\n  }\r\n\r\n  if (anyChanges) {\r\n    const newTreeContent = lines.join('\\n') + (lines.length ? '\\n' : '');\r\n    return (\r\n      await getCommandOutput('git', ['mktree'], undefined, newTreeContent)\r\n    ).trim();\r\n  } else {\r\n    // Nothing has changed, so we return the original treeish.\r\n    return treeish;\r\n  }\r\n}\r\n\r\nconst privateSectionRegex = new RegExp(\r\n  '^CORD PRIVATE SECTION START$.*?^CORD PRIVATE SECTION END(\\\\n|$)',\r\n  // s = dotAll (. matches new lines)\r\n  // m = multiline (^ and $ still match beginning and end of a line)\r\n  // g = globally, more than one match (needed for .replaceAll())\r\n  'smg',\r\n);\r\nfunction prepareSubrepoMessage(msg: string, monorepoCommitID: string) {\r\n  msg = msg.replaceAll(privateSectionRegex, '');\r\n  return `${msg.trimRight()}\\n\\nmonorepo-commit: ${monorepoCommitID}`;\r\n}\r\n\r\nfunction streamLinesFromCommand(cmd: string, ...args: string[]) {\r\n  return readline.createInterface({\r\n    input: spawn(cmd, args, {\r\n      stdio: ['ignore', 'pipe', process.stderr],\r\n    }).stdout,\r\n  });\r\n}\r\n\r\nasync function getCommandOutput(\r\n  cmd: string,\r\n  args: string[],\r\n  env?: NodeJS.ProcessEnv,\r\n  stdin?: string,\r\n) {\r\n  const fragments: string[] = [];\r\n\r\n  const child = spawn(cmd, args, {\r\n    stdio: [stdin === undefined ? 'ignore' : 'pipe', 'pipe', process.stderr],\r\n    env: env ? { ...process.env, ...env } : undefined,\r\n  });\r\n\r\n  const finished = new Promise<void>((resolve, reject) => {\r\n    child.on('error', reject);\r\n    child.once('close', (code) =>\r\n      code === 0 ? resolve() : reject(new Error(`exit code ${code}`)),\r\n    );\r\n  });\r\n\r\n  if (stdin !== undefined && child.stdin) {\r\n    const stream = child.stdin;\r\n    stream.write(stdin, 'utf-8', () => stream.end());\r\n  }\r\n\r\n  if (child.stdout) {\r\n    for await (const fragment of child.stdout) {\r\n      fragments.push(fragment);\r\n    }\r\n  }\r\n\r\n  await finished;\r\n  return fragments.join('');\r\n}\r\n\r\nfunction runCommand(cmd: string, ...args: string[]): Promise<void> {\r\n  return new Promise<void>((resolve, reject) => {\r\n    const proc = spawn(cmd, args, { stdio: ['ignore', 'inherit', 'inherit'] });\r\n    proc.on('error', reject);\r\n    proc.once('close', resolve);\r\n  });\r\n}\r\n\r\nasync function* zipIterators<T, U, V>(\r\n  ...generators: AsyncGenerator<T, U, V>[]\r\n) {\r\n  const gens = [...generators.entries()];\r\n\r\n  while (gens.length) {\r\n    const [idx, gen] = gens.shift()!;\r\n\r\n    const item = await gen.next();\r\n    if (!item.done) {\r\n      yield [idx, item.value] as const;\r\n      gens.push([idx, gen]);\r\n    }\r\n  }\r\n}\r\n\r\nmain(argv.name, argv['master-branch'], argv['repo']).then(\r\n  () => process.exit(0),\r\n  (err) => {\r\n    console.error(err);\r\n    process.exit(1);\r\n  },\r\n);\r\n"],
  "mappings": "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",
  "names": []
}
