{
  "version": 3,
  "sources": ["scripts/check-database-schema.ts", "database/tooling/pg-formatter.ts", "database/tooling/migra.ts", "database/tooling/utils.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node -r dotenv/config\r\n\r\n// This script can be used in several ways:\r\n// * with the `--check` option it makes sure that migrations and schema are\r\n//   consistent. If they are not, the script fails and outputs a series of SQL\r\n//   statements that, if added to the schema, would make it consistent with the\r\n//   migrations. This is mostly meant as an indicator of the inconsistency.\r\n//   Usually the displayed remedy shouldn't be appended at the end of the\r\n//   schema, but put into the right places. E.g. `ALTER TABLE foo ALTER COLUMN\r\n//   bar SET NOT NULL` should not be appended at the end - rather the `CREATE\r\n//   TABLE foo` should be found and `NOT NULL` added to the definition of\r\n//   column `bar`.\r\n// * with the `--createMigration migration-name` option, a new migration file\r\n//   is created in the `database/migrations` folder with an autogenerated\r\n//   migration that would ensure consistency between migrations and the schema.\r\n//   The autogenerated migration is *one* way to get from the previous schema\r\n//   to the current one. When making changes to the schema, you can start with\r\n//   that autogenerated migration, but make sure that it carries out the\r\n//   migration in the intended way. E.g. it might suggest to drop a column and\r\n//   create a new one, when you mean to rename an existing column instead.\r\n//   Also, the autogenerated migration only does structural changes to the\r\n//   database, but you might want to add data operations. For example, if you\r\n//   were to add a `NOT NULL` constraint to some column in the schema, the\r\n//   autogenerated migration will provide the correct `ALTER TABLE ... ALTER\r\n//   COLUMN ... SET NOT NULL` statement for you (and the inverse in the\r\n//   down-migration), but this migration would fail if the database has rows in\r\n//   that table where that column currently is NULL. So, you would have to add\r\n//   statements to the migration to deal with that, e.g. `DELETE FROM table\r\n//   WHERE column IS NULL` or `UPDATE table SET column=DEFAULT WHERE column IS\r\n//   NULL`, or whatever is the right thing to do in the particular situation.\r\n//   There is no way to autogenerate the *correct* migration, but the\r\n//   autogenerated migration can still be useful as an indicator of all the\r\n//   things that need to be migrated.  And for some migrations, they will even\r\n//   be correct.\r\n// * there are two more options: `--checkSchema` and `--checkMigrations` apply\r\n//   the schema and the migrations, respectively, to an empty temporary\r\n//   database to check they are syntactically sound and valid.\r\n\r\nimport { promises as fs } from 'fs';\r\n\r\nimport prettier from 'prettier';\r\nimport yargs from 'yargs';\r\n\r\nimport { format } from 'database/tooling/pg-formatter.ts';\r\nimport {\r\n  installMigra,\r\n  migra,\r\n  runSequelizeMigrate,\r\n} from 'database/tooling/migra.ts';\r\nimport {\r\n  withTemporaryDatabase,\r\n  executeSqlFile,\r\n} from 'database/tooling/utils.ts';\r\n\r\nasync function main() {\r\n  const { argv } = yargs(process.argv.slice(2))\r\n    .option('checkMigrations', {\r\n      type: 'boolean',\r\n      description:\r\n        'Check that all migrations can be applied to an empty database with ' +\r\n        'no errors',\r\n    })\r\n    .option('checkSchema', {\r\n      type: 'boolean',\r\n      description:\r\n        'Check if schema description can be applied to an empty database ' +\r\n        'with no errors',\r\n    })\r\n    .option('check', {\r\n      type: 'boolean',\r\n      description:\r\n        'Check that both migrations and schema description can be applied to ' +\r\n        'an empty database with no error and yield identical schema. Any ' +\r\n        'diff that touches the database/ directory should be tested with ' +\r\n        'this option.',\r\n    })\r\n    .option('createMigration', {\r\n      type: 'string',\r\n      description:\r\n        'Create a new database migration that reflects changes in the schema ' +\r\n        'description. You must provide a name for the new migration which ' +\r\n        'will then be saved in ' +\r\n        'database/migrations/<current time>_<name provided>.cjs',\r\n    })\r\n    .option('checkDatabase', {\r\n      type: 'boolean',\r\n      description:\r\n        'Compare the current live database schema (of the database ' +\r\n        'configured in your .env) against the schema definition file',\r\n    })\r\n    .help();\r\n\r\n  const {\r\n    checkMigrations,\r\n    checkSchema,\r\n    check,\r\n    createMigration,\r\n    checkDatabase,\r\n  } = argv;\r\n\r\n  if (\r\n    !(\r\n      checkMigrations ||\r\n      checkSchema ||\r\n      check ||\r\n      createMigration ||\r\n      checkDatabase\r\n    )\r\n  ) {\r\n    yargs.showHelp();\r\n    throw null;\r\n  }\r\n  if (\r\n    createMigration &&\r\n    (checkMigrations || checkSchema || check || checkDatabase)\r\n  ) {\r\n    throw 'Do not mix the --createMigration option with other options!';\r\n  }\r\n\r\n  if (check || createMigration || checkDatabase) {\r\n    await installMigra();\r\n  }\r\n\r\n  const needSchemaDatabase = !!(\r\n    checkSchema ||\r\n    check ||\r\n    createMigration ||\r\n    checkDatabase\r\n  );\r\n  const needMigrationsDatabase = !!(\r\n    checkMigrations ||\r\n    check ||\r\n    createMigration\r\n  );\r\n  let upMigration: string | null = null;\r\n  let downMigration: string | null = null;\r\n\r\n  await withTemporaryDatabaseIfNeeded(\r\n    needSchemaDatabase,\r\n    async (schemaDatabase) => {\r\n      if (schemaDatabase !== null) {\r\n        try {\r\n          await executeSqlFile('database/schema.sql', schemaDatabase);\r\n        } catch (_) {\r\n          throw 'Failed to apply database schema migration to empty database';\r\n        }\r\n      }\r\n\r\n      if (needMigrationsDatabase) {\r\n        await withTemporaryDatabase(async (migrationsDatabase) => {\r\n          try {\r\n            await runSequelizeMigrate(migrationsDatabase);\r\n          } catch (_) {\r\n            throw 'Failed to apply all database migrations to empty database';\r\n          }\r\n\r\n          if ((check || createMigration) && schemaDatabase !== null) {\r\n            downMigration = await migra(\r\n              postgresUrl(schemaDatabase),\r\n              postgresUrl(migrationsDatabase),\r\n              'cord',\r\n            );\r\n\r\n            if (check && downMigration !== null) {\r\n              throw (\r\n                'The database migrations are not consistent with the full ' +\r\n                'database schema definition.\\n' +\r\n                'Adding the following statements to the schema definition ' +\r\n                'would make it consistent with the migrations:\\n\\n' +\r\n                prepareMigration(downMigration, '', false)\r\n              );\r\n            }\r\n\r\n            if (createMigration) {\r\n              if (downMigration === null) {\r\n                throw (\r\n                  'No changes to database schema detected. ' +\r\n                  'No database migration generated.'\r\n                );\r\n              } else {\r\n                upMigration = await migra(\r\n                  postgresUrl(migrationsDatabase),\r\n                  postgresUrl(schemaDatabase),\r\n                  'cord',\r\n                );\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n\r\n      if (checkDatabase && schemaDatabase) {\r\n        const { POSTGRES_DB } = process.env;\r\n\r\n        if (!POSTGRES_DB) {\r\n          throw new Error(\r\n            'Using the --checkDatabase option requires you to set POSTGRES_DB',\r\n          );\r\n        }\r\n\r\n        const migration = await migra(\r\n          postgresUrl(schemaDatabase),\r\n          postgresUrl(POSTGRES_DB),\r\n          'cord',\r\n        );\r\n\r\n        if (migration === null) {\r\n          console.log(\r\n            \"The configured database's schema is consistent with the schema definition\",\r\n          );\r\n        } else {\r\n          throw (\r\n            \"The configured database's schema is not consistent with the full \" +\r\n            'database schema definition.\\n' +\r\n            'Adding the following statements to the schema definition ' +\r\n            'would make it consistent with the database:\\n\\n' +\r\n            prepareMigration(migration, '', false)\r\n          );\r\n        }\r\n      }\r\n    },\r\n  );\r\n\r\n  if (createMigration) {\r\n    const migrationFile = `'use strict';\r\n\r\n          module.exports = {\r\n            up: (queryInterface) =>\r\n              queryInterface.sequelize.query(\\`${prepareMigration(\r\n                upMigration ?? '',\r\n              )}\\`),\r\n           down: (queryInterface) =>\r\n              queryInterface.sequelize.query(\\`${prepareMigration(\r\n                downMigration ?? '',\r\n              )}\\`),\r\n          };`;\r\n\r\n    const now = new Date();\r\n    const timestamp =\r\n      now.getUTCFullYear().toString() +\r\n      (now.getUTCMonth() + 1).toString().padStart(2, '0') +\r\n      now.getUTCDate().toString().padStart(2, '0') +\r\n      now.getUTCHours().toString().padStart(2, '0') +\r\n      now.getUTCMinutes().toString().padStart(2, '0') +\r\n      now.getUTCSeconds().toString().padStart(2, '0');\r\n    const filename = `database/migrations/${timestamp}-${createMigration}.cjs`;\r\n\r\n    const formattedMigrationFile = await prettier.format(migrationFile, {\r\n      filepath: filename,\r\n      ...(await prettier.resolveConfig(filename)),\r\n    });\r\n\r\n    await fs.writeFile(filename, formattedMigrationFile);\r\n    console.log(`New database written to ${filename}`);\r\n  }\r\n}\r\n\r\nfunction prepareMigration(sql: string, indent = '      ', transaction = true) {\r\n  sql = format(sql.trim(), { keywordCase: 'uppercase', noRcFile: true }).trim();\r\n  if (transaction) {\r\n    sql = `\\nBEGIN;\\n\\n${sql}\\n\\nCOMMIT;`;\r\n  }\r\n  return sql.replace(/\\n/g, `\\n${indent}`).replace(/ +(\\n|$)/g, '$1');\r\n}\r\n\r\nfunction postgresUrl(database: string) {\r\n  const u = new URL('postgresql://');\r\n\r\n  const { POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_HOST, POSTGRES_PORT } =\r\n    process.env;\r\n\r\n  if (POSTGRES_USER) {\r\n    u.username = POSTGRES_USER;\r\n  }\r\n\r\n  if (POSTGRES_PASSWORD) {\r\n    u.password = POSTGRES_PASSWORD;\r\n  }\r\n\r\n  if (POSTGRES_HOST) {\r\n    if (POSTGRES_HOST[0] === '/') {\r\n      // Unix domain socket connection, must be specified as a search parameter\r\n      u.searchParams.append('host', POSTGRES_HOST);\r\n    } else {\r\n      u.host = encodeURIComponent(POSTGRES_HOST);\r\n    }\r\n  }\r\n\r\n  if (POSTGRES_PORT) {\r\n    u.port = POSTGRES_PORT;\r\n  }\r\n\r\n  u.pathname = database;\r\n\r\n  return u.toString();\r\n}\r\n\r\nfunction withTemporaryDatabaseIfNeeded<T>(\r\n  needed: boolean,\r\n  func: (arg: string | null) => Promise<T>,\r\n) {\r\n  if (needed) {\r\n    return withTemporaryDatabase(func);\r\n  } else {\r\n    return func(null);\r\n  }\r\n}\r\n\r\nmain().then(\r\n  () => {\r\n    process.exit(0);\r\n  },\r\n  (err) => {\r\n    if (err != null) {\r\n      console.error('\\n');\r\n      console.error(err);\r\n    }\r\n    process.exit(1);\r\n  },\r\n);\r\n", "export { format } from 'pg-formatter';\r\n", "import * as child_process from 'child_process';\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport { makePgEnv, run } from 'database/tooling/utils.ts';\r\n\r\nconst venvPath = path.resolve(process.cwd(), 'tmp', 'migra.python-venv');\r\nconst venvBinPath = path.resolve(venvPath, 'bin');\r\nconst migraPath = path.resolve(venvBinPath, 'migra');\r\n\r\n// `env`: this contains the PG* environment variables with the connection\r\n// details for Postgres command line tools. This does *not* include the\r\n// database name, because we do not ever want to connect to the configured\r\n// database in this script. Rather, we will create temporary databases to\r\n// connect to.\r\nconst env = makePgEnv();\r\nconst venvEnv = makePgEnv({ PATH: `${venvBinPath}:${process.env.PATH}` });\r\n\r\nexport async function installMigra() {\r\n  if (!(await file_exists(venvPath))) {\r\n    console.log('Creating Python virtualenv for installing migra...');\r\n    await run('python3', ['-m', 'venv', venvPath]);\r\n    await run(\r\n      'pip',\r\n      ['install', '--upgrade', 'pip', 'setuptools', 'wheel', 'packaging'],\r\n      { env: venvEnv },\r\n    );\r\n  }\r\n\r\n  if (!(await file_exists(migraPath))) {\r\n    console.log('Installing migra in Python virtualenv...');\r\n    await run('pip', ['install', 'psycopg2-binary', 'migra'], { env: venvEnv });\r\n  }\r\n}\r\n\r\n/** Run the migra tool to find schema differences between two PostgreSQL\r\n *  databases\r\n *\r\n * Pass two connection strings (like \"postgresql://dbname\") to this function!\r\n * It will return `null` if the two databases have identical structure, or if\r\n * they don't, it will return a string containing the database statements that\r\n * can be applied to database A to transform its structure into that of database\r\n * B.\r\n *\r\n * Optional, the name of a PostgreSQL schema can be provided, and then the diff\r\n * will be produced for that schema only.\r\n *\r\n * @param dbA connection string for database A\r\n * @param dbB connection string for database B\r\n * @param schema name of database schema for which to produce the diff\r\n */\r\nexport async function migra(\r\n  dbA: string,\r\n  dbB: string,\r\n  ...schemas: string[]\r\n): Promise<string | null> {\r\n  if (schemas.length === 0) {\r\n    return await migraImpl(dbA, dbB);\r\n  }\r\n\r\n  const results = (\r\n    await Promise.all(schemas.map((schema) => migraImpl(dbA, dbB, schema)))\r\n  ).filter(Boolean);\r\n\r\n  if (results.length === 0) {\r\n    return null;\r\n  } else {\r\n    return results.join('\\n\\n');\r\n  }\r\n}\r\n\r\nfunction migraImpl(\r\n  dbA: string,\r\n  dbB: string,\r\n  schema?: string | null,\r\n): Promise<string | null> {\r\n  return new Promise<string | null>((resolve, reject) =>\r\n    child_process.execFile(\r\n      migraPath,\r\n      ['--unsafe', ...(schema == null ? [] : ['--schema', schema]), dbA, dbB],\r\n      {\r\n        env: venvEnv,\r\n      },\r\n      (error, stdout, stderr) => {\r\n        if (error) {\r\n          if (error.code === 2) {\r\n            // migra exits with code 2 if the two schemas differ\r\n            resolve(stdout);\r\n          } else {\r\n            console.error(stderr);\r\n            reject(error);\r\n          }\r\n        } else {\r\n          // migra exits with code 0 if the two schemas are identical\r\n          resolve(null);\r\n        }\r\n      },\r\n    ),\r\n  );\r\n}\r\n\r\nexport function runSequelizeMigrate(database: string, ...extraArgs: string[]) {\r\n  return run(\r\n    'npx',\r\n    ['sequelize-cli', 'db:migrate', '--env', 'pgenv', ...(extraArgs || [])],\r\n    {\r\n      env: { ...env, PGDATABASE: database },\r\n    },\r\n  );\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!\r\nfunction file_exists(path: string) {\r\n  return fs.access(path).then(\r\n    () => true,\r\n    () => false,\r\n  );\r\n}\r\n", "import * as child_process from 'child_process';\r\n\r\nimport type { ClientConfig } from 'pg';\r\nimport { v4 as uuid } from 'uuid';\r\n\r\nexport function makePgEnv(override: NodeJS.ProcessEnv = {}): NodeJS.ProcessEnv {\r\n  const { PGDATABASE: _, ...env } = process.env;\r\n\r\n  return {\r\n    ...env,\r\n    PGHOST: process.env.POSTGRES_HOST,\r\n    PGPORT: process.env.POSTGRES_PORT,\r\n    PGUSER: process.env.POSTGRES_USER,\r\n    PGPASSWORD: process.env.POSTGRES_PASSWORD,\r\n    ...override,\r\n  };\r\n}\r\n\r\nexport async function executeSqlFile(sqlFilename: string, database: string) {\r\n  await run(\r\n    'psql',\r\n    [\r\n      '--echo-errors',\r\n      '--set=ON_ERROR_STOP=t',\r\n      '--single-transaction',\r\n      '--file',\r\n      sqlFilename,\r\n      database,\r\n    ],\r\n    { env: makePgEnv() },\r\n  );\r\n}\r\n\r\nexport async function withTemporaryDatabase<T>(\r\n  callback: (\r\n    database: string,\r\n    clientConfig: ClientConfig,\r\n    env: NodeJS.ProcessEnv,\r\n  ) => Promise<T>,\r\n): Promise<T> {\r\n  const env = makePgEnv();\r\n  const dbname = `temp-${uuid()}`;\r\n  console.log(`Creating temporary database: ${dbname}`);\r\n\r\n  await run('createdb', ['--template=template_radical_db', dbname], { env });\r\n  const clientConfig: ClientConfig = {\r\n    user: env.PGUSER,\r\n    password: env.PGPASSWORD,\r\n    host: env.PGHOST,\r\n    port: Number(env.PGPORT) || undefined,\r\n    database: dbname,\r\n  };\r\n\r\n  try {\r\n    return await callback(dbname, clientConfig, { ...env, PGDATABASE: dbname });\r\n  } finally {\r\n    console.log(`Destroying temporary database: ${dbname}`);\r\n    await run('dropdb', ['--if-exists', dbname], { env });\r\n  }\r\n}\r\n\r\nexport function run(\r\n  cmd: string,\r\n  args: string[],\r\n  env?: child_process.ExecFileOptions,\r\n) {\r\n  return new Promise<string>((resolve, reject) => {\r\n    child_process.execFile(cmd, args, env ?? {}, (error, stdout, stderr) => {\r\n      if (error) {\r\n        console.error(stderr);\r\n        reject(error);\r\n      } else {\r\n        resolve(stdout);\r\n      }\r\n    });\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": ["fs", "child_process", "env", "resolve", "resolve", "path", "fs"]
}
