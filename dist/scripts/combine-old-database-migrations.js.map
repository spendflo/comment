{
  "version": 3,
  "sources": ["scripts/combine-old-database-migrations.ts", "database/tooling/migra.ts", "database/tooling/utils.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\r\n\r\n/**\r\n * Combine a number of old database migration into a single one\r\n *\r\n * At the time of writing this script, we have 318 migrations in the\r\n * database/migrations directory. That's a lot. It slows down the\r\n * check-database-schema script down, and it is just a lot of noise.\r\n *\r\n * This script simply combines many migrations into one. Call it with the name\r\n * of the migration up to which you want to combine them into one. The given\r\n * migration, and all the ones before leading to it, will disappear and be\r\n * replaced with one migration that contains the whole database content (schema\r\n * and data) created by the individual migrations replaced.\r\n *\r\n * To run this script, first choose up to which migration you want to combine\r\n * them all in one. Then you call this script:\r\n *\r\n * dist/scripts/combine-old-database-migrations.js\r\n * --to=TIMESTAMP-MIGRATION-NAME.js\r\n *\r\n * The script will delete old migration files and create one new migration. You\r\n * should be able to commit those changes without manual changes.\r\n *\r\n * This is a suitable test plan:\r\n *\r\n * Before running the script:\r\n * * `dist/scripts/check-database-schema.js --check` to check that your\r\n *   `cord.sql` file is equivalent to the sum of all migrations\r\n * * `dist/scripts/check-database-schema.js --checkDatabase` to check that your\r\n *   local database conforms with the `cord.sql` file\r\n *\r\n * After running the script:\r\n * * `dist/scripts/check-database-schema.js --check` to check that your\r\n *   `cord.sql` file is equivalent to the sum of all migrations, which now\r\n *   includes the single new migration instead of the many old ones\r\n * * `npm run migrate` to run the new migration against your local database\r\n * * `dist/scripts/check-database-schema.js --checkDatabase` to check that your\r\n *   local database conforms with the `cord.sql` file\r\n * * repeat the last two steps (`npm run migrate` should exit without applying\r\n *   any migrations)\r\n * * run the following queries against your local database - this wipes the all\r\n *   your local data:\r\n *   * `DROP SCHEMA IF EXISTS cord CASCADE;`\r\n *   * `DROP TABLE public.\"SequelizeMeta\";`\r\n * * `npm run migrate` to run *all* migrations against your now empty database\r\n * * `dist/scripts/check-database-schema.js --checkDatabase` to check that your\r\n *   local database conforms with the `cord.sql` file\r\n * * repeat the last two steps (`npm run migrate` should exit without applying\r\n *   any migrations)\r\n */\r\n\r\nimport * as child_process from 'child_process';\r\nimport { promises as fs } from 'fs';\r\n\r\nimport 'dotenv/config.js';\r\nimport pg from 'pg';\r\nimport prettier from 'prettier';\r\nimport yargs from 'yargs';\r\n\r\nimport { runSequelizeMigrate } from 'database/tooling/migra.ts';\r\nimport { withTemporaryDatabase } from 'database/tooling/utils.ts';\r\n\r\nasync function main() {\r\n  const { to: toMigration } = yargs(process.argv.slice(2))\r\n    .option('to', {\r\n      type: 'string',\r\n      demandOption: true,\r\n      description:\r\n        'name of the migration up to which you want combine migrations ' +\r\n        'together. This is a migration file name without the ' +\r\n        'database/migrations/ prefix but with the .js extension.',\r\n    })\r\n    .help().argv;\r\n\r\n  await fs.access(`database/migrations/${toMigration}`);\r\n\r\n  await withTemporaryDatabase(async (database, clientConfig, env) => {\r\n    await runSequelizeMigrate(database, '--to', toMigration);\r\n\r\n    const client = new pg.Client(clientConfig);\r\n    await client.connect();\r\n\r\n    let migrationNames: string[];\r\n    try {\r\n      // Let's get the names of all the migrations that Sequelize has applied\r\n      migrationNames = (\r\n        await client.query<{ name: string }>(\r\n          'SELECT name FROM public.\"SequelizeMeta\" ORDER BY name;',\r\n        )\r\n      ).rows.map(({ name }) => name);\r\n    } finally {\r\n      await client.end();\r\n    }\r\n\r\n    if (!migrationNames.length) {\r\n      throw new Error('No migrations!');\r\n    }\r\n\r\n    const match = /^\\d+/.exec(toMigration);\r\n    if (!match) {\r\n      throw new Error(`Migration name must begin with a number`);\r\n    }\r\n    const newMigrationPath = `database/migrations/${\r\n      BigInt(match[0]) + BigInt(1)\r\n    }-cord-schema.cjs`;\r\n\r\n    const dump = await spawn(\r\n      'pg_dump',\r\n      [\r\n        '--no-owner',\r\n        '--no-acl',\r\n        '--schema=cord',\r\n        '--inserts',\r\n        '--rows-per-insert=100',\r\n      ],\r\n      env,\r\n    );\r\n\r\n    const migration = `'use strict';\r\n    \r\n    module.exports = {\r\n        up: ({ sequelize }) => sequelize.transaction(\r\n            { isolationLevel: 'SERIALIZABLE' },\r\n            async (transaction) => {\r\n                const names = new Set((await sequelize.query(\r\n                    'SELECT name FROM public.\"SequelizeMeta\";',\r\n                    { type: 'SELECT', transaction },\r\n                )).map(({ name }) => name));\r\n\r\n                if (originalMigrationNames.every(n => !names.has(n))) {\r\n                    // No original migrations have been applied\r\n                    await sequelize.query(dump + setup, { transaction });\r\n                } else if (originalMigrationNames.every(n => names.has(n))) {\r\n                    // All original migrations have been applied before\r\n                    await sequelize.query(\r\n                        'DELETE FROM public.\"SequelizeMeta\" WHERE name=ANY($1);',\r\n                        { bind: [originalMigrationNames], transaction }\r\n                    );\r\n                } else {\r\n                    throw new Error('Some but not all original migrations have been applied');\r\n                }\r\n            },\r\n        ),\r\n        down: ({ sequelize }) =>\r\n            sequelize.query(\\`\r\n                DROP SCHEMA IF EXISTS \"cord\" CASCADE;\r\n                DROP FUNCTION IF EXISTS public.gen_random_uuid();\r\n            \\`),\r\n    };\r\n\r\n    const originalMigrationNames = ${JSON.stringify(migrationNames)};\r\n\r\n    const dump = ${multiLineStringLiteral(removeCommentsAndBlankLines(dump))};\r\n    const setup = ${multiLineStringLiteral(setup)};\r\n    `;\r\n\r\n    const formattedMigration = await prettier.format(migration, {\r\n      filepath: newMigrationPath,\r\n      ...(await prettier.resolveConfig(newMigrationPath)),\r\n    });\r\n\r\n    for (const name of migrationNames) {\r\n      await fs.unlink(`database/migrations/${name}`);\r\n    }\r\n    await fs.writeFile(newMigrationPath, formattedMigration);\r\n  });\r\n}\r\n\r\nconst setup = `\r\nCREATE OR REPLACE FUNCTION public.gen_random_uuid()\r\nRETURNS uuid AS 'SELECT uuid_generate_v4();' LANGUAGE SQL;\r\n\r\nSET search_path = cord, public;`;\r\n\r\nfunction spawn(\r\n  command: string,\r\n  args: string[],\r\n  env: typeof process.env,\r\n): Promise<string> {\r\n  return new Promise<string>((resolve, reject) => {\r\n    const proc = child_process.spawn(command, args, {\r\n      stdio: ['ignore', 'pipe', 'inherit'],\r\n      env,\r\n    });\r\n    let stdout = '';\r\n\r\n    proc.on('error', reject);\r\n    proc.on('exit', (code) => {\r\n      if (code === 0) {\r\n        resolve(stdout);\r\n      } else {\r\n        reject(new Error(`Child process exited with status ${code}`));\r\n      }\r\n    });\r\n    proc.stdout.on('data', (data) => {\r\n      stdout += data;\r\n    });\r\n  });\r\n}\r\n\r\nfunction multiLineStringLiteral(s: string) {\r\n  return `\\`${s\r\n    .replaceAll('\\\\', '\\\\\\\\')\r\n    .replaceAll('`', '\\\\`')\r\n    .replaceAll('${', '\\\\${')}\\``;\r\n}\r\n\r\nfunction removeCommentsAndBlankLines(sql: string) {\r\n  sql = sql.replace(\r\n    /(\"(\"\"|[^\"])*\")|('(''|[^'])*')|(--[^\\n]*\\n*)|(\\n\\n+)/gm,\r\n    (match) => {\r\n      if (\r\n        (match[0] === '\"' && match[match.length - 1] === '\"') ||\r\n        (match[0] === \"'\" && match[match.length - 1] === \"'\")\r\n      ) {\r\n        return match;\r\n      } else if (match[0] === '\\n') {\r\n        return '\\n';\r\n      } else if (match.startsWith('--')) {\r\n        return '';\r\n      } else {\r\n        throw new Error('Logic error');\r\n      }\r\n    },\r\n  );\r\n\r\n  return sql;\r\n}\r\n\r\nmain().then(\r\n  () => {\r\n    process.exit(0);\r\n  },\r\n  (err) => {\r\n    console.error('\\n');\r\n    console.error(err);\r\n    process.exit(1);\r\n  },\r\n);\r\n", "import * as child_process from 'child_process';\r\nimport { promises as fs } from 'fs';\r\nimport * as path from 'path';\r\n\r\nimport { makePgEnv, run } from 'database/tooling/utils.ts';\r\n\r\nconst venvPath = path.resolve(process.cwd(), 'tmp', 'migra.python-venv');\r\nconst venvBinPath = path.resolve(venvPath, 'bin');\r\nconst migraPath = path.resolve(venvBinPath, 'migra');\r\n\r\n// `env`: this contains the PG* environment variables with the connection\r\n// details for Postgres command line tools. This does *not* include the\r\n// database name, because we do not ever want to connect to the configured\r\n// database in this script. Rather, we will create temporary databases to\r\n// connect to.\r\nconst env = makePgEnv();\r\nconst venvEnv = makePgEnv({ PATH: `${venvBinPath}:${process.env.PATH}` });\r\n\r\nexport async function installMigra() {\r\n  if (!(await file_exists(venvPath))) {\r\n    console.log('Creating Python virtualenv for installing migra...');\r\n    await run('python3', ['-m', 'venv', venvPath]);\r\n    await run(\r\n      'pip',\r\n      ['install', '--upgrade', 'pip', 'setuptools', 'wheel', 'packaging'],\r\n      { env: venvEnv },\r\n    );\r\n  }\r\n\r\n  if (!(await file_exists(migraPath))) {\r\n    console.log('Installing migra in Python virtualenv...');\r\n    await run('pip', ['install', 'psycopg2-binary', 'migra'], { env: venvEnv });\r\n  }\r\n}\r\n\r\n/** Run the migra tool to find schema differences between two PostgreSQL\r\n *  databases\r\n *\r\n * Pass two connection strings (like \"postgresql://dbname\") to this function!\r\n * It will return `null` if the two databases have identical structure, or if\r\n * they don't, it will return a string containing the database statements that\r\n * can be applied to database A to transform its structure into that of database\r\n * B.\r\n *\r\n * Optional, the name of a PostgreSQL schema can be provided, and then the diff\r\n * will be produced for that schema only.\r\n *\r\n * @param dbA connection string for database A\r\n * @param dbB connection string for database B\r\n * @param schema name of database schema for which to produce the diff\r\n */\r\nexport async function migra(\r\n  dbA: string,\r\n  dbB: string,\r\n  ...schemas: string[]\r\n): Promise<string | null> {\r\n  if (schemas.length === 0) {\r\n    return await migraImpl(dbA, dbB);\r\n  }\r\n\r\n  const results = (\r\n    await Promise.all(schemas.map((schema) => migraImpl(dbA, dbB, schema)))\r\n  ).filter(Boolean);\r\n\r\n  if (results.length === 0) {\r\n    return null;\r\n  } else {\r\n    return results.join('\\n\\n');\r\n  }\r\n}\r\n\r\nfunction migraImpl(\r\n  dbA: string,\r\n  dbB: string,\r\n  schema?: string | null,\r\n): Promise<string | null> {\r\n  return new Promise<string | null>((resolve, reject) =>\r\n    child_process.execFile(\r\n      migraPath,\r\n      ['--unsafe', ...(schema == null ? [] : ['--schema', schema]), dbA, dbB],\r\n      {\r\n        env: venvEnv,\r\n      },\r\n      (error, stdout, stderr) => {\r\n        if (error) {\r\n          if (error.code === 2) {\r\n            // migra exits with code 2 if the two schemas differ\r\n            resolve(stdout);\r\n          } else {\r\n            console.error(stderr);\r\n            reject(error);\r\n          }\r\n        } else {\r\n          // migra exits with code 0 if the two schemas are identical\r\n          resolve(null);\r\n        }\r\n      },\r\n    ),\r\n  );\r\n}\r\n\r\nexport function runSequelizeMigrate(database: string, ...extraArgs: string[]) {\r\n  return run(\r\n    'npx',\r\n    ['sequelize-cli', 'db:migrate', '--env', 'pgenv', ...(extraArgs || [])],\r\n    {\r\n      env: { ...env, PGDATABASE: database },\r\n    },\r\n  );\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!\r\nfunction file_exists(path: string) {\r\n  return fs.access(path).then(\r\n    () => true,\r\n    () => false,\r\n  );\r\n}\r\n", "import * as child_process from 'child_process';\r\n\r\nimport type { ClientConfig } from 'pg';\r\nimport { v4 as uuid } from 'uuid';\r\n\r\nexport function makePgEnv(override: NodeJS.ProcessEnv = {}): NodeJS.ProcessEnv {\r\n  const { PGDATABASE: _, ...env } = process.env;\r\n\r\n  return {\r\n    ...env,\r\n    PGHOST: process.env.POSTGRES_HOST,\r\n    PGPORT: process.env.POSTGRES_PORT,\r\n    PGUSER: process.env.POSTGRES_USER,\r\n    PGPASSWORD: process.env.POSTGRES_PASSWORD,\r\n    ...override,\r\n  };\r\n}\r\n\r\nexport async function executeSqlFile(sqlFilename: string, database: string) {\r\n  await run(\r\n    'psql',\r\n    [\r\n      '--echo-errors',\r\n      '--set=ON_ERROR_STOP=t',\r\n      '--single-transaction',\r\n      '--file',\r\n      sqlFilename,\r\n      database,\r\n    ],\r\n    { env: makePgEnv() },\r\n  );\r\n}\r\n\r\nexport async function withTemporaryDatabase<T>(\r\n  callback: (\r\n    database: string,\r\n    clientConfig: ClientConfig,\r\n    env: NodeJS.ProcessEnv,\r\n  ) => Promise<T>,\r\n): Promise<T> {\r\n  const env = makePgEnv();\r\n  const dbname = `temp-${uuid()}`;\r\n  console.log(`Creating temporary database: ${dbname}`);\r\n\r\n  await run('createdb', ['--template=template_radical_db', dbname], { env });\r\n  const clientConfig: ClientConfig = {\r\n    user: env.PGUSER,\r\n    password: env.PGPASSWORD,\r\n    host: env.PGHOST,\r\n    port: Number(env.PGPORT) || undefined,\r\n    database: dbname,\r\n  };\r\n\r\n  try {\r\n    return await callback(dbname, clientConfig, { ...env, PGDATABASE: dbname });\r\n  } finally {\r\n    console.log(`Destroying temporary database: ${dbname}`);\r\n    await run('dropdb', ['--if-exists', dbname], { env });\r\n  }\r\n}\r\n\r\nexport function run(\r\n  cmd: string,\r\n  args: string[],\r\n  env?: child_process.ExecFileOptions,\r\n) {\r\n  return new Promise<string>((resolve, reject) => {\r\n    child_process.execFile(cmd, args, env ?? {}, (error, stdout, stderr) => {\r\n      if (error) {\r\n        console.error(stderr);\r\n        reject(error);\r\n      } else {\r\n        resolve(stdout);\r\n      }\r\n    });\r\n  });\r\n}\r\n"],
  "mappings": "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",
  "names": ["child_process", "env", "env", "resolve", "env", "spawn", "resolve"]
}
