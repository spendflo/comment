{
  "version": 3,
  "sources": ["scripts/combine-old-database-migrations.ts", "database/tooling/migra.ts", "database/tooling/utils.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\n\n/**\n * Combine a number of old database migration into a single one\n *\n * At the time of writing this script, we have 318 migrations in the\n * database/migrations directory. That's a lot. It slows down the\n * check-database-schema script down, and it is just a lot of noise.\n *\n * This script simply combines many migrations into one. Call it with the name\n * of the migration up to which you want to combine them into one. The given\n * migration, and all the ones before leading to it, will disappear and be\n * replaced with one migration that contains the whole database content (schema\n * and data) created by the individual migrations replaced.\n *\n * To run this script, first choose up to which migration you want to combine\n * them all in one. Then you call this script:\n *\n * dist/scripts/combine-old-database-migrations.js\n * --to=TIMESTAMP-MIGRATION-NAME.js\n *\n * The script will delete old migration files and create one new migration. You\n * should be able to commit those changes without manual changes.\n *\n * This is a suitable test plan:\n *\n * Before running the script:\n * * `dist/scripts/check-database-schema.js --check` to check that your\n *   `cord.sql` file is equivalent to the sum of all migrations\n * * `dist/scripts/check-database-schema.js --checkDatabase` to check that your\n *   local database conforms with the `cord.sql` file\n *\n * After running the script:\n * * `dist/scripts/check-database-schema.js --check` to check that your\n *   `cord.sql` file is equivalent to the sum of all migrations, which now\n *   includes the single new migration instead of the many old ones\n * * `npm run migrate` to run the new migration against your local database\n * * `dist/scripts/check-database-schema.js --checkDatabase` to check that your\n *   local database conforms with the `cord.sql` file\n * * repeat the last two steps (`npm run migrate` should exit without applying\n *   any migrations)\n * * run the following queries against your local database - this wipes the all\n *   your local data:\n *   * `DROP SCHEMA IF EXISTS cord CASCADE;`\n *   * `DROP TABLE public.\"SequelizeMeta\";`\n * * `npm run migrate` to run *all* migrations against your now empty database\n * * `dist/scripts/check-database-schema.js --checkDatabase` to check that your\n *   local database conforms with the `cord.sql` file\n * * repeat the last two steps (`npm run migrate` should exit without applying\n *   any migrations)\n */\n\nimport * as child_process from 'child_process';\nimport { promises as fs } from 'fs';\n\nimport 'dotenv/config.js';\nimport pg from 'pg';\nimport prettier from 'prettier';\nimport yargs from 'yargs';\n\nimport { runSequelizeMigrate } from 'database/tooling/migra.ts';\nimport { withTemporaryDatabase } from 'database/tooling/utils.ts';\n\nasync function main() {\n  const { to: toMigration } = yargs(process.argv.slice(2))\n    .option('to', {\n      type: 'string',\n      demandOption: true,\n      description:\n        'name of the migration up to which you want combine migrations ' +\n        'together. This is a migration file name without the ' +\n        'database/migrations/ prefix but with the .js extension.',\n    })\n    .help().argv;\n\n  await fs.access(`database/migrations/${toMigration}`);\n\n  await withTemporaryDatabase(async (database, clientConfig, env) => {\n    await runSequelizeMigrate(database, '--to', toMigration);\n\n    const client = new pg.Client(clientConfig);\n    await client.connect();\n\n    let migrationNames: string[];\n    try {\n      // Let's get the names of all the migrations that Sequelize has applied\n      migrationNames = (\n        await client.query<{ name: string }>(\n          'SELECT name FROM public.\"SequelizeMeta\" ORDER BY name;',\n        )\n      ).rows.map(({ name }) => name);\n    } finally {\n      await client.end();\n    }\n\n    if (!migrationNames.length) {\n      throw new Error('No migrations!');\n    }\n\n    const match = /^\\d+/.exec(toMigration);\n    if (!match) {\n      throw new Error(`Migration name must begin with a number`);\n    }\n    const newMigrationPath = `database/migrations/${\n      BigInt(match[0]) + BigInt(1)\n    }-cord-schema.cjs`;\n\n    const dump = await spawn(\n      'pg_dump',\n      [\n        '--no-owner',\n        '--no-acl',\n        '--schema=cord',\n        '--inserts',\n        '--rows-per-insert=100',\n      ],\n      env,\n    );\n\n    const migration = `'use strict';\n    \n    module.exports = {\n        up: ({ sequelize }) => sequelize.transaction(\n            { isolationLevel: 'SERIALIZABLE' },\n            async (transaction) => {\n                const names = new Set((await sequelize.query(\n                    'SELECT name FROM public.\"SequelizeMeta\";',\n                    { type: 'SELECT', transaction },\n                )).map(({ name }) => name));\n\n                if (originalMigrationNames.every(n => !names.has(n))) {\n                    // No original migrations have been applied\n                    await sequelize.query(dump + setup, { transaction });\n                } else if (originalMigrationNames.every(n => names.has(n))) {\n                    // All original migrations have been applied before\n                    await sequelize.query(\n                        'DELETE FROM public.\"SequelizeMeta\" WHERE name=ANY($1);',\n                        { bind: [originalMigrationNames], transaction }\n                    );\n                } else {\n                    throw new Error('Some but not all original migrations have been applied');\n                }\n            },\n        ),\n        down: ({ sequelize }) =>\n            sequelize.query(\\`\n                DROP SCHEMA IF EXISTS \"cord\" CASCADE;\n                DROP FUNCTION IF EXISTS public.gen_random_uuid();\n            \\`),\n    };\n\n    const originalMigrationNames = ${JSON.stringify(migrationNames)};\n\n    const dump = ${multiLineStringLiteral(removeCommentsAndBlankLines(dump))};\n    const setup = ${multiLineStringLiteral(setup)};\n    `;\n\n    const formattedMigration = await prettier.format(migration, {\n      filepath: newMigrationPath,\n      ...(await prettier.resolveConfig(newMigrationPath)),\n    });\n\n    for (const name of migrationNames) {\n      await fs.unlink(`database/migrations/${name}`);\n    }\n    await fs.writeFile(newMigrationPath, formattedMigration);\n  });\n}\n\nconst setup = `\nCREATE OR REPLACE FUNCTION public.gen_random_uuid()\nRETURNS uuid AS 'SELECT uuid_generate_v4();' LANGUAGE SQL;\n\nSET search_path = cord, public;`;\n\nfunction spawn(\n  command: string,\n  args: string[],\n  env: typeof process.env,\n): Promise<string> {\n  return new Promise<string>((resolve, reject) => {\n    const proc = child_process.spawn(command, args, {\n      stdio: ['ignore', 'pipe', 'inherit'],\n      env,\n    });\n    let stdout = '';\n\n    proc.on('error', reject);\n    proc.on('exit', (code) => {\n      if (code === 0) {\n        resolve(stdout);\n      } else {\n        reject(new Error(`Child process exited with status ${code}`));\n      }\n    });\n    proc.stdout.on('data', (data) => {\n      stdout += data;\n    });\n  });\n}\n\nfunction multiLineStringLiteral(s: string) {\n  return `\\`${s\n    .replaceAll('\\\\', '\\\\\\\\')\n    .replaceAll('`', '\\\\`')\n    .replaceAll('${', '\\\\${')}\\``;\n}\n\nfunction removeCommentsAndBlankLines(sql: string) {\n  sql = sql.replace(\n    /(\"(\"\"|[^\"])*\")|('(''|[^'])*')|(--[^\\n]*\\n*)|(\\n\\n+)/gm,\n    (match) => {\n      if (\n        (match[0] === '\"' && match[match.length - 1] === '\"') ||\n        (match[0] === \"'\" && match[match.length - 1] === \"'\")\n      ) {\n        return match;\n      } else if (match[0] === '\\n') {\n        return '\\n';\n      } else if (match.startsWith('--')) {\n        return '';\n      } else {\n        throw new Error('Logic error');\n      }\n    },\n  );\n\n  return sql;\n}\n\nmain().then(\n  () => {\n    process.exit(0);\n  },\n  (err) => {\n    console.error('\\n');\n    console.error(err);\n    process.exit(1);\n  },\n);\n", "import * as child_process from 'child_process';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\n\nimport { makePgEnv, run } from 'database/tooling/utils.ts';\n\nconst venvPath = path.resolve(process.cwd(), 'tmp', 'migra.python-venv');\nconst venvBinPath = path.resolve(venvPath, 'bin');\nconst migraPath = path.resolve(venvBinPath, 'migra');\n\n// `env`: this contains the PG* environment variables with the connection\n// details for Postgres command line tools. This does *not* include the\n// database name, because we do not ever want to connect to the configured\n// database in this script. Rather, we will create temporary databases to\n// connect to.\nconst env = makePgEnv();\nconst venvEnv = makePgEnv({ PATH: `${venvBinPath}:${process.env.PATH}` });\n\nexport async function installMigra() {\n  if (!(await file_exists(venvPath))) {\n    console.log('Creating Python virtualenv for installing migra...');\n    await run('python3', ['-m', 'venv', venvPath]);\n    await run(\n      'pip',\n      ['install', '--upgrade', 'pip', 'setuptools', 'wheel', 'packaging'],\n      { env: venvEnv },\n    );\n  }\n\n  if (!(await file_exists(migraPath))) {\n    console.log('Installing migra in Python virtualenv...');\n    await run('pip', ['install', 'psycopg2-binary', 'migra'], { env: venvEnv });\n  }\n}\n\n/** Run the migra tool to find schema differences between two PostgreSQL\n *  databases\n *\n * Pass two connection strings (like \"postgresql://dbname\") to this function!\n * It will return `null` if the two databases have identical structure, or if\n * they don't, it will return a string containing the database statements that\n * can be applied to database A to transform its structure into that of database\n * B.\n *\n * Optional, the name of a PostgreSQL schema can be provided, and then the diff\n * will be produced for that schema only.\n *\n * @param dbA connection string for database A\n * @param dbB connection string for database B\n * @param schema name of database schema for which to produce the diff\n */\nexport async function migra(\n  dbA: string,\n  dbB: string,\n  ...schemas: string[]\n): Promise<string | null> {\n  if (schemas.length === 0) {\n    return await migraImpl(dbA, dbB);\n  }\n\n  const results = (\n    await Promise.all(schemas.map((schema) => migraImpl(dbA, dbB, schema)))\n  ).filter(Boolean);\n\n  if (results.length === 0) {\n    return null;\n  } else {\n    return results.join('\\n\\n');\n  }\n}\n\nfunction migraImpl(\n  dbA: string,\n  dbB: string,\n  schema?: string | null,\n): Promise<string | null> {\n  return new Promise<string | null>((resolve, reject) =>\n    child_process.execFile(\n      migraPath,\n      ['--unsafe', ...(schema == null ? [] : ['--schema', schema]), dbA, dbB],\n      {\n        env: venvEnv,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          if (error.code === 2) {\n            // migra exits with code 2 if the two schemas differ\n            resolve(stdout);\n          } else {\n            console.error(stderr);\n            reject(error);\n          }\n        } else {\n          // migra exits with code 0 if the two schemas are identical\n          resolve(null);\n        }\n      },\n    ),\n  );\n}\n\nexport function runSequelizeMigrate(database: string, ...extraArgs: string[]) {\n  return run(\n    'npx',\n    ['sequelize-cli', 'db:migrate', '--env', 'pgenv', ...(extraArgs || [])],\n    {\n      env: { ...env, PGDATABASE: database },\n    },\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!\nfunction file_exists(path: string) {\n  return fs.access(path).then(\n    () => true,\n    () => false,\n  );\n}\n", "import * as child_process from 'child_process';\n\nimport type { ClientConfig } from 'pg';\nimport { v4 as uuid } from 'uuid';\n\nexport function makePgEnv(override: NodeJS.ProcessEnv = {}): NodeJS.ProcessEnv {\n  const { PGDATABASE: _, ...env } = process.env;\n\n  return {\n    ...env,\n    PGHOST: process.env.POSTGRES_HOST,\n    PGPORT: process.env.POSTGRES_PORT,\n    PGUSER: process.env.POSTGRES_USER,\n    PGPASSWORD: process.env.POSTGRES_PASSWORD,\n    ...override,\n  };\n}\n\nexport async function executeSqlFile(sqlFilename: string, database: string) {\n  await run(\n    'psql',\n    [\n      '--echo-errors',\n      '--set=ON_ERROR_STOP=t',\n      '--single-transaction',\n      '--file',\n      sqlFilename,\n      database,\n    ],\n    { env: makePgEnv() },\n  );\n}\n\nexport async function withTemporaryDatabase<T>(\n  callback: (\n    database: string,\n    clientConfig: ClientConfig,\n    env: NodeJS.ProcessEnv,\n  ) => Promise<T>,\n): Promise<T> {\n  const env = makePgEnv();\n  const dbname = `temp-${uuid()}`;\n  console.log(`Creating temporary database: ${dbname}`);\n\n  await run('createdb', ['--template=template_radical_db', dbname], { env });\n  const clientConfig: ClientConfig = {\n    user: env.PGUSER,\n    password: env.PGPASSWORD,\n    host: env.PGHOST,\n    port: Number(env.PGPORT) || undefined,\n    database: dbname,\n  };\n\n  try {\n    return await callback(dbname, clientConfig, { ...env, PGDATABASE: dbname });\n  } finally {\n    console.log(`Destroying temporary database: ${dbname}`);\n    await run('dropdb', ['--if-exists', dbname], { env });\n  }\n}\n\nexport function run(\n  cmd: string,\n  args: string[],\n  env?: child_process.ExecFileOptions,\n) {\n  return new Promise<string>((resolve, reject) => {\n    child_process.execFile(cmd, args, env ?? {}, (error, stdout, stderr) => {\n      if (error) {\n        console.error(stderr);\n        reject(error);\n      } else {\n        resolve(stdout);\n      }\n    });\n  });\n}\n"],
  "mappings": "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",
  "names": ["child_process", "env", "env", "resolve", "env", "spawn", "resolve"]
}
