{
  "version": 3,
  "sources": ["scripts/check-database-schema.ts", "database/tooling/pg-formatter.ts", "database/tooling/migra.ts", "database/tooling/utils.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node -r dotenv/config\n\n// This script can be used in several ways:\n// * with the `--check` option it makes sure that migrations and schema are\n//   consistent. If they are not, the script fails and outputs a series of SQL\n//   statements that, if added to the schema, would make it consistent with the\n//   migrations. This is mostly meant as an indicator of the inconsistency.\n//   Usually the displayed remedy shouldn't be appended at the end of the\n//   schema, but put into the right places. E.g. `ALTER TABLE foo ALTER COLUMN\n//   bar SET NOT NULL` should not be appended at the end - rather the `CREATE\n//   TABLE foo` should be found and `NOT NULL` added to the definition of\n//   column `bar`.\n// * with the `--createMigration migration-name` option, a new migration file\n//   is created in the `database/migrations` folder with an autogenerated\n//   migration that would ensure consistency between migrations and the schema.\n//   The autogenerated migration is *one* way to get from the previous schema\n//   to the current one. When making changes to the schema, you can start with\n//   that autogenerated migration, but make sure that it carries out the\n//   migration in the intended way. E.g. it might suggest to drop a column and\n//   create a new one, when you mean to rename an existing column instead.\n//   Also, the autogenerated migration only does structural changes to the\n//   database, but you might want to add data operations. For example, if you\n//   were to add a `NOT NULL` constraint to some column in the schema, the\n//   autogenerated migration will provide the correct `ALTER TABLE ... ALTER\n//   COLUMN ... SET NOT NULL` statement for you (and the inverse in the\n//   down-migration), but this migration would fail if the database has rows in\n//   that table where that column currently is NULL. So, you would have to add\n//   statements to the migration to deal with that, e.g. `DELETE FROM table\n//   WHERE column IS NULL` or `UPDATE table SET column=DEFAULT WHERE column IS\n//   NULL`, or whatever is the right thing to do in the particular situation.\n//   There is no way to autogenerate the *correct* migration, but the\n//   autogenerated migration can still be useful as an indicator of all the\n//   things that need to be migrated.  And for some migrations, they will even\n//   be correct.\n// * there are two more options: `--checkSchema` and `--checkMigrations` apply\n//   the schema and the migrations, respectively, to an empty temporary\n//   database to check they are syntactically sound and valid.\n\nimport { promises as fs } from 'fs';\n\nimport prettier from 'prettier';\nimport yargs from 'yargs';\n\nimport { format } from 'database/tooling/pg-formatter.ts';\nimport {\n  installMigra,\n  migra,\n  runSequelizeMigrate,\n} from 'database/tooling/migra.ts';\nimport {\n  withTemporaryDatabase,\n  executeSqlFile,\n} from 'database/tooling/utils.ts';\n\nasync function main() {\n  const { argv } = yargs(process.argv.slice(2))\n    .option('checkMigrations', {\n      type: 'boolean',\n      description:\n        'Check that all migrations can be applied to an empty database with ' +\n        'no errors',\n    })\n    .option('checkSchema', {\n      type: 'boolean',\n      description:\n        'Check if schema description can be applied to an empty database ' +\n        'with no errors',\n    })\n    .option('check', {\n      type: 'boolean',\n      description:\n        'Check that both migrations and schema description can be applied to ' +\n        'an empty database with no error and yield identical schema. Any ' +\n        'diff that touches the database/ directory should be tested with ' +\n        'this option.',\n    })\n    .option('createMigration', {\n      type: 'string',\n      description:\n        'Create a new database migration that reflects changes in the schema ' +\n        'description. You must provide a name for the new migration which ' +\n        'will then be saved in ' +\n        'database/migrations/<current time>_<name provided>.cjs',\n    })\n    .option('checkDatabase', {\n      type: 'boolean',\n      description:\n        'Compare the current live database schema (of the database ' +\n        'configured in your .env) against the schema definition file',\n    })\n    .help();\n\n  const {\n    checkMigrations,\n    checkSchema,\n    check,\n    createMigration,\n    checkDatabase,\n  } = argv;\n\n  if (\n    !(\n      checkMigrations ||\n      checkSchema ||\n      check ||\n      createMigration ||\n      checkDatabase\n    )\n  ) {\n    yargs.showHelp();\n    throw null;\n  }\n  if (\n    createMigration &&\n    (checkMigrations || checkSchema || check || checkDatabase)\n  ) {\n    throw 'Do not mix the --createMigration option with other options!';\n  }\n\n  if (check || createMigration || checkDatabase) {\n    await installMigra();\n  }\n\n  const needSchemaDatabase = !!(\n    checkSchema ||\n    check ||\n    createMigration ||\n    checkDatabase\n  );\n  const needMigrationsDatabase = !!(\n    checkMigrations ||\n    check ||\n    createMigration\n  );\n  let upMigration: string | null = null;\n  let downMigration: string | null = null;\n\n  await withTemporaryDatabaseIfNeeded(\n    needSchemaDatabase,\n    async (schemaDatabase) => {\n      if (schemaDatabase !== null) {\n        try {\n          await executeSqlFile('database/schema.sql', schemaDatabase);\n        } catch (_) {\n          throw 'Failed to apply database schema migration to empty database';\n        }\n      }\n\n      if (needMigrationsDatabase) {\n        await withTemporaryDatabase(async (migrationsDatabase) => {\n          try {\n            await runSequelizeMigrate(migrationsDatabase);\n          } catch (_) {\n            throw 'Failed to apply all database migrations to empty database';\n          }\n\n          if ((check || createMigration) && schemaDatabase !== null) {\n            downMigration = await migra(\n              postgresUrl(schemaDatabase),\n              postgresUrl(migrationsDatabase),\n              'cord',\n            );\n\n            if (check && downMigration !== null) {\n              throw (\n                'The database migrations are not consistent with the full ' +\n                'database schema definition.\\n' +\n                'Adding the following statements to the schema definition ' +\n                'would make it consistent with the migrations:\\n\\n' +\n                prepareMigration(downMigration, '', false)\n              );\n            }\n\n            if (createMigration) {\n              if (downMigration === null) {\n                throw (\n                  'No changes to database schema detected. ' +\n                  'No database migration generated.'\n                );\n              } else {\n                upMigration = await migra(\n                  postgresUrl(migrationsDatabase),\n                  postgresUrl(schemaDatabase),\n                  'cord',\n                );\n              }\n            }\n          }\n        });\n      }\n\n      if (checkDatabase && schemaDatabase) {\n        const { POSTGRES_DB } = process.env;\n\n        if (!POSTGRES_DB) {\n          throw new Error(\n            'Using the --checkDatabase option requires you to set POSTGRES_DB',\n          );\n        }\n\n        const migration = await migra(\n          postgresUrl(schemaDatabase),\n          postgresUrl(POSTGRES_DB),\n          'cord',\n        );\n\n        if (migration === null) {\n          console.log(\n            \"The configured database's schema is consistent with the schema definition\",\n          );\n        } else {\n          throw (\n            \"The configured database's schema is not consistent with the full \" +\n            'database schema definition.\\n' +\n            'Adding the following statements to the schema definition ' +\n            'would make it consistent with the database:\\n\\n' +\n            prepareMigration(migration, '', false)\n          );\n        }\n      }\n    },\n  );\n\n  if (createMigration) {\n    const migrationFile = `'use strict';\n\n          module.exports = {\n            up: (queryInterface) =>\n              queryInterface.sequelize.query(\\`${prepareMigration(\n                upMigration ?? '',\n              )}\\`),\n           down: (queryInterface) =>\n              queryInterface.sequelize.query(\\`${prepareMigration(\n                downMigration ?? '',\n              )}\\`),\n          };`;\n\n    const now = new Date();\n    const timestamp =\n      now.getUTCFullYear().toString() +\n      (now.getUTCMonth() + 1).toString().padStart(2, '0') +\n      now.getUTCDate().toString().padStart(2, '0') +\n      now.getUTCHours().toString().padStart(2, '0') +\n      now.getUTCMinutes().toString().padStart(2, '0') +\n      now.getUTCSeconds().toString().padStart(2, '0');\n    const filename = `database/migrations/${timestamp}-${createMigration}.cjs`;\n\n    const formattedMigrationFile = await prettier.format(migrationFile, {\n      filepath: filename,\n      ...(await prettier.resolveConfig(filename)),\n    });\n\n    await fs.writeFile(filename, formattedMigrationFile);\n    console.log(`New database written to ${filename}`);\n  }\n}\n\nfunction prepareMigration(sql: string, indent = '      ', transaction = true) {\n  sql = format(sql.trim(), { keywordCase: 'uppercase', noRcFile: true }).trim();\n  if (transaction) {\n    sql = `\\nBEGIN;\\n\\n${sql}\\n\\nCOMMIT;`;\n  }\n  return sql.replace(/\\n/g, `\\n${indent}`).replace(/ +(\\n|$)/g, '$1');\n}\n\nfunction postgresUrl(database: string) {\n  const u = new URL('postgresql://');\n\n  const { POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_HOST, POSTGRES_PORT } =\n    process.env;\n\n  if (POSTGRES_USER) {\n    u.username = POSTGRES_USER;\n  }\n\n  if (POSTGRES_PASSWORD) {\n    u.password = POSTGRES_PASSWORD;\n  }\n\n  if (POSTGRES_HOST) {\n    if (POSTGRES_HOST[0] === '/') {\n      // Unix domain socket connection, must be specified as a search parameter\n      u.searchParams.append('host', POSTGRES_HOST);\n    } else {\n      u.host = encodeURIComponent(POSTGRES_HOST);\n    }\n  }\n\n  if (POSTGRES_PORT) {\n    u.port = POSTGRES_PORT;\n  }\n\n  u.pathname = database;\n\n  return u.toString();\n}\n\nfunction withTemporaryDatabaseIfNeeded<T>(\n  needed: boolean,\n  func: (arg: string | null) => Promise<T>,\n) {\n  if (needed) {\n    return withTemporaryDatabase(func);\n  } else {\n    return func(null);\n  }\n}\n\nmain().then(\n  () => {\n    process.exit(0);\n  },\n  (err) => {\n    if (err != null) {\n      console.error('\\n');\n      console.error(err);\n    }\n    process.exit(1);\n  },\n);\n", "export { format } from 'pg-formatter';\n", "import * as child_process from 'child_process';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\n\nimport { makePgEnv, run } from 'database/tooling/utils.ts';\n\nconst venvPath = path.resolve(process.cwd(), 'tmp', 'migra.python-venv');\nconst venvBinPath = path.resolve(venvPath, 'bin');\nconst migraPath = path.resolve(venvBinPath, 'migra');\n\n// `env`: this contains the PG* environment variables with the connection\n// details for Postgres command line tools. This does *not* include the\n// database name, because we do not ever want to connect to the configured\n// database in this script. Rather, we will create temporary databases to\n// connect to.\nconst env = makePgEnv();\nconst venvEnv = makePgEnv({ PATH: `${venvBinPath}:${process.env.PATH}` });\n\nexport async function installMigra() {\n  if (!(await file_exists(venvPath))) {\n    console.log('Creating Python virtualenv for installing migra...');\n    await run('python3', ['-m', 'venv', venvPath]);\n    await run(\n      'pip',\n      ['install', '--upgrade', 'pip', 'setuptools', 'wheel', 'packaging'],\n      { env: venvEnv },\n    );\n  }\n\n  if (!(await file_exists(migraPath))) {\n    console.log('Installing migra in Python virtualenv...');\n    await run('pip', ['install', 'psycopg2-binary', 'migra'], { env: venvEnv });\n  }\n}\n\n/** Run the migra tool to find schema differences between two PostgreSQL\n *  databases\n *\n * Pass two connection strings (like \"postgresql://dbname\") to this function!\n * It will return `null` if the two databases have identical structure, or if\n * they don't, it will return a string containing the database statements that\n * can be applied to database A to transform its structure into that of database\n * B.\n *\n * Optional, the name of a PostgreSQL schema can be provided, and then the diff\n * will be produced for that schema only.\n *\n * @param dbA connection string for database A\n * @param dbB connection string for database B\n * @param schema name of database schema for which to produce the diff\n */\nexport async function migra(\n  dbA: string,\n  dbB: string,\n  ...schemas: string[]\n): Promise<string | null> {\n  if (schemas.length === 0) {\n    return await migraImpl(dbA, dbB);\n  }\n\n  const results = (\n    await Promise.all(schemas.map((schema) => migraImpl(dbA, dbB, schema)))\n  ).filter(Boolean);\n\n  if (results.length === 0) {\n    return null;\n  } else {\n    return results.join('\\n\\n');\n  }\n}\n\nfunction migraImpl(\n  dbA: string,\n  dbB: string,\n  schema?: string | null,\n): Promise<string | null> {\n  return new Promise<string | null>((resolve, reject) =>\n    child_process.execFile(\n      migraPath,\n      ['--unsafe', ...(schema == null ? [] : ['--schema', schema]), dbA, dbB],\n      {\n        env: venvEnv,\n      },\n      (error, stdout, stderr) => {\n        if (error) {\n          if (error.code === 2) {\n            // migra exits with code 2 if the two schemas differ\n            resolve(stdout);\n          } else {\n            console.error(stderr);\n            reject(error);\n          }\n        } else {\n          // migra exits with code 0 if the two schemas are identical\n          resolve(null);\n        }\n      },\n    ),\n  );\n}\n\nexport function runSequelizeMigrate(database: string, ...extraArgs: string[]) {\n  return run(\n    'npx',\n    ['sequelize-cli', 'db:migrate', '--env', 'pgenv', ...(extraArgs || [])],\n    {\n      env: { ...env, PGDATABASE: database },\n    },\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!\nfunction file_exists(path: string) {\n  return fs.access(path).then(\n    () => true,\n    () => false,\n  );\n}\n", "import * as child_process from 'child_process';\n\nimport type { ClientConfig } from 'pg';\nimport { v4 as uuid } from 'uuid';\n\nexport function makePgEnv(override: NodeJS.ProcessEnv = {}): NodeJS.ProcessEnv {\n  const { PGDATABASE: _, ...env } = process.env;\n\n  return {\n    ...env,\n    PGHOST: process.env.POSTGRES_HOST,\n    PGPORT: process.env.POSTGRES_PORT,\n    PGUSER: process.env.POSTGRES_USER,\n    PGPASSWORD: process.env.POSTGRES_PASSWORD,\n    ...override,\n  };\n}\n\nexport async function executeSqlFile(sqlFilename: string, database: string) {\n  await run(\n    'psql',\n    [\n      '--echo-errors',\n      '--set=ON_ERROR_STOP=t',\n      '--single-transaction',\n      '--file',\n      sqlFilename,\n      database,\n    ],\n    { env: makePgEnv() },\n  );\n}\n\nexport async function withTemporaryDatabase<T>(\n  callback: (\n    database: string,\n    clientConfig: ClientConfig,\n    env: NodeJS.ProcessEnv,\n  ) => Promise<T>,\n): Promise<T> {\n  const env = makePgEnv();\n  const dbname = `temp-${uuid()}`;\n  console.log(`Creating temporary database: ${dbname}`);\n\n  await run('createdb', ['--template=template_radical_db', dbname], { env });\n  const clientConfig: ClientConfig = {\n    user: env.PGUSER,\n    password: env.PGPASSWORD,\n    host: env.PGHOST,\n    port: Number(env.PGPORT) || undefined,\n    database: dbname,\n  };\n\n  try {\n    return await callback(dbname, clientConfig, { ...env, PGDATABASE: dbname });\n  } finally {\n    console.log(`Destroying temporary database: ${dbname}`);\n    await run('dropdb', ['--if-exists', dbname], { env });\n  }\n}\n\nexport function run(\n  cmd: string,\n  args: string[],\n  env?: child_process.ExecFileOptions,\n) {\n  return new Promise<string>((resolve, reject) => {\n    child_process.execFile(cmd, args, env ?? {}, (error, stdout, stderr) => {\n      if (error) {\n        console.error(stderr);\n        reject(error);\n      } else {\n        resolve(stdout);\n      }\n    });\n  });\n}\n"],
  "mappings": "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",
  "names": ["fs", "child_process", "env", "resolve", "resolve", "path", "fs"]
}
