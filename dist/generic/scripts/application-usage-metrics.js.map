{
  "version": 3,
  "sources": ["scripts/application-usage-metrics.ts", "server/src/metrics/applicationUsageMetrics.ts", "common/util/index.ts", "common/types/index.ts", "common/const/Urls.ts", "common/const/Ids.ts", "opensource/sdk-js/packages/react/common/lib/messageNode.ts", "server/src/util/readReplicaDatabase.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\r\n\r\n/**\r\n * This script calculates an application usage metrics for the given\r\n * application. It does not read the data from the application_usage_metrics\r\n * table, but instead performs the calculation. The calculated values are not\r\n * persisted, but only printed out on the terminal.\r\n *\r\n * The purpose of the script is to test metrics queries.\r\n */\r\n\r\nimport 'dotenv/config.js';\r\nimport Pg from 'pg';\r\nimport yargs from 'yargs';\r\n\r\nimport {\r\n  applicationUsageMetricTypes,\r\n  applicationUsageMetricsQueries,\r\n  isApplicationUsageMetricType,\r\n} from 'server/src/metrics/applicationUsageMetrics.ts';\r\nimport { assertUUID } from 'common/util/index.ts';\r\nimport { getReadReplicaDbConfigFromEnv } from 'server/src/util/readReplicaDatabase.ts';\r\n\r\nconst argv = yargs(process.argv.slice(2))\r\n  .option('appID', {\r\n    type: 'string',\r\n    demandOption: true,\r\n    description: 'id of application for which metrics will be calculated',\r\n  })\r\n  .option('metric', {\r\n    type: 'string',\r\n    demandOption: true,\r\n    description: 'name of metric to calculate',\r\n    choices: applicationUsageMetricTypes,\r\n  })\r\n  .option('days', {\r\n    type: 'number',\r\n    default: 30,\r\n    description: 'number of days',\r\n  })\r\n  .strict()\r\n  .help()\r\n  .alias('help', 'h').argv;\r\n\r\nconst { appID, metric, days } = argv;\r\n\r\nasync function main() {\r\n  if (!isApplicationUsageMetricType(metric)) {\r\n    throw new Error(`Unknown metric: ${metric}`);\r\n  }\r\n  assertUUID(appID);\r\n  if (typeof days !== 'number' || days <= 0) {\r\n    throw new Error(`Invalid value for --days: ${days}`);\r\n  }\r\n\r\n  const config = getReadReplicaDbConfigFromEnv(process.env);\r\n  const pg = new Pg.Client(config);\r\n  await pg.connect();\r\n  await pg.query('SET search_path=cord,public;');\r\n\r\n  const metricQueries = applicationUsageMetricsQueries();\r\n  const mq = metricQueries[metric];\r\n  const query = mq.query;\r\n  const bind = mq.bind ? [...mq.bind] : [];\r\n\r\n  // We are adding two more placeholders: the values of `days` and `appID`. (The\r\n  // placeholder to be used for `days` is `$1` if after adding `days` to the\r\n  // array the array length is 1, and so forth. And then the same for\r\n  // `appID`.)\r\n  bind.push(days);\r\n  const daysPlaceholder = `$${bind.length}`;\r\n  bind.push(appID);\r\n  const appIDPlaceholder = `$${bind.length}`;\r\n\r\n  // We are wrapping the query here, in order to restrict the query to the\r\n  // requested number of days, but also to make sure to list all of the last\r\n  // `days` days, not just the ones returned by the given query. (If days are\r\n  // missing in the given query, we will print those out as `null` - the actual\r\n  // async job that persist the data will treat them as zero values.) We also\r\n  // check the creation date of the given application, and won't output any days\r\n  // before creation.\r\n  const wrappedQuery = `\\\r\n  WITH q AS (${query.trim()})\r\n  SELECT\r\n    d.date::text AS \"date\",\r\n    q.value::integer AS \"value\"\r\n  FROM applications a\r\n  CROSS JOIN (\r\n    SELECT CURRENT_DATE-generate_series(1,${daysPlaceholder}) AS \"date\"\r\n  ) d\r\n  LEFT OUTER JOIN q ON (q.\"applicationID\", q.\"date\")=(a.\"id\", d.\"date\")\r\n  WHERE a.id = ${appIDPlaceholder}\r\n  AND d.\"date\" >= a.\"createdTimestamp\"::date\r\n  ORDER BY d.\"date\";`;\r\n\r\n  const startTime = performance.now();\r\n  const { rows } = await pg.query<{ date: string; value: number | null }>(\r\n    wrappedQuery,\r\n    bind,\r\n  );\r\n  const endTime = performance.now();\r\n\r\n  console.log(`Query time: ${endTime - startTime}ms`);\r\n  for (const { date, value } of rows) {\r\n    console.log(`${date} : ${value ?? 'null (meaning 0)'}`);\r\n  }\r\n}\r\n\r\nmain().then(\r\n  () => process.exit(0),\r\n  (err) => {\r\n    console.error(err);\r\n    process.exit(1);\r\n  },\r\n);\r\n", "/**\r\n * Names of all application usage metric types in use\r\n */\r\nexport const applicationUsageMetricTypes = [\r\n  'number_of_messages',\r\n  'users_sent_message',\r\n  'users_sent_message_7d',\r\n  'users_sent_message_28d',\r\n  'users_activated',\r\n  'users_activated_7d',\r\n  'users_activated_28d',\r\n  'users_exposed_to_cord',\r\n  'users_exposed_to_cord_7d',\r\n  'users_exposed_to_cord_28d',\r\n] as const;\r\n\r\nexport type ApplicationUsageMetricType =\r\n  (typeof applicationUsageMetricTypes)[number];\r\n\r\nexport function isApplicationUsageMetricType(\r\n  x: any,\r\n): x is ApplicationUsageMetricType {\r\n  return (\r\n    typeof x === 'string' && applicationUsageMetricTypes.includes(x as any)\r\n  );\r\n}\r\n\r\ninterface MetricQuery {\r\n  query: string;\r\n  bind?: any[];\r\n}\r\n\r\nexport const applicationUsageMetricsQueries = (): Record<\r\n  ApplicationUsageMetricType,\r\n  MetricQuery\r\n> => ({\r\n  number_of_messages: {\r\n    // Group all messages by application ID (via their orgID) and the date part\r\n    // of the timestamp and count the number of messages with each appID/date\r\n    // combination. That simply gives us the number of messages written per day\r\n    // in an application.\r\n    query: `\r\n        SELECT\r\n            o.\"platformApplicationID\" AS \"applicationID\",\r\n            metrics_day(m.timestamp) AS \"date\",\r\n            COUNT(m) AS \"value\"\r\n        FROM messages m\r\n        INNER JOIN orgs o ON m.\"orgID\"=o.id\r\n        WHERE o.\"platformApplicationID\" IS NOT NULL\r\n        GROUP BY 1, 2`,\r\n  },\r\n  users_sent_message: usersSentMessage(1),\r\n  users_sent_message_7d: usersSentMessage(7),\r\n  users_sent_message_28d: usersSentMessage(28),\r\n  users_activated: usersActivated(1),\r\n  users_activated_7d: usersActivated(7),\r\n  users_activated_28d: usersActivated(28),\r\n  users_exposed_to_cord: usersExposedToCord(1),\r\n  users_exposed_to_cord_7d: usersExposedToCord(7),\r\n  users_exposed_to_cord_28d: usersExposedToCord(28),\r\n});\r\n\r\nfunction usersSentMessage(windowDays: number): MetricQuery {\r\n  // Calculate the number of users who authored messages over a window of N\r\n  // (`windowDays`) days. This means, if N=1, it calculates the number of\r\n  // message sending users for the day of `date` itself. For N=7, the value\r\n  // corresponds to the number of unique active users on the day of `date` and\r\n  // the six days before.\r\n  //\r\n  // This is how the query works: first we construct a matrix of all messages\r\n  // and the numbers from 0 to N-1, and we call these numbers \"shift\". (So each\r\n  // message is represented N times in the matrix, with a shift value of 0 to\r\n  // N-1.) Then we add \"shift\" days to the message timestamp (we only take date\r\n  // portion of the timestamp). So we now have N rows for each message, the\r\n  // first having the date set to the day the message was written, and then\r\n  // additional rows with the date set to the following N-1 days.\r\n  //\r\n  // Now we group these messages by their application ID (via the orgs table),\r\n  // and their shifted dates. And for each appID/date combination we count the\r\n  // number of unique message authors. Done.\r\n  //\r\n  // What we then have, is for any given appID/date combination, the number of\r\n  // unique message authors of messages written on the given date, or the N-1\r\n  // days before (because those messages all get the shift to the given date).\r\n  return {\r\n    query: `\r\n      SELECT\r\n        o.\"platformApplicationID\" AS \"applicationID\",\r\n        metrics_day(m.timestamp) + s.shift AS \"date\",\r\n        COUNT(DISTINCT m.\"sourceID\") AS \"value\"\r\n      FROM (SELECT generate_series(0, $1-1) AS shift) s\r\n      CROSS JOIN messages m\r\n      INNER JOIN orgs o ON m.\"orgID\"=o.id\r\n      WHERE o.\"platformApplicationID\" IS NOT NULL\r\n      GROUP BY 1, 2`,\r\n    bind: [windowDays],\r\n  };\r\n}\r\n\r\nfunction usersActivated(windowDays: number): MetricQuery {\r\n  // Calculate the \"activated users\" metric.\r\n  //\r\n  // First, collect all actions that happened in threads. That's messages\r\n  // written or reactions made. The `thread_actions` subquery returns rows of\r\n  // thread ids, user/org ids and dates of when things happened.\r\n  //\r\n  // Next, collect when a user was first active in a thread. Just by grouping\r\n  // the previous results by thread/user/org and taking the earliest (minimum)\r\n  // date.\r\n  //\r\n  // Then, calculate when we consider that a thread has become active. That's\r\n  // when not the first but the second user did something in the thread. This is\r\n  // not about a precise time, but just the day it happened. We are calculating\r\n  // daily time series anyway, and also this means that when two users start and\r\n  // comment on a thread the same day, they both count as activated, because\r\n  // they both did something in a thread that is considered active on that day.\r\n  // Just to clarify: once a thread has become active, it stays active. Meaning\r\n  // that if on a later day a user writes/reacts in that thread, that user will\r\n  // be considered activated, because they interacted with the thread in which\r\n  // they are not alone. Even if nobody else was active in that thread on the\r\n  // same day. On the other hand, when one user starts a thread and a second\r\n  // user reacts or comments the next day, then the first user wasn't activated,\r\n  // but the second was when they commented.\r\n  //\r\n  // Finally, we count the number of unique users in an application that were\r\n  // activated on a given day, by collecting all the users that did something on\r\n  // that day in a thread that had been active on the day or previously.\r\n  //\r\n  // For getting weekly/monthly number we do the same shifting as in the\r\n  // `usersSentMessage` query above. So, say for the weekly metric, when a user\r\n  // does a thing in a thread, we now act as if they did that thing on the day\r\n  // they did it, and then they did it six more times on the following days. So,\r\n  // if A starts a new thread on day 1, and B reacts on day 3, then A and B are\r\n  // both activated on day 3. Also on day 4, 5, 6, 7. On day 8, 9, we only count\r\n  // B as activated, because only B has been active within the time window of\r\n  // one week.\r\n  return {\r\n    query: `\r\n      WITH thread_actions AS NOT MATERIALIZED (\r\n        SELECT DISTINCT\r\n          \"threadID\",\r\n          \"sourceID\" AS \"userID\",\r\n          \"orgID\",\r\n          metrics_day(timestamp) AS \"day\"\r\n        FROM messages\r\n        UNION\r\n        SELECT m.\"threadID\", mr.\"userID\", m.\"orgID\", metrics_day(mr.timestamp)\r\n        FROM message_reactions mr INNER JOIN messages m ON mr.\"messageID\"=m.id\r\n      ), thread_user_first_action AS NOT MATERIALIZED (\r\n        SELECT\r\n          \"threadID\", \"userID\", \"orgID\",\r\n          min(\"day\") AS \"day\"\r\n        FROM thread_actions GROUP BY 1, 2, 3\r\n      ), thread_becomes_active AS (\r\n        SELECT DISTINCT\r\n          \"threadID\",\r\n          nth_value(day, 2) OVER w AS day\r\n        FROM thread_user_first_action\r\n        WINDOW w AS (PARTITION BY \"threadID\" ORDER BY day ASC)\r\n      )\r\n      SELECT\r\n        o.\"platformApplicationID\" AS \"applicationID\",\r\n        ta.day + s.shift AS \"date\",\r\n        COUNT(DISTINCT ta.\"userID\") AS \"value\"\r\n      FROM (SELECT generate_series(0, $1-1) AS shift) s\r\n      CROSS JOIN thread_actions ta\r\n      INNER JOIN orgs o ON ta.\"orgID\"=o.id\r\n      INNER JOIN thread_becomes_active tba USING(\"threadID\")\r\n      WHERE o.\"platformApplicationID\" IS NOT NULL\r\n      AND ta.day >= tba.day\r\n      GROUP BY 1, 2`,\r\n    bind: [windowDays],\r\n  };\r\n}\r\n\r\nfunction usersExposedToCord(windowDays: number): MetricQuery {\r\n  // Calculate the number of unique users who have been exposed to ANY Cord component.\r\n  // The weekly and monthly numbers are calculated using the same shifting logic seen in\r\n  // `usersSentMessage`. If a user is exposed to a Cord component on one day then we also count\r\n  // it as them being exposed to it every day following that day depending on the time window we have chosen.\r\n  return {\r\n    query: `\r\n      SELECT\r\n        e.\"platformApplicationID\" AS \"applicationID\",\r\n        metrics_day(e.\"serverTimestamp\") + s.shift AS \"date\",\r\n        COUNT(DISTINCT e.\"userID\") AS \"value\"\r\n      FROM (SELECT generate_series(0, $1-1) AS shift) s\r\n      CROSS JOIN events e\r\n      WHERE e.\"platformApplicationID\" IS NOT NULL\r\n      AND e.type = 'sdk-components-used'\r\n      GROUP BY 1,2`,\r\n    bind: [windowDays],\r\n  };\r\n}\r\n", "import md5 from 'blueimp-md5';\r\nimport jsonStableStringify from 'fast-json-stable-stringify';\r\nimport { unique } from 'radash';\r\nimport shajs from 'sha.js';\r\nimport dayjs from 'dayjs';\r\nimport Calendar from 'dayjs/plugin/calendar.js';\r\nimport isBetween from 'dayjs/plugin/isBetween.js';\r\n\r\nimport type {\r\n  UUID,\r\n  MessageContent,\r\n  ReferencedUserData,\r\n} from 'common/types/index.ts';\r\nimport { MessageNodeType } from 'common/types/index.ts';\r\nimport {\r\n  CORD_PLATFORM_ORG_ID,\r\n  CORD_ADMIN_PLATFORM_ORG_ID,\r\n  GILLIAN_TEST_SLACK_ORG_ID,\r\n  RADICAL_ORG_ID,\r\n  RADICAL_TEST_ORG_ID,\r\n  KAT_TEST_SLACK_ORG_ID,\r\n  CORD_SLACK_TEAM_ID,\r\n  CORD_TEST_SLACK_TEAM_ID,\r\n} from 'common/const/Ids.ts';\r\nimport {\r\n  getMessageNodeChildren,\r\n  textFromNodeRecursive,\r\n} from '@cord-sdk/react/common/lib/messageNode.ts';\r\nimport { trimStart } from '@cord-sdk/react/common/lib/trim.ts';\r\n\r\nconst uuidRegex =\r\n  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;\r\n\r\nexport const isEmployee = (orgID: UUID | undefined) =>\r\n  orgID === RADICAL_ORG_ID ||\r\n  orgID === RADICAL_TEST_ORG_ID ||\r\n  orgID === CORD_PLATFORM_ORG_ID ||\r\n  orgID === GILLIAN_TEST_SLACK_ORG_ID ||\r\n  orgID === KAT_TEST_SLACK_ORG_ID ||\r\n  orgID === CORD_ADMIN_PLATFORM_ORG_ID ||\r\n  process.env.NODE_ENV === 'development';\r\n\r\nexport const isInternalSlackOrg = (slackTeamID: string | undefined) =>\r\n  slackTeamID === CORD_SLACK_TEAM_ID || slackTeamID === CORD_TEST_SLACK_TEAM_ID;\r\n\r\nexport const assertUUID = (value: string): UUID => {\r\n  if (!uuidRegex.test(value)) {\r\n    throw new Error(`Invalid UUID ${value}`);\r\n  } else {\r\n    return value;\r\n  }\r\n};\r\n\r\n/**\r\n * @deprecated MD5 is no longer secure, use sha256Hash instead.\r\n */\r\nexport function md5Hash(object: boolean | number | string | object) {\r\n  return md5(jsonStableStringify(object));\r\n}\r\n\r\nexport function sha256Hash(value: string) {\r\n  return shajs('sha256').update(value).digest('hex');\r\n}\r\nexport const SHA256_HASH_LENGTH = 64;\r\n\r\nexport function generateSalt() {\r\n  const buf = new Uint8Array(8);\r\n  crypto.getRandomValues(buf);\r\n  return Array.from(buf)\r\n    .map((b) => b.toString(16).padStart(2, '0'))\r\n    .join('');\r\n}\r\n\r\nexport function sha256HashAndSalt(\r\n  value: string,\r\n  salt: string = generateSalt(),\r\n) {\r\n  return 'sha256' + ':' + salt + ':' + sha256Hash(salt + ':' + value);\r\n}\r\n\r\nexport function prepareTextContent(textContent: string) {\r\n  return (\r\n    textContent\r\n      .trim()\r\n      .toLowerCase()\r\n      // Remove Zero Width No-Break Space (U+FEFF)\r\n      .replace(/[\\uFEFF\\n]/gm, '')\r\n  );\r\n}\r\n\r\nexport function doesTextQualify(text: string | undefined | null) {\r\n  return Boolean(text && text.length > 1 && text.trim());\r\n}\r\n\r\nexport function getSha256Salt(hash: string): string {\r\n  return hash?.split(':')[1] ?? '';\r\n}\r\n\r\nexport function matchesHash(value: string, hashWithSalt: string) {\r\n  return hashWithSalt === sha256HashAndSalt(value, getSha256Salt(hashWithSalt));\r\n}\r\n\r\nexport function isNotNull<T>(value: T | null): value is T {\r\n  return value !== null;\r\n}\r\n\r\nexport function isDefined<T>(value: T | null | undefined): value is T {\r\n  return value !== null && value !== undefined;\r\n}\r\n\r\nexport function getMentionedUserIDs(content: MessageContent): UUID[] {\r\n  let users: UUID[] = [];\r\n  for (const node of content) {\r\n    if (node.type === MessageNodeType.MENTION) {\r\n      users.push(node.user.id);\r\n    } else {\r\n      const children = getMessageNodeChildren(node);\r\n      if (children) {\r\n        users = [...users, ...getMentionedUserIDs(children)];\r\n      }\r\n    }\r\n  }\r\n\r\n  return unique(users);\r\n}\r\n\r\nexport function getReferencedUserIDs(content: MessageContent): UUID[] {\r\n  const accumulator = new Set<UUID>();\r\n  gatherReferencedUserIDs(content, accumulator);\r\n  return [...accumulator];\r\n}\r\n\r\nfunction gatherReferencedUserIDs(\r\n  nodes: MessageContent,\r\n  accumulator: Set<UUID>,\r\n) {\r\n  for (const node of nodes) {\r\n    if (\r\n      node.type === MessageNodeType.MENTION ||\r\n      node.type === MessageNodeType.ASSIGNEE\r\n    ) {\r\n      accumulator.add(node.user.id);\r\n      continue;\r\n    }\r\n    const children = getMessageNodeChildren(node);\r\n    if (children) {\r\n      gatherReferencedUserIDs(children, accumulator);\r\n    }\r\n  }\r\n}\r\n\r\nexport function getReferencedUserIDsAndNames(\r\n  content: MessageContent,\r\n): ReferencedUserData[] {\r\n  const accumulator = new Map<UUID, string>();\r\n  gatherReferencedUserIDsAndName(content, accumulator);\r\n  return [...accumulator].map(([id, name]) => ({ id, name }));\r\n}\r\n\r\nfunction gatherReferencedUserIDsAndName(\r\n  nodes: MessageContent,\r\n  accumulator: Map<UUID, string>,\r\n) {\r\n  for (const node of nodes) {\r\n    if (\r\n      node.type === MessageNodeType.MENTION ||\r\n      node.type === MessageNodeType.ASSIGNEE\r\n    ) {\r\n      const userID = node.user.id;\r\n      const name = trimStart(textFromNodeRecursive(node), '@');\r\n      accumulator.set(userID, name);\r\n      continue;\r\n    }\r\n    const children = getMessageNodeChildren(node);\r\n    if (children) {\r\n      gatherReferencedUserIDsAndName(children, accumulator);\r\n    }\r\n  }\r\n}\r\n\r\n// JS replaceAll not well supported yet: https://caniuse.com/?search=replaceAll\r\nexport function replaceAll(str: string, replace: string, replaceWith: string) {\r\n  return str.split(replace).join(replaceWith);\r\n}\r\n\r\nexport type UserWithNames = {\r\n  displayName: string;\r\n  fullName: string;\r\n};\r\n\r\nexport type DisplayableUser = UserWithNames & {\r\n  id: UUID;\r\n  profilePictureURL: string | null;\r\n};\r\n\r\nexport function assert(predicate: boolean, message: string): asserts predicate {\r\n  if (!predicate) {\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the supplied items using the specified combiner.\r\n *\r\n * @example\r\n * // Returns \"foo, bar, or baz\"\r\n * combine(\"or\", [\"foo\", \"bar\", \"baz\"])\r\n */\r\nexport function combine(combiner: string, items: string[]): string {\r\n  if (items.length === 0) {\r\n    return '';\r\n  } else if (items.length === 1) {\r\n    return items[0];\r\n  } else if (items.length === 2) {\r\n    return `${items[0]} ${combiner} ${items[1]}`;\r\n  } else {\r\n    return `${items.slice(0, -1).join(', ')}, ${combiner} ${\r\n      items[items.length - 1]\r\n    }`;\r\n  }\r\n}\r\n\r\nexport const CORD_DEEP_LINK_THREAD_QUERY_PARAM = 'cord_thread';\r\nexport const CORD_DEEP_LINK_MESSAGE_QUERY_PARAM = 'cord_message';\r\nexport const CORD_DEEP_LINK_QUERY_PARAM = 'cord_link';\r\n\r\nexport const CORD_ARGS_TO_REMOVE = [\r\n  // delete deeplinking query params from urls. We dont want them as part of\r\n  // the pageContext\r\n\r\n  // old deeplinking query params. Keep here to support old deeplinks.\r\n  CORD_DEEP_LINK_THREAD_QUERY_PARAM,\r\n  CORD_DEEP_LINK_MESSAGE_QUERY_PARAM,\r\n\r\n  // new (unified) deeplinking query param\r\n  CORD_DEEP_LINK_QUERY_PARAM,\r\n];\r\n\r\nexport function extractDeepLinkQueryParams(\r\n  url: string,\r\n): { threadID: UUID; messageID: UUID } | null {\r\n  try {\r\n    const parsed = new URL(url);\r\n    return extractDeepLinkQueryParamsV1(parsed);\r\n  } catch (e) {\r\n    return null;\r\n  }\r\n}\r\n\r\n// also see injectDeeplinkQueryParamsV1()\r\nfunction extractDeepLinkQueryParamsV1(\r\n  url: URL,\r\n): { threadID: UUID; messageID: UUID } | null {\r\n  const [version, threadID, messageID]: (string | undefined)[] = (\r\n    url.searchParams.get(CORD_DEEP_LINK_QUERY_PARAM) ?? ''\r\n  ).split('_');\r\n\r\n  if (version !== 'v1' || !threadID || !messageID) {\r\n    return null;\r\n  }\r\n\r\n  return {\r\n    threadID,\r\n    messageID,\r\n  };\r\n}\r\n\r\ndayjs.extend(Calendar);\r\ndayjs.extend(isBetween);\r\n\r\nfunction getNowTimestamp() {\r\n  return dayjs(new Date(Date.now()));\r\n}\r\n\r\nexport function isTimestampTodayOrInTheFuture(timestamp: string) {\r\n  const now = getNowTimestamp();\r\n  return (\r\n    dayjs(timestamp).isSame(dayjs(now), 'day') ||\r\n    dayjs(timestamp).isAfter(dayjs(now), 'day')\r\n  );\r\n}\r\n\r\nexport function isTimestampFromPastSevenDays(timestamp: string) {\r\n  const now = getNowTimestamp();\r\n  const sevenDaysBefore = now.subtract(7, 'day');\r\n\r\n  return (\r\n    dayjs(timestamp).isBetween(now, sevenDaysBefore, 'day') ||\r\n    dayjs(timestamp).isSame(sevenDaysBefore, 'date')\r\n  );\r\n}\r\n\r\nexport function isTimestampFromPastThirtyDays(timestamp: string) {\r\n  const now = getNowTimestamp();\r\n  const thirtyDaysBefore = now.subtract(30, 'day');\r\n\r\n  return (\r\n    dayjs(timestamp).isBetween(now, thirtyDaysBefore) ||\r\n    dayjs(timestamp).isSame(thirtyDaysBefore, 'date')\r\n  );\r\n}\r\n\r\nexport function isTimestampFromPastThreeMonths(timestamp: string) {\r\n  const now = getNowTimestamp();\r\n  const threeMonthsBefore = now.subtract(3, 'month');\r\n  return (\r\n    dayjs(timestamp).isBetween(now, threeMonthsBefore) ||\r\n    dayjs(timestamp).isSame(threeMonthsBefore, 'day')\r\n  );\r\n}\r\n\r\nexport function isTimestampFromPastYear(timestamp: string) {\r\n  const now = getNowTimestamp();\r\n  const pastYear = now.subtract(1, 'year');\r\n  return (\r\n    dayjs(timestamp).isBetween(now, pastYear) ||\r\n    dayjs(timestamp).isSame(pastYear, 'day')\r\n  );\r\n}\r\n\r\nexport function isTimestampMoreThanAYearAgo(timestamp: string) {\r\n  const now = getNowTimestamp();\r\n  const pastYear = now.subtract(1, 'year');\r\n  return dayjs(timestamp).isBefore(pastYear, 'day');\r\n}\r\n\r\nexport function createDefaultSenderEmailName(applicationName: string) {\r\n  return applicationName.toLowerCase().split(/\\W/).join('') + '-notifications';\r\n}\r\n\r\n/**\r\n * in both the console UI and the API we don't allow editing the whole sender\r\n * field on customEmailTemplate, but only specific parts of it. This function\r\n * takes a 'sender' input and returns parts of the email.\r\n *\r\n * @example\r\n * const input = 'Cord <hello@cord.com>';\r\n * getEmailInfoFromSenderData(input); // {emailAddress: \"hello@cord.com\", domain: \"cord.com\", username: \"hello\" }\r\n */\r\ntype SenderInfo = {\r\n  domain: string;\r\n  emailAddress: string;\r\n  username: string;\r\n};\r\nexport function getEmailInfoFromSenderData(\r\n  sender?: string,\r\n): SenderInfo | undefined {\r\n  if (!sender) {\r\n    return undefined;\r\n  }\r\n\r\n  const mentionMatchingPattern = new RegExp(\r\n    '(<)' + // first match a \"<\"\r\n      '([^@]+)' + // then match anything that's not an @ symbol and is at least 1 char\r\n      '(@)' + // then match the @ so we can just access the domain itself easily\r\n      '([^>]+)', // then match anything that's not an > symbol and is at least 1 char\r\n    'gm',\r\n  );\r\n\r\n  let info: SenderInfo | undefined = undefined;\r\n  let match: RegExpExecArray | null;\r\n\r\n  while ((match = mentionMatchingPattern.exec(sender))) {\r\n    info = {\r\n      username: match[2],\r\n      domain: match[4],\r\n      emailAddress: match[0].substring(1),\r\n    };\r\n  }\r\n\r\n  return info;\r\n}\r\n\r\nexport function capitalizeFirstLetter(string: string) {\r\n  return string.charAt(0).toUpperCase() + string.slice(1);\r\n}\r\n", "// See #8935:\r\n/// <reference lib=\"es2022\" />\r\n\r\nimport type OpenAI from 'openai';\r\n\r\nimport jsonStableStringify from 'fast-json-stable-stringify';\r\nimport type { Placement } from '@floating-ui/react-dom';\r\nimport { isEqual } from '@cord-sdk/react/common/lib/fast-deep-equal.ts';\r\n\r\nexport type {\r\n  DocumentAnnotationResult,\r\n  Screenshot,\r\n  DocumentLocation,\r\n  LocationTextConfig,\r\n  HighlightedTextConfig,\r\n  AdditionalTargetData,\r\n  Annotation,\r\n  AnnotationWithThreadID,\r\n  AnnotationCapturePosition,\r\n} from '@cord-sdk/types';\r\nexport { locationJson } from '@cord-sdk/types';\r\nimport { locationJson, MessageNodeType } from '@cord-sdk/types';\r\nimport type {\r\n  FlatJsonObject,\r\n  LocationFilterOptions,\r\n  ResolvedStatus,\r\n  MessageAnnotation,\r\n  ElementIdentifierVersion,\r\n  EntityMetadata,\r\n  NotificationListFilter,\r\n  ThreadListFilter,\r\n  JsonValue,\r\n  JsonObject,\r\n  MessageContent,\r\n  MessageNode,\r\n  ViewerThreadStatus,\r\n} from '@cord-sdk/types';\r\n\r\nexport type {\r\n  MessageAnnotation,\r\n  ElementIdentifierVersion,\r\n  EntityMetadata,\r\n  NotificationListFilter,\r\n  ThreadListFilter,\r\n  JsonValue,\r\n  JsonObject,\r\n};\r\n\r\nexport type SimpleTranslationParameters = FlatJsonObject;\r\n\r\nexport enum DataTableQueries {\r\n  ADMIN_USERS = 'admin_users',\r\n  SET_ADMIN = 'set_admin',\r\n  USER_DETAILS = 'user_details',\r\n  ORG_DETAILS = 'org_details',\r\n  APP_DETAILS = 'app_details',\r\n  THREAD_DETAILS = 'thread_details',\r\n  MESSAGE_DETAILS = 'message_details',\r\n  CUSTOMER_DETAILS = 'customer_details',\r\n  ORG_MEMBER_DETAILS = 'org_member_details',\r\n  ID_SEARCH = 'id_search',\r\n  PROD_APPLICATIONS = 'prod_applications',\r\n  STAGING_APPLICATIONS = 'staging_applications',\r\n  SAMPLE_APPLICATIONS = 'sample_applications',\r\n  VERIFIED_CUSTOMERS = 'verified_customers',\r\n  SAMPLE_CUSTOMERS = 'sample_customers',\r\n  DEPLOYS = 'deploys',\r\n  PAGE_CONTEXTS = 'page_contexts',\r\n  BROWSER_METRICS = 'browser_metrics',\r\n  OS_METRICS = 'os_metrics',\r\n  GO_REDIRECTS = 'go_redirects',\r\n}\r\n\r\nexport type NonNullableKeys<T, K extends keyof T> = T & {\r\n  [P in K]: NonNullable<T[P]>;\r\n};\r\n\r\nexport type NullableKeys<T, K extends keyof T> = Omit<T, K> & {\r\n  [P in K]: T[P] | null;\r\n};\r\n\r\nexport type ElementOf<T extends Array<any>> = T[number];\r\n\r\n/**\r\n * A mapping type that effectively combines Required<T> and NonNullable<T> to\r\n * turn { foo?: string | undefined } into { foo: string }\r\n */\r\n// NOTE(9/9/2021): This is equivalent to Required<T> if we compiled with\r\n// --strictNullChecks, but we currently don't\r\nexport type ReallyRequired<T> = {\r\n  [P in keyof T]-?: NonNullable<T[P]>;\r\n};\r\n\r\nexport type { MessageContent, MessageNode };\r\nexport { MessageNodeType };\r\n\r\nexport type UUID = string;\r\n\r\nexport type Location = {\r\n  [k: string]: string | number | boolean;\r\n};\r\n\r\nexport type SortDirection = 'ascending' | 'descending';\r\n\r\nexport function isValidFlatJsonObject(obj: any): obj is FlatJsonObject {\r\n  if (!obj) {\r\n    return false;\r\n  }\r\n  if (typeof obj !== 'object' || Array.isArray(obj)) {\r\n    return false;\r\n  }\r\n  for (const [_, value] of Object.entries(obj)) {\r\n    const t = typeof value;\r\n    if (t !== 'string' && t !== 'number' && t !== 'boolean') {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function isLocation(obj: any): obj is Location {\r\n  return isValidFlatJsonObject(obj);\r\n}\r\n\r\nexport function isValidMetadata(obj: any): obj is EntityMetadata {\r\n  return isValidFlatJsonObject(obj);\r\n}\r\n\r\nexport function toLocation(obj: any): Location | null {\r\n  return isLocation(obj) ? obj : null;\r\n}\r\n\r\n// We receive location as either Location or LocationFilterOptions from\r\n// our apis. Since Location type can be flat object with multiple properties\r\n// we have to check the property type to make sure we're getting the right value.\r\n// eg: {value: 'foo', ...} is Location\r\n// while {value: {value: 'foo'} ...} is LocationFilterOptions\r\nexport function getLocationFilter(\r\n  obj: LocationFilterOptions | Location | undefined,\r\n): LocationFilterOptions | undefined {\r\n  if (!obj) {\r\n    return undefined;\r\n  }\r\n\r\n  if (isLocation(obj)) {\r\n    return { value: obj, partialMatch: false };\r\n  }\r\n\r\n  if (isLocation(obj.value)) {\r\n    return obj;\r\n  }\r\n  return undefined;\r\n}\r\n\r\n// Function to convert our external resolvedStatus filter enum\r\n// to our internal 'resolved' boolean property\r\nexport function getResolvedFromStatus(\r\n  status: ResolvedStatus,\r\n): boolean | undefined {\r\n  // we've not included a fallback value as this will just increase the chances\r\n  // of returning the wrong data somewhere. So we make sure to pass whatever\r\n  // we've said the default is for the API that's calling this.\r\n  switch (status) {\r\n    case 'resolved': {\r\n      return true;\r\n    }\r\n    case 'unresolved': {\r\n      return false;\r\n    }\r\n    case 'any': {\r\n      return undefined;\r\n    }\r\n    default: {\r\n      const unhandledStatus: never = status;\r\n      throw new Error('Invalid resolved status type ' + unhandledStatus);\r\n    }\r\n  }\r\n}\r\n\r\nexport function getViewerThreadFilter(\r\n  viewerStatus: ViewerThreadStatus | ViewerThreadStatus[] | undefined,\r\n): ViewerThreadStatus[] {\r\n  if (!viewerStatus) {\r\n    return [];\r\n  }\r\n  if (typeof viewerStatus === 'string') {\r\n    return [viewerStatus];\r\n  }\r\n  return viewerStatus;\r\n}\r\n\r\nexport function metadataMatches(\r\n  metadata: EntityMetadata,\r\n  matcher: EntityMetadata,\r\n): boolean {\r\n  for (const [key, value] of Object.entries(matcher)) {\r\n    if (metadata[key] !== value) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function locationMatches(context: Location, matcher: Location): boolean {\r\n  for (const [key, value] of Object.entries(matcher)) {\r\n    if (context[key] !== value) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction flatJsonObjectEqual(\r\n  a: FlatJsonObject | null,\r\n  b: FlatJsonObject | null,\r\n): boolean {\r\n  if (a === null && b === null) {\r\n    return true;\r\n  }\r\n  if (a === null || b === null) {\r\n    return false;\r\n  }\r\n  if (Object.keys(a).length !== Object.keys(b).length) {\r\n    return false;\r\n  }\r\n  for (const [key, value] of Object.entries(a)) {\r\n    if (b[key] !== value) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport function locationEqual(a: Location | null, b: Location | null): boolean {\r\n  return flatJsonObjectEqual(a, b);\r\n}\r\n\r\nexport function metadataEqual(\r\n  a: EntityMetadata | null,\r\n  b: EntityMetadata | null,\r\n): boolean {\r\n  return flatJsonObjectEqual(a, b);\r\n}\r\n\r\n/**\r\n * Implements the canonical comparison for locations.  Currently, this sorts by\r\n * number of elements, then the JSON representation alphabetically, but we can\r\n * change that if we come up with something better.\r\n */\r\nexport function locationCompare(a: Location, b: Location): number {\r\n  const lengthA = Object.keys(a).length;\r\n  const lengthB = Object.keys(b).length;\r\n  if (lengthA !== lengthB) {\r\n    return lengthA - lengthB;\r\n  }\r\n  return locationJson(a).localeCompare(locationJson(b));\r\n}\r\n\r\nexport type PageContext = {\r\n  providerID: UUID | null;\r\n  data: Location;\r\n};\r\n\r\nexport function pageContextEqual(\r\n  a: PageContext | null,\r\n  b: PageContext | null,\r\n): boolean {\r\n  if (a === null && b === null) {\r\n    return true;\r\n  }\r\n  if (a === null || b === null) {\r\n    return false;\r\n  }\r\n  // Two contexts from different providers are never equal\r\n  if (a.providerID !== b.providerID) {\r\n    return false;\r\n  }\r\n  // If either has data, compare the data, otherwise compare the locations\r\n  return isEqual(a.data, b.data);\r\n}\r\n\r\n// This returns a string key that is equivalent from an equality perspective to\r\n// comparing the pageContexts.  Specifically, the intention is that\r\n// pageContextEqual(a, b) === (pageContextKey(a) === pageContextKey(b))\r\n\r\n// The functioning of this depends a lot on our specific logic of\r\n// building PageContexts, such that, for instance,\r\n// a.location === b.location => a.providerID === b.providerID.\r\n\r\n// It also needs to stay consistent with the logic in server/src/util/hash.ts.\r\nexport function pageContextKey(pageContext: PageContext): string {\r\n  return jsonStableStringify({\r\n    providerID: pageContext.providerID,\r\n    data: pageContext.data,\r\n  });\r\n}\r\n\r\n/**\r\n * Convert a PageContext-like object into an actual PageContext.\r\n *\r\n * The PageContext types that we exchange with GraphQL allow nullable fields to\r\n * be undefined as well. This function takes such objects and returns a valid\r\n * PageContext.\r\n */\r\ntype PageContextLike = {\r\n  providerID?: UUID | null;\r\n  data: Location;\r\n};\r\nexport function toPageContext(pageContext: PageContextLike): PageContext;\r\nexport function toPageContext(pageContext: null | undefined): null;\r\nexport function toPageContext(\r\n  pageContext: PageContextLike | null | undefined,\r\n): PageContext | null;\r\nexport function toPageContext(\r\n  pageContext: PageContextLike | null | undefined,\r\n): PageContext | null {\r\n  if (!pageContext) {\r\n    return null;\r\n  }\r\n  const { providerID, data } = pageContext;\r\n  if (!isLocation(data)) {\r\n    throw new Error('Invalid context');\r\n  }\r\n  return {\r\n    providerID: providerID ?? null,\r\n    data,\r\n  };\r\n}\r\n\r\nexport type OrgMemberState = 'active' | 'inactive' | 'deleted'; // must match the keys in OrgMemberStateEnumType\r\n\r\nexport type UserType = 'person' | 'bot'; // must match the keys in UserTypeEnumType\r\n\r\nexport type UserState = 'active' | 'deleted'; // must match the keys in UserStateEnumType\r\n\r\nexport type ImportedSlackMessageType = 'reply' | 'supportBotReply'; // must match the keys in ImportedSlackMessageTypeEnumType\r\n\r\nexport type MessageType = 'action_message' | 'user_message'; //must match the keys in MessageTypeEnumType\r\n\r\nexport interface Todo {\r\n  id: UUID;\r\n  done: boolean;\r\n}\r\n\r\nexport enum MessageAttachmentType {\r\n  FILE = 'file',\r\n  ANNOTATION = 'annotation',\r\n  SCREENSHOT = 'screenshot',\r\n}\r\n\r\nexport const MessageAnnotationAttachmentTypeName =\r\n  'MessageAnnotationAttachment';\r\n\r\nexport function parseElementIdentifierVersion(\r\n  val: string,\r\n): ElementIdentifierVersion | null {\r\n  if (val === '1' || val === '2') {\r\n    return val;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport enum ElementIdentifierMatch {\r\n  EXACT = 'exact',\r\n  PARTIAL = 'partial',\r\n  NONE = 'none',\r\n}\r\n\r\nexport enum LocationMatch {\r\n  EXACT = 'exact',\r\n  SIBLING = 'sibling',\r\n  MULTIMEDIA = 'multimedia',\r\n  CHART = 'chart',\r\n  STALE = 'stale',\r\n  MAYBE_STALE = 'maybe_stale',\r\n  NONE = 'none',\r\n  // User has old extension, and does not have the latest identifier version\r\n  INCOMPATIBLE_IDENTIFIER_VERSION = 'incompatible_identifier_version',\r\n  // Used if fallback document coordinates are included, and we don't have an exact/sibling match\r\n  DOCUMENT_COORDINATES = 'document_coordinates',\r\n  // If we weren't able to annotate, so we're instead relying on the screenshot\r\n  // Examples: annotating a pdf, annotating an iframe we can't access\r\n  UNAVAILABLE = 'unavailable',\r\n  // If the annotation was on an inaccessible cross-domain iframe. We want to\r\n  // show it while the message is being drafted, but not after it's been posted\r\n  INACCESSIBLE_CROSS_DOMAIN_IFRAME = 'inaccessible_cross_domain_iframe',\r\n  OUTSIDE_ACCESSIBLE_VIRTUALISED_LIST = 'outside_accessible_virtualised_list',\r\n  OUTSIDE_INACCESSIBLE_VIRTUALISED_LIST = 'outside_inaccessible_virtualised_list',\r\n}\r\n\r\nexport function annotationHasLocation(annotation: MessageAnnotation) {\r\n  return annotation.location !== null || annotation.customLocation !== null;\r\n}\r\n\r\nexport const ThreadCreatedTypeName = 'ThreadCreated';\r\nexport const ThreadMessageAddedTypeName = 'ThreadMessageAdded';\r\nexport const ThreadMessageUpdatedTypeName = 'ThreadMessageUpdated';\r\nexport const ThreadMessageContentAppendedTypeName =\r\n  'ThreadMessageContentAppended';\r\nexport const ThreadMessageRemovedTypeName = 'ThreadMessageRemoved';\r\nexport const ThreadParticipantsUpdatedIncrementalTypeName =\r\n  'ThreadParticipantsUpdatedIncremental';\r\nexport const ThreadTypingUsersUpdatedTypeName = 'ThreadTypingUsersUpdated';\r\nexport const ThreadShareToSlackTypeName = 'ThreadShareToSlack';\r\nexport const ThreadPropertiesUpdatedTypeName = 'ThreadPropertiesUpdated';\r\nexport const ThreadSubscriberUpdatedTypeName = 'ThreadSubscriberUpdated';\r\nexport const ThreadDeletedTypeName = 'ThreadDeleted';\r\n\r\nexport const PageThreadAddedTypeName = 'PageThreadAdded';\r\nexport const PageThreadDeletedTypename = 'PageThreadDeleted';\r\nexport const PageThreadReplyAddedTypeName = 'PageThreadReplyAdded';\r\nexport const PageVisitorsUpdatedTypeName = 'PageVisitorsUpdated';\r\nexport const PageThreadResolvedTypeName = 'PageThreadResolved';\r\nexport const PageThreadUnresolvedTypeName = 'PageThreadUnresolved';\r\nexport const ThreadFilterablePropertiesMatchTypeName =\r\n  'ThreadFilterablePropertiesMatch';\r\nexport const ThreadFilterablePropertiesUnmatchTypeName =\r\n  'ThreadFilterablePropertiesUnmatch';\r\n\r\nexport const NotificationAddedTypeName = 'NotificationAdded';\r\nexport const NotificationReadStateUpdatedTypeName =\r\n  'NotificationReadStateUpdated';\r\nexport const NotificationDeletedTypeName = 'NotificationDeleted';\r\n\r\nexport const OrgMemberAddedTypeName = 'OrgMemberAdded';\r\nexport const OrgMemberRemovedTypeName = 'OrgMemberRemoved';\r\n\r\nexport const ConsoleGettingStartedUpdatedTypeName =\r\n  'ConsoleGettingStartedUpdated';\r\n\r\nexport const CustomerSubscriptionUpdatedTypeName =\r\n  'CustomerSubscriptionUpdated';\r\n\r\nexport type FileAttachmentInput = {\r\n  id: UUID;\r\n  fileID: UUID;\r\n};\r\n\r\n// Subset of winston log levels, which can be found in NpmConfigSetLevels type in winston type file\r\nexport enum LogLevel {\r\n  ERROR = 'error',\r\n  WARN = 'warn',\r\n  INFO = 'info',\r\n  DEBUG = 'debug',\r\n}\r\n\r\nexport type PopperPosition = Placement;\r\n\r\n// called when the sidebar shows and hides, with a reference to the Cord iframe\r\n// expected to make domain-specific document adjustments to accommodate the sidebar\r\n// in its two states (expanded / not).\r\nexport type DocumentMutator = (width: number | null) => void;\r\n\r\n// called with the document to initialize any mutator-specific elements and behavior\r\n// expected to return the actual mutator function\r\nexport type DocumentMutatorInitializer = (\r\n  document: Document,\r\n) => DocumentMutator;\r\n\r\nexport type SimpleValue = string | number | boolean;\r\n\r\nexport type PreferencesValueType = JsonValue;\r\n\r\nexport type PreferencesType = JsonObject;\r\n\r\nexport enum UserReference {\r\n  MENTION = 'mention',\r\n  ASSIGNEE = 'assignee',\r\n}\r\n\r\nexport type RuleProviderInfo = {\r\n  id: UUID; // the ID of the provider, should be unique among providers\r\n  name: string; // the name of the provider\r\n  iconURL?: string | null; // URL for a favicon-like image\r\n  nuxText?: string | null; // the text to show the user teaching them how to use Radical on this specific provider\r\n  disableAnnotations?: boolean; // if annotations should be disabled for this provider. example: slack static PDFs where due to the chrome pdf viewer we don't have access to the scroll position\r\n};\r\n\r\n// a ruleset provider should export all the rules specific to a SaaS, even when\r\n// those rules span across different domain names.\r\nexport type RuleProvider = RuleProviderInfo & {\r\n  domains: string[]; // the domains that this provider's rules cover\r\n  rules: ProviderRule[]; // deny and approve rules\r\n  mergeHashWithLocation?: boolean; // a fix for providers like Snowflake who have URLs with query parameters after the # in the URL\r\n  visibleInDiscoverToolsSection: boolean; // the state of wether the tool is visible in th Discover tools section in the NUX flow, i.e. internal tools should not be included, localhost should not be included\r\n  platformApplicationID: UUID | null; // Application ID of provider, if relevant\r\n\r\n  // the functions to call to mutate the document to make room for the sidebar.\r\n  // this is a list to allow per-domain granularity.\r\n  documentMutators: ProviderDocumentMutator[];\r\n};\r\n\r\nexport type ProviderRule = {\r\n  id: UUID;\r\n  type: ProviderRuleType;\r\n  matchPatterns: ProviderRuleMatchPatterns;\r\n  nameTemplate: string | null;\r\n  contextTransformation: PageContextTransformation;\r\n  observeDOMMutations: boolean;\r\n};\r\n\r\nexport type ProviderDocumentMutator =\r\n  | { id: UUID; type: 'default_css'; config: CSSMutatorConfig }\r\n  | { id: UUID; type: 'custom_css'; config: CSSMutatorConfig }\r\n  | { id: UUID; type: 'fixed_elements'; config: null };\r\n\r\nexport type ProviderDocumentMutatorType = ProviderDocumentMutator['type'];\r\n\r\nexport type CSSMutatorConfig = {\r\n  cssTemplate: string;\r\n};\r\n\r\nexport type ProviderRuleType = 'allow' | 'deny';\r\n\r\nexport type ProviderRuleMatchPatterns = {\r\n  protocol?: string;\r\n  domain?: string;\r\n  path?: string;\r\n  hash?: string;\r\n  queryParams?: { [key: string]: string };\r\n  selector?: string;\r\n  contains?: string;\r\n};\r\n\r\nexport type ProviderRuleTestMatchType = 'allow' | 'deny' | 'none';\r\n\r\nexport type PageDetails = {\r\n  pageContext: PageContext;\r\n  pageName: string | null;\r\n};\r\n\r\nexport type MatchResult = (\r\n  | {\r\n      match: 'allow' | 'deny';\r\n      ruleID: UUID;\r\n    }\r\n  | {\r\n      match: 'none';\r\n    }\r\n) &\r\n  PageDetails;\r\n\r\nexport type PageContextTransformationType =\r\n  | 'default'\r\n  | 'replace'\r\n  | 'extend'\r\n  | 'metabase';\r\n\r\nexport type PageContextTransformation = {\r\n  type: PageContextTransformationType;\r\n  data: JsonObject | null;\r\n};\r\n\r\nexport type ProvidersResult = {\r\n  ruleProviders: RuleProvider[];\r\n  version: string;\r\n};\r\n\r\nexport type DeepPartial<T> = {\r\n  [P in keyof T]?: DeepPartial<T[P]>;\r\n};\r\n\r\nexport type LinearTeam = {\r\n  id: string;\r\n  name: string;\r\n  projects: {\r\n    nodes: Array<{\r\n      id: string;\r\n      name: string;\r\n    }>;\r\n  };\r\n};\r\n\r\nexport type AtlassianProject = {\r\n  // expand: 'description,lead,issueTypes,url,projectKeys,permissions,insight',\r\n  id: string; // 10000\r\n  key: string; // STLR\r\n  name: string; // 'Stellar'\r\n  issueTypes: Array<{\r\n    id: string; //'10001'\r\n    // description: 'Tasks track small, distinct pieces of work.';\r\n    name: string;\r\n    subtask: boolean;\r\n    // avatarId: 10318;\r\n    // hierarchyLevel: 0;\r\n  }>;\r\n  simplified: boolean;\r\n  style: string; // 'next-gen'\r\n  isPrivate: boolean;\r\n  entityId: UUID;\r\n  uuid: UUID;\r\n};\r\n\r\nexport type MondayBoard = {\r\n  id: string;\r\n  name: string;\r\n  subitem_board?: {\r\n    id: string;\r\n  };\r\n  groups: Array<{\r\n    id: string;\r\n    title: string;\r\n    position: string;\r\n  }>;\r\n};\r\n\r\nexport type JiraConnectionPreferences = {\r\n  projectID: string;\r\n  issueType: string;\r\n  subissueType?: string;\r\n};\r\n\r\nexport type AsanaConnectionPreferences = {\r\n  projectID: string | undefined;\r\n};\r\n\r\nexport type MondayConnectionPreferences = {\r\n  boardID: string;\r\n  groupID?: string;\r\n};\r\n\r\ntype TrelloList = {\r\n  id: UUID;\r\n  name: string;\r\n  closed?: string;\r\n  pos?: number;\r\n  softLimit?: string;\r\n  idBoard?: UUID;\r\n  subscriber: boolean;\r\n};\r\n\r\ntype TrelloBoard = {\r\n  id: UUID;\r\n  name: string;\r\n  idOrganization: UUID;\r\n  lists: TrelloList[];\r\n};\r\n\r\ntype TrelloOrg = {\r\n  id: UUID;\r\n  name: string;\r\n};\r\n\r\nexport type TrelloConnectionPreferencesType = {\r\n  id: UUID;\r\n  email: string;\r\n  boards: TrelloBoard[];\r\n  organizations: TrelloOrg[];\r\n};\r\n\r\nexport type TrelloCard = {\r\n  name: string;\r\n  desc: string;\r\n  idList: UUID;\r\n};\r\n\r\nexport type AsanaProject = {\r\n  gid: string;\r\n  name: string;\r\n};\r\n\r\nexport type JiraIssuePreviewData = {\r\n  key: string;\r\n  title: string;\r\n  url: string;\r\n  assignee: string | undefined;\r\n  status: string;\r\n  done: boolean;\r\n  priority: string;\r\n  subtasks: Array<{\r\n    id: string;\r\n    title: string;\r\n    done: boolean;\r\n  }>;\r\n};\r\n\r\nexport type AsanaTaskPreviewData = {\r\n  title: string;\r\n  url: string;\r\n  assignee: string | undefined;\r\n  done: boolean;\r\n};\r\n\r\nexport type LinearIssuePreviewData = {\r\n  title: string;\r\n  identifier: string;\r\n  url: string;\r\n  assignee: string | undefined;\r\n  status: string;\r\n  priority: string;\r\n  done: boolean;\r\n  orgName: string | undefined;\r\n};\r\n\r\nexport type MondayItemPreviewData = {\r\n  title: string;\r\n  url: string;\r\n  assignee: string | undefined;\r\n  done: boolean;\r\n  assigneeColumnID: string | undefined;\r\n  statusColumnID: string | undefined;\r\n};\r\n\r\nexport type TaskPreviewData =\r\n  | AsanaTaskPreviewData\r\n  | JiraIssuePreviewData\r\n  | LinearIssuePreviewData\r\n  | MondayItemPreviewData;\r\n\r\nexport enum LinearIssueStateTypes {\r\n  BACKLOG = 'backlog',\r\n  TODO = 'unstarted',\r\n  IN_PROGRESS = 'started',\r\n  DONE = 'completed',\r\n  CANCELED = 'canceled',\r\n}\r\n\r\nexport type LinearConnectionPreferences = {\r\n  teamID: string;\r\n  projectID?: string;\r\n};\r\n\r\nexport type APICordTokenData = {\r\n  session_id: UUID;\r\n};\r\n\r\nexport type AppServerAuthTokenData = {\r\n  app_id: UUID;\r\n};\r\n\r\nexport type CustomerServerAuthTokenData = {\r\n  customer_id: UUID;\r\n};\r\n\r\nexport type NotificationChannels = {\r\n  slack: boolean;\r\n  email: boolean;\r\n};\r\n\r\nexport type CustomLinks = {\r\n  learnMore?: string | null;\r\n  upgradePlan?: string | null;\r\n  leaveFeedback?: string | null;\r\n};\r\n\r\nexport type ThirdPartyAuth = 'slack' | 'google' | 'ms-teams';\r\n\r\nexport type OutboundNotificationType =\r\n  | 'slack'\r\n  | 'email'\r\n  | 'slackEmailMatched'\r\n  | 'sharedToSlackChannel'\r\n  | 'sharedToEmail';\r\n\r\nexport type { Point2D } from '@cord-sdk/types';\r\n\r\nexport type CustomNUXStepContent = {\r\n  title: string | null;\r\n  text: string | null;\r\n  imageURL: string | null;\r\n};\r\n\r\nexport type CustomNUX = {\r\n  initialOpen: CustomNUXStepContent | null;\r\n  welcome: CustomNUXStepContent | null;\r\n};\r\n\r\nexport type SlackOAuthLinkOrgState = {\r\n  data: {\r\n    userID: string;\r\n    orgID: string;\r\n    platformApplicationID: string;\r\n  };\r\n  type: 'link_org';\r\n  nonce: string;\r\n};\r\n\r\nexport type SlackOAuthConsoleUserState = {\r\n  data: {\r\n    platformApplicationID: string;\r\n  };\r\n  type: 'console_user';\r\n  nonce: string;\r\n};\r\n\r\nexport type SlackOAuthDecodeState =\r\n  | SlackOAuthLinkOrgState\r\n  | SlackOAuthConsoleUserState;\r\n\r\nexport type ThreadSupportStatusType = 'open' | 'closed';\r\n\r\nexport type UserWithOrgDetails = {\r\n  id: UUID;\r\n  externalID: string;\r\n  displayName: string;\r\n  fullName: string;\r\n  name: string | null;\r\n  shortName: string | null;\r\n  profilePictureURL: string | null;\r\n  metadata: EntityMetadata;\r\n  canBeNotifiedOnSlack: boolean;\r\n};\r\n\r\nexport type OutboundNotificationMetadata =\r\n  OutboundNotificationMetadataByType[OutboundNotificationType];\r\n\r\n// when adding new fields to existing metadata types, either make the new\r\n// fields optional or run a backfill migration\r\nexport type OutboundNotificationMetadataByType = {\r\n  slack: Record<string, never>;\r\n  email: Record<string, never>;\r\n  slackEmailMatched: Record<string, never>;\r\n  sharedToSlackChannel: {\r\n    type: 'sharedToSlackChannel';\r\n    targetSlackChannelID: string;\r\n  };\r\n  sharedToEmail: {\r\n    type: 'sharedToEmail';\r\n    targetEmail: string;\r\n  };\r\n};\r\n\r\n// Internal threads are the standard mirrored Slack threads\r\n// that users can share to their linked Slack org.\r\n// Support threads are the ones mirrored to a vendor's Slack org\r\n// and support channel after a support bot is mentioned.\r\nexport type ThreadMirrorType = 'internal' | 'support';\r\n\r\nexport type Tier = 'prod' | 'staging' | 'test' | 'dev';\r\n\r\nexport type SharedToSlackInfo = {\r\n  channel: string | null;\r\n  slackURL: string | null;\r\n};\r\n\r\nexport type ThreadMode =\r\n  // Only shows the first message, and optionally the number of replies\r\n  | 'collapsed'\r\n  // Can show all messages, also includes a composer to add a new message\r\n  | 'inline'\r\n  // Used in the sidebar only - thread spans across the whole page\r\n  | 'fullHeight'\r\n  // The initial state when we are creating a new thread - composer only\r\n  | 'newThread';\r\n\r\nexport type Announcement =\r\n  | 'welcome'\r\n  | 'completeProfile'\r\n  | 'connectOrgToSlack'\r\n  | 'linkProfileToSlack'\r\n  | 'slackIsConnected';\r\n\r\nexport type ReferencedUserData = { id: UUID; name: string };\r\n\r\nconst DEPLOYMENT_TYPES = ['sdk'] as const;\r\n\r\nexport type DeploymentType = (typeof DEPLOYMENT_TYPES)[number];\r\n\r\nexport function isDeploymentType(s: string): s is DeploymentType {\r\n  if (DEPLOYMENT_TYPES.includes(s as DeploymentType)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function toDeploymentType(\r\n  s: string | null | undefined,\r\n): DeploymentType | null {\r\n  if (s && isDeploymentType(s)) {\r\n    return s;\r\n  }\r\n  return null;\r\n}\r\n\r\nexport type ApplicationEnvironment =\r\n  | 'production'\r\n  | 'staging'\r\n  | 'sample' // console self-serve test (not paying) app\r\n  | 'sampletoken' // sample token apps created for docs integration guide and demo apps opensource repos (wiped periodically)\r\n  | 'demo'; // temporary token apps created for docs and cord.com demo apps (wiped periodically)\r\n\r\n// NB you there are some classes of token you might expect are environments,\r\n// but actually all belong to one appID:\r\n// The docs live components are all in the CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID app\r\n// The e2e tests are all in the CORD_AUTOMATED_TESTS_APPLICATION_ID app\r\n// The CORD_PLAYGROUND_APPLICATION_ID has been retired from service\r\n\r\nexport type EmptyJsonObject = Record<string, never>;\r\n\r\nexport type CustomerType = 'verified' | 'sample';\r\n\r\nexport type CustomerImplementationStage =\r\n  | 'launched'\r\n  | 'implementing'\r\n  | 'proof_of_concept'\r\n  | 'inactive';\r\n\r\nexport type AdminCRTComingFrom = 'them' | 'us';\r\n\r\nexport type AdminCRTDecision = 'done' | 'accepted' | 'rejected' | 'pending';\r\n\r\nexport type AdminCRTCommunicationStatus =\r\n  | 'none'\r\n  | 'request_acked'\r\n  | 'decision_sent'\r\n  | 'decision_acked';\r\n\r\nexport type AdminCRTIssueType = 'request' | 'bug' | 'onboarding_step';\r\n\r\nexport type AdminCRTPriority = 'blocker' | 'high' | 'low';\r\n\r\nexport type AdminCRTCustomerIssue = {\r\n  customerID: UUID;\r\n  title: string;\r\n  body: string;\r\n  comingFrom: AdminCRTComingFrom;\r\n  decision: AdminCRTDecision;\r\n  communicationStatus: AdminCRTCommunicationStatus;\r\n  lastTouch?: string;\r\n  type: AdminCRTIssueType;\r\n  priority: AdminCRTPriority;\r\n  externallyVisible: boolean;\r\n  assignee?: UUID;\r\n};\r\n\r\nexport type DocsCachedEmbedding = {\r\n  url: string;\r\n  plaintext: string;\r\n  embedding?: OpenAI.CreateEmbeddingResponse | undefined;\r\n};\r\n\r\nexport type CordDotComCachedEmbedding = DocsCachedEmbedding & {\r\n  title: string;\r\n};\r\n\r\n// This is for the mouse move events within iframes\r\nexport type IframeMouseMoveData = { x: number; y: number; frame_id: string };\r\n\r\nexport type Maybe<T> = T | null | undefined;\r\nexport type Nullable<T> = T | null;\r\n", "// This is for important URLs to all kinds of services\r\n\r\nexport const TOP_SERVER_HOST = process.env.TOP_SERVER_HOST!;\r\nexport const APP_SERVER_HOST = process.env.APP_SERVER_HOST!;\r\nexport const API_SERVER_HOST = process.env.API_SERVER_HOST!;\r\nexport const API_SERVER_HOST_PRODUCTION =\r\n  process.env.API_SERVER_HOST_PRODUCTION!;\r\nexport const ADMIN_SERVER_HOST = process.env.ADMIN_SERVER_HOST!;\r\nexport const CONSOLE_SERVER_HOST = process.env.CONSOLE_SERVER_HOST!;\r\nexport const MARKETING_SERVER_HOST = process.env.MARKETING_SERVER_HOST!;\r\nexport const CORD_TO_HOST = process.env.CORD_TO_HOST!;\r\nexport const AUTH0_CUSTOM_LOGIN_DOMAIN = process.env.AUTH0_CUSTOM_LOGIN_DOMAIN!;\r\nexport const DOCS_SERVER_HOST = process.env.DOCS_SERVER_HOST!;\r\nexport const SLACK_APP_REDIRECT_HOST = process.env.SLACK_APP_REDIRECT_HOST;\r\n\r\nexport const TOP_ORIGIN = 'https://' + process.env.TOP_SERVER_HOST;\r\nexport const APP_ORIGIN = 'https://' + process.env.APP_SERVER_HOST;\r\nexport const API_ORIGIN = 'https://' + process.env.API_SERVER_HOST;\r\nexport const ADMIN_ORIGIN = 'https://' + process.env.ADMIN_SERVER_HOST;\r\nexport const CONSOLE_ORIGIN = 'https://' + process.env.CONSOLE_SERVER_HOST;\r\nexport const MARKETING_ORIGIN = 'https://' + process.env.MARKETING_SERVER_HOST;\r\nexport const CORD_TO_ORIGIN = 'https://' + process.env.CORD_TO_HOST;\r\nexport const AUTH0_ORIGIN = 'https://' + process.env.AUTH0_CUSTOM_LOGIN_DOMAIN;\r\nexport const DOCS_ORIGIN = 'https://' + process.env.DOCS_SERVER_HOST;\r\nexport const DOCS_AI_CHATBOT_SERVER_HOST =\r\n  process.env.DOCS_AI_CHATBOT_SERVER_HOST;\r\nexport const COMMUNITY_ORIGIN = 'https://' + process.env.COMMUNITY_SERVER_HOST;\r\n\r\n// See https://github.com/getcord/interactive-demos\r\nexport const DEMO_APPS_WEBHOOK_URL =\r\n  'https://cord-interactive-demos.vercel.app/events';\r\n", "import { DOCS_ORIGIN } from 'common/const/Urls.ts';\r\n\r\nexport const SUPPORT_USER_UUID = 'c9a61e1d-7c8a-4c7e-838a-9d431cf4ed77';\r\nexport const RADICAL_ORG_ID = '6bba8678-b14e-4af7-b2f2-05ee807dfa82';\r\nexport const RADICAL_TEST_ORG_ID = '3689f86d-0c70-40de-a2f0-a4a9ea4994e3';\r\nexport const CORD_PLATFORM_ORG_ID = '746c0b57-7363-4766-9ee9-7ae8ec7531a8';\r\nexport const CORD_ADMIN_PLATFORM_ORG_ID =\r\n  '84ae9086-8414-4ed3-ab73-096e6438f095';\r\nexport const CORD_SDK_TEST_ORG_ID = 'edda098d-6db7-4202-a5ac-ff3293b78c47';\r\nexport const GILLIAN_TEST_SLACK_ORG_ID = 'f7ab9ab8-f5b2-41a4-a419-1b8076626d3f';\r\nexport const KAT_TEST_SLACK_ORG_ID = '4506fadd-f8dc-4795-9b5d-d28feda39d84';\r\nexport const CORD_SLACK_TEAM_ID = 'T012Y0TBQLW'; // radicalhqworkspace\r\nexport const CORD_TEST_SLACK_TEAM_ID = 'T015UJY6YQK'; // radicaltestorg\r\n\r\nexport const SLACK_APP_CLIENT_ID = '1100027398710.1180115520790';\r\nexport const SLACK_APP_ID = 'A015A3DFAP8';\r\nexport const SLACK_DEV_APP_CLIENT_ID = '1198644236835.1943446227956';\r\nexport const SLACK_ADMIN_LOGIN_APP_CLIENT_ID = '1100027398710.2437628320357';\r\nexport const SLACK_ADMIN_LOGIN_APP_ID = 'A02CVJG9EAH';\r\nexport const SLACK_DEV_APP_ID = 'A01TRD46PU4';\r\nexport const SLACK_INTERNAL_TOOLS_APP_ID = 'A04JKM945CM';\r\nexport const CORD_UPDATES_TEST_CHANNEL_ID = 'C0547K3V868';\r\n\r\n// As opposed to e.g. a customer's Slack app\r\nexport const CORD_SLACK_APP_IDS = [\r\n  SLACK_APP_ID,\r\n  SLACK_DEV_APP_ID,\r\n  SLACK_ADMIN_LOGIN_APP_ID,\r\n  SLACK_INTERNAL_TOOLS_APP_ID,\r\n];\r\n\r\nexport const CORD_APPLICATION_ID = '5a076ee9-8b9e-4156-9ac4-871bdc4569ec';\r\nexport const CORD_SDK_TEST_APPLICATION_ID =\r\n  'b6501bf5-46f7-4db7-9996-c42dd9f758b0';\r\nexport const CORD_SAMPLE_TOKEN_CUSTOMER_ID =\r\n  '1c367aca-37c9-4733-8bef-e9f11a7d0f17';\r\nexport const CORD_DEMO_APPS_TOKEN_CUSTOMER_ID =\r\n  '4383cf39-8b6a-4c33-9d8a-71567ed47a60';\r\nexport const CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID =\r\n  'aeb2797f-f0a3-485c-a317-4986e2c8343b';\r\nexport const CORD_AUTOMATED_TESTS_APPLICATION_ID =\r\n  'dfa86152-9e7e-4d2d-acd6-bfddef71f58e';\r\nexport const CLACK_APPLICATION_ID = '5fa22ba9-5446-4af8-bc93-7ce54a9aa0ba';\r\nexport const CORD_HOMEPAGE_APPLICATION_ID =\r\n  '29e6499a-bbed-4eb2-b057-b36d60ad76c9';\r\nexport const AUTH0_CLIENT_ID = process.env.AUTH0_CLIENT_ID!;\r\n\r\nexport const CORD_CUSTOMER_ID = '12ed6251-28d5-4686-9a75-20a15bd31499';\r\n\r\nexport const CSS_CUSTOMIZATION_ON_DOCS_PREFIX = 'css-customization-';\r\nexport const BETA_V2_DOCS_PREFIX = 'beta2-';\r\nexport const LIVE_CSS_ON_DOCS_THREAD_ID_PREFIX = 'live-css-docs-thread-';\r\nexport const LIVE_COMPONENT_ON_DOCS_THREAD_ID_PREFIX =\r\n  'live-component-docs-thread-';\r\nexport const LIVE_COMPONENT_INBOX_THREAD_ID_PREFIX =\r\n  'live_component-docs-inbox-thread-';\r\nexport const LIVE_COMPONENT_INBOX_LAUNCHER_THREAD_ID_PREFIX =\r\n  'live_component-docs-inbox-launcher-thread-';\r\nexport const LIVE_COMPONENT_ON_DOCS_COMPOSER_THREAD_ID_PREFIX =\r\n  'live-component-docs-composer-thread-';\r\nexport const LIVE_COMPONENT_ON_DOCS_MESSAGE_THREAD_ID_PREFIX =\r\n  'live-component-docs-message-thread-';\r\nexport const LIVE_COMPONENT_ON_DOCS_MESSAGE_CONTENT_THREAD_ID_PREFIX =\r\n  'live-component-docs-message-content-thread-';\r\nexport const LIVE_COMPONENT_ON_DOCS_PIN_THREAD_ID_PREFIX =\r\n  'live-component-docs-pin-thread-';\r\nexport const LIVE_COMPONENT_ON_DOCS_REACTIONS_THREAD_ID_PREFIX =\r\n  'live-component-docs-reactions-thread-';\r\nexport const LIVE_COMPONENT_ON_DOCS_EXTERNAL_NOTIFICATION_PREFIX =\r\n  'live-component-docs-external-notification-';\r\nexport const LIVE_CUSTOMIZATION_ON_DOCS_REPLACEMENTS_THREAD_ID_PREFIX =\r\n  'live-customization-docs-replacements-thread-';\r\nexport const DOCS_TOKEN_KEY = 'docs-token';\r\n\r\nexport const LIVE_COMPONENT_ON_DOCS_NO_AVATAR_USER_ID = 'noavatar';\r\n\r\nexport const DOCS_LIVE_PAGE_LOCATIONS = {\r\n  cssCustomization: 'css-customization',\r\n  liveCss: 'live-css-docs',\r\n  liveThread: 'live-thread',\r\n  liveThreadList: 'live-thread-list',\r\n  livePin: 'live-pin',\r\n  livePinChartExample: 'live-pin-chart-example',\r\n  liveFloatingThreads: 'live-floating-threads',\r\n  liveSelectionComments: 'live-selection-comments',\r\n  liveSidebar: 'live-sidebar',\r\n  liveInbox: 'live-inbox',\r\n  liveInboxLauncher: 'live-inbox-launcher',\r\n  liveSidebarLauncher: 'live-sidebar-launcher',\r\n  livePagePresence: 'live-page-presence',\r\n  livePresenceFacepile: 'live-presence-facepile',\r\n  liveComposer: 'live-composer',\r\n  liveMessage: 'live-message',\r\n  liveMessageContent: 'live-message-content',\r\n  liveNotificationList: 'live-notification-list',\r\n  liveThreadedComments: 'live-threaded-comments',\r\n  liveReactions: 'live-reactions',\r\n  liveReplacementsTutorial: 'live-replacements-tutorial',\r\n  liveBetaV2Thread: 'live-beta-v2-thread',\r\n  liveBetaV2Threads: 'live-beta-v2-threads',\r\n};\r\n\r\nexport const CORD_DOCS_CLIENT_TOKEN = '__cord_docs_token__';\r\n\r\nexport const DOCS_URLS = {\r\n  tutorials: {\r\n    getProductionReady: {\r\n      addYourBranding: `${DOCS_ORIGIN}/get-started/live-css-editor`,\r\n    },\r\n    integrationGuide: `${DOCS_ORIGIN}/get-started/integration-guide`,\r\n    demoApps: `${DOCS_ORIGIN}/get-started/demo-apps`,\r\n  },\r\n  components: {\r\n    thread: `${DOCS_ORIGIN}/components/cord-thread`,\r\n    threadList: `${DOCS_ORIGIN}/components/cord-thread-list`,\r\n    threadedComments: `${DOCS_ORIGIN}/components/cord-threaded-comments`,\r\n    sidebar: `${DOCS_ORIGIN}/components/cord-sidebar`,\r\n    inbox: `${DOCS_ORIGIN}/components/cord-inbox`,\r\n    inboxLauncher: `${DOCS_ORIGIN}/components/cord-inbox-launcher`,\r\n    sidebarLauncher: `${DOCS_ORIGIN}/components/cord-sidebar-launcher`,\r\n    composer: `${DOCS_ORIGIN}/components/cord-composer`,\r\n    message: `${DOCS_ORIGIN}/components/cord-message`,\r\n    messageContent: `${DOCS_ORIGIN}/components/cord-message-content`,\r\n    reactions: `${DOCS_ORIGIN}/components/cord-reactions`,\r\n  },\r\n  howTo: {\r\n    customThreadedComments: `${DOCS_ORIGIN}/customization/custom-threaded-comments`,\r\n    cssCustomization: `${DOCS_ORIGIN}/customization/css`,\r\n    replacements: `${DOCS_ORIGIN}/customization/custom-react-components/tutorial`,\r\n  },\r\n  getStarted: {\r\n    authenticateYourUser: `${DOCS_ORIGIN}/get-started/integration-guide/generate-an-auth-token`,\r\n  },\r\n  betaV2Components: {\r\n    threads: `${DOCS_ORIGIN}/components/cord-threads?version=2.0`,\r\n    thread: `${DOCS_ORIGIN}/components/cord-thread?version=2.0`,\r\n  },\r\n};\r\n\r\nexport const CORD_DEV_CONSOLE_LOGGING_SLACK_CHANNEL_ID = 'C05FAVBSSN7';\r\nexport const CORD_SELF_SERVE_SLACK_CHANNEL_ID = 'C05GR4WSV5Z';\r\n\r\n// Tokens created for the sample token and demo apps environment types both\r\n// create groups with this id.  Both of them need to use the same groupID because\r\n// it is hardcoded into the demo apps client code, and while the demo apps mostly\r\n// use the demo apps environment apps, they sometimes use sample app tokens.\r\nexport const DEMO_APPS_APP_GROUP_ID = 'my-first-group';\r\n", "import type { Node } from 'slate';\r\nimport { Element } from 'slate';\r\nimport { v4 as uuid } from 'uuid';\r\nimport { MessageNodeType } from '@cord-sdk/types';\r\nimport type {\r\n  MessageAssigneeNode,\r\n  MessageContent,\r\n  MessageMentionNode,\r\n  MessageNode,\r\n  MessageNodeWithChildren,\r\n  MessageStyledBlockType,\r\n  MessageTextNode,\r\n  MessageTodoNode,\r\n  UUID,\r\n} from '@cord-sdk/types';\r\nimport { trimStart, trimEnd } from './trim.js';\r\n\r\nexport const MAX_BULLET_INDENT = 4;\r\n\r\n// '& Node' in return value stops Slate complaining when passing node to its methods\r\n// Casting to any is because TS doesn't seem to like combining the two to make the node\r\nexport function createMessageNode<\r\n  NodeType extends MessageNodeType,\r\n  NodeAttributes extends MessageNode<NodeType> = MessageNode<NodeType>,\r\n>(\r\n  nodeType: NodeType,\r\n  nodeAttributes: Omit<NodeAttributes, 'type'>,\r\n): MessageNode<NodeType> & Node {\r\n  return {\r\n    type: nodeType,\r\n    ...nodeAttributes,\r\n  } as any;\r\n}\r\n\r\nexport function createMessageTextNode(text: string): MessageTextNode {\r\n  return {\r\n    text,\r\n  };\r\n}\r\n\r\nexport function createFormattedMessageTextNode(input: {\r\n  text: string;\r\n  bold?: boolean;\r\n  italic?: boolean;\r\n  underline?: boolean;\r\n  code?: boolean;\r\n}): MessageTextNode {\r\n  return input;\r\n}\r\n\r\nexport function isMessageNodeType<NodeType extends MessageNodeType>(\r\n  node: Node | undefined,\r\n  nodeType: NodeType,\r\n): node is MessageNode<NodeType> {\r\n  return Boolean(node && Element.isElement(node) && node.type === nodeType);\r\n}\r\n\r\nexport function isMessageNodeText(node: MessageNode): node is MessageTextNode {\r\n  return !node.type && 'text' in node;\r\n}\r\n\r\nexport function createParagraphNode(text = '') {\r\n  return createMessageNode(MessageNodeType.PARAGRAPH, {\r\n    children: [{ text }],\r\n  });\r\n}\r\n\r\nexport function createMentionNode(userID: UUID, name: string) {\r\n  return createMessageNode(MessageNodeType.MENTION, {\r\n    user: { id: userID },\r\n    children: [{ text: `@${name}` }],\r\n  });\r\n}\r\n\r\nexport function createAssigneeNode(userID: UUID, name: string) {\r\n  return createMessageNode(MessageNodeType.ASSIGNEE, {\r\n    user: { id: userID },\r\n    children: [{ text: `+${name}` }],\r\n  });\r\n}\r\n\r\nexport function createLinkNode(url: string, text: string) {\r\n  return createMessageNode(MessageNodeType.LINK, {\r\n    url,\r\n    children: [{ text }],\r\n  });\r\n}\r\n\r\nexport function messageContentFromString(text: string): MessageContent {\r\n  return [createParagraphNode(text)];\r\n}\r\n\r\nfunction getInitialStyledBlockProps(\r\n  blockType: MessageStyledBlockType,\r\n  indent?: number,\r\n) {\r\n  if (blockType === MessageNodeType.TODO) {\r\n    return {\r\n      done: false,\r\n      todoID: uuid(),\r\n    };\r\n  } else if (\r\n    blockType === MessageNodeType.BULLET ||\r\n    blockType === MessageNodeType.NUMBER_BULLET\r\n  ) {\r\n    return {\r\n      indent,\r\n    };\r\n  } else {\r\n    return {};\r\n  }\r\n}\r\n\r\nexport function createStyledBlockNode(\r\n  blockType: MessageStyledBlockType,\r\n  text: string,\r\n  indent?: number,\r\n) {\r\n  return createMessageNode(blockType, {\r\n    children: messageContentFromString(text),\r\n    ...getInitialStyledBlockProps(blockType, indent),\r\n  });\r\n}\r\n\r\nconst findTodoNodesInSubtree = (\r\n  parent: MessageNode,\r\n  accumulator: MessageTodoNode[],\r\n): void => {\r\n  if (parent.type === MessageNodeType.TODO) {\r\n    accumulator.push(parent);\r\n  } else {\r\n    const children = getMessageNodeChildren(parent);\r\n    if (children) {\r\n      for (const node of children) {\r\n        findTodoNodesInSubtree(node, accumulator);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\nexport const todoNodesFromMessage = (messageContent: MessageContent) => {\r\n  const accumulator: MessageTodoNode[] = [];\r\n\r\n  for (const node of messageContent) {\r\n    findTodoNodesInSubtree(node, accumulator);\r\n  }\r\n\r\n  return accumulator;\r\n};\r\n\r\nexport function getMessageNodeChildren(node: MessageNode) {\r\n  return (node as MessageNodeWithChildren).children;\r\n}\r\n\r\nexport const textFromNodeRecursive = (node: MessageNode): string => {\r\n  let textArr: Array<string> = [];\r\n\r\n  if (isMessageNodeText(node)) {\r\n    return node.text;\r\n  }\r\n\r\n  const children = getMessageNodeChildren(node);\r\n  if (children) {\r\n    textArr = textArr.concat(\r\n      children.map((child) => textFromNodeRecursive(child)),\r\n    );\r\n  }\r\n\r\n  const result = textArr.join('');\r\n\r\n  return result;\r\n};\r\n\r\nexport function convertStructuredMessageToText(\r\n  messageContent: MessageContent,\r\n): string {\r\n  return messageContent\r\n    .map((node) => textFromNodeRecursive(node))\r\n    .join('\\n')\r\n    .trim();\r\n}\r\n\r\n// converts a list of MessageNode into text.\r\n// any whitespace or assignees at the start/end are removed.\r\nfunction taskTitleFromMessageNodes(\r\n  nodes: (MessageTextNode | MessageAssigneeNode | MessageMentionNode)[],\r\n): string {\r\n  let pending = '';\r\n  let text = '';\r\n\r\n  for (const node of nodes) {\r\n    if (node.type === MessageNodeType.ASSIGNEE) {\r\n      if (text.trim() === '') {\r\n        // no text was seen so far, so this is an assignee at the start of a\r\n        // message. We want to skip those.\r\n        continue;\r\n      }\r\n      // okay, we have seen some text already, but this assignee might be at\r\n      // the very end of the message. Hence let the assignee wait in the\r\n      // pending until we find non-empty text (which would mean the assignee is\r\n      // not at the end of the message)\r\n      pending += trimStart(textFromNodeRecursive(node), '+');\r\n      continue;\r\n    }\r\n\r\n    let newText = '';\r\n    if (isMessageNodeText(node)) {\r\n      newText = node.text;\r\n    } else if (node.type === MessageNodeType.MENTION) {\r\n      newText = trimStart(textFromNodeRecursive(node), '@');\r\n    }\r\n\r\n    const isEmpty = newText.trim() === '';\r\n    if (isEmpty) {\r\n      // this might be either trailing whitespace or whitespace in the middle\r\n      // of the message. For now, let's have it in pending until something\r\n      // non-empty arrives\r\n      pending += newText;\r\n    } else {\r\n      // we found some non-empty text so whatever was waiting in the pending\r\n      // can now finally become part of text\r\n      text += pending + newText;\r\n      pending = '';\r\n    }\r\n  }\r\n\r\n  return trimEnd(text.trim(), ':').trim();\r\n}\r\n\r\n// converts each MessageNode into text, returns the first non-empty one.\r\nexport function taskTitleFromMessageContent(\r\n  messageContent: MessageContent,\r\n): string {\r\n  for (let i = 0; i < messageContent.length; i++) {\r\n    const nodes: (\r\n      | MessageTextNode\r\n      | MessageAssigneeNode\r\n      | MessageMentionNode\r\n    )[] = [];\r\n    flattenMessage(messageContent[i], nodes);\r\n\r\n    const title = taskTitleFromMessageNodes(nodes);\r\n    if (title.length > 0) {\r\n      return title;\r\n    }\r\n  }\r\n\r\n  return 'Task created using Cord';\r\n}\r\n\r\nfunction flattenMessage(\r\n  node: MessageNode,\r\n  accumulator: (MessageTextNode | MessageAssigneeNode | MessageMentionNode)[],\r\n) {\r\n  if (\r\n    isMessageNodeText(node) ||\r\n    node.type === MessageNodeType.ASSIGNEE ||\r\n    node.type === MessageNodeType.MENTION\r\n  ) {\r\n    accumulator.push(node);\r\n    return;\r\n  }\r\n  const children = getMessageNodeChildren(node);\r\n  if (!children) {\r\n    return;\r\n  }\r\n\r\n  for (const child of children) {\r\n    flattenMessage(child, accumulator);\r\n  }\r\n}\r\n\r\n// message.content is null if message is deleted\r\nexport const findMessageNode = (\r\n  arr: MessageContent | null,\r\n  nodeType: MessageNodeType,\r\n): any => {\r\n  if (!arr) {\r\n    return null;\r\n  }\r\n  for (const item of arr) {\r\n    if (item.type === nodeType) {\r\n      return item;\r\n    }\r\n    if ('children' in item) {\r\n      const p = findMessageNode(item.children, nodeType);\r\n      if (p) {\r\n        return p;\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n};\r\n", "export type DatabaseConfig = {\r\n  database?: string;\r\n  host?: string;\r\n  password?: string;\r\n  port?: number;\r\n  user?: string;\r\n};\r\n\r\nexport function getReadReplicaDbConfigFromEnv(\r\n  env: Record<string, string | undefined>,\r\n): DatabaseConfig {\r\n  return {\r\n    host: env.POSTGRES_READ_HOST ?? env.POSTGRES_HOST,\r\n    port: Number(env.POSTGRES_READ_PORT ?? env.POSTGRES_PORT),\r\n    database: env.POSTGRES_DB,\r\n    user: env.POSTGRES_USER,\r\n    password: env.POSTGRES_PASSWORD,\r\n  };\r\n}\r\n"],
  "mappings": "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",
  "names": ["jsonStableStringify"]
}
