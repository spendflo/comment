{
  "version": 3,
  "sources": ["scripts/application-usage-metrics.ts", "server/src/metrics/applicationUsageMetrics.ts", "common/util/index.ts", "common/types/index.ts", "common/const/Urls.ts", "common/const/Ids.ts", "opensource/sdk-js/packages/react/common/lib/messageNode.ts", "server/src/util/readReplicaDatabase.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\n\n/**\n * This script calculates an application usage metrics for the given\n * application. It does not read the data from the application_usage_metrics\n * table, but instead performs the calculation. The calculated values are not\n * persisted, but only printed out on the terminal.\n *\n * The purpose of the script is to test metrics queries.\n */\n\nimport 'dotenv/config.js';\nimport Pg from 'pg';\nimport yargs from 'yargs';\n\nimport {\n  applicationUsageMetricTypes,\n  applicationUsageMetricsQueries,\n  isApplicationUsageMetricType,\n} from 'server/src/metrics/applicationUsageMetrics.ts';\nimport { assertUUID } from 'common/util/index.ts';\nimport { getReadReplicaDbConfigFromEnv } from 'server/src/util/readReplicaDatabase.ts';\n\nconst argv = yargs(process.argv.slice(2))\n  .option('appID', {\n    type: 'string',\n    demandOption: true,\n    description: 'id of application for which metrics will be calculated',\n  })\n  .option('metric', {\n    type: 'string',\n    demandOption: true,\n    description: 'name of metric to calculate',\n    choices: applicationUsageMetricTypes,\n  })\n  .option('days', {\n    type: 'number',\n    default: 30,\n    description: 'number of days',\n  })\n  .strict()\n  .help()\n  .alias('help', 'h').argv;\n\nconst { appID, metric, days } = argv;\n\nasync function main() {\n  if (!isApplicationUsageMetricType(metric)) {\n    throw new Error(`Unknown metric: ${metric}`);\n  }\n  assertUUID(appID);\n  if (typeof days !== 'number' || days <= 0) {\n    throw new Error(`Invalid value for --days: ${days}`);\n  }\n\n  const config = getReadReplicaDbConfigFromEnv(process.env);\n  const pg = new Pg.Client(config);\n  await pg.connect();\n  await pg.query('SET search_path=cord,public;');\n\n  const metricQueries = applicationUsageMetricsQueries();\n  const mq = metricQueries[metric];\n  const query = mq.query;\n  const bind = mq.bind ? [...mq.bind] : [];\n\n  // We are adding two more placeholders: the values of `days` and `appID`. (The\n  // placeholder to be used for `days` is `$1` if after adding `days` to the\n  // array the array length is 1, and so forth. And then the same for\n  // `appID`.)\n  bind.push(days);\n  const daysPlaceholder = `$${bind.length}`;\n  bind.push(appID);\n  const appIDPlaceholder = `$${bind.length}`;\n\n  // We are wrapping the query here, in order to restrict the query to the\n  // requested number of days, but also to make sure to list all of the last\n  // `days` days, not just the ones returned by the given query. (If days are\n  // missing in the given query, we will print those out as `null` - the actual\n  // async job that persist the data will treat them as zero values.) We also\n  // check the creation date of the given application, and won't output any days\n  // before creation.\n  const wrappedQuery = `\\\n  WITH q AS (${query.trim()})\n  SELECT\n    d.date::text AS \"date\",\n    q.value::integer AS \"value\"\n  FROM applications a\n  CROSS JOIN (\n    SELECT CURRENT_DATE-generate_series(1,${daysPlaceholder}) AS \"date\"\n  ) d\n  LEFT OUTER JOIN q ON (q.\"applicationID\", q.\"date\")=(a.\"id\", d.\"date\")\n  WHERE a.id = ${appIDPlaceholder}\n  AND d.\"date\" >= a.\"createdTimestamp\"::date\n  ORDER BY d.\"date\";`;\n\n  const startTime = performance.now();\n  const { rows } = await pg.query<{ date: string; value: number | null }>(\n    wrappedQuery,\n    bind,\n  );\n  const endTime = performance.now();\n\n  console.log(`Query time: ${endTime - startTime}ms`);\n  for (const { date, value } of rows) {\n    console.log(`${date} : ${value ?? 'null (meaning 0)'}`);\n  }\n}\n\nmain().then(\n  () => process.exit(0),\n  (err) => {\n    console.error(err);\n    process.exit(1);\n  },\n);\n", "/**\n * Names of all application usage metric types in use\n */\nexport const applicationUsageMetricTypes = [\n  'number_of_messages',\n  'users_sent_message',\n  'users_sent_message_7d',\n  'users_sent_message_28d',\n  'users_activated',\n  'users_activated_7d',\n  'users_activated_28d',\n  'users_exposed_to_cord',\n  'users_exposed_to_cord_7d',\n  'users_exposed_to_cord_28d',\n] as const;\n\nexport type ApplicationUsageMetricType =\n  (typeof applicationUsageMetricTypes)[number];\n\nexport function isApplicationUsageMetricType(\n  x: any,\n): x is ApplicationUsageMetricType {\n  return (\n    typeof x === 'string' && applicationUsageMetricTypes.includes(x as any)\n  );\n}\n\ninterface MetricQuery {\n  query: string;\n  bind?: any[];\n}\n\nexport const applicationUsageMetricsQueries = (): Record<\n  ApplicationUsageMetricType,\n  MetricQuery\n> => ({\n  number_of_messages: {\n    // Group all messages by application ID (via their orgID) and the date part\n    // of the timestamp and count the number of messages with each appID/date\n    // combination. That simply gives us the number of messages written per day\n    // in an application.\n    query: `\n        SELECT\n            o.\"platformApplicationID\" AS \"applicationID\",\n            metrics_day(m.timestamp) AS \"date\",\n            COUNT(m) AS \"value\"\n        FROM messages m\n        INNER JOIN orgs o ON m.\"orgID\"=o.id\n        WHERE o.\"platformApplicationID\" IS NOT NULL\n        GROUP BY 1, 2`,\n  },\n  users_sent_message: usersSentMessage(1),\n  users_sent_message_7d: usersSentMessage(7),\n  users_sent_message_28d: usersSentMessage(28),\n  users_activated: usersActivated(1),\n  users_activated_7d: usersActivated(7),\n  users_activated_28d: usersActivated(28),\n  users_exposed_to_cord: usersExposedToCord(1),\n  users_exposed_to_cord_7d: usersExposedToCord(7),\n  users_exposed_to_cord_28d: usersExposedToCord(28),\n});\n\nfunction usersSentMessage(windowDays: number): MetricQuery {\n  // Calculate the number of users who authored messages over a window of N\n  // (`windowDays`) days. This means, if N=1, it calculates the number of\n  // message sending users for the day of `date` itself. For N=7, the value\n  // corresponds to the number of unique active users on the day of `date` and\n  // the six days before.\n  //\n  // This is how the query works: first we construct a matrix of all messages\n  // and the numbers from 0 to N-1, and we call these numbers \"shift\". (So each\n  // message is represented N times in the matrix, with a shift value of 0 to\n  // N-1.) Then we add \"shift\" days to the message timestamp (we only take date\n  // portion of the timestamp). So we now have N rows for each message, the\n  // first having the date set to the day the message was written, and then\n  // additional rows with the date set to the following N-1 days.\n  //\n  // Now we group these messages by their application ID (via the orgs table),\n  // and their shifted dates. And for each appID/date combination we count the\n  // number of unique message authors. Done.\n  //\n  // What we then have, is for any given appID/date combination, the number of\n  // unique message authors of messages written on the given date, or the N-1\n  // days before (because those messages all get the shift to the given date).\n  return {\n    query: `\n      SELECT\n        o.\"platformApplicationID\" AS \"applicationID\",\n        metrics_day(m.timestamp) + s.shift AS \"date\",\n        COUNT(DISTINCT m.\"sourceID\") AS \"value\"\n      FROM (SELECT generate_series(0, $1-1) AS shift) s\n      CROSS JOIN messages m\n      INNER JOIN orgs o ON m.\"orgID\"=o.id\n      WHERE o.\"platformApplicationID\" IS NOT NULL\n      GROUP BY 1, 2`,\n    bind: [windowDays],\n  };\n}\n\nfunction usersActivated(windowDays: number): MetricQuery {\n  // Calculate the \"activated users\" metric.\n  //\n  // First, collect all actions that happened in threads. That's messages\n  // written or reactions made. The `thread_actions` subquery returns rows of\n  // thread ids, user/org ids and dates of when things happened.\n  //\n  // Next, collect when a user was first active in a thread. Just by grouping\n  // the previous results by thread/user/org and taking the earliest (minimum)\n  // date.\n  //\n  // Then, calculate when we consider that a thread has become active. That's\n  // when not the first but the second user did something in the thread. This is\n  // not about a precise time, but just the day it happened. We are calculating\n  // daily time series anyway, and also this means that when two users start and\n  // comment on a thread the same day, they both count as activated, because\n  // they both did something in a thread that is considered active on that day.\n  // Just to clarify: once a thread has become active, it stays active. Meaning\n  // that if on a later day a user writes/reacts in that thread, that user will\n  // be considered activated, because they interacted with the thread in which\n  // they are not alone. Even if nobody else was active in that thread on the\n  // same day. On the other hand, when one user starts a thread and a second\n  // user reacts or comments the next day, then the first user wasn't activated,\n  // but the second was when they commented.\n  //\n  // Finally, we count the number of unique users in an application that were\n  // activated on a given day, by collecting all the users that did something on\n  // that day in a thread that had been active on the day or previously.\n  //\n  // For getting weekly/monthly number we do the same shifting as in the\n  // `usersSentMessage` query above. So, say for the weekly metric, when a user\n  // does a thing in a thread, we now act as if they did that thing on the day\n  // they did it, and then they did it six more times on the following days. So,\n  // if A starts a new thread on day 1, and B reacts on day 3, then A and B are\n  // both activated on day 3. Also on day 4, 5, 6, 7. On day 8, 9, we only count\n  // B as activated, because only B has been active within the time window of\n  // one week.\n  return {\n    query: `\n      WITH thread_actions AS NOT MATERIALIZED (\n        SELECT DISTINCT\n          \"threadID\",\n          \"sourceID\" AS \"userID\",\n          \"orgID\",\n          metrics_day(timestamp) AS \"day\"\n        FROM messages\n        UNION\n        SELECT m.\"threadID\", mr.\"userID\", m.\"orgID\", metrics_day(mr.timestamp)\n        FROM message_reactions mr INNER JOIN messages m ON mr.\"messageID\"=m.id\n      ), thread_user_first_action AS NOT MATERIALIZED (\n        SELECT\n          \"threadID\", \"userID\", \"orgID\",\n          min(\"day\") AS \"day\"\n        FROM thread_actions GROUP BY 1, 2, 3\n      ), thread_becomes_active AS (\n        SELECT DISTINCT\n          \"threadID\",\n          nth_value(day, 2) OVER w AS day\n        FROM thread_user_first_action\n        WINDOW w AS (PARTITION BY \"threadID\" ORDER BY day ASC)\n      )\n      SELECT\n        o.\"platformApplicationID\" AS \"applicationID\",\n        ta.day + s.shift AS \"date\",\n        COUNT(DISTINCT ta.\"userID\") AS \"value\"\n      FROM (SELECT generate_series(0, $1-1) AS shift) s\n      CROSS JOIN thread_actions ta\n      INNER JOIN orgs o ON ta.\"orgID\"=o.id\n      INNER JOIN thread_becomes_active tba USING(\"threadID\")\n      WHERE o.\"platformApplicationID\" IS NOT NULL\n      AND ta.day >= tba.day\n      GROUP BY 1, 2`,\n    bind: [windowDays],\n  };\n}\n\nfunction usersExposedToCord(windowDays: number): MetricQuery {\n  // Calculate the number of unique users who have been exposed to ANY Cord component.\n  // The weekly and monthly numbers are calculated using the same shifting logic seen in\n  // `usersSentMessage`. If a user is exposed to a Cord component on one day then we also count\n  // it as them being exposed to it every day following that day depending on the time window we have chosen.\n  return {\n    query: `\n      SELECT\n        e.\"platformApplicationID\" AS \"applicationID\",\n        metrics_day(e.\"serverTimestamp\") + s.shift AS \"date\",\n        COUNT(DISTINCT e.\"userID\") AS \"value\"\n      FROM (SELECT generate_series(0, $1-1) AS shift) s\n      CROSS JOIN events e\n      WHERE e.\"platformApplicationID\" IS NOT NULL\n      AND e.type = 'sdk-components-used'\n      GROUP BY 1,2`,\n    bind: [windowDays],\n  };\n}\n", "import md5 from 'blueimp-md5';\nimport jsonStableStringify from 'fast-json-stable-stringify';\nimport { unique } from 'radash';\nimport shajs from 'sha.js';\nimport dayjs from 'dayjs';\nimport Calendar from 'dayjs/plugin/calendar.js';\nimport isBetween from 'dayjs/plugin/isBetween.js';\n\nimport type {\n  UUID,\n  MessageContent,\n  ReferencedUserData,\n} from 'common/types/index.ts';\nimport { MessageNodeType } from 'common/types/index.ts';\nimport {\n  CORD_PLATFORM_ORG_ID,\n  CORD_ADMIN_PLATFORM_ORG_ID,\n  GILLIAN_TEST_SLACK_ORG_ID,\n  RADICAL_ORG_ID,\n  RADICAL_TEST_ORG_ID,\n  KAT_TEST_SLACK_ORG_ID,\n  CORD_SLACK_TEAM_ID,\n  CORD_TEST_SLACK_TEAM_ID,\n} from 'common/const/Ids.ts';\nimport {\n  getMessageNodeChildren,\n  textFromNodeRecursive,\n} from '@cord-sdk/react/common/lib/messageNode.ts';\nimport { trimStart } from '@cord-sdk/react/common/lib/trim.ts';\n\nconst uuidRegex =\n  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;\n\nexport const isEmployee = (orgID: UUID | undefined) =>\n  orgID === RADICAL_ORG_ID ||\n  orgID === RADICAL_TEST_ORG_ID ||\n  orgID === CORD_PLATFORM_ORG_ID ||\n  orgID === GILLIAN_TEST_SLACK_ORG_ID ||\n  orgID === KAT_TEST_SLACK_ORG_ID ||\n  orgID === CORD_ADMIN_PLATFORM_ORG_ID ||\n  process.env.NODE_ENV === 'development';\n\nexport const isInternalSlackOrg = (slackTeamID: string | undefined) =>\n  slackTeamID === CORD_SLACK_TEAM_ID || slackTeamID === CORD_TEST_SLACK_TEAM_ID;\n\nexport const assertUUID = (value: string): UUID => {\n  if (!uuidRegex.test(value)) {\n    throw new Error(`Invalid UUID ${value}`);\n  } else {\n    return value;\n  }\n};\n\n/**\n * @deprecated MD5 is no longer secure, use sha256Hash instead.\n */\nexport function md5Hash(object: boolean | number | string | object) {\n  return md5(jsonStableStringify(object));\n}\n\nexport function sha256Hash(value: string) {\n  return shajs('sha256').update(value).digest('hex');\n}\nexport const SHA256_HASH_LENGTH = 64;\n\nexport function generateSalt() {\n  const buf = new Uint8Array(8);\n  crypto.getRandomValues(buf);\n  return Array.from(buf)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\nexport function sha256HashAndSalt(\n  value: string,\n  salt: string = generateSalt(),\n) {\n  return 'sha256' + ':' + salt + ':' + sha256Hash(salt + ':' + value);\n}\n\nexport function prepareTextContent(textContent: string) {\n  return (\n    textContent\n      .trim()\n      .toLowerCase()\n      // Remove Zero Width No-Break Space (U+FEFF)\n      .replace(/[\\uFEFF\\n]/gm, '')\n  );\n}\n\nexport function doesTextQualify(text: string | undefined | null) {\n  return Boolean(text && text.length > 1 && text.trim());\n}\n\nexport function getSha256Salt(hash: string): string {\n  return hash?.split(':')[1] ?? '';\n}\n\nexport function matchesHash(value: string, hashWithSalt: string) {\n  return hashWithSalt === sha256HashAndSalt(value, getSha256Salt(hashWithSalt));\n}\n\nexport function isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nexport function getMentionedUserIDs(content: MessageContent): UUID[] {\n  let users: UUID[] = [];\n  for (const node of content) {\n    if (node.type === MessageNodeType.MENTION) {\n      users.push(node.user.id);\n    } else {\n      const children = getMessageNodeChildren(node);\n      if (children) {\n        users = [...users, ...getMentionedUserIDs(children)];\n      }\n    }\n  }\n\n  return unique(users);\n}\n\nexport function getReferencedUserIDs(content: MessageContent): UUID[] {\n  const accumulator = new Set<UUID>();\n  gatherReferencedUserIDs(content, accumulator);\n  return [...accumulator];\n}\n\nfunction gatherReferencedUserIDs(\n  nodes: MessageContent,\n  accumulator: Set<UUID>,\n) {\n  for (const node of nodes) {\n    if (\n      node.type === MessageNodeType.MENTION ||\n      node.type === MessageNodeType.ASSIGNEE\n    ) {\n      accumulator.add(node.user.id);\n      continue;\n    }\n    const children = getMessageNodeChildren(node);\n    if (children) {\n      gatherReferencedUserIDs(children, accumulator);\n    }\n  }\n}\n\nexport function getReferencedUserIDsAndNames(\n  content: MessageContent,\n): ReferencedUserData[] {\n  const accumulator = new Map<UUID, string>();\n  gatherReferencedUserIDsAndName(content, accumulator);\n  return [...accumulator].map(([id, name]) => ({ id, name }));\n}\n\nfunction gatherReferencedUserIDsAndName(\n  nodes: MessageContent,\n  accumulator: Map<UUID, string>,\n) {\n  for (const node of nodes) {\n    if (\n      node.type === MessageNodeType.MENTION ||\n      node.type === MessageNodeType.ASSIGNEE\n    ) {\n      const userID = node.user.id;\n      const name = trimStart(textFromNodeRecursive(node), '@');\n      accumulator.set(userID, name);\n      continue;\n    }\n    const children = getMessageNodeChildren(node);\n    if (children) {\n      gatherReferencedUserIDsAndName(children, accumulator);\n    }\n  }\n}\n\n// JS replaceAll not well supported yet: https://caniuse.com/?search=replaceAll\nexport function replaceAll(str: string, replace: string, replaceWith: string) {\n  return str.split(replace).join(replaceWith);\n}\n\nexport type UserWithNames = {\n  displayName: string;\n  fullName: string;\n};\n\nexport type DisplayableUser = UserWithNames & {\n  id: UUID;\n  profilePictureURL: string | null;\n};\n\nexport function assert(predicate: boolean, message: string): asserts predicate {\n  if (!predicate) {\n    throw new Error(message);\n  }\n}\n\n/**\n * Returns the supplied items using the specified combiner.\n *\n * @example\n * // Returns \"foo, bar, or baz\"\n * combine(\"or\", [\"foo\", \"bar\", \"baz\"])\n */\nexport function combine(combiner: string, items: string[]): string {\n  if (items.length === 0) {\n    return '';\n  } else if (items.length === 1) {\n    return items[0];\n  } else if (items.length === 2) {\n    return `${items[0]} ${combiner} ${items[1]}`;\n  } else {\n    return `${items.slice(0, -1).join(', ')}, ${combiner} ${\n      items[items.length - 1]\n    }`;\n  }\n}\n\nexport const CORD_DEEP_LINK_THREAD_QUERY_PARAM = 'cord_thread';\nexport const CORD_DEEP_LINK_MESSAGE_QUERY_PARAM = 'cord_message';\nexport const CORD_DEEP_LINK_QUERY_PARAM = 'cord_link';\n\nexport const CORD_ARGS_TO_REMOVE = [\n  // delete deeplinking query params from urls. We dont want them as part of\n  // the pageContext\n\n  // old deeplinking query params. Keep here to support old deeplinks.\n  CORD_DEEP_LINK_THREAD_QUERY_PARAM,\n  CORD_DEEP_LINK_MESSAGE_QUERY_PARAM,\n\n  // new (unified) deeplinking query param\n  CORD_DEEP_LINK_QUERY_PARAM,\n];\n\nexport function extractDeepLinkQueryParams(\n  url: string,\n): { threadID: UUID; messageID: UUID } | null {\n  try {\n    const parsed = new URL(url);\n    return extractDeepLinkQueryParamsV1(parsed);\n  } catch (e) {\n    return null;\n  }\n}\n\n// also see injectDeeplinkQueryParamsV1()\nfunction extractDeepLinkQueryParamsV1(\n  url: URL,\n): { threadID: UUID; messageID: UUID } | null {\n  const [version, threadID, messageID]: (string | undefined)[] = (\n    url.searchParams.get(CORD_DEEP_LINK_QUERY_PARAM) ?? ''\n  ).split('_');\n\n  if (version !== 'v1' || !threadID || !messageID) {\n    return null;\n  }\n\n  return {\n    threadID,\n    messageID,\n  };\n}\n\ndayjs.extend(Calendar);\ndayjs.extend(isBetween);\n\nfunction getNowTimestamp() {\n  return dayjs(new Date(Date.now()));\n}\n\nexport function isTimestampTodayOrInTheFuture(timestamp: string) {\n  const now = getNowTimestamp();\n  return (\n    dayjs(timestamp).isSame(dayjs(now), 'day') ||\n    dayjs(timestamp).isAfter(dayjs(now), 'day')\n  );\n}\n\nexport function isTimestampFromPastSevenDays(timestamp: string) {\n  const now = getNowTimestamp();\n  const sevenDaysBefore = now.subtract(7, 'day');\n\n  return (\n    dayjs(timestamp).isBetween(now, sevenDaysBefore, 'day') ||\n    dayjs(timestamp).isSame(sevenDaysBefore, 'date')\n  );\n}\n\nexport function isTimestampFromPastThirtyDays(timestamp: string) {\n  const now = getNowTimestamp();\n  const thirtyDaysBefore = now.subtract(30, 'day');\n\n  return (\n    dayjs(timestamp).isBetween(now, thirtyDaysBefore) ||\n    dayjs(timestamp).isSame(thirtyDaysBefore, 'date')\n  );\n}\n\nexport function isTimestampFromPastThreeMonths(timestamp: string) {\n  const now = getNowTimestamp();\n  const threeMonthsBefore = now.subtract(3, 'month');\n  return (\n    dayjs(timestamp).isBetween(now, threeMonthsBefore) ||\n    dayjs(timestamp).isSame(threeMonthsBefore, 'day')\n  );\n}\n\nexport function isTimestampFromPastYear(timestamp: string) {\n  const now = getNowTimestamp();\n  const pastYear = now.subtract(1, 'year');\n  return (\n    dayjs(timestamp).isBetween(now, pastYear) ||\n    dayjs(timestamp).isSame(pastYear, 'day')\n  );\n}\n\nexport function isTimestampMoreThanAYearAgo(timestamp: string) {\n  const now = getNowTimestamp();\n  const pastYear = now.subtract(1, 'year');\n  return dayjs(timestamp).isBefore(pastYear, 'day');\n}\n\nexport function createDefaultSenderEmailName(applicationName: string) {\n  return applicationName.toLowerCase().split(/\\W/).join('') + '-notifications';\n}\n\n/**\n * in both the console UI and the API we don't allow editing the whole sender\n * field on customEmailTemplate, but only specific parts of it. This function\n * takes a 'sender' input and returns parts of the email.\n *\n * @example\n * const input = 'Cord <hello@cord.com>';\n * getEmailInfoFromSenderData(input); // {emailAddress: \"hello@cord.com\", domain: \"cord.com\", username: \"hello\" }\n */\ntype SenderInfo = {\n  domain: string;\n  emailAddress: string;\n  username: string;\n};\nexport function getEmailInfoFromSenderData(\n  sender?: string,\n): SenderInfo | undefined {\n  if (!sender) {\n    return undefined;\n  }\n\n  const mentionMatchingPattern = new RegExp(\n    '(<)' + // first match a \"<\"\n      '([^@]+)' + // then match anything that's not an @ symbol and is at least 1 char\n      '(@)' + // then match the @ so we can just access the domain itself easily\n      '([^>]+)', // then match anything that's not an > symbol and is at least 1 char\n    'gm',\n  );\n\n  let info: SenderInfo | undefined = undefined;\n  let match: RegExpExecArray | null;\n\n  while ((match = mentionMatchingPattern.exec(sender))) {\n    info = {\n      username: match[2],\n      domain: match[4],\n      emailAddress: match[0].substring(1),\n    };\n  }\n\n  return info;\n}\n\nexport function capitalizeFirstLetter(string: string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n", "// See #8935:\n/// <reference lib=\"es2022\" />\n\nimport type OpenAI from 'openai';\n\nimport jsonStableStringify from 'fast-json-stable-stringify';\nimport type { Placement } from '@floating-ui/react-dom';\nimport { isEqual } from '@cord-sdk/react/common/lib/fast-deep-equal.ts';\n\nexport type {\n  DocumentAnnotationResult,\n  Screenshot,\n  DocumentLocation,\n  LocationTextConfig,\n  HighlightedTextConfig,\n  AdditionalTargetData,\n  Annotation,\n  AnnotationWithThreadID,\n  AnnotationCapturePosition,\n} from '@cord-sdk/types';\nexport { locationJson } from '@cord-sdk/types';\nimport { locationJson, MessageNodeType } from '@cord-sdk/types';\nimport type {\n  FlatJsonObject,\n  LocationFilterOptions,\n  ResolvedStatus,\n  MessageAnnotation,\n  ElementIdentifierVersion,\n  EntityMetadata,\n  NotificationListFilter,\n  ThreadListFilter,\n  JsonValue,\n  JsonObject,\n  MessageContent,\n  MessageNode,\n  ViewerThreadStatus,\n} from '@cord-sdk/types';\n\nexport type {\n  MessageAnnotation,\n  ElementIdentifierVersion,\n  EntityMetadata,\n  NotificationListFilter,\n  ThreadListFilter,\n  JsonValue,\n  JsonObject,\n};\n\nexport type SimpleTranslationParameters = FlatJsonObject;\n\nexport enum DataTableQueries {\n  ADMIN_USERS = 'admin_users',\n  SET_ADMIN = 'set_admin',\n  USER_DETAILS = 'user_details',\n  ORG_DETAILS = 'org_details',\n  APP_DETAILS = 'app_details',\n  THREAD_DETAILS = 'thread_details',\n  MESSAGE_DETAILS = 'message_details',\n  CUSTOMER_DETAILS = 'customer_details',\n  ORG_MEMBER_DETAILS = 'org_member_details',\n  ID_SEARCH = 'id_search',\n  PROD_APPLICATIONS = 'prod_applications',\n  STAGING_APPLICATIONS = 'staging_applications',\n  SAMPLE_APPLICATIONS = 'sample_applications',\n  VERIFIED_CUSTOMERS = 'verified_customers',\n  SAMPLE_CUSTOMERS = 'sample_customers',\n  DEPLOYS = 'deploys',\n  PAGE_CONTEXTS = 'page_contexts',\n  BROWSER_METRICS = 'browser_metrics',\n  OS_METRICS = 'os_metrics',\n  GO_REDIRECTS = 'go_redirects',\n}\n\nexport type NonNullableKeys<T, K extends keyof T> = T & {\n  [P in K]: NonNullable<T[P]>;\n};\n\nexport type NullableKeys<T, K extends keyof T> = Omit<T, K> & {\n  [P in K]: T[P] | null;\n};\n\nexport type ElementOf<T extends Array<any>> = T[number];\n\n/**\n * A mapping type that effectively combines Required<T> and NonNullable<T> to\n * turn { foo?: string | undefined } into { foo: string }\n */\n// NOTE(9/9/2021): This is equivalent to Required<T> if we compiled with\n// --strictNullChecks, but we currently don't\nexport type ReallyRequired<T> = {\n  [P in keyof T]-?: NonNullable<T[P]>;\n};\n\nexport type { MessageContent, MessageNode };\nexport { MessageNodeType };\n\nexport type UUID = string;\n\nexport type Location = {\n  [k: string]: string | number | boolean;\n};\n\nexport type SortDirection = 'ascending' | 'descending';\n\nexport function isValidFlatJsonObject(obj: any): obj is FlatJsonObject {\n  if (!obj) {\n    return false;\n  }\n  if (typeof obj !== 'object' || Array.isArray(obj)) {\n    return false;\n  }\n  for (const [_, value] of Object.entries(obj)) {\n    const t = typeof value;\n    if (t !== 'string' && t !== 'number' && t !== 'boolean') {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isLocation(obj: any): obj is Location {\n  return isValidFlatJsonObject(obj);\n}\n\nexport function isValidMetadata(obj: any): obj is EntityMetadata {\n  return isValidFlatJsonObject(obj);\n}\n\nexport function toLocation(obj: any): Location | null {\n  return isLocation(obj) ? obj : null;\n}\n\n// We receive location as either Location or LocationFilterOptions from\n// our apis. Since Location type can be flat object with multiple properties\n// we have to check the property type to make sure we're getting the right value.\n// eg: {value: 'foo', ...} is Location\n// while {value: {value: 'foo'} ...} is LocationFilterOptions\nexport function getLocationFilter(\n  obj: LocationFilterOptions | Location | undefined,\n): LocationFilterOptions | undefined {\n  if (!obj) {\n    return undefined;\n  }\n\n  if (isLocation(obj)) {\n    return { value: obj, partialMatch: false };\n  }\n\n  if (isLocation(obj.value)) {\n    return obj;\n  }\n  return undefined;\n}\n\n// Function to convert our external resolvedStatus filter enum\n// to our internal 'resolved' boolean property\nexport function getResolvedFromStatus(\n  status: ResolvedStatus,\n): boolean | undefined {\n  // we've not included a fallback value as this will just increase the chances\n  // of returning the wrong data somewhere. So we make sure to pass whatever\n  // we've said the default is for the API that's calling this.\n  switch (status) {\n    case 'resolved': {\n      return true;\n    }\n    case 'unresolved': {\n      return false;\n    }\n    case 'any': {\n      return undefined;\n    }\n    default: {\n      const unhandledStatus: never = status;\n      throw new Error('Invalid resolved status type ' + unhandledStatus);\n    }\n  }\n}\n\nexport function getViewerThreadFilter(\n  viewerStatus: ViewerThreadStatus | ViewerThreadStatus[] | undefined,\n): ViewerThreadStatus[] {\n  if (!viewerStatus) {\n    return [];\n  }\n  if (typeof viewerStatus === 'string') {\n    return [viewerStatus];\n  }\n  return viewerStatus;\n}\n\nexport function metadataMatches(\n  metadata: EntityMetadata,\n  matcher: EntityMetadata,\n): boolean {\n  for (const [key, value] of Object.entries(matcher)) {\n    if (metadata[key] !== value) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function locationMatches(context: Location, matcher: Location): boolean {\n  for (const [key, value] of Object.entries(matcher)) {\n    if (context[key] !== value) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction flatJsonObjectEqual(\n  a: FlatJsonObject | null,\n  b: FlatJsonObject | null,\n): boolean {\n  if (a === null && b === null) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const [key, value] of Object.entries(a)) {\n    if (b[key] !== value) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function locationEqual(a: Location | null, b: Location | null): boolean {\n  return flatJsonObjectEqual(a, b);\n}\n\nexport function metadataEqual(\n  a: EntityMetadata | null,\n  b: EntityMetadata | null,\n): boolean {\n  return flatJsonObjectEqual(a, b);\n}\n\n/**\n * Implements the canonical comparison for locations.  Currently, this sorts by\n * number of elements, then the JSON representation alphabetically, but we can\n * change that if we come up with something better.\n */\nexport function locationCompare(a: Location, b: Location): number {\n  const lengthA = Object.keys(a).length;\n  const lengthB = Object.keys(b).length;\n  if (lengthA !== lengthB) {\n    return lengthA - lengthB;\n  }\n  return locationJson(a).localeCompare(locationJson(b));\n}\n\nexport type PageContext = {\n  providerID: UUID | null;\n  data: Location;\n};\n\nexport function pageContextEqual(\n  a: PageContext | null,\n  b: PageContext | null,\n): boolean {\n  if (a === null && b === null) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  // Two contexts from different providers are never equal\n  if (a.providerID !== b.providerID) {\n    return false;\n  }\n  // If either has data, compare the data, otherwise compare the locations\n  return isEqual(a.data, b.data);\n}\n\n// This returns a string key that is equivalent from an equality perspective to\n// comparing the pageContexts.  Specifically, the intention is that\n// pageContextEqual(a, b) === (pageContextKey(a) === pageContextKey(b))\n\n// The functioning of this depends a lot on our specific logic of\n// building PageContexts, such that, for instance,\n// a.location === b.location => a.providerID === b.providerID.\n\n// It also needs to stay consistent with the logic in server/src/util/hash.ts.\nexport function pageContextKey(pageContext: PageContext): string {\n  return jsonStableStringify({\n    providerID: pageContext.providerID,\n    data: pageContext.data,\n  });\n}\n\n/**\n * Convert a PageContext-like object into an actual PageContext.\n *\n * The PageContext types that we exchange with GraphQL allow nullable fields to\n * be undefined as well. This function takes such objects and returns a valid\n * PageContext.\n */\ntype PageContextLike = {\n  providerID?: UUID | null;\n  data: Location;\n};\nexport function toPageContext(pageContext: PageContextLike): PageContext;\nexport function toPageContext(pageContext: null | undefined): null;\nexport function toPageContext(\n  pageContext: PageContextLike | null | undefined,\n): PageContext | null;\nexport function toPageContext(\n  pageContext: PageContextLike | null | undefined,\n): PageContext | null {\n  if (!pageContext) {\n    return null;\n  }\n  const { providerID, data } = pageContext;\n  if (!isLocation(data)) {\n    throw new Error('Invalid context');\n  }\n  return {\n    providerID: providerID ?? null,\n    data,\n  };\n}\n\nexport type OrgMemberState = 'active' | 'inactive' | 'deleted'; // must match the keys in OrgMemberStateEnumType\n\nexport type UserType = 'person' | 'bot'; // must match the keys in UserTypeEnumType\n\nexport type UserState = 'active' | 'deleted'; // must match the keys in UserStateEnumType\n\nexport type ImportedSlackMessageType = 'reply' | 'supportBotReply'; // must match the keys in ImportedSlackMessageTypeEnumType\n\nexport type MessageType = 'action_message' | 'user_message'; //must match the keys in MessageTypeEnumType\n\nexport interface Todo {\n  id: UUID;\n  done: boolean;\n}\n\nexport enum MessageAttachmentType {\n  FILE = 'file',\n  ANNOTATION = 'annotation',\n  SCREENSHOT = 'screenshot',\n}\n\nexport const MessageAnnotationAttachmentTypeName =\n  'MessageAnnotationAttachment';\n\nexport function parseElementIdentifierVersion(\n  val: string,\n): ElementIdentifierVersion | null {\n  if (val === '1' || val === '2') {\n    return val;\n  }\n  return null;\n}\n\nexport enum ElementIdentifierMatch {\n  EXACT = 'exact',\n  PARTIAL = 'partial',\n  NONE = 'none',\n}\n\nexport enum LocationMatch {\n  EXACT = 'exact',\n  SIBLING = 'sibling',\n  MULTIMEDIA = 'multimedia',\n  CHART = 'chart',\n  STALE = 'stale',\n  MAYBE_STALE = 'maybe_stale',\n  NONE = 'none',\n  // User has old extension, and does not have the latest identifier version\n  INCOMPATIBLE_IDENTIFIER_VERSION = 'incompatible_identifier_version',\n  // Used if fallback document coordinates are included, and we don't have an exact/sibling match\n  DOCUMENT_COORDINATES = 'document_coordinates',\n  // If we weren't able to annotate, so we're instead relying on the screenshot\n  // Examples: annotating a pdf, annotating an iframe we can't access\n  UNAVAILABLE = 'unavailable',\n  // If the annotation was on an inaccessible cross-domain iframe. We want to\n  // show it while the message is being drafted, but not after it's been posted\n  INACCESSIBLE_CROSS_DOMAIN_IFRAME = 'inaccessible_cross_domain_iframe',\n  OUTSIDE_ACCESSIBLE_VIRTUALISED_LIST = 'outside_accessible_virtualised_list',\n  OUTSIDE_INACCESSIBLE_VIRTUALISED_LIST = 'outside_inaccessible_virtualised_list',\n}\n\nexport function annotationHasLocation(annotation: MessageAnnotation) {\n  return annotation.location !== null || annotation.customLocation !== null;\n}\n\nexport const ThreadCreatedTypeName = 'ThreadCreated';\nexport const ThreadMessageAddedTypeName = 'ThreadMessageAdded';\nexport const ThreadMessageUpdatedTypeName = 'ThreadMessageUpdated';\nexport const ThreadMessageContentAppendedTypeName =\n  'ThreadMessageContentAppended';\nexport const ThreadMessageRemovedTypeName = 'ThreadMessageRemoved';\nexport const ThreadParticipantsUpdatedIncrementalTypeName =\n  'ThreadParticipantsUpdatedIncremental';\nexport const ThreadTypingUsersUpdatedTypeName = 'ThreadTypingUsersUpdated';\nexport const ThreadShareToSlackTypeName = 'ThreadShareToSlack';\nexport const ThreadPropertiesUpdatedTypeName = 'ThreadPropertiesUpdated';\nexport const ThreadSubscriberUpdatedTypeName = 'ThreadSubscriberUpdated';\nexport const ThreadDeletedTypeName = 'ThreadDeleted';\n\nexport const PageThreadAddedTypeName = 'PageThreadAdded';\nexport const PageThreadDeletedTypename = 'PageThreadDeleted';\nexport const PageThreadReplyAddedTypeName = 'PageThreadReplyAdded';\nexport const PageVisitorsUpdatedTypeName = 'PageVisitorsUpdated';\nexport const PageThreadResolvedTypeName = 'PageThreadResolved';\nexport const PageThreadUnresolvedTypeName = 'PageThreadUnresolved';\nexport const ThreadFilterablePropertiesMatchTypeName =\n  'ThreadFilterablePropertiesMatch';\nexport const ThreadFilterablePropertiesUnmatchTypeName =\n  'ThreadFilterablePropertiesUnmatch';\n\nexport const NotificationAddedTypeName = 'NotificationAdded';\nexport const NotificationReadStateUpdatedTypeName =\n  'NotificationReadStateUpdated';\nexport const NotificationDeletedTypeName = 'NotificationDeleted';\n\nexport const OrgMemberAddedTypeName = 'OrgMemberAdded';\nexport const OrgMemberRemovedTypeName = 'OrgMemberRemoved';\n\nexport const ConsoleGettingStartedUpdatedTypeName =\n  'ConsoleGettingStartedUpdated';\n\nexport const CustomerSubscriptionUpdatedTypeName =\n  'CustomerSubscriptionUpdated';\n\nexport type FileAttachmentInput = {\n  id: UUID;\n  fileID: UUID;\n};\n\n// Subset of winston log levels, which can be found in NpmConfigSetLevels type in winston type file\nexport enum LogLevel {\n  ERROR = 'error',\n  WARN = 'warn',\n  INFO = 'info',\n  DEBUG = 'debug',\n}\n\nexport type PopperPosition = Placement;\n\n// called when the sidebar shows and hides, with a reference to the Cord iframe\n// expected to make domain-specific document adjustments to accommodate the sidebar\n// in its two states (expanded / not).\nexport type DocumentMutator = (width: number | null) => void;\n\n// called with the document to initialize any mutator-specific elements and behavior\n// expected to return the actual mutator function\nexport type DocumentMutatorInitializer = (\n  document: Document,\n) => DocumentMutator;\n\nexport type SimpleValue = string | number | boolean;\n\nexport type PreferencesValueType = JsonValue;\n\nexport type PreferencesType = JsonObject;\n\nexport enum UserReference {\n  MENTION = 'mention',\n  ASSIGNEE = 'assignee',\n}\n\nexport type RuleProviderInfo = {\n  id: UUID; // the ID of the provider, should be unique among providers\n  name: string; // the name of the provider\n  iconURL?: string | null; // URL for a favicon-like image\n  nuxText?: string | null; // the text to show the user teaching them how to use Radical on this specific provider\n  disableAnnotations?: boolean; // if annotations should be disabled for this provider. example: slack static PDFs where due to the chrome pdf viewer we don't have access to the scroll position\n};\n\n// a ruleset provider should export all the rules specific to a SaaS, even when\n// those rules span across different domain names.\nexport type RuleProvider = RuleProviderInfo & {\n  domains: string[]; // the domains that this provider's rules cover\n  rules: ProviderRule[]; // deny and approve rules\n  mergeHashWithLocation?: boolean; // a fix for providers like Snowflake who have URLs with query parameters after the # in the URL\n  visibleInDiscoverToolsSection: boolean; // the state of wether the tool is visible in th Discover tools section in the NUX flow, i.e. internal tools should not be included, localhost should not be included\n  platformApplicationID: UUID | null; // Application ID of provider, if relevant\n\n  // the functions to call to mutate the document to make room for the sidebar.\n  // this is a list to allow per-domain granularity.\n  documentMutators: ProviderDocumentMutator[];\n};\n\nexport type ProviderRule = {\n  id: UUID;\n  type: ProviderRuleType;\n  matchPatterns: ProviderRuleMatchPatterns;\n  nameTemplate: string | null;\n  contextTransformation: PageContextTransformation;\n  observeDOMMutations: boolean;\n};\n\nexport type ProviderDocumentMutator =\n  | { id: UUID; type: 'default_css'; config: CSSMutatorConfig }\n  | { id: UUID; type: 'custom_css'; config: CSSMutatorConfig }\n  | { id: UUID; type: 'fixed_elements'; config: null };\n\nexport type ProviderDocumentMutatorType = ProviderDocumentMutator['type'];\n\nexport type CSSMutatorConfig = {\n  cssTemplate: string;\n};\n\nexport type ProviderRuleType = 'allow' | 'deny';\n\nexport type ProviderRuleMatchPatterns = {\n  protocol?: string;\n  domain?: string;\n  path?: string;\n  hash?: string;\n  queryParams?: { [key: string]: string };\n  selector?: string;\n  contains?: string;\n};\n\nexport type ProviderRuleTestMatchType = 'allow' | 'deny' | 'none';\n\nexport type PageDetails = {\n  pageContext: PageContext;\n  pageName: string | null;\n};\n\nexport type MatchResult = (\n  | {\n      match: 'allow' | 'deny';\n      ruleID: UUID;\n    }\n  | {\n      match: 'none';\n    }\n) &\n  PageDetails;\n\nexport type PageContextTransformationType =\n  | 'default'\n  | 'replace'\n  | 'extend'\n  | 'metabase';\n\nexport type PageContextTransformation = {\n  type: PageContextTransformationType;\n  data: JsonObject | null;\n};\n\nexport type ProvidersResult = {\n  ruleProviders: RuleProvider[];\n  version: string;\n};\n\nexport type DeepPartial<T> = {\n  [P in keyof T]?: DeepPartial<T[P]>;\n};\n\nexport type LinearTeam = {\n  id: string;\n  name: string;\n  projects: {\n    nodes: Array<{\n      id: string;\n      name: string;\n    }>;\n  };\n};\n\nexport type AtlassianProject = {\n  // expand: 'description,lead,issueTypes,url,projectKeys,permissions,insight',\n  id: string; // 10000\n  key: string; // STLR\n  name: string; // 'Stellar'\n  issueTypes: Array<{\n    id: string; //'10001'\n    // description: 'Tasks track small, distinct pieces of work.';\n    name: string;\n    subtask: boolean;\n    // avatarId: 10318;\n    // hierarchyLevel: 0;\n  }>;\n  simplified: boolean;\n  style: string; // 'next-gen'\n  isPrivate: boolean;\n  entityId: UUID;\n  uuid: UUID;\n};\n\nexport type MondayBoard = {\n  id: string;\n  name: string;\n  subitem_board?: {\n    id: string;\n  };\n  groups: Array<{\n    id: string;\n    title: string;\n    position: string;\n  }>;\n};\n\nexport type JiraConnectionPreferences = {\n  projectID: string;\n  issueType: string;\n  subissueType?: string;\n};\n\nexport type AsanaConnectionPreferences = {\n  projectID: string | undefined;\n};\n\nexport type MondayConnectionPreferences = {\n  boardID: string;\n  groupID?: string;\n};\n\ntype TrelloList = {\n  id: UUID;\n  name: string;\n  closed?: string;\n  pos?: number;\n  softLimit?: string;\n  idBoard?: UUID;\n  subscriber: boolean;\n};\n\ntype TrelloBoard = {\n  id: UUID;\n  name: string;\n  idOrganization: UUID;\n  lists: TrelloList[];\n};\n\ntype TrelloOrg = {\n  id: UUID;\n  name: string;\n};\n\nexport type TrelloConnectionPreferencesType = {\n  id: UUID;\n  email: string;\n  boards: TrelloBoard[];\n  organizations: TrelloOrg[];\n};\n\nexport type TrelloCard = {\n  name: string;\n  desc: string;\n  idList: UUID;\n};\n\nexport type AsanaProject = {\n  gid: string;\n  name: string;\n};\n\nexport type JiraIssuePreviewData = {\n  key: string;\n  title: string;\n  url: string;\n  assignee: string | undefined;\n  status: string;\n  done: boolean;\n  priority: string;\n  subtasks: Array<{\n    id: string;\n    title: string;\n    done: boolean;\n  }>;\n};\n\nexport type AsanaTaskPreviewData = {\n  title: string;\n  url: string;\n  assignee: string | undefined;\n  done: boolean;\n};\n\nexport type LinearIssuePreviewData = {\n  title: string;\n  identifier: string;\n  url: string;\n  assignee: string | undefined;\n  status: string;\n  priority: string;\n  done: boolean;\n  orgName: string | undefined;\n};\n\nexport type MondayItemPreviewData = {\n  title: string;\n  url: string;\n  assignee: string | undefined;\n  done: boolean;\n  assigneeColumnID: string | undefined;\n  statusColumnID: string | undefined;\n};\n\nexport type TaskPreviewData =\n  | AsanaTaskPreviewData\n  | JiraIssuePreviewData\n  | LinearIssuePreviewData\n  | MondayItemPreviewData;\n\nexport enum LinearIssueStateTypes {\n  BACKLOG = 'backlog',\n  TODO = 'unstarted',\n  IN_PROGRESS = 'started',\n  DONE = 'completed',\n  CANCELED = 'canceled',\n}\n\nexport type LinearConnectionPreferences = {\n  teamID: string;\n  projectID?: string;\n};\n\nexport type APICordTokenData = {\n  session_id: UUID;\n};\n\nexport type AppServerAuthTokenData = {\n  app_id: UUID;\n};\n\nexport type CustomerServerAuthTokenData = {\n  customer_id: UUID;\n};\n\nexport type NotificationChannels = {\n  slack: boolean;\n  email: boolean;\n};\n\nexport type CustomLinks = {\n  learnMore?: string | null;\n  upgradePlan?: string | null;\n  leaveFeedback?: string | null;\n};\n\nexport type ThirdPartyAuth = 'slack' | 'google' | 'ms-teams';\n\nexport type OutboundNotificationType =\n  | 'slack'\n  | 'email'\n  | 'slackEmailMatched'\n  | 'sharedToSlackChannel'\n  | 'sharedToEmail';\n\nexport type { Point2D } from '@cord-sdk/types';\n\nexport type CustomNUXStepContent = {\n  title: string | null;\n  text: string | null;\n  imageURL: string | null;\n};\n\nexport type CustomNUX = {\n  initialOpen: CustomNUXStepContent | null;\n  welcome: CustomNUXStepContent | null;\n};\n\nexport type SlackOAuthLinkOrgState = {\n  data: {\n    userID: string;\n    orgID: string;\n    platformApplicationID: string;\n  };\n  type: 'link_org';\n  nonce: string;\n};\n\nexport type SlackOAuthConsoleUserState = {\n  data: {\n    platformApplicationID: string;\n  };\n  type: 'console_user';\n  nonce: string;\n};\n\nexport type SlackOAuthDecodeState =\n  | SlackOAuthLinkOrgState\n  | SlackOAuthConsoleUserState;\n\nexport type ThreadSupportStatusType = 'open' | 'closed';\n\nexport type UserWithOrgDetails = {\n  id: UUID;\n  externalID: string;\n  displayName: string;\n  fullName: string;\n  name: string | null;\n  shortName: string | null;\n  profilePictureURL: string | null;\n  metadata: EntityMetadata;\n  canBeNotifiedOnSlack: boolean;\n};\n\nexport type OutboundNotificationMetadata =\n  OutboundNotificationMetadataByType[OutboundNotificationType];\n\n// when adding new fields to existing metadata types, either make the new\n// fields optional or run a backfill migration\nexport type OutboundNotificationMetadataByType = {\n  slack: Record<string, never>;\n  email: Record<string, never>;\n  slackEmailMatched: Record<string, never>;\n  sharedToSlackChannel: {\n    type: 'sharedToSlackChannel';\n    targetSlackChannelID: string;\n  };\n  sharedToEmail: {\n    type: 'sharedToEmail';\n    targetEmail: string;\n  };\n};\n\n// Internal threads are the standard mirrored Slack threads\n// that users can share to their linked Slack org.\n// Support threads are the ones mirrored to a vendor's Slack org\n// and support channel after a support bot is mentioned.\nexport type ThreadMirrorType = 'internal' | 'support';\n\nexport type Tier = 'prod' | 'staging' | 'test' | 'dev';\n\nexport type SharedToSlackInfo = {\n  channel: string | null;\n  slackURL: string | null;\n};\n\nexport type ThreadMode =\n  // Only shows the first message, and optionally the number of replies\n  | 'collapsed'\n  // Can show all messages, also includes a composer to add a new message\n  | 'inline'\n  // Used in the sidebar only - thread spans across the whole page\n  | 'fullHeight'\n  // The initial state when we are creating a new thread - composer only\n  | 'newThread';\n\nexport type Announcement =\n  | 'welcome'\n  | 'completeProfile'\n  | 'connectOrgToSlack'\n  | 'linkProfileToSlack'\n  | 'slackIsConnected';\n\nexport type ReferencedUserData = { id: UUID; name: string };\n\nconst DEPLOYMENT_TYPES = ['sdk'] as const;\n\nexport type DeploymentType = (typeof DEPLOYMENT_TYPES)[number];\n\nexport function isDeploymentType(s: string): s is DeploymentType {\n  if (DEPLOYMENT_TYPES.includes(s as DeploymentType)) {\n    return true;\n  }\n  return false;\n}\n\nexport function toDeploymentType(\n  s: string | null | undefined,\n): DeploymentType | null {\n  if (s && isDeploymentType(s)) {\n    return s;\n  }\n  return null;\n}\n\nexport type ApplicationEnvironment =\n  | 'production'\n  | 'staging'\n  | 'sample' // console self-serve test (not paying) app\n  | 'sampletoken' // sample token apps created for docs integration guide and demo apps opensource repos (wiped periodically)\n  | 'demo'; // temporary token apps created for docs and cord.com demo apps (wiped periodically)\n\n// NB you there are some classes of token you might expect are environments,\n// but actually all belong to one appID:\n// The docs live components are all in the CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID app\n// The e2e tests are all in the CORD_AUTOMATED_TESTS_APPLICATION_ID app\n// The CORD_PLAYGROUND_APPLICATION_ID has been retired from service\n\nexport type EmptyJsonObject = Record<string, never>;\n\nexport type CustomerType = 'verified' | 'sample';\n\nexport type CustomerImplementationStage =\n  | 'launched'\n  | 'implementing'\n  | 'proof_of_concept'\n  | 'inactive';\n\nexport type AdminCRTComingFrom = 'them' | 'us';\n\nexport type AdminCRTDecision = 'done' | 'accepted' | 'rejected' | 'pending';\n\nexport type AdminCRTCommunicationStatus =\n  | 'none'\n  | 'request_acked'\n  | 'decision_sent'\n  | 'decision_acked';\n\nexport type AdminCRTIssueType = 'request' | 'bug' | 'onboarding_step';\n\nexport type AdminCRTPriority = 'blocker' | 'high' | 'low';\n\nexport type AdminCRTCustomerIssue = {\n  customerID: UUID;\n  title: string;\n  body: string;\n  comingFrom: AdminCRTComingFrom;\n  decision: AdminCRTDecision;\n  communicationStatus: AdminCRTCommunicationStatus;\n  lastTouch?: string;\n  type: AdminCRTIssueType;\n  priority: AdminCRTPriority;\n  externallyVisible: boolean;\n  assignee?: UUID;\n};\n\nexport type DocsCachedEmbedding = {\n  url: string;\n  plaintext: string;\n  embedding?: OpenAI.CreateEmbeddingResponse | undefined;\n};\n\nexport type CordDotComCachedEmbedding = DocsCachedEmbedding & {\n  title: string;\n};\n\n// This is for the mouse move events within iframes\nexport type IframeMouseMoveData = { x: number; y: number; frame_id: string };\n\nexport type Maybe<T> = T | null | undefined;\nexport type Nullable<T> = T | null;\n", "// This is for important URLs to all kinds of services\n\nexport const TOP_SERVER_HOST = process.env.TOP_SERVER_HOST!;\nexport const APP_SERVER_HOST = process.env.APP_SERVER_HOST!;\nexport const API_SERVER_HOST = process.env.API_SERVER_HOST!;\nexport const API_SERVER_HOST_PRODUCTION =\n  process.env.API_SERVER_HOST_PRODUCTION!;\nexport const ADMIN_SERVER_HOST = process.env.ADMIN_SERVER_HOST!;\nexport const CONSOLE_SERVER_HOST = process.env.CONSOLE_SERVER_HOST!;\nexport const MARKETING_SERVER_HOST = process.env.MARKETING_SERVER_HOST!;\nexport const CORD_TO_HOST = process.env.CORD_TO_HOST!;\nexport const AUTH0_CUSTOM_LOGIN_DOMAIN = process.env.AUTH0_CUSTOM_LOGIN_DOMAIN!;\nexport const DOCS_SERVER_HOST = process.env.DOCS_SERVER_HOST!;\nexport const SLACK_APP_REDIRECT_HOST = process.env.SLACK_APP_REDIRECT_HOST;\n\nexport const TOP_ORIGIN = 'https://' + process.env.TOP_SERVER_HOST;\nexport const APP_ORIGIN = 'https://' + process.env.APP_SERVER_HOST;\nexport const API_ORIGIN = 'https://' + process.env.API_SERVER_HOST;\nexport const ADMIN_ORIGIN = 'https://' + process.env.ADMIN_SERVER_HOST;\nexport const CONSOLE_ORIGIN = 'https://' + process.env.CONSOLE_SERVER_HOST;\nexport const MARKETING_ORIGIN = 'https://' + process.env.MARKETING_SERVER_HOST;\nexport const CORD_TO_ORIGIN = 'https://' + process.env.CORD_TO_HOST;\nexport const AUTH0_ORIGIN = 'https://' + process.env.AUTH0_CUSTOM_LOGIN_DOMAIN;\nexport const DOCS_ORIGIN = 'https://' + process.env.DOCS_SERVER_HOST;\nexport const DOCS_AI_CHATBOT_SERVER_HOST =\n  process.env.DOCS_AI_CHATBOT_SERVER_HOST;\nexport const COMMUNITY_ORIGIN = 'https://' + process.env.COMMUNITY_SERVER_HOST;\n\n// See https://github.com/getcord/interactive-demos\nexport const DEMO_APPS_WEBHOOK_URL =\n  'https://cord-interactive-demos.vercel.app/events';\n", "import { DOCS_ORIGIN } from 'common/const/Urls.ts';\n\nexport const SUPPORT_USER_UUID = 'c9a61e1d-7c8a-4c7e-838a-9d431cf4ed77';\nexport const RADICAL_ORG_ID = '6bba8678-b14e-4af7-b2f2-05ee807dfa82';\nexport const RADICAL_TEST_ORG_ID = '3689f86d-0c70-40de-a2f0-a4a9ea4994e3';\nexport const CORD_PLATFORM_ORG_ID = '746c0b57-7363-4766-9ee9-7ae8ec7531a8';\nexport const CORD_ADMIN_PLATFORM_ORG_ID =\n  '84ae9086-8414-4ed3-ab73-096e6438f095';\nexport const CORD_SDK_TEST_ORG_ID = 'edda098d-6db7-4202-a5ac-ff3293b78c47';\nexport const GILLIAN_TEST_SLACK_ORG_ID = 'f7ab9ab8-f5b2-41a4-a419-1b8076626d3f';\nexport const KAT_TEST_SLACK_ORG_ID = '4506fadd-f8dc-4795-9b5d-d28feda39d84';\nexport const CORD_SLACK_TEAM_ID = 'T012Y0TBQLW'; // radicalhqworkspace\nexport const CORD_TEST_SLACK_TEAM_ID = 'T015UJY6YQK'; // radicaltestorg\n\nexport const SLACK_APP_CLIENT_ID = '1100027398710.1180115520790';\nexport const SLACK_APP_ID = 'A015A3DFAP8';\nexport const SLACK_DEV_APP_CLIENT_ID = '1198644236835.1943446227956';\nexport const SLACK_ADMIN_LOGIN_APP_CLIENT_ID = '1100027398710.2437628320357';\nexport const SLACK_ADMIN_LOGIN_APP_ID = 'A02CVJG9EAH';\nexport const SLACK_DEV_APP_ID = 'A01TRD46PU4';\nexport const SLACK_INTERNAL_TOOLS_APP_ID = 'A04JKM945CM';\nexport const CORD_UPDATES_TEST_CHANNEL_ID = 'C0547K3V868';\n\n// As opposed to e.g. a customer's Slack app\nexport const CORD_SLACK_APP_IDS = [\n  SLACK_APP_ID,\n  SLACK_DEV_APP_ID,\n  SLACK_ADMIN_LOGIN_APP_ID,\n  SLACK_INTERNAL_TOOLS_APP_ID,\n];\n\nexport const CORD_APPLICATION_ID = '5a076ee9-8b9e-4156-9ac4-871bdc4569ec';\nexport const CORD_SDK_TEST_APPLICATION_ID =\n  'b6501bf5-46f7-4db7-9996-c42dd9f758b0';\nexport const CORD_SAMPLE_TOKEN_CUSTOMER_ID =\n  '1c367aca-37c9-4733-8bef-e9f11a7d0f17';\nexport const CORD_DEMO_APPS_TOKEN_CUSTOMER_ID =\n  '4383cf39-8b6a-4c33-9d8a-71567ed47a60';\nexport const CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID =\n  'aeb2797f-f0a3-485c-a317-4986e2c8343b';\nexport const CORD_AUTOMATED_TESTS_APPLICATION_ID =\n  'dfa86152-9e7e-4d2d-acd6-bfddef71f58e';\nexport const CLACK_APPLICATION_ID = '5fa22ba9-5446-4af8-bc93-7ce54a9aa0ba';\nexport const CORD_HOMEPAGE_APPLICATION_ID =\n  '29e6499a-bbed-4eb2-b057-b36d60ad76c9';\nexport const AUTH0_CLIENT_ID = process.env.AUTH0_CLIENT_ID!;\n\nexport const CORD_CUSTOMER_ID = '12ed6251-28d5-4686-9a75-20a15bd31499';\n\nexport const CSS_CUSTOMIZATION_ON_DOCS_PREFIX = 'css-customization-';\nexport const BETA_V2_DOCS_PREFIX = 'beta2-';\nexport const LIVE_CSS_ON_DOCS_THREAD_ID_PREFIX = 'live-css-docs-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_THREAD_ID_PREFIX =\n  'live-component-docs-thread-';\nexport const LIVE_COMPONENT_INBOX_THREAD_ID_PREFIX =\n  'live_component-docs-inbox-thread-';\nexport const LIVE_COMPONENT_INBOX_LAUNCHER_THREAD_ID_PREFIX =\n  'live_component-docs-inbox-launcher-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_COMPOSER_THREAD_ID_PREFIX =\n  'live-component-docs-composer-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_MESSAGE_THREAD_ID_PREFIX =\n  'live-component-docs-message-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_MESSAGE_CONTENT_THREAD_ID_PREFIX =\n  'live-component-docs-message-content-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_PIN_THREAD_ID_PREFIX =\n  'live-component-docs-pin-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_REACTIONS_THREAD_ID_PREFIX =\n  'live-component-docs-reactions-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_EXTERNAL_NOTIFICATION_PREFIX =\n  'live-component-docs-external-notification-';\nexport const LIVE_CUSTOMIZATION_ON_DOCS_REPLACEMENTS_THREAD_ID_PREFIX =\n  'live-customization-docs-replacements-thread-';\nexport const DOCS_TOKEN_KEY = 'docs-token';\n\nexport const LIVE_COMPONENT_ON_DOCS_NO_AVATAR_USER_ID = 'noavatar';\n\nexport const DOCS_LIVE_PAGE_LOCATIONS = {\n  cssCustomization: 'css-customization',\n  liveCss: 'live-css-docs',\n  liveThread: 'live-thread',\n  liveThreadList: 'live-thread-list',\n  livePin: 'live-pin',\n  livePinChartExample: 'live-pin-chart-example',\n  liveFloatingThreads: 'live-floating-threads',\n  liveSelectionComments: 'live-selection-comments',\n  liveSidebar: 'live-sidebar',\n  liveInbox: 'live-inbox',\n  liveInboxLauncher: 'live-inbox-launcher',\n  liveSidebarLauncher: 'live-sidebar-launcher',\n  livePagePresence: 'live-page-presence',\n  livePresenceFacepile: 'live-presence-facepile',\n  liveComposer: 'live-composer',\n  liveMessage: 'live-message',\n  liveMessageContent: 'live-message-content',\n  liveNotificationList: 'live-notification-list',\n  liveThreadedComments: 'live-threaded-comments',\n  liveReactions: 'live-reactions',\n  liveReplacementsTutorial: 'live-replacements-tutorial',\n  liveBetaV2Thread: 'live-beta-v2-thread',\n  liveBetaV2Threads: 'live-beta-v2-threads',\n};\n\nexport const CORD_DOCS_CLIENT_TOKEN = '__cord_docs_token__';\n\nexport const DOCS_URLS = {\n  tutorials: {\n    getProductionReady: {\n      addYourBranding: `${DOCS_ORIGIN}/get-started/live-css-editor`,\n    },\n    integrationGuide: `${DOCS_ORIGIN}/get-started/integration-guide`,\n    demoApps: `${DOCS_ORIGIN}/get-started/demo-apps`,\n  },\n  components: {\n    thread: `${DOCS_ORIGIN}/components/cord-thread`,\n    threadList: `${DOCS_ORIGIN}/components/cord-thread-list`,\n    threadedComments: `${DOCS_ORIGIN}/components/cord-threaded-comments`,\n    sidebar: `${DOCS_ORIGIN}/components/cord-sidebar`,\n    inbox: `${DOCS_ORIGIN}/components/cord-inbox`,\n    inboxLauncher: `${DOCS_ORIGIN}/components/cord-inbox-launcher`,\n    sidebarLauncher: `${DOCS_ORIGIN}/components/cord-sidebar-launcher`,\n    composer: `${DOCS_ORIGIN}/components/cord-composer`,\n    message: `${DOCS_ORIGIN}/components/cord-message`,\n    messageContent: `${DOCS_ORIGIN}/components/cord-message-content`,\n    reactions: `${DOCS_ORIGIN}/components/cord-reactions`,\n  },\n  howTo: {\n    customThreadedComments: `${DOCS_ORIGIN}/customization/custom-threaded-comments`,\n    cssCustomization: `${DOCS_ORIGIN}/customization/css`,\n    replacements: `${DOCS_ORIGIN}/customization/custom-react-components/tutorial`,\n  },\n  getStarted: {\n    authenticateYourUser: `${DOCS_ORIGIN}/get-started/integration-guide/generate-an-auth-token`,\n  },\n  betaV2Components: {\n    threads: `${DOCS_ORIGIN}/components/cord-threads?version=2.0`,\n    thread: `${DOCS_ORIGIN}/components/cord-thread?version=2.0`,\n  },\n};\n\nexport const CORD_DEV_CONSOLE_LOGGING_SLACK_CHANNEL_ID = 'C05FAVBSSN7';\nexport const CORD_SELF_SERVE_SLACK_CHANNEL_ID = 'C05GR4WSV5Z';\n\n// Tokens created for the sample token and demo apps environment types both\n// create groups with this id.  Both of them need to use the same groupID because\n// it is hardcoded into the demo apps client code, and while the demo apps mostly\n// use the demo apps environment apps, they sometimes use sample app tokens.\nexport const DEMO_APPS_APP_GROUP_ID = 'my-first-group';\n", "import type { Node } from 'slate';\nimport { Element } from 'slate';\nimport { v4 as uuid } from 'uuid';\nimport { MessageNodeType } from '@cord-sdk/types';\nimport type {\n  MessageAssigneeNode,\n  MessageContent,\n  MessageMentionNode,\n  MessageNode,\n  MessageNodeWithChildren,\n  MessageStyledBlockType,\n  MessageTextNode,\n  MessageTodoNode,\n  UUID,\n} from '@cord-sdk/types';\nimport { trimStart, trimEnd } from './trim.js';\n\nexport const MAX_BULLET_INDENT = 4;\n\n// '& Node' in return value stops Slate complaining when passing node to its methods\n// Casting to any is because TS doesn't seem to like combining the two to make the node\nexport function createMessageNode<\n  NodeType extends MessageNodeType,\n  NodeAttributes extends MessageNode<NodeType> = MessageNode<NodeType>,\n>(\n  nodeType: NodeType,\n  nodeAttributes: Omit<NodeAttributes, 'type'>,\n): MessageNode<NodeType> & Node {\n  return {\n    type: nodeType,\n    ...nodeAttributes,\n  } as any;\n}\n\nexport function createMessageTextNode(text: string): MessageTextNode {\n  return {\n    text,\n  };\n}\n\nexport function createFormattedMessageTextNode(input: {\n  text: string;\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n  code?: boolean;\n}): MessageTextNode {\n  return input;\n}\n\nexport function isMessageNodeType<NodeType extends MessageNodeType>(\n  node: Node | undefined,\n  nodeType: NodeType,\n): node is MessageNode<NodeType> {\n  return Boolean(node && Element.isElement(node) && node.type === nodeType);\n}\n\nexport function isMessageNodeText(node: MessageNode): node is MessageTextNode {\n  return !node.type && 'text' in node;\n}\n\nexport function createParagraphNode(text = '') {\n  return createMessageNode(MessageNodeType.PARAGRAPH, {\n    children: [{ text }],\n  });\n}\n\nexport function createMentionNode(userID: UUID, name: string) {\n  return createMessageNode(MessageNodeType.MENTION, {\n    user: { id: userID },\n    children: [{ text: `@${name}` }],\n  });\n}\n\nexport function createAssigneeNode(userID: UUID, name: string) {\n  return createMessageNode(MessageNodeType.ASSIGNEE, {\n    user: { id: userID },\n    children: [{ text: `+${name}` }],\n  });\n}\n\nexport function createLinkNode(url: string, text: string) {\n  return createMessageNode(MessageNodeType.LINK, {\n    url,\n    children: [{ text }],\n  });\n}\n\nexport function messageContentFromString(text: string): MessageContent {\n  return [createParagraphNode(text)];\n}\n\nfunction getInitialStyledBlockProps(\n  blockType: MessageStyledBlockType,\n  indent?: number,\n) {\n  if (blockType === MessageNodeType.TODO) {\n    return {\n      done: false,\n      todoID: uuid(),\n    };\n  } else if (\n    blockType === MessageNodeType.BULLET ||\n    blockType === MessageNodeType.NUMBER_BULLET\n  ) {\n    return {\n      indent,\n    };\n  } else {\n    return {};\n  }\n}\n\nexport function createStyledBlockNode(\n  blockType: MessageStyledBlockType,\n  text: string,\n  indent?: number,\n) {\n  return createMessageNode(blockType, {\n    children: messageContentFromString(text),\n    ...getInitialStyledBlockProps(blockType, indent),\n  });\n}\n\nconst findTodoNodesInSubtree = (\n  parent: MessageNode,\n  accumulator: MessageTodoNode[],\n): void => {\n  if (parent.type === MessageNodeType.TODO) {\n    accumulator.push(parent);\n  } else {\n    const children = getMessageNodeChildren(parent);\n    if (children) {\n      for (const node of children) {\n        findTodoNodesInSubtree(node, accumulator);\n      }\n    }\n  }\n};\n\nexport const todoNodesFromMessage = (messageContent: MessageContent) => {\n  const accumulator: MessageTodoNode[] = [];\n\n  for (const node of messageContent) {\n    findTodoNodesInSubtree(node, accumulator);\n  }\n\n  return accumulator;\n};\n\nexport function getMessageNodeChildren(node: MessageNode) {\n  return (node as MessageNodeWithChildren).children;\n}\n\nexport const textFromNodeRecursive = (node: MessageNode): string => {\n  let textArr: Array<string> = [];\n\n  if (isMessageNodeText(node)) {\n    return node.text;\n  }\n\n  const children = getMessageNodeChildren(node);\n  if (children) {\n    textArr = textArr.concat(\n      children.map((child) => textFromNodeRecursive(child)),\n    );\n  }\n\n  const result = textArr.join('');\n\n  return result;\n};\n\nexport function convertStructuredMessageToText(\n  messageContent: MessageContent,\n): string {\n  return messageContent\n    .map((node) => textFromNodeRecursive(node))\n    .join('\\n')\n    .trim();\n}\n\n// converts a list of MessageNode into text.\n// any whitespace or assignees at the start/end are removed.\nfunction taskTitleFromMessageNodes(\n  nodes: (MessageTextNode | MessageAssigneeNode | MessageMentionNode)[],\n): string {\n  let pending = '';\n  let text = '';\n\n  for (const node of nodes) {\n    if (node.type === MessageNodeType.ASSIGNEE) {\n      if (text.trim() === '') {\n        // no text was seen so far, so this is an assignee at the start of a\n        // message. We want to skip those.\n        continue;\n      }\n      // okay, we have seen some text already, but this assignee might be at\n      // the very end of the message. Hence let the assignee wait in the\n      // pending until we find non-empty text (which would mean the assignee is\n      // not at the end of the message)\n      pending += trimStart(textFromNodeRecursive(node), '+');\n      continue;\n    }\n\n    let newText = '';\n    if (isMessageNodeText(node)) {\n      newText = node.text;\n    } else if (node.type === MessageNodeType.MENTION) {\n      newText = trimStart(textFromNodeRecursive(node), '@');\n    }\n\n    const isEmpty = newText.trim() === '';\n    if (isEmpty) {\n      // this might be either trailing whitespace or whitespace in the middle\n      // of the message. For now, let's have it in pending until something\n      // non-empty arrives\n      pending += newText;\n    } else {\n      // we found some non-empty text so whatever was waiting in the pending\n      // can now finally become part of text\n      text += pending + newText;\n      pending = '';\n    }\n  }\n\n  return trimEnd(text.trim(), ':').trim();\n}\n\n// converts each MessageNode into text, returns the first non-empty one.\nexport function taskTitleFromMessageContent(\n  messageContent: MessageContent,\n): string {\n  for (let i = 0; i < messageContent.length; i++) {\n    const nodes: (\n      | MessageTextNode\n      | MessageAssigneeNode\n      | MessageMentionNode\n    )[] = [];\n    flattenMessage(messageContent[i], nodes);\n\n    const title = taskTitleFromMessageNodes(nodes);\n    if (title.length > 0) {\n      return title;\n    }\n  }\n\n  return 'Task created using Cord';\n}\n\nfunction flattenMessage(\n  node: MessageNode,\n  accumulator: (MessageTextNode | MessageAssigneeNode | MessageMentionNode)[],\n) {\n  if (\n    isMessageNodeText(node) ||\n    node.type === MessageNodeType.ASSIGNEE ||\n    node.type === MessageNodeType.MENTION\n  ) {\n    accumulator.push(node);\n    return;\n  }\n  const children = getMessageNodeChildren(node);\n  if (!children) {\n    return;\n  }\n\n  for (const child of children) {\n    flattenMessage(child, accumulator);\n  }\n}\n\n// message.content is null if message is deleted\nexport const findMessageNode = (\n  arr: MessageContent | null,\n  nodeType: MessageNodeType,\n): any => {\n  if (!arr) {\n    return null;\n  }\n  for (const item of arr) {\n    if (item.type === nodeType) {\n      return item;\n    }\n    if ('children' in item) {\n      const p = findMessageNode(item.children, nodeType);\n      if (p) {\n        return p;\n      }\n    }\n  }\n\n  return null;\n};\n", "export type DatabaseConfig = {\n  database?: string;\n  host?: string;\n  password?: string;\n  port?: number;\n  user?: string;\n};\n\nexport function getReadReplicaDbConfigFromEnv(\n  env: Record<string, string | undefined>,\n): DatabaseConfig {\n  return {\n    host: env.POSTGRES_READ_HOST ?? env.POSTGRES_HOST,\n    port: Number(env.POSTGRES_READ_PORT ?? env.POSTGRES_PORT),\n    database: env.POSTGRES_DB,\n    user: env.POSTGRES_USER,\n    password: env.POSTGRES_PASSWORD,\n  };\n}\n"],
  "mappings": "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",
  "names": ["jsonStableStringify"]
}
