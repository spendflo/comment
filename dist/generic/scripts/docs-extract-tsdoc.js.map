{
  "version": 3,
  "sources": ["scripts/docs-extract-tsdoc.ts", "common/util/index.ts", "common/types/index.ts", "common/const/Urls.ts", "common/const/Ids.ts", "opensource/sdk-js/packages/react/common/lib/messageNode.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\n\n/**\n * This script compiles our opensource code, extracts the exported symbols from\n * the TypeScript compiler output, and generates a file in the same format as\n * TJV outputs, so that we can use them in our docs.\n *\n * In general, you want to run docs-codegen.sh, which builds and runs everything\n * necessary for the docs (both this and TJV), rather than running this script\n * directly.\n */\n\nimport 'dotenv/config.js';\nimport * as path from 'path';\n\nimport * as prettier from 'prettier';\nimport ts from 'typescript';\n\nimport {\n  DocNodeKind,\n  StandardTags,\n  TSDocConfiguration,\n  TSDocParser,\n  TSDocTagDefinition,\n  TSDocTagSyntaxKind,\n} from '@microsoft/tsdoc';\nimport type {\n  DocSection,\n  DocPlainText,\n  DocEscapedText,\n  DocCodeSpan,\n  DocFencedCode,\n  DocNode,\n  DocNodeContainer,\n  DocParagraph,\n  DocBlock,\n  DocErrorText,\n  DocComment,\n} from '@microsoft/tsdoc';\nimport type {\n  Property,\n  PropertiesList,\n  AnyOf,\n  Interface,\n  Method,\n  SingleMethod,\n} from 'docs/server/ui/propertiesList/types.ts';\n\nimport { isDefined } from 'common/util/index.ts';\n\nconst TSDOC_CONFIG = new TSDocConfiguration();\nTSDOC_CONFIG.addTagDefinitions([\n  new TSDocTagDefinition({\n    tagName: '@minLength',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n  new TSDocTagDefinition({\n    tagName: '@maxLength',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n  new TSDocTagDefinition({\n    tagName: '@format',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n  new TSDocTagDefinition({\n    tagName: '@minimum',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n  new TSDocTagDefinition({\n    tagName: '@maximum',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n  new TSDocTagDefinition({\n    tagName: '@minItems',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n  new TSDocTagDefinition({\n    tagName: '@maxItems',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n  new TSDocTagDefinition({\n    tagName: '@additionalProperties',\n    syntaxKind: TSDocTagSyntaxKind.BlockTag,\n  }),\n]);\n\ntype Writeable<T> = { -readonly [P in keyof T]: Writeable<T[P]> };\n\ninterface Namespace {\n  [key: string]: Namespace | Interface | Method;\n}\n\nfunction containerToMarkdown(\n  container: DocNodeContainer,\n  customBlocks?: readonly DocBlock[],\n) {\n  let content = nodesToMarkdown(container.nodes);\n  if (customBlocks) {\n    for (const block of customBlocks) {\n      if (block.blockTag.tagNameWithUpperCase === '@MAXITEMS') {\n        content += `\\n\\nThis field has a maximum length of ${containerToMarkdown(\n          block.content,\n        )}.`;\n      }\n    }\n  }\n  return content;\n}\n\nfunction nodesToMarkdown(nodes: readonly DocNode[]) {\n  return nodesToMarkdownInternal(nodes).trim();\n}\n\nfunction nodesToMarkdownInternal(nodes: readonly DocNode[]) {\n  let result = '';\n  for (const node of nodes) {\n    switch (node.kind) {\n      case DocNodeKind.PlainText:\n        result += (node as DocPlainText).text.replaceAll(\n          '(https://docs.cord.com/',\n          '(/',\n        );\n        break;\n      case DocNodeKind.EscapedText:\n        result += (node as DocEscapedText).decodedText;\n        break;\n      case DocNodeKind.CodeSpan:\n        result += '`' + (node as DocCodeSpan).code + '`';\n        break;\n      case DocNodeKind.FencedCode: {\n        const fencedCode = node as DocFencedCode;\n        result +=\n          '```' + fencedCode.language + '\\n' + fencedCode.code + '\\n```';\n        break;\n      }\n      case DocNodeKind.Section:\n        result += nodesToMarkdownInternal((node as DocSection).nodes);\n        break;\n      case DocNodeKind.SoftBreak:\n        result += ' ';\n        break;\n      case DocNodeKind.Paragraph:\n        result +=\n          nodesToMarkdownInternal((node as DocParagraph).nodes) + '\\n\\n';\n        break;\n      case DocNodeKind.ErrorText: {\n        const errorTextNode = node as DocErrorText;\n        throw new Error(\n          `The docs have a TSDoc formatting error: ${errorTextNode.errorMessage}\\n\\n${errorTextNode.textExcerpt}`,\n        );\n      }\n      case DocNodeKind.BlockTag:\n        // A tag like @format or @example, which we can just ignore, it's not\n        // part of the text\n        break;\n      default:\n        throw new Error(`Unknown doc node kind: ${node.kind}`);\n    }\n  }\n  return result;\n}\n\nfunction extractExamples(customBlocks: readonly DocBlock[]) {\n  const exampleBlocks = customBlocks.filter(\n    (b) =>\n      b.blockTag.tagNameWithUpperCase ===\n      StandardTags.example.tagNameWithUpperCase,\n  );\n  const result: Record<string, string> = {};\n  for (const exampleBlock of exampleBlocks) {\n    let nodes = exampleBlock.content.nodes;\n    let key = 'Example';\n    if (nodes[0].kind === DocNodeKind.Paragraph) {\n      key = containerToMarkdown(nodes[0] as DocParagraph);\n      nodes = nodes.slice(1);\n    }\n    if (nodes[0].kind === DocNodeKind.FencedCode) {\n      result[key] = (nodes[0] as DocFencedCode).code.trim();\n    } else {\n      result[key] = nodesToMarkdown(nodes);\n    }\n  }\n  return result;\n}\n\nfunction getTsDoc(node: ts.Node) {\n  const sourceText = node.getSourceFile().getFullText();\n  const commentRanges = ts\n    .getLeadingCommentRanges(sourceText, node.pos)\n    ?.filter(({ pos }) => sourceText.substring(pos, pos + 3) === '/**');\n  if (!commentRanges || commentRanges.length === 0) {\n    return undefined;\n  }\n  if (commentRanges.length !== 1) {\n    throw new Error('Node had more than one doc comment');\n  }\n  const commentRange = commentRanges[0];\n  const parser = new TSDocParser(TSDOC_CONFIG);\n  return parser.parseString(\n    sourceText.substring(commentRange.pos, commentRange.end),\n  ).docComment;\n}\n\nfunction isHidden(docs: DocComment | undefined): boolean {\n  if (docs?.deprecatedBlock) {\n    return true;\n  }\n\n  // If we want to add types but not document them, say because it is an\n  // experimental feature, we can add `@privateRemarks hidden` to the relevant\n  // TSDoc section.\n  if (docs?.privateRemarks) {\n    return !!containerToMarkdown(docs.privateRemarks?.content).includes(\n      'hidden',\n    );\n  }\n\n  return false;\n}\n\nfunction isBuiltInType(type: ts.Type): boolean {\n  return !!type.symbol?.declarations?.some(\n    (d) => d.getSourceFile().hasNoDefaultLib,\n  );\n}\n\nfunction isForeignType(type: ts.Type): boolean {\n  return !!type.symbol?.declarations?.some((d) =>\n    d.getSourceFile().fileName.includes('/node_modules/'),\n  );\n}\n\nfunction isFromBuiltInType(symbol: ts.Symbol): boolean {\n  return !!symbol.declarations?.some(\n    (d) => d.parent.getSourceFile().hasNoDefaultLib,\n  );\n}\n\nconst UTILITY_TYPES = ['Partial', 'Required', 'Readonly', 'Pick', 'Omit'];\n\n/**\n * Returns whether the given type is a built-in utility type that doesn't supply\n * any properties itself and just modifies another type.  See\n * https://www.typescriptlang.org/docs/handbook/utility-types.html.\n */\nfunction isUtilityType(type: ts.Type): boolean {\n  return !!(\n    isBuiltInType(type) &&\n    type.aliasSymbol &&\n    UTILITY_TYPES.includes(type.aliasSymbol.name)\n  );\n}\n\nfunction isUnion(type: ts.Type): type is ts.UnionType {\n  return !!(type.flags & ts.TypeFlags.Union);\n}\n\nfunction isStringLiteral(type: ts.Type): type is ts.StringLiteralType {\n  return !!(type.flags & ts.TypeFlags.StringLiteral);\n}\n\nfunction isBooleanLiteral(type: ts.Type): boolean {\n  return !!(type.flags & ts.TypeFlags.BooleanLiteral);\n}\n\nfunction isPrimitiveType(type: ts.Type): boolean {\n  return !!(\n    type.flags &\n    (ts.TypeFlags.String |\n      ts.TypeFlags.Number |\n      ts.TypeFlags.Boolean |\n      ts.TypeFlags.Null |\n      ts.TypeFlags.Undefined)\n  );\n}\n\nfunction isObject(type: ts.Type): type is ts.ObjectType {\n  return !!(type.flags & ts.TypeFlags.Object);\n}\n\nfunction isIntersection(type: ts.Type): type is ts.IntersectionType {\n  return !!(type.flags & ts.TypeFlags.Intersection);\n}\n\nfunction isFunction(type: ts.Type): boolean {\n  return type.getCallSignatures().length > 0;\n}\n\nfunction isArray(type: ts.Type): type is ts.TypeReference {\n  return (\n    isObject(type) &&\n    type.getSymbol()?.getName() === 'Array' &&\n    !!(type.objectFlags & ts.ObjectFlags.Reference)\n  );\n}\n\nfunction isTuple(type: ts.Type): type is ts.TypeReference {\n  return (\n    isObject(type) &&\n    !!(type.objectFlags & ts.ObjectFlags.Reference) &&\n    !!((type as ts.TypeReference).target.objectFlags & ts.ObjectFlags.Tuple)\n  );\n}\n\nfunction isUndefined(type: ts.Type): boolean {\n  return !!(type.flags & ts.TypeFlags.Undefined);\n}\n\nfunction isOptional(symbol: ts.Symbol): boolean {\n  return !!(symbol.flags & ts.SymbolFlags.Optional);\n}\n\nfunction isMethod(symbol: ts.Symbol): boolean {\n  return !!(symbol.flags & ts.SymbolFlags.Method);\n}\n\nfunction isProperty(symbol: ts.Symbol): boolean {\n  return !!(symbol.flags & ts.SymbolFlags.Property);\n}\n\nfunction typeForSymbol(\n  symbol: ts.Symbol,\n  typeChecker: ts.TypeChecker,\n): [ts.Type, DocComment | undefined] {\n  if (symbol.declarations?.[0]) {\n    return [\n      typeChecker.getTypeOfSymbolAtLocation(symbol, symbol.declarations[0]),\n      getTsDoc(symbol.declarations[0]),\n    ];\n  } else {\n    return [typeChecker.getTypeOfSymbol(symbol), undefined];\n  }\n}\n\nfunction typeDetails(\n  type: ts.Type,\n  typeChecker: ts.TypeChecker,\n  options: { removeUndefined?: boolean } = {},\n): Writeable<AnyOf | Property> {\n  return typeDetailsInternal(type, typeChecker, new Set(), options);\n}\n\nfunction typeDetailsInternal(\n  type: ts.Type,\n  typeChecker: ts.TypeChecker,\n  seenTypes: Set<ts.Type>,\n  options: { removeUndefined?: boolean } = {},\n): Writeable<AnyOf | Property> {\n  if (seenTypes.has(type)) {\n    // If we are evaluating a type and see that type again, we don't want to\n    // infinitely recurse, so just emit the type's name and quit\n    return {\n      type: typeChecker.typeToString(type),\n    };\n  }\n  const originalType = type;\n  try {\n    seenTypes.add(originalType);\n    if (options.removeUndefined) {\n      if (isUnion(type)) {\n        const undefinedIndex = type.types.findIndex(isUndefined);\n        if (undefinedIndex > -1) {\n          if (type.types.length === 2) {\n            type = type.types[1 - undefinedIndex];\n          } else {\n            type = {\n              ...type,\n              types: type.types.filter((t) => !isUndefined(t)),\n            } as ts.UnionType;\n          }\n        }\n      }\n    }\n    // I have no idea why, but sometimes the TS compiler outputs booleans as\n    // `true | false` rather than `boolean`, so replace those\n    if (isUnion(type) && type.types.filter(isBooleanLiteral).length === 2) {\n      if (type.types.length === 2) {\n        return {\n          type: 'boolean',\n        };\n      }\n      type = {\n        ...type,\n        types: [\n          {\n            flags: ts.TypeFlags.Boolean,\n          },\n          ...type.types.filter((t) => !isBooleanLiteral(t)),\n        ],\n      } as ts.UnionType;\n    }\n    if (isUnion(type)) {\n      if (type.types.every(isStringLiteral)) {\n        // This is a string union, we express those as enums\n        return {\n          type: 'string',\n          enum: type.types.map((t) => t.value),\n        };\n      }\n      if (type.types.every(isPrimitiveType)) {\n        // A union of simple types, just put them in the array\n        return {\n          type: type.types.map((t) => typeChecker.typeToString(t)),\n        };\n      }\n      // At least one of the unioned types is more complicated, use an anyOf\n      return {\n        anyOf: type.types.map(\n          (t) =>\n            typeDetailsInternal(\n              t,\n              typeChecker,\n              seenTypes,\n            ) as Writeable<Property>,\n        ),\n      };\n    }\n    if (isArray(type)) {\n      return {\n        type: typeChecker.typeToString(type),\n        items: typeDetailsInternal(\n          typeChecker.getTypeArguments(type)[0],\n          typeChecker,\n          seenTypes,\n        ),\n      };\n    }\n    if (isTuple(type)) {\n      return {\n        type: typeChecker.typeToString(type),\n      };\n    }\n    if (\n      (isObject(type) || isIntersection(type)) &&\n      !isFunction(type) &&\n      (!(isBuiltInType(type) || isForeignType(type)) || isUtilityType(type)) &&\n      typeChecker.getPropertiesOfType(type).length > 0\n    ) {\n      const result: Writeable<PropertiesList> = {\n        properties: {},\n        propertyOrder: [],\n        required: [],\n      };\n      for (const prop of typeChecker.getPropertiesOfType(type)) {\n        const [propType, docs] = typeForSymbol(prop, typeChecker);\n        if (isHidden(docs)) {\n          continue;\n        }\n        result.properties[prop.getName()] = {\n          description: docs\n            ? containerToMarkdown(docs.summarySection, docs.customBlocks)\n            : undefined,\n          ...typeDetailsInternal(propType, typeChecker, seenTypes, {\n            removeUndefined: true,\n          }),\n        };\n        result.propertyOrder.push(prop.getName());\n        if (!isOptional(prop)) {\n          result.required!.push(prop.getName());\n        }\n      }\n      const typeToString = typeChecker.typeToString(type);\n      return {\n        // If typeToString starts with a brace, it doesn't have a name and it's\n        // just outputting the structure, so call it 'object'\n        type: typeToString.startsWith('{') ? 'object' : typeToString,\n        ...result,\n      };\n    }\n    return {\n      type: typeChecker.typeToString(type),\n    };\n  } finally {\n    seenTypes.delete(originalType);\n  }\n}\n\nfunction extractParameters(\n  declaration: ts.SignatureDeclaration,\n  typeChecker: ts.TypeChecker,\n): Writeable<PropertiesList> {\n  const result: Writeable<PropertiesList> = {\n    propertyOrder: [],\n    required: [],\n    properties: {},\n  };\n  const paramDocs = getTsDoc(declaration)?.params;\n  for (const parameter of declaration.parameters) {\n    const name = (parameter.name as ts.Identifier).getText();\n    const optional = typeChecker.isOptionalParameter(parameter);\n    const docBlock = paramDocs?.tryGetBlockByName(name);\n    result.properties[name] = {\n      description: docBlock ? containerToMarkdown(docBlock.content) : undefined,\n      ...typeDetails(typeChecker.getTypeAtLocation(parameter), typeChecker, {\n        removeUndefined: optional,\n      }),\n    };\n    result.propertyOrder.push(name);\n    if (!optional) {\n      result.required?.push(name);\n    }\n  }\n  return result;\n}\n\nfunction extractSingleFunctionDeclaration(\n  node: ts.Symbol,\n  declaration: ts.SignatureDeclaration,\n  typeChecker: ts.TypeChecker,\n): Writeable<SingleMethod> | undefined {\n  const docs = getTsDoc(declaration);\n  if (!docs) {\n    return undefined;\n  }\n  const signature = typeChecker.getSignatureFromDeclaration(declaration)!;\n  return {\n    name: node.getName(),\n    summary: containerToMarkdown(docs.summarySection),\n    examples: extractExamples(docs.customBlocks),\n    parameters: extractParameters(declaration, typeChecker),\n    returns: {\n      description: docs.returnsBlock\n        ? containerToMarkdown(docs.returnsBlock.content)\n        : undefined,\n      ...typeDetails(signature.getReturnType(), typeChecker),\n    },\n  };\n}\n\nfunction extractFunction(\n  symbol: ts.Symbol,\n  typeChecker: ts.TypeChecker,\n): Writeable<Method> | undefined {\n  const declarations = (symbol.getDeclarations() ?? []).filter(\n    (d): d is ts.FunctionDeclaration | ts.MethodSignature =>\n      ts.isFunctionDeclaration(d) || ts.isMethodSignature(d),\n  );\n  if (declarations.length === 0) {\n    return undefined;\n  }\n  if (declarations.length === 1) {\n    return extractSingleFunctionDeclaration(\n      symbol,\n      declarations[0],\n      typeChecker,\n    );\n  } else {\n    return {\n      overloaded: true,\n      overloads: declarations\n        .filter((d) => ts.isMethodSignature(d) || !d.body)\n        .map((declaration) =>\n          extractSingleFunctionDeclaration(symbol, declaration, typeChecker),\n        )\n        .filter(isDefined),\n    };\n  }\n}\n\nfunction extractModule(\n  moduleSymbol: ts.Symbol,\n  typeChecker: ts.TypeChecker,\n): Namespace {\n  const result: Namespace = {};\n  typeChecker.getExportsOfModule(moduleSymbol).forEach((exported) => {\n    switch (exported.flags) {\n      case ts.SymbolFlags.Alias: {\n        const aliased = typeChecker.getAliasedSymbol(exported);\n        switch (aliased.flags) {\n          case ts.SymbolFlags.ValueModule:\n            result[exported.getName()] = extractModule(aliased, typeChecker);\n            break;\n          case ts.SymbolFlags.Interface:\n            processInterface(aliased, typeChecker, result);\n            break;\n        }\n        break;\n      }\n      case ts.SymbolFlags.Interface:\n      case ts.SymbolFlags.TypeAlias: {\n        processInterface(exported, typeChecker, result);\n        break;\n      }\n      case ts.SymbolFlags.Function: {\n        const method = extractFunction(exported, typeChecker);\n        if (method) {\n          result[exported.getName()] = method;\n        }\n        break;\n      }\n    }\n  });\n  return result;\n}\n\nfunction processInterface(\n  exported: ts.Symbol,\n  typeChecker: ts.TypeChecker,\n  result: Namespace,\n): void {\n  const ifaceData: Writeable<Interface> = {\n    name: exported.getName(),\n    methods: { methodOrder: [], required: [], methods: {} },\n    properties: {\n      properties: {},\n      propertyOrder: [],\n      required: [],\n    },\n  };\n  const type = typeChecker.getDeclaredTypeOfSymbol(exported);\n  for (const member of typeChecker.getPropertiesOfType(type)) {\n    if (isFromBuiltInType(member)) {\n      continue;\n    }\n    if (isProperty(member)) {\n      const [memberType, docs] = typeForSymbol(member, typeChecker);\n      if (isHidden(docs)) {\n        continue;\n      }\n      ifaceData.properties.properties[member.getName()] = {\n        ...typeDetails(memberType, typeChecker, {\n          removeUndefined: isOptional(member),\n        }),\n        description: docs\n          ? containerToMarkdown(docs.summarySection, docs.customBlocks)\n          : undefined,\n      };\n      ifaceData.properties.propertyOrder.push(member.getName());\n      if (!isOptional(member)) {\n        ifaceData.properties.required!.push(member.getName());\n      }\n    } else if (isMethod(member)) {\n      const method = extractFunction(member, typeChecker);\n      if (method) {\n        ifaceData.methods.methods[member.getName()] = method;\n        ifaceData.methods.methodOrder.push(member.getName());\n        if (!isOptional(member)) {\n          ifaceData.methods.required.push(member.getName());\n        }\n      }\n    }\n  }\n  // Don't bother outputting any types that are uninteresting\n  if (\n    Object.keys(ifaceData.methods.methods).length > 0 ||\n    Object.keys(ifaceData.properties.properties).length > 0\n  ) {\n    result[exported.getName()] = ifaceData;\n  }\n}\n\nfunction packageToPath(sdkPackage: string): string {\n  return path.resolve(`opensource/sdk-js/packages/${sdkPackage}/index.ts`);\n}\n\nfunction extractPackage(sdkPackage: string, tsProgram: ts.Program): Namespace {\n  const typeChecker = tsProgram.getTypeChecker();\n  const sourceFile = tsProgram.getSourceFile(packageToPath(sdkPackage))!;\n  return extractModule(\n    typeChecker.getSymbolAtLocation(sourceFile)!,\n    typeChecker,\n  );\n}\n\nconst PACKAGES = [\n  'types',\n  'react',\n  'chatbot-base',\n  'chatbot-anthropic',\n  'chatbot-openai',\n];\n\nconst main = async () => {\n  // Compile the code\n\n  const tsCompilerHost = {\n    ...ts.createCompilerHost({}),\n\n    // make sure we don't write files\n    writeFile: () => {},\n\n    // don't give it access to any directories\n    getDirectories: () => [],\n  };\n  const tsProgram = ts.createProgram(\n    PACKAGES.map(packageToPath),\n    {\n      target: ts.ScriptTarget.ES2021,\n      moduleResolution: ts.ModuleResolutionKind.NodeJs,\n      strictNullChecks: true,\n    },\n    tsCompilerHost,\n  );\n\n  // Extract the TSDoc for the docs\n\n  const schemaOut = Object.fromEntries(\n    PACKAGES.map((p) => [p, extractPackage(p, tsProgram)]),\n  );\n\n  console.log(\n    await prettier.format(\n      `\n// @generated\n// npm run docs-codegen\n/* eslint-disable */\nexport default ${JSON.stringify(schemaOut)} as const;`,\n      { filepath: 'out.ts', ...(await prettier.resolveConfig('out.ts')) },\n    ),\n  );\n};\n\nPromise.resolve(main()).catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n", "import md5 from 'blueimp-md5';\nimport jsonStableStringify from 'fast-json-stable-stringify';\nimport { unique } from 'radash';\nimport shajs from 'sha.js';\nimport dayjs from 'dayjs';\nimport Calendar from 'dayjs/plugin/calendar.js';\nimport isBetween from 'dayjs/plugin/isBetween.js';\n\nimport type {\n  UUID,\n  MessageContent,\n  ReferencedUserData,\n} from 'common/types/index.ts';\nimport { MessageNodeType } from 'common/types/index.ts';\nimport {\n  CORD_PLATFORM_ORG_ID,\n  CORD_ADMIN_PLATFORM_ORG_ID,\n  GILLIAN_TEST_SLACK_ORG_ID,\n  RADICAL_ORG_ID,\n  RADICAL_TEST_ORG_ID,\n  KAT_TEST_SLACK_ORG_ID,\n  CORD_SLACK_TEAM_ID,\n  CORD_TEST_SLACK_TEAM_ID,\n} from 'common/const/Ids.ts';\nimport {\n  getMessageNodeChildren,\n  textFromNodeRecursive,\n} from '@cord-sdk/react/common/lib/messageNode.ts';\nimport { trimStart } from '@cord-sdk/react/common/lib/trim.ts';\n\nconst uuidRegex =\n  /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;\n\nexport const isEmployee = (orgID: UUID | undefined) =>\n  orgID === RADICAL_ORG_ID ||\n  orgID === RADICAL_TEST_ORG_ID ||\n  orgID === CORD_PLATFORM_ORG_ID ||\n  orgID === GILLIAN_TEST_SLACK_ORG_ID ||\n  orgID === KAT_TEST_SLACK_ORG_ID ||\n  orgID === CORD_ADMIN_PLATFORM_ORG_ID ||\n  process.env.NODE_ENV === 'development';\n\nexport const isInternalSlackOrg = (slackTeamID: string | undefined) =>\n  slackTeamID === CORD_SLACK_TEAM_ID || slackTeamID === CORD_TEST_SLACK_TEAM_ID;\n\nexport const assertUUID = (value: string): UUID => {\n  if (!uuidRegex.test(value)) {\n    throw new Error(`Invalid UUID ${value}`);\n  } else {\n    return value;\n  }\n};\n\n/**\n * @deprecated MD5 is no longer secure, use sha256Hash instead.\n */\nexport function md5Hash(object: boolean | number | string | object) {\n  return md5(jsonStableStringify(object));\n}\n\nexport function sha256Hash(value: string) {\n  return shajs('sha256').update(value).digest('hex');\n}\nexport const SHA256_HASH_LENGTH = 64;\n\nexport function generateSalt() {\n  const buf = new Uint8Array(8);\n  crypto.getRandomValues(buf);\n  return Array.from(buf)\n    .map((b) => b.toString(16).padStart(2, '0'))\n    .join('');\n}\n\nexport function sha256HashAndSalt(\n  value: string,\n  salt: string = generateSalt(),\n) {\n  return 'sha256' + ':' + salt + ':' + sha256Hash(salt + ':' + value);\n}\n\nexport function prepareTextContent(textContent: string) {\n  return (\n    textContent\n      .trim()\n      .toLowerCase()\n      // Remove Zero Width No-Break Space (U+FEFF)\n      .replace(/[\\uFEFF\\n]/gm, '')\n  );\n}\n\nexport function doesTextQualify(text: string | undefined | null) {\n  return Boolean(text && text.length > 1 && text.trim());\n}\n\nexport function getSha256Salt(hash: string): string {\n  return hash?.split(':')[1] ?? '';\n}\n\nexport function matchesHash(value: string, hashWithSalt: string) {\n  return hashWithSalt === sha256HashAndSalt(value, getSha256Salt(hashWithSalt));\n}\n\nexport function isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nexport function isDefined<T>(value: T | null | undefined): value is T {\n  return value !== null && value !== undefined;\n}\n\nexport function getMentionedUserIDs(content: MessageContent): UUID[] {\n  let users: UUID[] = [];\n  for (const node of content) {\n    if (node.type === MessageNodeType.MENTION) {\n      users.push(node.user.id);\n    } else {\n      const children = getMessageNodeChildren(node);\n      if (children) {\n        users = [...users, ...getMentionedUserIDs(children)];\n      }\n    }\n  }\n\n  return unique(users);\n}\n\nexport function getReferencedUserIDs(content: MessageContent): UUID[] {\n  const accumulator = new Set<UUID>();\n  gatherReferencedUserIDs(content, accumulator);\n  return [...accumulator];\n}\n\nfunction gatherReferencedUserIDs(\n  nodes: MessageContent,\n  accumulator: Set<UUID>,\n) {\n  for (const node of nodes) {\n    if (\n      node.type === MessageNodeType.MENTION ||\n      node.type === MessageNodeType.ASSIGNEE\n    ) {\n      accumulator.add(node.user.id);\n      continue;\n    }\n    const children = getMessageNodeChildren(node);\n    if (children) {\n      gatherReferencedUserIDs(children, accumulator);\n    }\n  }\n}\n\nexport function getReferencedUserIDsAndNames(\n  content: MessageContent,\n): ReferencedUserData[] {\n  const accumulator = new Map<UUID, string>();\n  gatherReferencedUserIDsAndName(content, accumulator);\n  return [...accumulator].map(([id, name]) => ({ id, name }));\n}\n\nfunction gatherReferencedUserIDsAndName(\n  nodes: MessageContent,\n  accumulator: Map<UUID, string>,\n) {\n  for (const node of nodes) {\n    if (\n      node.type === MessageNodeType.MENTION ||\n      node.type === MessageNodeType.ASSIGNEE\n    ) {\n      const userID = node.user.id;\n      const name = trimStart(textFromNodeRecursive(node), '@');\n      accumulator.set(userID, name);\n      continue;\n    }\n    const children = getMessageNodeChildren(node);\n    if (children) {\n      gatherReferencedUserIDsAndName(children, accumulator);\n    }\n  }\n}\n\n// JS replaceAll not well supported yet: https://caniuse.com/?search=replaceAll\nexport function replaceAll(str: string, replace: string, replaceWith: string) {\n  return str.split(replace).join(replaceWith);\n}\n\nexport type UserWithNames = {\n  displayName: string;\n  fullName: string;\n};\n\nexport type DisplayableUser = UserWithNames & {\n  id: UUID;\n  profilePictureURL: string | null;\n};\n\nexport function assert(predicate: boolean, message: string): asserts predicate {\n  if (!predicate) {\n    throw new Error(message);\n  }\n}\n\n/**\n * Returns the supplied items using the specified combiner.\n *\n * @example\n * // Returns \"foo, bar, or baz\"\n * combine(\"or\", [\"foo\", \"bar\", \"baz\"])\n */\nexport function combine(combiner: string, items: string[]): string {\n  if (items.length === 0) {\n    return '';\n  } else if (items.length === 1) {\n    return items[0];\n  } else if (items.length === 2) {\n    return `${items[0]} ${combiner} ${items[1]}`;\n  } else {\n    return `${items.slice(0, -1).join(', ')}, ${combiner} ${\n      items[items.length - 1]\n    }`;\n  }\n}\n\nexport const CORD_DEEP_LINK_THREAD_QUERY_PARAM = 'cord_thread';\nexport const CORD_DEEP_LINK_MESSAGE_QUERY_PARAM = 'cord_message';\nexport const CORD_DEEP_LINK_QUERY_PARAM = 'cord_link';\n\nexport const CORD_ARGS_TO_REMOVE = [\n  // delete deeplinking query params from urls. We dont want them as part of\n  // the pageContext\n\n  // old deeplinking query params. Keep here to support old deeplinks.\n  CORD_DEEP_LINK_THREAD_QUERY_PARAM,\n  CORD_DEEP_LINK_MESSAGE_QUERY_PARAM,\n\n  // new (unified) deeplinking query param\n  CORD_DEEP_LINK_QUERY_PARAM,\n];\n\nexport function extractDeepLinkQueryParams(\n  url: string,\n): { threadID: UUID; messageID: UUID } | null {\n  try {\n    const parsed = new URL(url);\n    return extractDeepLinkQueryParamsV1(parsed);\n  } catch (e) {\n    return null;\n  }\n}\n\n// also see injectDeeplinkQueryParamsV1()\nfunction extractDeepLinkQueryParamsV1(\n  url: URL,\n): { threadID: UUID; messageID: UUID } | null {\n  const [version, threadID, messageID]: (string | undefined)[] = (\n    url.searchParams.get(CORD_DEEP_LINK_QUERY_PARAM) ?? ''\n  ).split('_');\n\n  if (version !== 'v1' || !threadID || !messageID) {\n    return null;\n  }\n\n  return {\n    threadID,\n    messageID,\n  };\n}\n\ndayjs.extend(Calendar);\ndayjs.extend(isBetween);\n\nfunction getNowTimestamp() {\n  return dayjs(new Date(Date.now()));\n}\n\nexport function isTimestampTodayOrInTheFuture(timestamp: string) {\n  const now = getNowTimestamp();\n  return (\n    dayjs(timestamp).isSame(dayjs(now), 'day') ||\n    dayjs(timestamp).isAfter(dayjs(now), 'day')\n  );\n}\n\nexport function isTimestampFromPastSevenDays(timestamp: string) {\n  const now = getNowTimestamp();\n  const sevenDaysBefore = now.subtract(7, 'day');\n\n  return (\n    dayjs(timestamp).isBetween(now, sevenDaysBefore, 'day') ||\n    dayjs(timestamp).isSame(sevenDaysBefore, 'date')\n  );\n}\n\nexport function isTimestampFromPastThirtyDays(timestamp: string) {\n  const now = getNowTimestamp();\n  const thirtyDaysBefore = now.subtract(30, 'day');\n\n  return (\n    dayjs(timestamp).isBetween(now, thirtyDaysBefore) ||\n    dayjs(timestamp).isSame(thirtyDaysBefore, 'date')\n  );\n}\n\nexport function isTimestampFromPastThreeMonths(timestamp: string) {\n  const now = getNowTimestamp();\n  const threeMonthsBefore = now.subtract(3, 'month');\n  return (\n    dayjs(timestamp).isBetween(now, threeMonthsBefore) ||\n    dayjs(timestamp).isSame(threeMonthsBefore, 'day')\n  );\n}\n\nexport function isTimestampFromPastYear(timestamp: string) {\n  const now = getNowTimestamp();\n  const pastYear = now.subtract(1, 'year');\n  return (\n    dayjs(timestamp).isBetween(now, pastYear) ||\n    dayjs(timestamp).isSame(pastYear, 'day')\n  );\n}\n\nexport function isTimestampMoreThanAYearAgo(timestamp: string) {\n  const now = getNowTimestamp();\n  const pastYear = now.subtract(1, 'year');\n  return dayjs(timestamp).isBefore(pastYear, 'day');\n}\n\nexport function createDefaultSenderEmailName(applicationName: string) {\n  return applicationName.toLowerCase().split(/\\W/).join('') + '-notifications';\n}\n\n/**\n * in both the console UI and the API we don't allow editing the whole sender\n * field on customEmailTemplate, but only specific parts of it. This function\n * takes a 'sender' input and returns parts of the email.\n *\n * @example\n * const input = 'Cord <hello@cord.com>';\n * getEmailInfoFromSenderData(input); // {emailAddress: \"hello@cord.com\", domain: \"cord.com\", username: \"hello\" }\n */\ntype SenderInfo = {\n  domain: string;\n  emailAddress: string;\n  username: string;\n};\nexport function getEmailInfoFromSenderData(\n  sender?: string,\n): SenderInfo | undefined {\n  if (!sender) {\n    return undefined;\n  }\n\n  const mentionMatchingPattern = new RegExp(\n    '(<)' + // first match a \"<\"\n      '([^@]+)' + // then match anything that's not an @ symbol and is at least 1 char\n      '(@)' + // then match the @ so we can just access the domain itself easily\n      '([^>]+)', // then match anything that's not an > symbol and is at least 1 char\n    'gm',\n  );\n\n  let info: SenderInfo | undefined = undefined;\n  let match: RegExpExecArray | null;\n\n  while ((match = mentionMatchingPattern.exec(sender))) {\n    info = {\n      username: match[2],\n      domain: match[4],\n      emailAddress: match[0].substring(1),\n    };\n  }\n\n  return info;\n}\n\nexport function capitalizeFirstLetter(string: string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n", "// See #8935:\n/// <reference lib=\"es2022\" />\n\nimport type OpenAI from 'openai';\n\nimport jsonStableStringify from 'fast-json-stable-stringify';\nimport type { Placement } from '@floating-ui/react-dom';\nimport { isEqual } from '@cord-sdk/react/common/lib/fast-deep-equal.ts';\n\nexport type {\n  DocumentAnnotationResult,\n  Screenshot,\n  DocumentLocation,\n  LocationTextConfig,\n  HighlightedTextConfig,\n  AdditionalTargetData,\n  Annotation,\n  AnnotationWithThreadID,\n  AnnotationCapturePosition,\n} from '@cord-sdk/types';\nexport { locationJson } from '@cord-sdk/types';\nimport { locationJson, MessageNodeType } from '@cord-sdk/types';\nimport type {\n  FlatJsonObject,\n  LocationFilterOptions,\n  ResolvedStatus,\n  MessageAnnotation,\n  ElementIdentifierVersion,\n  EntityMetadata,\n  NotificationListFilter,\n  ThreadListFilter,\n  JsonValue,\n  JsonObject,\n  MessageContent,\n  MessageNode,\n  ViewerThreadStatus,\n} from '@cord-sdk/types';\n\nexport type {\n  MessageAnnotation,\n  ElementIdentifierVersion,\n  EntityMetadata,\n  NotificationListFilter,\n  ThreadListFilter,\n  JsonValue,\n  JsonObject,\n};\n\nexport type SimpleTranslationParameters = FlatJsonObject;\n\nexport enum DataTableQueries {\n  ADMIN_USERS = 'admin_users',\n  SET_ADMIN = 'set_admin',\n  USER_DETAILS = 'user_details',\n  ORG_DETAILS = 'org_details',\n  APP_DETAILS = 'app_details',\n  THREAD_DETAILS = 'thread_details',\n  MESSAGE_DETAILS = 'message_details',\n  CUSTOMER_DETAILS = 'customer_details',\n  ORG_MEMBER_DETAILS = 'org_member_details',\n  ID_SEARCH = 'id_search',\n  PROD_APPLICATIONS = 'prod_applications',\n  STAGING_APPLICATIONS = 'staging_applications',\n  SAMPLE_APPLICATIONS = 'sample_applications',\n  VERIFIED_CUSTOMERS = 'verified_customers',\n  SAMPLE_CUSTOMERS = 'sample_customers',\n  DEPLOYS = 'deploys',\n  PAGE_CONTEXTS = 'page_contexts',\n  BROWSER_METRICS = 'browser_metrics',\n  OS_METRICS = 'os_metrics',\n  GO_REDIRECTS = 'go_redirects',\n}\n\nexport type NonNullableKeys<T, K extends keyof T> = T & {\n  [P in K]: NonNullable<T[P]>;\n};\n\nexport type NullableKeys<T, K extends keyof T> = Omit<T, K> & {\n  [P in K]: T[P] | null;\n};\n\nexport type ElementOf<T extends Array<any>> = T[number];\n\n/**\n * A mapping type that effectively combines Required<T> and NonNullable<T> to\n * turn { foo?: string | undefined } into { foo: string }\n */\n// NOTE(9/9/2021): This is equivalent to Required<T> if we compiled with\n// --strictNullChecks, but we currently don't\nexport type ReallyRequired<T> = {\n  [P in keyof T]-?: NonNullable<T[P]>;\n};\n\nexport type { MessageContent, MessageNode };\nexport { MessageNodeType };\n\nexport type UUID = string;\n\nexport type Location = {\n  [k: string]: string | number | boolean;\n};\n\nexport type SortDirection = 'ascending' | 'descending';\n\nexport function isValidFlatJsonObject(obj: any): obj is FlatJsonObject {\n  if (!obj) {\n    return false;\n  }\n  if (typeof obj !== 'object' || Array.isArray(obj)) {\n    return false;\n  }\n  for (const [_, value] of Object.entries(obj)) {\n    const t = typeof value;\n    if (t !== 'string' && t !== 'number' && t !== 'boolean') {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isLocation(obj: any): obj is Location {\n  return isValidFlatJsonObject(obj);\n}\n\nexport function isValidMetadata(obj: any): obj is EntityMetadata {\n  return isValidFlatJsonObject(obj);\n}\n\nexport function toLocation(obj: any): Location | null {\n  return isLocation(obj) ? obj : null;\n}\n\n// We receive location as either Location or LocationFilterOptions from\n// our apis. Since Location type can be flat object with multiple properties\n// we have to check the property type to make sure we're getting the right value.\n// eg: {value: 'foo', ...} is Location\n// while {value: {value: 'foo'} ...} is LocationFilterOptions\nexport function getLocationFilter(\n  obj: LocationFilterOptions | Location | undefined,\n): LocationFilterOptions | undefined {\n  if (!obj) {\n    return undefined;\n  }\n\n  if (isLocation(obj)) {\n    return { value: obj, partialMatch: false };\n  }\n\n  if (isLocation(obj.value)) {\n    return obj;\n  }\n  return undefined;\n}\n\n// Function to convert our external resolvedStatus filter enum\n// to our internal 'resolved' boolean property\nexport function getResolvedFromStatus(\n  status: ResolvedStatus,\n): boolean | undefined {\n  // we've not included a fallback value as this will just increase the chances\n  // of returning the wrong data somewhere. So we make sure to pass whatever\n  // we've said the default is for the API that's calling this.\n  switch (status) {\n    case 'resolved': {\n      return true;\n    }\n    case 'unresolved': {\n      return false;\n    }\n    case 'any': {\n      return undefined;\n    }\n    default: {\n      const unhandledStatus: never = status;\n      throw new Error('Invalid resolved status type ' + unhandledStatus);\n    }\n  }\n}\n\nexport function getViewerThreadFilter(\n  viewerStatus: ViewerThreadStatus | ViewerThreadStatus[] | undefined,\n): ViewerThreadStatus[] {\n  if (!viewerStatus) {\n    return [];\n  }\n  if (typeof viewerStatus === 'string') {\n    return [viewerStatus];\n  }\n  return viewerStatus;\n}\n\nexport function metadataMatches(\n  metadata: EntityMetadata,\n  matcher: EntityMetadata,\n): boolean {\n  for (const [key, value] of Object.entries(matcher)) {\n    if (metadata[key] !== value) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function locationMatches(context: Location, matcher: Location): boolean {\n  for (const [key, value] of Object.entries(matcher)) {\n    if (context[key] !== value) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction flatJsonObjectEqual(\n  a: FlatJsonObject | null,\n  b: FlatJsonObject | null,\n): boolean {\n  if (a === null && b === null) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  if (Object.keys(a).length !== Object.keys(b).length) {\n    return false;\n  }\n  for (const [key, value] of Object.entries(a)) {\n    if (b[key] !== value) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function locationEqual(a: Location | null, b: Location | null): boolean {\n  return flatJsonObjectEqual(a, b);\n}\n\nexport function metadataEqual(\n  a: EntityMetadata | null,\n  b: EntityMetadata | null,\n): boolean {\n  return flatJsonObjectEqual(a, b);\n}\n\n/**\n * Implements the canonical comparison for locations.  Currently, this sorts by\n * number of elements, then the JSON representation alphabetically, but we can\n * change that if we come up with something better.\n */\nexport function locationCompare(a: Location, b: Location): number {\n  const lengthA = Object.keys(a).length;\n  const lengthB = Object.keys(b).length;\n  if (lengthA !== lengthB) {\n    return lengthA - lengthB;\n  }\n  return locationJson(a).localeCompare(locationJson(b));\n}\n\nexport type PageContext = {\n  providerID: UUID | null;\n  data: Location;\n};\n\nexport function pageContextEqual(\n  a: PageContext | null,\n  b: PageContext | null,\n): boolean {\n  if (a === null && b === null) {\n    return true;\n  }\n  if (a === null || b === null) {\n    return false;\n  }\n  // Two contexts from different providers are never equal\n  if (a.providerID !== b.providerID) {\n    return false;\n  }\n  // If either has data, compare the data, otherwise compare the locations\n  return isEqual(a.data, b.data);\n}\n\n// This returns a string key that is equivalent from an equality perspective to\n// comparing the pageContexts.  Specifically, the intention is that\n// pageContextEqual(a, b) === (pageContextKey(a) === pageContextKey(b))\n\n// The functioning of this depends a lot on our specific logic of\n// building PageContexts, such that, for instance,\n// a.location === b.location => a.providerID === b.providerID.\n\n// It also needs to stay consistent with the logic in server/src/util/hash.ts.\nexport function pageContextKey(pageContext: PageContext): string {\n  return jsonStableStringify({\n    providerID: pageContext.providerID,\n    data: pageContext.data,\n  });\n}\n\n/**\n * Convert a PageContext-like object into an actual PageContext.\n *\n * The PageContext types that we exchange with GraphQL allow nullable fields to\n * be undefined as well. This function takes such objects and returns a valid\n * PageContext.\n */\ntype PageContextLike = {\n  providerID?: UUID | null;\n  data: Location;\n};\nexport function toPageContext(pageContext: PageContextLike): PageContext;\nexport function toPageContext(pageContext: null | undefined): null;\nexport function toPageContext(\n  pageContext: PageContextLike | null | undefined,\n): PageContext | null;\nexport function toPageContext(\n  pageContext: PageContextLike | null | undefined,\n): PageContext | null {\n  if (!pageContext) {\n    return null;\n  }\n  const { providerID, data } = pageContext;\n  if (!isLocation(data)) {\n    throw new Error('Invalid context');\n  }\n  return {\n    providerID: providerID ?? null,\n    data,\n  };\n}\n\nexport type OrgMemberState = 'active' | 'inactive' | 'deleted'; // must match the keys in OrgMemberStateEnumType\n\nexport type UserType = 'person' | 'bot'; // must match the keys in UserTypeEnumType\n\nexport type UserState = 'active' | 'deleted'; // must match the keys in UserStateEnumType\n\nexport type ImportedSlackMessageType = 'reply' | 'supportBotReply'; // must match the keys in ImportedSlackMessageTypeEnumType\n\nexport type MessageType = 'action_message' | 'user_message'; //must match the keys in MessageTypeEnumType\n\nexport interface Todo {\n  id: UUID;\n  done: boolean;\n}\n\nexport enum MessageAttachmentType {\n  FILE = 'file',\n  ANNOTATION = 'annotation',\n  SCREENSHOT = 'screenshot',\n}\n\nexport const MessageAnnotationAttachmentTypeName =\n  'MessageAnnotationAttachment';\n\nexport function parseElementIdentifierVersion(\n  val: string,\n): ElementIdentifierVersion | null {\n  if (val === '1' || val === '2') {\n    return val;\n  }\n  return null;\n}\n\nexport enum ElementIdentifierMatch {\n  EXACT = 'exact',\n  PARTIAL = 'partial',\n  NONE = 'none',\n}\n\nexport enum LocationMatch {\n  EXACT = 'exact',\n  SIBLING = 'sibling',\n  MULTIMEDIA = 'multimedia',\n  CHART = 'chart',\n  STALE = 'stale',\n  MAYBE_STALE = 'maybe_stale',\n  NONE = 'none',\n  // User has old extension, and does not have the latest identifier version\n  INCOMPATIBLE_IDENTIFIER_VERSION = 'incompatible_identifier_version',\n  // Used if fallback document coordinates are included, and we don't have an exact/sibling match\n  DOCUMENT_COORDINATES = 'document_coordinates',\n  // If we weren't able to annotate, so we're instead relying on the screenshot\n  // Examples: annotating a pdf, annotating an iframe we can't access\n  UNAVAILABLE = 'unavailable',\n  // If the annotation was on an inaccessible cross-domain iframe. We want to\n  // show it while the message is being drafted, but not after it's been posted\n  INACCESSIBLE_CROSS_DOMAIN_IFRAME = 'inaccessible_cross_domain_iframe',\n  OUTSIDE_ACCESSIBLE_VIRTUALISED_LIST = 'outside_accessible_virtualised_list',\n  OUTSIDE_INACCESSIBLE_VIRTUALISED_LIST = 'outside_inaccessible_virtualised_list',\n}\n\nexport function annotationHasLocation(annotation: MessageAnnotation) {\n  return annotation.location !== null || annotation.customLocation !== null;\n}\n\nexport const ThreadCreatedTypeName = 'ThreadCreated';\nexport const ThreadMessageAddedTypeName = 'ThreadMessageAdded';\nexport const ThreadMessageUpdatedTypeName = 'ThreadMessageUpdated';\nexport const ThreadMessageContentAppendedTypeName =\n  'ThreadMessageContentAppended';\nexport const ThreadMessageRemovedTypeName = 'ThreadMessageRemoved';\nexport const ThreadParticipantsUpdatedIncrementalTypeName =\n  'ThreadParticipantsUpdatedIncremental';\nexport const ThreadTypingUsersUpdatedTypeName = 'ThreadTypingUsersUpdated';\nexport const ThreadShareToSlackTypeName = 'ThreadShareToSlack';\nexport const ThreadPropertiesUpdatedTypeName = 'ThreadPropertiesUpdated';\nexport const ThreadSubscriberUpdatedTypeName = 'ThreadSubscriberUpdated';\nexport const ThreadDeletedTypeName = 'ThreadDeleted';\n\nexport const PageThreadAddedTypeName = 'PageThreadAdded';\nexport const PageThreadDeletedTypename = 'PageThreadDeleted';\nexport const PageThreadReplyAddedTypeName = 'PageThreadReplyAdded';\nexport const PageVisitorsUpdatedTypeName = 'PageVisitorsUpdated';\nexport const PageThreadResolvedTypeName = 'PageThreadResolved';\nexport const PageThreadUnresolvedTypeName = 'PageThreadUnresolved';\nexport const ThreadFilterablePropertiesMatchTypeName =\n  'ThreadFilterablePropertiesMatch';\nexport const ThreadFilterablePropertiesUnmatchTypeName =\n  'ThreadFilterablePropertiesUnmatch';\n\nexport const NotificationAddedTypeName = 'NotificationAdded';\nexport const NotificationReadStateUpdatedTypeName =\n  'NotificationReadStateUpdated';\nexport const NotificationDeletedTypeName = 'NotificationDeleted';\n\nexport const OrgMemberAddedTypeName = 'OrgMemberAdded';\nexport const OrgMemberRemovedTypeName = 'OrgMemberRemoved';\n\nexport const ConsoleGettingStartedUpdatedTypeName =\n  'ConsoleGettingStartedUpdated';\n\nexport const CustomerSubscriptionUpdatedTypeName =\n  'CustomerSubscriptionUpdated';\n\nexport type FileAttachmentInput = {\n  id: UUID;\n  fileID: UUID;\n};\n\n// Subset of winston log levels, which can be found in NpmConfigSetLevels type in winston type file\nexport enum LogLevel {\n  ERROR = 'error',\n  WARN = 'warn',\n  INFO = 'info',\n  DEBUG = 'debug',\n}\n\nexport type PopperPosition = Placement;\n\n// called when the sidebar shows and hides, with a reference to the Cord iframe\n// expected to make domain-specific document adjustments to accommodate the sidebar\n// in its two states (expanded / not).\nexport type DocumentMutator = (width: number | null) => void;\n\n// called with the document to initialize any mutator-specific elements and behavior\n// expected to return the actual mutator function\nexport type DocumentMutatorInitializer = (\n  document: Document,\n) => DocumentMutator;\n\nexport type SimpleValue = string | number | boolean;\n\nexport type PreferencesValueType = JsonValue;\n\nexport type PreferencesType = JsonObject;\n\nexport enum UserReference {\n  MENTION = 'mention',\n  ASSIGNEE = 'assignee',\n}\n\nexport type RuleProviderInfo = {\n  id: UUID; // the ID of the provider, should be unique among providers\n  name: string; // the name of the provider\n  iconURL?: string | null; // URL for a favicon-like image\n  nuxText?: string | null; // the text to show the user teaching them how to use Radical on this specific provider\n  disableAnnotations?: boolean; // if annotations should be disabled for this provider. example: slack static PDFs where due to the chrome pdf viewer we don't have access to the scroll position\n};\n\n// a ruleset provider should export all the rules specific to a SaaS, even when\n// those rules span across different domain names.\nexport type RuleProvider = RuleProviderInfo & {\n  domains: string[]; // the domains that this provider's rules cover\n  rules: ProviderRule[]; // deny and approve rules\n  mergeHashWithLocation?: boolean; // a fix for providers like Snowflake who have URLs with query parameters after the # in the URL\n  visibleInDiscoverToolsSection: boolean; // the state of wether the tool is visible in th Discover tools section in the NUX flow, i.e. internal tools should not be included, localhost should not be included\n  platformApplicationID: UUID | null; // Application ID of provider, if relevant\n\n  // the functions to call to mutate the document to make room for the sidebar.\n  // this is a list to allow per-domain granularity.\n  documentMutators: ProviderDocumentMutator[];\n};\n\nexport type ProviderRule = {\n  id: UUID;\n  type: ProviderRuleType;\n  matchPatterns: ProviderRuleMatchPatterns;\n  nameTemplate: string | null;\n  contextTransformation: PageContextTransformation;\n  observeDOMMutations: boolean;\n};\n\nexport type ProviderDocumentMutator =\n  | { id: UUID; type: 'default_css'; config: CSSMutatorConfig }\n  | { id: UUID; type: 'custom_css'; config: CSSMutatorConfig }\n  | { id: UUID; type: 'fixed_elements'; config: null };\n\nexport type ProviderDocumentMutatorType = ProviderDocumentMutator['type'];\n\nexport type CSSMutatorConfig = {\n  cssTemplate: string;\n};\n\nexport type ProviderRuleType = 'allow' | 'deny';\n\nexport type ProviderRuleMatchPatterns = {\n  protocol?: string;\n  domain?: string;\n  path?: string;\n  hash?: string;\n  queryParams?: { [key: string]: string };\n  selector?: string;\n  contains?: string;\n};\n\nexport type ProviderRuleTestMatchType = 'allow' | 'deny' | 'none';\n\nexport type PageDetails = {\n  pageContext: PageContext;\n  pageName: string | null;\n};\n\nexport type MatchResult = (\n  | {\n      match: 'allow' | 'deny';\n      ruleID: UUID;\n    }\n  | {\n      match: 'none';\n    }\n) &\n  PageDetails;\n\nexport type PageContextTransformationType =\n  | 'default'\n  | 'replace'\n  | 'extend'\n  | 'metabase';\n\nexport type PageContextTransformation = {\n  type: PageContextTransformationType;\n  data: JsonObject | null;\n};\n\nexport type ProvidersResult = {\n  ruleProviders: RuleProvider[];\n  version: string;\n};\n\nexport type DeepPartial<T> = {\n  [P in keyof T]?: DeepPartial<T[P]>;\n};\n\nexport type LinearTeam = {\n  id: string;\n  name: string;\n  projects: {\n    nodes: Array<{\n      id: string;\n      name: string;\n    }>;\n  };\n};\n\nexport type AtlassianProject = {\n  // expand: 'description,lead,issueTypes,url,projectKeys,permissions,insight',\n  id: string; // 10000\n  key: string; // STLR\n  name: string; // 'Stellar'\n  issueTypes: Array<{\n    id: string; //'10001'\n    // description: 'Tasks track small, distinct pieces of work.';\n    name: string;\n    subtask: boolean;\n    // avatarId: 10318;\n    // hierarchyLevel: 0;\n  }>;\n  simplified: boolean;\n  style: string; // 'next-gen'\n  isPrivate: boolean;\n  entityId: UUID;\n  uuid: UUID;\n};\n\nexport type MondayBoard = {\n  id: string;\n  name: string;\n  subitem_board?: {\n    id: string;\n  };\n  groups: Array<{\n    id: string;\n    title: string;\n    position: string;\n  }>;\n};\n\nexport type JiraConnectionPreferences = {\n  projectID: string;\n  issueType: string;\n  subissueType?: string;\n};\n\nexport type AsanaConnectionPreferences = {\n  projectID: string | undefined;\n};\n\nexport type MondayConnectionPreferences = {\n  boardID: string;\n  groupID?: string;\n};\n\ntype TrelloList = {\n  id: UUID;\n  name: string;\n  closed?: string;\n  pos?: number;\n  softLimit?: string;\n  idBoard?: UUID;\n  subscriber: boolean;\n};\n\ntype TrelloBoard = {\n  id: UUID;\n  name: string;\n  idOrganization: UUID;\n  lists: TrelloList[];\n};\n\ntype TrelloOrg = {\n  id: UUID;\n  name: string;\n};\n\nexport type TrelloConnectionPreferencesType = {\n  id: UUID;\n  email: string;\n  boards: TrelloBoard[];\n  organizations: TrelloOrg[];\n};\n\nexport type TrelloCard = {\n  name: string;\n  desc: string;\n  idList: UUID;\n};\n\nexport type AsanaProject = {\n  gid: string;\n  name: string;\n};\n\nexport type JiraIssuePreviewData = {\n  key: string;\n  title: string;\n  url: string;\n  assignee: string | undefined;\n  status: string;\n  done: boolean;\n  priority: string;\n  subtasks: Array<{\n    id: string;\n    title: string;\n    done: boolean;\n  }>;\n};\n\nexport type AsanaTaskPreviewData = {\n  title: string;\n  url: string;\n  assignee: string | undefined;\n  done: boolean;\n};\n\nexport type LinearIssuePreviewData = {\n  title: string;\n  identifier: string;\n  url: string;\n  assignee: string | undefined;\n  status: string;\n  priority: string;\n  done: boolean;\n  orgName: string | undefined;\n};\n\nexport type MondayItemPreviewData = {\n  title: string;\n  url: string;\n  assignee: string | undefined;\n  done: boolean;\n  assigneeColumnID: string | undefined;\n  statusColumnID: string | undefined;\n};\n\nexport type TaskPreviewData =\n  | AsanaTaskPreviewData\n  | JiraIssuePreviewData\n  | LinearIssuePreviewData\n  | MondayItemPreviewData;\n\nexport enum LinearIssueStateTypes {\n  BACKLOG = 'backlog',\n  TODO = 'unstarted',\n  IN_PROGRESS = 'started',\n  DONE = 'completed',\n  CANCELED = 'canceled',\n}\n\nexport type LinearConnectionPreferences = {\n  teamID: string;\n  projectID?: string;\n};\n\nexport type APICordTokenData = {\n  session_id: UUID;\n};\n\nexport type AppServerAuthTokenData = {\n  app_id: UUID;\n};\n\nexport type CustomerServerAuthTokenData = {\n  customer_id: UUID;\n};\n\nexport type NotificationChannels = {\n  slack: boolean;\n  email: boolean;\n};\n\nexport type CustomLinks = {\n  learnMore?: string | null;\n  upgradePlan?: string | null;\n  leaveFeedback?: string | null;\n};\n\nexport type ThirdPartyAuth = 'slack' | 'google' | 'ms-teams';\n\nexport type OutboundNotificationType =\n  | 'slack'\n  | 'email'\n  | 'slackEmailMatched'\n  | 'sharedToSlackChannel'\n  | 'sharedToEmail';\n\nexport type { Point2D } from '@cord-sdk/types';\n\nexport type CustomNUXStepContent = {\n  title: string | null;\n  text: string | null;\n  imageURL: string | null;\n};\n\nexport type CustomNUX = {\n  initialOpen: CustomNUXStepContent | null;\n  welcome: CustomNUXStepContent | null;\n};\n\nexport type SlackOAuthLinkOrgState = {\n  data: {\n    userID: string;\n    orgID: string;\n    platformApplicationID: string;\n  };\n  type: 'link_org';\n  nonce: string;\n};\n\nexport type SlackOAuthConsoleUserState = {\n  data: {\n    platformApplicationID: string;\n  };\n  type: 'console_user';\n  nonce: string;\n};\n\nexport type SlackOAuthDecodeState =\n  | SlackOAuthLinkOrgState\n  | SlackOAuthConsoleUserState;\n\nexport type ThreadSupportStatusType = 'open' | 'closed';\n\nexport type UserWithOrgDetails = {\n  id: UUID;\n  externalID: string;\n  displayName: string;\n  fullName: string;\n  name: string | null;\n  shortName: string | null;\n  profilePictureURL: string | null;\n  metadata: EntityMetadata;\n  canBeNotifiedOnSlack: boolean;\n};\n\nexport type OutboundNotificationMetadata =\n  OutboundNotificationMetadataByType[OutboundNotificationType];\n\n// when adding new fields to existing metadata types, either make the new\n// fields optional or run a backfill migration\nexport type OutboundNotificationMetadataByType = {\n  slack: Record<string, never>;\n  email: Record<string, never>;\n  slackEmailMatched: Record<string, never>;\n  sharedToSlackChannel: {\n    type: 'sharedToSlackChannel';\n    targetSlackChannelID: string;\n  };\n  sharedToEmail: {\n    type: 'sharedToEmail';\n    targetEmail: string;\n  };\n};\n\n// Internal threads are the standard mirrored Slack threads\n// that users can share to their linked Slack org.\n// Support threads are the ones mirrored to a vendor's Slack org\n// and support channel after a support bot is mentioned.\nexport type ThreadMirrorType = 'internal' | 'support';\n\nexport type Tier = 'prod' | 'staging' | 'test' | 'dev';\n\nexport type SharedToSlackInfo = {\n  channel: string | null;\n  slackURL: string | null;\n};\n\nexport type ThreadMode =\n  // Only shows the first message, and optionally the number of replies\n  | 'collapsed'\n  // Can show all messages, also includes a composer to add a new message\n  | 'inline'\n  // Used in the sidebar only - thread spans across the whole page\n  | 'fullHeight'\n  // The initial state when we are creating a new thread - composer only\n  | 'newThread';\n\nexport type Announcement =\n  | 'welcome'\n  | 'completeProfile'\n  | 'connectOrgToSlack'\n  | 'linkProfileToSlack'\n  | 'slackIsConnected';\n\nexport type ReferencedUserData = { id: UUID; name: string };\n\nconst DEPLOYMENT_TYPES = ['sdk'] as const;\n\nexport type DeploymentType = (typeof DEPLOYMENT_TYPES)[number];\n\nexport function isDeploymentType(s: string): s is DeploymentType {\n  if (DEPLOYMENT_TYPES.includes(s as DeploymentType)) {\n    return true;\n  }\n  return false;\n}\n\nexport function toDeploymentType(\n  s: string | null | undefined,\n): DeploymentType | null {\n  if (s && isDeploymentType(s)) {\n    return s;\n  }\n  return null;\n}\n\nexport type ApplicationEnvironment =\n  | 'production'\n  | 'staging'\n  | 'sample' // console self-serve test (not paying) app\n  | 'sampletoken' // sample token apps created for docs integration guide and demo apps opensource repos (wiped periodically)\n  | 'demo'; // temporary token apps created for docs and cord.com demo apps (wiped periodically)\n\n// NB you there are some classes of token you might expect are environments,\n// but actually all belong to one appID:\n// The docs live components are all in the CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID app\n// The e2e tests are all in the CORD_AUTOMATED_TESTS_APPLICATION_ID app\n// The CORD_PLAYGROUND_APPLICATION_ID has been retired from service\n\nexport type EmptyJsonObject = Record<string, never>;\n\nexport type CustomerType = 'verified' | 'sample';\n\nexport type CustomerImplementationStage =\n  | 'launched'\n  | 'implementing'\n  | 'proof_of_concept'\n  | 'inactive';\n\nexport type AdminCRTComingFrom = 'them' | 'us';\n\nexport type AdminCRTDecision = 'done' | 'accepted' | 'rejected' | 'pending';\n\nexport type AdminCRTCommunicationStatus =\n  | 'none'\n  | 'request_acked'\n  | 'decision_sent'\n  | 'decision_acked';\n\nexport type AdminCRTIssueType = 'request' | 'bug' | 'onboarding_step';\n\nexport type AdminCRTPriority = 'blocker' | 'high' | 'low';\n\nexport type AdminCRTCustomerIssue = {\n  customerID: UUID;\n  title: string;\n  body: string;\n  comingFrom: AdminCRTComingFrom;\n  decision: AdminCRTDecision;\n  communicationStatus: AdminCRTCommunicationStatus;\n  lastTouch?: string;\n  type: AdminCRTIssueType;\n  priority: AdminCRTPriority;\n  externallyVisible: boolean;\n  assignee?: UUID;\n};\n\nexport type DocsCachedEmbedding = {\n  url: string;\n  plaintext: string;\n  embedding?: OpenAI.CreateEmbeddingResponse | undefined;\n};\n\nexport type CordDotComCachedEmbedding = DocsCachedEmbedding & {\n  title: string;\n};\n\n// This is for the mouse move events within iframes\nexport type IframeMouseMoveData = { x: number; y: number; frame_id: string };\n\nexport type Maybe<T> = T | null | undefined;\nexport type Nullable<T> = T | null;\n", "// This is for important URLs to all kinds of services\n\nexport const TOP_SERVER_HOST = process.env.TOP_SERVER_HOST!;\nexport const APP_SERVER_HOST = process.env.APP_SERVER_HOST!;\nexport const API_SERVER_HOST = process.env.API_SERVER_HOST!;\nexport const API_SERVER_HOST_PRODUCTION =\n  process.env.API_SERVER_HOST_PRODUCTION!;\nexport const ADMIN_SERVER_HOST = process.env.ADMIN_SERVER_HOST!;\nexport const CONSOLE_SERVER_HOST = process.env.CONSOLE_SERVER_HOST!;\nexport const MARKETING_SERVER_HOST = process.env.MARKETING_SERVER_HOST!;\nexport const CORD_TO_HOST = process.env.CORD_TO_HOST!;\nexport const AUTH0_CUSTOM_LOGIN_DOMAIN = process.env.AUTH0_CUSTOM_LOGIN_DOMAIN!;\nexport const DOCS_SERVER_HOST = process.env.DOCS_SERVER_HOST!;\nexport const SLACK_APP_REDIRECT_HOST = process.env.SLACK_APP_REDIRECT_HOST;\n\nexport const TOP_ORIGIN = 'https://' + process.env.TOP_SERVER_HOST;\nexport const APP_ORIGIN = 'https://' + process.env.APP_SERVER_HOST;\nexport const API_ORIGIN = 'https://' + process.env.API_SERVER_HOST;\nexport const ADMIN_ORIGIN = 'https://' + process.env.ADMIN_SERVER_HOST;\nexport const CONSOLE_ORIGIN = 'https://' + process.env.CONSOLE_SERVER_HOST;\nexport const MARKETING_ORIGIN = 'https://' + process.env.MARKETING_SERVER_HOST;\nexport const CORD_TO_ORIGIN = 'https://' + process.env.CORD_TO_HOST;\nexport const AUTH0_ORIGIN = 'https://' + process.env.AUTH0_CUSTOM_LOGIN_DOMAIN;\nexport const DOCS_ORIGIN = 'https://' + process.env.DOCS_SERVER_HOST;\nexport const DOCS_AI_CHATBOT_SERVER_HOST =\n  process.env.DOCS_AI_CHATBOT_SERVER_HOST;\nexport const COMMUNITY_ORIGIN = 'https://' + process.env.COMMUNITY_SERVER_HOST;\n\n// See https://github.com/getcord/interactive-demos\nexport const DEMO_APPS_WEBHOOK_URL =\n  'https://cord-interactive-demos.vercel.app/events';\n", "import { DOCS_ORIGIN } from 'common/const/Urls.ts';\n\nexport const SUPPORT_USER_UUID = 'c9a61e1d-7c8a-4c7e-838a-9d431cf4ed77';\nexport const RADICAL_ORG_ID = '6bba8678-b14e-4af7-b2f2-05ee807dfa82';\nexport const RADICAL_TEST_ORG_ID = '3689f86d-0c70-40de-a2f0-a4a9ea4994e3';\nexport const CORD_PLATFORM_ORG_ID = '746c0b57-7363-4766-9ee9-7ae8ec7531a8';\nexport const CORD_ADMIN_PLATFORM_ORG_ID =\n  '84ae9086-8414-4ed3-ab73-096e6438f095';\nexport const CORD_SDK_TEST_ORG_ID = 'edda098d-6db7-4202-a5ac-ff3293b78c47';\nexport const GILLIAN_TEST_SLACK_ORG_ID = 'f7ab9ab8-f5b2-41a4-a419-1b8076626d3f';\nexport const KAT_TEST_SLACK_ORG_ID = '4506fadd-f8dc-4795-9b5d-d28feda39d84';\nexport const CORD_SLACK_TEAM_ID = 'T012Y0TBQLW'; // radicalhqworkspace\nexport const CORD_TEST_SLACK_TEAM_ID = 'T015UJY6YQK'; // radicaltestorg\n\nexport const SLACK_APP_CLIENT_ID = '1100027398710.1180115520790';\nexport const SLACK_APP_ID = 'A015A3DFAP8';\nexport const SLACK_DEV_APP_CLIENT_ID = '1198644236835.1943446227956';\nexport const SLACK_ADMIN_LOGIN_APP_CLIENT_ID = '1100027398710.2437628320357';\nexport const SLACK_ADMIN_LOGIN_APP_ID = 'A02CVJG9EAH';\nexport const SLACK_DEV_APP_ID = 'A01TRD46PU4';\nexport const SLACK_INTERNAL_TOOLS_APP_ID = 'A04JKM945CM';\nexport const CORD_UPDATES_TEST_CHANNEL_ID = 'C0547K3V868';\n\n// As opposed to e.g. a customer's Slack app\nexport const CORD_SLACK_APP_IDS = [\n  SLACK_APP_ID,\n  SLACK_DEV_APP_ID,\n  SLACK_ADMIN_LOGIN_APP_ID,\n  SLACK_INTERNAL_TOOLS_APP_ID,\n];\n\nexport const CORD_APPLICATION_ID = '5a076ee9-8b9e-4156-9ac4-871bdc4569ec';\nexport const CORD_SDK_TEST_APPLICATION_ID =\n  'b6501bf5-46f7-4db7-9996-c42dd9f758b0';\nexport const CORD_SAMPLE_TOKEN_CUSTOMER_ID =\n  '1c367aca-37c9-4733-8bef-e9f11a7d0f17';\nexport const CORD_DEMO_APPS_TOKEN_CUSTOMER_ID =\n  '4383cf39-8b6a-4c33-9d8a-71567ed47a60';\nexport const CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID =\n  'aeb2797f-f0a3-485c-a317-4986e2c8343b';\nexport const CORD_AUTOMATED_TESTS_APPLICATION_ID =\n  'dfa86152-9e7e-4d2d-acd6-bfddef71f58e';\nexport const CLACK_APPLICATION_ID = '5fa22ba9-5446-4af8-bc93-7ce54a9aa0ba';\nexport const CORD_HOMEPAGE_APPLICATION_ID =\n  '29e6499a-bbed-4eb2-b057-b36d60ad76c9';\nexport const AUTH0_CLIENT_ID = process.env.AUTH0_CLIENT_ID!;\n\nexport const CORD_CUSTOMER_ID = '12ed6251-28d5-4686-9a75-20a15bd31499';\n\nexport const CSS_CUSTOMIZATION_ON_DOCS_PREFIX = 'css-customization-';\nexport const BETA_V2_DOCS_PREFIX = 'beta2-';\nexport const LIVE_CSS_ON_DOCS_THREAD_ID_PREFIX = 'live-css-docs-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_THREAD_ID_PREFIX =\n  'live-component-docs-thread-';\nexport const LIVE_COMPONENT_INBOX_THREAD_ID_PREFIX =\n  'live_component-docs-inbox-thread-';\nexport const LIVE_COMPONENT_INBOX_LAUNCHER_THREAD_ID_PREFIX =\n  'live_component-docs-inbox-launcher-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_COMPOSER_THREAD_ID_PREFIX =\n  'live-component-docs-composer-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_MESSAGE_THREAD_ID_PREFIX =\n  'live-component-docs-message-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_MESSAGE_CONTENT_THREAD_ID_PREFIX =\n  'live-component-docs-message-content-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_PIN_THREAD_ID_PREFIX =\n  'live-component-docs-pin-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_REACTIONS_THREAD_ID_PREFIX =\n  'live-component-docs-reactions-thread-';\nexport const LIVE_COMPONENT_ON_DOCS_EXTERNAL_NOTIFICATION_PREFIX =\n  'live-component-docs-external-notification-';\nexport const LIVE_CUSTOMIZATION_ON_DOCS_REPLACEMENTS_THREAD_ID_PREFIX =\n  'live-customization-docs-replacements-thread-';\nexport const DOCS_TOKEN_KEY = 'docs-token';\n\nexport const LIVE_COMPONENT_ON_DOCS_NO_AVATAR_USER_ID = 'noavatar';\n\nexport const DOCS_LIVE_PAGE_LOCATIONS = {\n  cssCustomization: 'css-customization',\n  liveCss: 'live-css-docs',\n  liveThread: 'live-thread',\n  liveThreadList: 'live-thread-list',\n  livePin: 'live-pin',\n  livePinChartExample: 'live-pin-chart-example',\n  liveFloatingThreads: 'live-floating-threads',\n  liveSelectionComments: 'live-selection-comments',\n  liveSidebar: 'live-sidebar',\n  liveInbox: 'live-inbox',\n  liveInboxLauncher: 'live-inbox-launcher',\n  liveSidebarLauncher: 'live-sidebar-launcher',\n  livePagePresence: 'live-page-presence',\n  livePresenceFacepile: 'live-presence-facepile',\n  liveComposer: 'live-composer',\n  liveMessage: 'live-message',\n  liveMessageContent: 'live-message-content',\n  liveNotificationList: 'live-notification-list',\n  liveThreadedComments: 'live-threaded-comments',\n  liveReactions: 'live-reactions',\n  liveReplacementsTutorial: 'live-replacements-tutorial',\n  liveBetaV2Thread: 'live-beta-v2-thread',\n  liveBetaV2Threads: 'live-beta-v2-threads',\n};\n\nexport const CORD_DOCS_CLIENT_TOKEN = '__cord_docs_token__';\n\nexport const DOCS_URLS = {\n  tutorials: {\n    getProductionReady: {\n      addYourBranding: `${DOCS_ORIGIN}/get-started/live-css-editor`,\n    },\n    integrationGuide: `${DOCS_ORIGIN}/get-started/integration-guide`,\n    demoApps: `${DOCS_ORIGIN}/get-started/demo-apps`,\n  },\n  components: {\n    thread: `${DOCS_ORIGIN}/components/cord-thread`,\n    threadList: `${DOCS_ORIGIN}/components/cord-thread-list`,\n    threadedComments: `${DOCS_ORIGIN}/components/cord-threaded-comments`,\n    sidebar: `${DOCS_ORIGIN}/components/cord-sidebar`,\n    inbox: `${DOCS_ORIGIN}/components/cord-inbox`,\n    inboxLauncher: `${DOCS_ORIGIN}/components/cord-inbox-launcher`,\n    sidebarLauncher: `${DOCS_ORIGIN}/components/cord-sidebar-launcher`,\n    composer: `${DOCS_ORIGIN}/components/cord-composer`,\n    message: `${DOCS_ORIGIN}/components/cord-message`,\n    messageContent: `${DOCS_ORIGIN}/components/cord-message-content`,\n    reactions: `${DOCS_ORIGIN}/components/cord-reactions`,\n  },\n  howTo: {\n    customThreadedComments: `${DOCS_ORIGIN}/customization/custom-threaded-comments`,\n    cssCustomization: `${DOCS_ORIGIN}/customization/css`,\n    replacements: `${DOCS_ORIGIN}/customization/custom-react-components/tutorial`,\n  },\n  getStarted: {\n    authenticateYourUser: `${DOCS_ORIGIN}/get-started/integration-guide/generate-an-auth-token`,\n  },\n  betaV2Components: {\n    threads: `${DOCS_ORIGIN}/components/cord-threads?version=2.0`,\n    thread: `${DOCS_ORIGIN}/components/cord-thread?version=2.0`,\n  },\n};\n\nexport const CORD_DEV_CONSOLE_LOGGING_SLACK_CHANNEL_ID = 'C05FAVBSSN7';\nexport const CORD_SELF_SERVE_SLACK_CHANNEL_ID = 'C05GR4WSV5Z';\n\n// Tokens created for the sample token and demo apps environment types both\n// create groups with this id.  Both of them need to use the same groupID because\n// it is hardcoded into the demo apps client code, and while the demo apps mostly\n// use the demo apps environment apps, they sometimes use sample app tokens.\nexport const DEMO_APPS_APP_GROUP_ID = 'my-first-group';\n", "import type { Node } from 'slate';\nimport { Element } from 'slate';\nimport { v4 as uuid } from 'uuid';\nimport { MessageNodeType } from '@cord-sdk/types';\nimport type {\n  MessageAssigneeNode,\n  MessageContent,\n  MessageMentionNode,\n  MessageNode,\n  MessageNodeWithChildren,\n  MessageStyledBlockType,\n  MessageTextNode,\n  MessageTodoNode,\n  UUID,\n} from '@cord-sdk/types';\nimport { trimStart, trimEnd } from './trim.js';\n\nexport const MAX_BULLET_INDENT = 4;\n\n// '& Node' in return value stops Slate complaining when passing node to its methods\n// Casting to any is because TS doesn't seem to like combining the two to make the node\nexport function createMessageNode<\n  NodeType extends MessageNodeType,\n  NodeAttributes extends MessageNode<NodeType> = MessageNode<NodeType>,\n>(\n  nodeType: NodeType,\n  nodeAttributes: Omit<NodeAttributes, 'type'>,\n): MessageNode<NodeType> & Node {\n  return {\n    type: nodeType,\n    ...nodeAttributes,\n  } as any;\n}\n\nexport function createMessageTextNode(text: string): MessageTextNode {\n  return {\n    text,\n  };\n}\n\nexport function createFormattedMessageTextNode(input: {\n  text: string;\n  bold?: boolean;\n  italic?: boolean;\n  underline?: boolean;\n  code?: boolean;\n}): MessageTextNode {\n  return input;\n}\n\nexport function isMessageNodeType<NodeType extends MessageNodeType>(\n  node: Node | undefined,\n  nodeType: NodeType,\n): node is MessageNode<NodeType> {\n  return Boolean(node && Element.isElement(node) && node.type === nodeType);\n}\n\nexport function isMessageNodeText(node: MessageNode): node is MessageTextNode {\n  return !node.type && 'text' in node;\n}\n\nexport function createParagraphNode(text = '') {\n  return createMessageNode(MessageNodeType.PARAGRAPH, {\n    children: [{ text }],\n  });\n}\n\nexport function createMentionNode(userID: UUID, name: string) {\n  return createMessageNode(MessageNodeType.MENTION, {\n    user: { id: userID },\n    children: [{ text: `@${name}` }],\n  });\n}\n\nexport function createAssigneeNode(userID: UUID, name: string) {\n  return createMessageNode(MessageNodeType.ASSIGNEE, {\n    user: { id: userID },\n    children: [{ text: `+${name}` }],\n  });\n}\n\nexport function createLinkNode(url: string, text: string) {\n  return createMessageNode(MessageNodeType.LINK, {\n    url,\n    children: [{ text }],\n  });\n}\n\nexport function messageContentFromString(text: string): MessageContent {\n  return [createParagraphNode(text)];\n}\n\nfunction getInitialStyledBlockProps(\n  blockType: MessageStyledBlockType,\n  indent?: number,\n) {\n  if (blockType === MessageNodeType.TODO) {\n    return {\n      done: false,\n      todoID: uuid(),\n    };\n  } else if (\n    blockType === MessageNodeType.BULLET ||\n    blockType === MessageNodeType.NUMBER_BULLET\n  ) {\n    return {\n      indent,\n    };\n  } else {\n    return {};\n  }\n}\n\nexport function createStyledBlockNode(\n  blockType: MessageStyledBlockType,\n  text: string,\n  indent?: number,\n) {\n  return createMessageNode(blockType, {\n    children: messageContentFromString(text),\n    ...getInitialStyledBlockProps(blockType, indent),\n  });\n}\n\nconst findTodoNodesInSubtree = (\n  parent: MessageNode,\n  accumulator: MessageTodoNode[],\n): void => {\n  if (parent.type === MessageNodeType.TODO) {\n    accumulator.push(parent);\n  } else {\n    const children = getMessageNodeChildren(parent);\n    if (children) {\n      for (const node of children) {\n        findTodoNodesInSubtree(node, accumulator);\n      }\n    }\n  }\n};\n\nexport const todoNodesFromMessage = (messageContent: MessageContent) => {\n  const accumulator: MessageTodoNode[] = [];\n\n  for (const node of messageContent) {\n    findTodoNodesInSubtree(node, accumulator);\n  }\n\n  return accumulator;\n};\n\nexport function getMessageNodeChildren(node: MessageNode) {\n  return (node as MessageNodeWithChildren).children;\n}\n\nexport const textFromNodeRecursive = (node: MessageNode): string => {\n  let textArr: Array<string> = [];\n\n  if (isMessageNodeText(node)) {\n    return node.text;\n  }\n\n  const children = getMessageNodeChildren(node);\n  if (children) {\n    textArr = textArr.concat(\n      children.map((child) => textFromNodeRecursive(child)),\n    );\n  }\n\n  const result = textArr.join('');\n\n  return result;\n};\n\nexport function convertStructuredMessageToText(\n  messageContent: MessageContent,\n): string {\n  return messageContent\n    .map((node) => textFromNodeRecursive(node))\n    .join('\\n')\n    .trim();\n}\n\n// converts a list of MessageNode into text.\n// any whitespace or assignees at the start/end are removed.\nfunction taskTitleFromMessageNodes(\n  nodes: (MessageTextNode | MessageAssigneeNode | MessageMentionNode)[],\n): string {\n  let pending = '';\n  let text = '';\n\n  for (const node of nodes) {\n    if (node.type === MessageNodeType.ASSIGNEE) {\n      if (text.trim() === '') {\n        // no text was seen so far, so this is an assignee at the start of a\n        // message. We want to skip those.\n        continue;\n      }\n      // okay, we have seen some text already, but this assignee might be at\n      // the very end of the message. Hence let the assignee wait in the\n      // pending until we find non-empty text (which would mean the assignee is\n      // not at the end of the message)\n      pending += trimStart(textFromNodeRecursive(node), '+');\n      continue;\n    }\n\n    let newText = '';\n    if (isMessageNodeText(node)) {\n      newText = node.text;\n    } else if (node.type === MessageNodeType.MENTION) {\n      newText = trimStart(textFromNodeRecursive(node), '@');\n    }\n\n    const isEmpty = newText.trim() === '';\n    if (isEmpty) {\n      // this might be either trailing whitespace or whitespace in the middle\n      // of the message. For now, let's have it in pending until something\n      // non-empty arrives\n      pending += newText;\n    } else {\n      // we found some non-empty text so whatever was waiting in the pending\n      // can now finally become part of text\n      text += pending + newText;\n      pending = '';\n    }\n  }\n\n  return trimEnd(text.trim(), ':').trim();\n}\n\n// converts each MessageNode into text, returns the first non-empty one.\nexport function taskTitleFromMessageContent(\n  messageContent: MessageContent,\n): string {\n  for (let i = 0; i < messageContent.length; i++) {\n    const nodes: (\n      | MessageTextNode\n      | MessageAssigneeNode\n      | MessageMentionNode\n    )[] = [];\n    flattenMessage(messageContent[i], nodes);\n\n    const title = taskTitleFromMessageNodes(nodes);\n    if (title.length > 0) {\n      return title;\n    }\n  }\n\n  return 'Task created using Cord';\n}\n\nfunction flattenMessage(\n  node: MessageNode,\n  accumulator: (MessageTextNode | MessageAssigneeNode | MessageMentionNode)[],\n) {\n  if (\n    isMessageNodeText(node) ||\n    node.type === MessageNodeType.ASSIGNEE ||\n    node.type === MessageNodeType.MENTION\n  ) {\n    accumulator.push(node);\n    return;\n  }\n  const children = getMessageNodeChildren(node);\n  if (!children) {\n    return;\n  }\n\n  for (const child of children) {\n    flattenMessage(child, accumulator);\n  }\n}\n\n// message.content is null if message is deleted\nexport const findMessageNode = (\n  arr: MessageContent | null,\n  nodeType: MessageNodeType,\n): any => {\n  if (!arr) {\n    return null;\n  }\n  for (const item of arr) {\n    if (item.type === nodeType) {\n      return item;\n    }\n    if ('children' in item) {\n      const p = findMessageNode(item.children, nodeType);\n      if (p) {\n        return p;\n      }\n    }\n  }\n\n  return null;\n};\n"],
  "mappings": "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",
  "names": ["jsonStableStringify"]
}
