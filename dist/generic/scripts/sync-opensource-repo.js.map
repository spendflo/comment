{
  "version": 3,
  "sources": ["scripts/sync-opensource-repo.ts"],
  "sourcesContent": ["#!/usr/bin/env -S node --enable-source-maps\n\n// This script helps with syncing our opensource repositories with\n// subdirectories in monorepo.\n//\n// Syncing can go both ways: importing new commits from the subrepo into\n// monorepo, and exporting new commits touching the opensource folder from\n// monorepo to a subrepo.\n//\n// To sync one of the opensource project, e.g. `sdk-js`: build/index.mjs\n//    --target=scripts/sync-opensource-repo.ts &&\n//    dist/scripts/sync-opensource-repo.js --name sdk-js\n//\n// The script will:\n// * in your local monorepo repository, create a remote called\n//   `opensource-sdk-js` (unless one exists already)\n// * fetch from that remote, so we have the history of the opensource repo\n//   (there will be remote branches like `opensource-sdk-js/master`)\n// * compare the history of the `opensource/sdk-js` directory in monorepo and of\n//   the `sdk-js` repository\n// * find the most recent pair of commits in these two repos with matching file\n//   contents.\n// * for any commit that touches `opensource/sdk-js` in monorepo *after* the\n//   last time monorepo and sdk-js repo were in sync, it creates a matching\n//   commits in a local branch called `opensource/sdk-js/export-commits`. That\n//   branch is attached to the history of `sdk-js`, not monorepo. To be precise,\n//   it branches of the most recent commit in `sdk-js` which was in sync with\n//   monorepo. So, if there are any commits in monorepo that need exporting to\n//   `sdk-js`, this branch will contain them. You should check whether these\n//   commits (and their commit messages!) are safe to publish as opensource. You\n//   can amend them locally, and when ready, push them to `sdk-js`. Typically,\n//   you would only alter the commit messages. If you find you need to also\n//   alter the file contents, you will need to land the same changes in\n//   monorepo. After all, we want the repo and the directory in monorepo to be\n//   in sync!\n// * for any commit in the `sdk-js` repository, the script will create matching\n//   commits on a local monorepo branch called\n//   `opensource/sdk-js/import-commits`. If there any such commits, you can\n//   either just create pull requests for each (e.g. using `spr diff --all` on\n//   that branch), or you can squash them into one commit and have one PR for\n//   the whole sync. At the end, you just want to have all these changes landed\n//   so that the contents of monorepo and `sdk-js` repo are in sync.\n//\n// The script will tell you how many commits it created, if any, in the import\n// and export branches.\n//\n// Obviously, the above explanation applies to any of our opensource\n// repositories, not just `sdk-js`.\n//\n// The script takes one to three options:\n// * `--name` is required and must be set to the name of the opensource\n//   repository you want to sync. That name must also match the name of the\n//   subdirectory in `opensource` in monorepo.\n// * `--master-branch` is optional and can be set to the name of the default\n//   branch in the opensource repository (defaults to master)\n// * `--repo` is optional and will override the opensource repository name\n//   if specified.  If not specified, it will default to name.\n\nimport { promises as fs } from 'fs';\nimport * as readline from 'readline';\nimport { spawn } from 'child_process';\n\nimport yargs from 'yargs';\n\nconst EMPTY_COMMIT = '0000000000000000000000000000000000000000';\nconst EMPTY_TREE = '4b825dc642cb6eb9a060e54bf8d69288fbee4904';\nconst filterOutCordPrefixedNames = (name: string) => !name.startsWith('CORD-');\n\nconst argv = yargs(process.argv.slice(2))\n  .option('name', { type: 'string', demandOption: true })\n  .option('master-branch', { type: 'string', default: 'master' })\n  .option('repo', { type: 'string' })\n  .strict()\n  .help()\n  .alias('help', 'h').argv;\n\nasync function main(\n  name: string,\n  masterBranch: string,\n  repo: string | undefined,\n) {\n  // If the repo is not specified, let's default it to the name\n  if (!repo) {\n    repo = name;\n  }\n  const pathWithinMainRepo = `opensource/${name}`;\n\n  // Make sure `pathWithinMainRepo` exists and is a directory\n  if (\n    !(await fs\n      .stat(pathWithinMainRepo)\n      .then((s) => s.isDirectory())\n      .catch(() => false))\n  ) {\n    throw new Error(\n      `'${pathWithinMainRepo}' does not exist or is not a directory`,\n    );\n  }\n\n  // Create git remote, if it does not exist yet\n  const gitRemoteName = `opensource-${repo}`;\n\n  if (\n    !(await getCommandOutput('git', ['remote']))\n      .split('\\n')\n      .map((l) => l.trim())\n      .includes(gitRemoteName)\n  ) {\n    // The git remote for the sub-repository is not registered yet.\n\n    await runCommand(\n      'git',\n      'remote',\n      'add',\n      gitRemoteName,\n      `git@github.com:getcord/${repo}`,\n    );\n  }\n\n  // Fetch from that remote, so we have the opensource repositories history\n  // available to work with\n  await runCommand('git', 'fetch', gitRemoteName);\n\n  // Get a list of monorepo and subrepo commits that need importing/exporting.\n  // Both `monorepoCommits` and `subrepoCommits` are arrays of commit hashes.\n  // The first item in each array is the last commit where monorepo and subrepo\n  // contents match. Any further items need importing/exporting.\n  const { monorepoCommits, subrepoCommits, monorepoTrees, subrepoTrees } =\n    await findCommonBase(\n      getMonorepoCommitsTouchingPath(pathWithinMainRepo),\n      getSubrepoCommits(gitRemoteName, masterBranch),\n    );\n\n  if (monorepoCommits.length > 1) {\n    // We need to export commits.\n    console.log(\n      `${monorepoCommits.length - 1} commit(s) need exporting into subrepo.`,\n    );\n    let newBranchCommit = subrepoCommits[0];\n    for (const newMonorepoCommit of monorepoCommits.slice(1)) {\n      // Get commit message and some meta data\n      const [authorName, authorEmail, authorDate, ...lines] = (\n        await getCommandOutput('git', [\n          'log',\n          '--format=%an%n%ae%n%aI%n%B',\n          '-n',\n          '1',\n          newMonorepoCommit,\n        ])\n      )\n        .trimRight()\n        .split('\\n');\n\n      // Create new commit for the subrepo\n      newBranchCommit = (\n        await getCommandOutput(\n          'git',\n          [\n            'commit-tree',\n            '-p',\n            newBranchCommit,\n            '-m',\n            prepareSubrepoMessage(lines.join('\\n'), newMonorepoCommit),\n            monorepoTrees.get(newMonorepoCommit)!,\n          ],\n          {\n            GIT_AUTHOR_NAME: authorName,\n            GIT_AUTHOR_EMAIL: authorEmail,\n            GIT_AUTHOR_DATE: authorDate,\n          },\n        )\n      ).trim();\n    }\n\n    // Create the \"export-commits\" branch\n    const branchName = `opensource/${repo}/export-commits`;\n    await runCommand('git', 'branch', '-f', branchName, newBranchCommit);\n    await runCommand(\n      'git',\n      'branch',\n      `--set-upstream-to=${gitRemoteName}/${masterBranch}`,\n      branchName,\n    );\n\n    console.log(`Prepared new commits in branch '${branchName}'`);\n  }\n\n  if (subrepoCommits.length > 1) {\n    // We need to import commits.\n    console.log(\n      `${subrepoCommits.length - 1} commit(s) need importing from subrepo.`,\n    );\n\n    // The `treeReplacer` replaces one subdirectory of a given tree with a\n    // different tree.\n    const treeReplacer = await makeTreeReplacer(monorepoCommits[0], [\n      'opensource',\n      name,\n    ]);\n\n    // Create new commit for monorepo\n    let newBranchCommit = monorepoCommits[0];\n    for (const newSubrepoCommit of subrepoCommits.slice(1)) {\n      const [authorName, authorEmail, authorDate, ...lines] = (\n        await getCommandOutput('git', [\n          'log',\n          '--format=%an%n%ae%n%aI%n%B',\n          '-n',\n          '1',\n          newSubrepoCommit,\n        ])\n      )\n        .trimRight()\n        .split('\\n');\n\n      newBranchCommit = (\n        await getCommandOutput(\n          'git',\n          [\n            'commit-tree',\n            '-p',\n            newBranchCommit,\n            '-m',\n            lines.join('\\n'),\n            await treeReplacer(subrepoTrees.get(newSubrepoCommit)!),\n          ],\n          {\n            GIT_AUTHOR_NAME: authorName,\n            GIT_AUTHOR_EMAIL: authorEmail,\n            GIT_AUTHOR_DATE: authorDate,\n          },\n        )\n      ).trim();\n    }\n\n    // Create the \"import-commits\" branch\n    const branchName = `opensource/${repo}/import-commits`;\n    await runCommand('git', 'branch', '-f', branchName, newBranchCommit);\n\n    console.log(`Prepared new commits in branch '${branchName}'`);\n  }\n}\n\n/**\n * Return `[commitHash, treeHash]` tuples for commits in monorepo that touch the\n * given path.\n *\n * The trees returned have all files and directories whose name begins with\n * 'CORD-' filtered out.\n *\n * Consequently, commits that touch the given directory, but only\n * adds/removes/modifies files beginning with 'CORD-' (and files in directories\n * beginning with 'CORD-') are omitted.\n */\nasync function* getMonorepoCommitsTouchingPath(\n  path: string,\n): AsyncGenerator<[string, string], void> {\n  let lastCommitHash: string | null = null;\n  let lastTreeHash: string | null = null;\n\n  // Iterate through all commits that touch `path`\n  for await (const line of streamLinesFromCommand(\n    'git',\n    'log',\n    '--format=tformat:%H',\n    '--',\n    path,\n  )) {\n    const commitHash = line.trim();\n    if (commitHash) {\n      // The `originalTreeish` is the git notation for `path` in the commit\n      // `commitHash`.\n      const originalTreeish = `${commitHash}:${path}`;\n\n      // `filterTreeByBane` filters out the files and directories whose name\n      // begin with 'CORD-'. It returnes either `originalTreeish` (if there was\n      // nothing to filter out), or a tree hash.\n      const filteredTreeish = await filterTreeByName(\n        originalTreeish,\n        filterOutCordPrefixedNames,\n      );\n\n      // `tree` is going to be the hash for the (filtered) tree. If\n      // `filteredTreeish` is `originalTreeish`, we have to turn it into a tree\n      // hash. Otherwise it's a hash already.\n      const tree =\n        filteredTreeish === originalTreeish\n          ? (\n              await getCommandOutput('git', [\n                'rev-parse',\n                `${commitHash}:${path}`,\n              ])\n            ).trim()\n          : filteredTreeish;\n\n      // If the previous commit we encountered had a different resulting tree,\n      // then that commit contained actual changes to the path (even after\n      // filtering out `CORD-`-prefixed files and directories). We can yield\n      // this now.\n      if (\n        lastCommitHash !== null &&\n        lastTreeHash !== null &&\n        lastTreeHash !== tree\n      ) {\n        yield [lastCommitHash, lastTreeHash];\n      }\n\n      // Update `lastCommitHash` and `lastTreeHash` to the commit/tree we\n      // encountered just now. We won't just yield it yet, because the next\n      // commit we get may have the same tree, and then we want to skip this\n      // one. The reason why we still have to skip commits at all here, is that\n      // `git log` gives us a list of all commits touching `path`, but some of\n      // those may only change files/directories prefixed with `CORD-`, and\n      // since we filter those out, such commits would result in no changes. We\n      // don't want to create empty commits, so we skip them.\n      lastCommitHash = commitHash;\n      lastTreeHash = tree;\n    }\n  }\n\n  if (lastCommitHash !== null && lastTreeHash !== null) {\n    // The last commit we encountered above is the first that ever touched `path`.\n\n    if (lastTreeHash !== EMPTY_TREE) {\n      // The tree is not empty after filtering, so this is a commit we want to\n      // emit.\n      yield [lastCommitHash, lastTreeHash];\n    }\n\n    // Finally, emit the empty tree, which represents the state before `path`\n    // was added to monorepo.\n    yield [`${lastCommitHash}~1`, EMPTY_TREE];\n  } else {\n    // We didn't find any commits at all, so let's just say the current state of\n    // monorepo corresponds to `path` being empty.\n    yield ['HEAD', EMPTY_TREE];\n  }\n}\n\nasync function* getSubrepoCommits(remote: string, branch: string) {\n  for await (const line of streamLinesFromCommand(\n    'git',\n    'log',\n    '--format=tformat:%H %T',\n    `refs/remotes/${remote}/${branch}`,\n  )) {\n    const fields = line.trim().split(/\\s+/);\n    if (fields.length === 2) {\n      yield fields as [string, string];\n    }\n  }\n  yield [EMPTY_COMMIT, EMPTY_TREE] as const;\n}\n\nasync function findCommonBase(\n  monorepoCommitIter: AsyncGenerator<readonly [string, string]>,\n  subrepoCommitIter: AsyncGenerator<readonly [string, string]>,\n) {\n  const commits: string[][] = [[], []];\n  const treePositions: Map<string, number>[] = [new Map(), new Map()];\n  const monorepoTrees = new Map<string, string>();\n  const subrepoTrees = new Map<string, string>();\n\n  for await (const [repoID, [commitID, treeID]] of zipIterators(\n    monorepoCommitIter,\n    subrepoCommitIter,\n  )) {\n    (repoID === 0 ? monorepoTrees : subrepoTrees).set(commitID, treeID);\n\n    commits[repoID].push(commitID);\n\n    const otherRepo = 1 - repoID;\n    const treeInOtherRepo = treePositions[otherRepo].get(treeID);\n    if (treeInOtherRepo !== undefined) {\n      commits[otherRepo] = commits[otherRepo].slice(0, treeInOtherRepo + 1);\n      break;\n    }\n\n    if (!treePositions[repoID].has(treeID)) {\n      treePositions[repoID].set(treeID, commits[repoID].length - 1);\n    }\n  }\n\n  return {\n    monorepoCommits: commits[0].reverse(),\n    subrepoCommits: commits[1].reverse(),\n    monorepoTrees,\n    subrepoTrees,\n  };\n}\n\nasync function makeTreeReplacer(\n  treeish: string,\n  path: string[],\n): Promise<(treeID: string) => Promise<string>> {\n  if (path.length === 0) {\n    return (treeID: string) => Promise.resolve(treeID);\n  }\n\n  const path0 = path[0]!;\n  let subtree = EMPTY_TREE;\n\n  const lines: string[] = [];\n  for await (const line of streamLinesFromCommand('git', 'ls-tree', treeish)) {\n    const match = /^\\d+ (\\w+) (\\w+)\\t(.*?)$/.exec(line);\n    if (match) {\n      const [_, type, hash, name] = match;\n\n      if (name === path0) {\n        if (type === 'tree') {\n          subtree = hash;\n        }\n      } else {\n        lines.push(line);\n      }\n    }\n  }\n\n  const rest = lines.join('\\n') + (lines.length ? '\\n' : '');\n  const innerReplacer = await makeTreeReplacer(subtree, path.slice(1));\n\n  return async (treeID: string) => {\n    const input = `${rest}040000 tree ${await innerReplacer(\n      treeID,\n    )}\\t${path0}\\n`;\n    return (await getCommandOutput('git', ['mktree'], undefined, input)).trim();\n  };\n}\n\nasync function filterTreeByName(\n  treeish: string,\n  func: (name: string) => boolean,\n) {\n  let anyChanges = false;\n\n  const lines: string[] = [];\n  // Iterate through all items in the treeish.\n  for await (const line of streamLinesFromCommand('git', 'ls-tree', treeish)) {\n    const match = /^(\\d+) (\\w+) (\\w+)\\t(.*?)$/.exec(line);\n    if (match) {\n      const [_, stat, type, hash, name] = match;\n\n      if (!func(name)) {\n        // we filter out this entry\n        anyChanges = true;\n        continue;\n      }\n\n      if (type === 'tree') {\n        // We have to descend this tree, too.\n\n        const filteredHash = await filterTreeByName(hash, func);\n\n        if (filteredHash !== hash) {\n          // The filtering produced a change\n          anyChanges = true;\n\n          if (filteredHash !== EMPTY_TREE) {\n            // The tree came back non-empty from filtering, so we add a line for\n            // the tree after filtering.\n            lines.push(`${stat} ${type} ${filteredHash}\\t${name}`);\n          }\n\n          // Either way, we have dealt with this entry. We `continue` so we do\n          // not push the original into the output array below.\n          continue;\n        }\n      }\n\n      // If we haven't `continue`d above, then we just add the line back unchanged\n      lines.push(line);\n    }\n  }\n\n  if (anyChanges) {\n    const newTreeContent = lines.join('\\n') + (lines.length ? '\\n' : '');\n    return (\n      await getCommandOutput('git', ['mktree'], undefined, newTreeContent)\n    ).trim();\n  } else {\n    // Nothing has changed, so we return the original treeish.\n    return treeish;\n  }\n}\n\nconst privateSectionRegex = new RegExp(\n  '^CORD PRIVATE SECTION START$.*?^CORD PRIVATE SECTION END(\\\\n|$)',\n  // s = dotAll (. matches new lines)\n  // m = multiline (^ and $ still match beginning and end of a line)\n  // g = globally, more than one match (needed for .replaceAll())\n  'smg',\n);\nfunction prepareSubrepoMessage(msg: string, monorepoCommitID: string) {\n  msg = msg.replaceAll(privateSectionRegex, '');\n  return `${msg.trimRight()}\\n\\nmonorepo-commit: ${monorepoCommitID}`;\n}\n\nfunction streamLinesFromCommand(cmd: string, ...args: string[]) {\n  return readline.createInterface({\n    input: spawn(cmd, args, {\n      stdio: ['ignore', 'pipe', process.stderr],\n    }).stdout,\n  });\n}\n\nasync function getCommandOutput(\n  cmd: string,\n  args: string[],\n  env?: NodeJS.ProcessEnv,\n  stdin?: string,\n) {\n  const fragments: string[] = [];\n\n  const child = spawn(cmd, args, {\n    stdio: [stdin === undefined ? 'ignore' : 'pipe', 'pipe', process.stderr],\n    env: env ? { ...process.env, ...env } : undefined,\n  });\n\n  const finished = new Promise<void>((resolve, reject) => {\n    child.on('error', reject);\n    child.once('close', (code) =>\n      code === 0 ? resolve() : reject(new Error(`exit code ${code}`)),\n    );\n  });\n\n  if (stdin !== undefined && child.stdin) {\n    const stream = child.stdin;\n    stream.write(stdin, 'utf-8', () => stream.end());\n  }\n\n  if (child.stdout) {\n    for await (const fragment of child.stdout) {\n      fragments.push(fragment);\n    }\n  }\n\n  await finished;\n  return fragments.join('');\n}\n\nfunction runCommand(cmd: string, ...args: string[]): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    const proc = spawn(cmd, args, { stdio: ['ignore', 'inherit', 'inherit'] });\n    proc.on('error', reject);\n    proc.once('close', resolve);\n  });\n}\n\nasync function* zipIterators<T, U, V>(\n  ...generators: AsyncGenerator<T, U, V>[]\n) {\n  const gens = [...generators.entries()];\n\n  while (gens.length) {\n    const [idx, gen] = gens.shift()!;\n\n    const item = await gen.next();\n    if (!item.done) {\n      yield [idx, item.value] as const;\n      gens.push([idx, gen]);\n    }\n  }\n}\n\nmain(argv.name, argv['master-branch'], argv['repo']).then(\n  () => process.exit(0),\n  (err) => {\n    console.error(err);\n    process.exit(1);\n  },\n);\n"],
  "mappings": "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",
  "names": []
}
