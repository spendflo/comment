var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// opensource/sdk-js/packages/types/dist/cjs/index.js
var require_cjs = __commonJS({
  "opensource/sdk-js/packages/types/dist/cjs/index.js"(exports) {
    "use strict";
    var resources = {
      en: {
        default: {},
        composer: {
          // The placeholder for sending a message that will create a new thread
          send_message_placeholder: "Add a comment...",
          // The placeholder for sending a message to a thread with messages in it
          reply_placeholder: "Reply...",
          // The placeholder for editing a message
          edit_message_placeholder: "Edit message...",
          // The tooltip for the "mention someone" menu button
          mention_someone_tooltip: "Mention someone",
          // The text of the button that starts an annotation
          annotate_action: "Annotate",
          // The tooltip for the annotation button if there is already an annotation
          // and clicking the button will cause it to be replaced
          replace_annotation_tooltip: "Replace annotation",
          // The tooltip for the button that adds an emoji to the message
          add_emoji_tooltip: "Add emoji",
          // The tooltip for the button that removes a task from the message
          remove_task_tooltip: "Remove task",
          // The tooltip for the button that adds a task to the message
          create_task_tooltip: "Create task",
          // The tooltip for the button that attaches a file to the message
          attach_file_tooltip: "Attach file",
          // The tooltip for the button that removes an attached file from the
          // message
          remove_file_action: "Remove",
          // The text of the button that initiates the Slack linking flow
          connect_to_slack_action: "Connect your Slack team",
          // The instructions shown in a message while the Slack linking flow is in
          // progress
          slack_follow_instructions: "Follow the instructions",
          // The text of the status indicator shown when a previous message is being
          // edited
          editing_status: "Editing",
          // The text of the button that cancels editing a previous message
          cancel_editing_action: "Cancel",
          // The text of the status indicator when the composer is disabled because
          // a thread is resolved
          resolved_status: "Resolved",
          // The text of the button in the composer that unresolves a thread
          unresolve_action: "Reopen to reply",
          // The text of the pill shown for an annotation when the annotation has no
          // more specific label
          annotation: "Your annotation",
          // The text of the button that removes an annotation from a message
          remove_annotation_action: "Remove",
          // The error text shown when a message failed to send
          send_message_action_failure: "Failed to send message. <restore>Restore the message</restore>",
          // The text shown when a user is dragging files over the composer
          drag_and_drop_files_tooltip: "Drop Files",
          attach_file_action_failure: "Failed to upload file: {{message}}"
        },
        thread: {
          // The title of the placeholder shown in an empty thread
          placeholder_title: "Chat with your team, right here",
          // The body of the placeholder shown in an empty thread
          placeholder_body: "Ask a question, give feedback, or just say 'Hi'. Comments can be seen by anyone who can access this page.",
          // The status text shown next to a thread where the first message is
          // unread
          new_status: "New",
          // The text of the link to add a reply to a thread
          reply_action: "Reply...",
          // The status text shown below a thread when it has unread replies
          new_replies_status_one: "1 unread",
          new_replies_status_other: "{{count}} unread",
          // The status text shown below a thread when it has no unread replies
          replies_status_one: "1 reply",
          replies_status_other: "{{count}} replies",
          // The text of the link that shows more messages in a thread when the list
          // of messages has been paginated
          show_more_one: "Show 1 more",
          show_more_other: "Show {{count}} more",
          // The text of the menu item that marks all messages in a thread as read
          mark_as_read_action: "Mark as read",
          // The text of the menu item that shares a thread with Slack
          share_via_slack_action: "Share with Slack",
          // The text of the menu item when an empty thread is set to
          share_via_slack_channel_action: "Share to #{{slackChannel}}",
          // The text of the menu item that shares a thread with Slack when the user
          // has not linked their Slack account
          share_via_slack_action_not_connected: "Connect to share",
          // The text shown after sharing a thread to Slack succeeds
          share_via_slack_action_success: "Shared to #{{slackChannel}}",
          // The placeholder for the input box for choosing a Slack channel to share
          // a thread to
          share_via_slack_channel_placeholder: "Type or select",
          // The text shown when sharing a thread to Slack and there are no public
          // channels in the Slack workspace the user has linked to
          share_via_slack_no_channels: "No public channels found",
          // The text shown when sharing a thread to Slack fails for an unknown reason
          share_via_slack_action_failure: "Error sharing to Slack, please try again",
          // The text of the menu item that shares a thread by email
          share_via_email_action: "Share via email",
          // The text of the button that shares a thread by email
          share_via_email_button_action: "$t(share_via_email_action)",
          // The text of the header for the email sharing dialog
          share_via_email_header: "$t(share_via_email_action)",
          // The text shown after sharing a thread to email succeeds
          share_via_email_action_success: "Shared to {{email}}",
          // The warning text shown to inform the user that when sharing a thread by
          // email, a screenshot will be sent with the email
          share_via_email_screenshot_warning: "A screenshot of this page will be included in the email.",
          // The placeholder for the input box for choosing an email address to
          // share a thread with
          share_via_email_placeholder: "email@email.com",
          // The text of the menu item that subscribes the user to a thread
          subscribe_action: "Subscribe",
          // The text shown after a user subscribes to a thread
          subscribe_action_success: "You've subscribed to this thread",
          // The text of the menu item that unsubscribes the user from a thread
          unsubscribe_action: "Unsubscribe",
          // The text shown after a user unsubscribes from a thread
          unsubscribe_action_success: "You've unsubscribed from this thread",
          // The text of the menu item that resolves a thread
          resolve_action: "Resolve",
          // The text shown after a user resolves a thread
          resolve_action_success: "You resolved this thread",
          // The status text shown on a resolved thread
          resolved_status: "Resolved",
          // The text of the menu item that unresolves a thread
          unresolve_action: "Reopen",
          // The text shown after a user unresolves a thread
          unresolve_action_success: "You have reopened this thread",
          // The text shown on the action to collapse an expanded thread
          collapse_action: "Collapse thread",
          // The text shown next to the facepile of users that are currently typing
          // into a thread
          typing_users_status: "Typing"
        },
        threads: {
          // The title placeholder text shown when no threads are shown in the
          // threads component
          placeholder_title: "Be the first to add a comment",
          // The body placeholder text shown when no threads are shown in a threaded
          // comments component
          placeholder_body: "Ask a question, give feedback, or just say 'Hi'. Comments can be seen by anyone who can access this page."
        },
        thread_list: {
          // The title placeholder text shown when no threads are shown in a thread
          // list
          placeholder_title: "Be the first to add a comment",
          // The body placeholder text shown when no threads are shown in a thread
          // list
          placeholder_body: "Ask a question, give feedback, or just say 'Hi'. Comments can be seen by anyone who can access this page.",
          // The text of the link that toggles the display of resolved threads from
          // not showing to showing
          show_resolved_threads_action: "Show resolved threads",
          // The text of the link that toggles the display of resolved threads from
          // showing to not showing
          hide_resolved_threads_action: "Hide resolved threads"
        },
        thread_preview: {
          // The text of the link that reveals the replies to a thread when there
          // are no unread messages in the thread
          show_replies_action_read_one: "1 reply",
          show_replies_action_read_other: "{{count}} replies",
          // The text of the link that reveals the replies to a thread when there
          // are unread messages in the thread
          show_replies_action_unread_one: "1 new reply",
          show_replies_action_unread_other: "{{count}} new replies",
          // The text of the link that hides the replies to a thread
          hide_replies_action: "Hide replies",
          // The text of the link that starts composing a reply to the thread
          reply_action: "Reply"
        },
        threaded_comments: {
          // The title placeholder text shown when no threads are shown in the unresolved threads portion of a
          // threaded comments component
          placeholder_title: "Be the first to add a comment",
          // The body placeholder text shown when no threads are shown in a threaded
          // comments component
          placeholder_body: "Ask a question, give feedback, or just say 'Hi'. Comments can be seen by anyone who can access this page.",
          // The title placeholder text shown when no threads are shown in the
          // resolved threads portion of a threaded comments component
          resolved_placeholder_title: "This is where resolved comments will appear",
          // The body placeholder text shown when no threads are shown in the
          // resolved threads portion of a threaded comments component
          resolved_placeholder_body: "Resolved comments can be seen by anyone who can access this page.",
          // The text of the button that shows unresolved threads
          show_unresolved: "Open",
          // The text of the button that shows resolved threads
          show_resolved: "Resolved",
          // The text of the link that toggles the display of resolved threads from
          // not showing to showing
          show_resolved_threads_action: "$t(thread_list:show_resolved_threads_action)",
          // The text of the link that toggles the display of resolved threads from
          // showing to not showing
          hide_resolved_threads_action: "$t(thread_list:hide_resolved_threads_action)",
          // The text of the link that shows additional threads when the list of
          // threads has been paginated
          load_more_action: "Load more",
          // The text of the link that reveals the replies to a thread when there
          // are no unread messages in the thread
          show_replies_action_read_one: "1 reply",
          show_replies_action_read_other: "{{count}} replies",
          // The text of the link that reveals the replies to a thread when there
          // are unread messages in the thread
          show_replies_action_unread_one: "1 new reply",
          show_replies_action_unread_other: "{{count}} new replies",
          // The text of the link that hides the replies to a thread
          hide_replies_action: "Hide replies",
          // The text of the link that shows more replies in a thread when the list
          // of messages has been paginated
          show_more_replies_action: "Show more",
          // The text of the link that starts composing a reply to the thread
          reply_action: "Reply",
          // The status text shown on a resolved thread
          resolved_status: "$t(thread:resolved_status)",
          // The text of the menu item that unresolves a thread
          unresolve_action: "$t(thread:unresolve_action)"
        },
        message: {
          // The text of the link to download an attached file
          download_action: "Download",
          // The error text shown when an attached file that is not an image cannot
          // be displayed
          unable_to_display_document: "Unable to display document",
          // The error text shown when an attached image file cannot be displayed
          unable_to_display_image: "Unable to display image",
          // The text shown next to a message that is currently being edited
          editing_status: "(Editing)",
          // The text shown next to a message that was previously edited
          edited_status: "(Edited)",
          // The text of the menu item that starts editing of a message
          edit_action: "Edit",
          // The text of the menu item that starts editing of a message in a
          // resolved thread
          edit_resolved_action: "Reopen to edit",
          // The text of the menu item that deletes a message
          delete_action: "Delete",
          // The status text that indicates a message was deleted
          deleted_message: "{{user.displayName}} deleted a message",
          // The status text that indicates one or more messages were deleted
          deleted_messages_one: "{{user.displayName}} deleted a message",
          deleted_messages_other: "{{user.displayName}} deleted {{count}} messages",
          // The tooltip on the indicator that a message arrived in Cord from Slack
          sent_via_slack_tooltip: "Sent via Slack",
          // The tooltip on the indicator that a message arrived in Cord from email
          sent_via_email_tooltip: "Sent via Email",
          // The text of the link that undeletes a message
          undo_delete_action: "Undo",
          // The text of the menu item that adds a reaction to a message
          add_reaction_action: "Add reaction",
          // The tooltip for the options menu on a message
          message_options_tooltip: "Options",
          // The status text shown when a screenshot is loading
          screenshot_loading_status: "Loading",
          // The status text shown when a screenshot is unavailable
          screenshot_missing_status: "No screenshot found",
          // The text shown on the button that displays a screenshot at a larger
          // size
          screenshot_expand_action: "Image",
          // The tooltip shown on the button that displays a screenshot at a larger
          // size
          screenshot_expand_tooltip: "Click to expand",
          // The status text showing who has seen a message when the list of users
          // is short enough to show every user individually
          seen_by_status: "Seen by {{users, list(style: short)}}",
          // The status text showing who has seen a message when the list of users
          // is too long to show every user individually
          seen_by_status_overflow_one: "Seen by {{users, list(style: narrow)}}, and 1 other",
          seen_by_status_overflow_other: "Seen by {{users, list(style: narrow)}}, and {{count}} others",
          // The text of the button in the media modal that copies a link to the
          // media
          image_modal_copy_link_action: "Link",
          // The tooltip for the button in the media modal that copies a link to the
          // media
          image_modal_copy_link_tooltip: "Click to copy",
          // The text shown after a user copies a link in the media modal
          image_modal_copy_link_success: "Copied to clipboard",
          // The status text shown below a blurred image in the media modal
          image_modal_blurred_status: "Potentially confidential content has been blurred",
          // The header text shown in the media modal for a screenshot accompanying
          // an annotation
          image_modal_annotation_header: "{{user.displayName}} annotated this <datespan>on {{date}}</datespan>",
          // The header text shown in the media modal for a normal file attachment
          image_modal_attachment_header: "{{user.displayName}} attached this <datespan>on {{date}}</datespan>",
          // The dayjs date format string used to display the date in the media
          // modal header
          image_modal_header_date_format: "D MMM [at] h:mm A",
          // The tooltip for a set of message reactions.
          reaction_with_emoji_name_tooltip_one: "{{users, list(style: narrow)}} reacted with {{emojiName}}",
          reaction_with_emoji_name_tooltip_other: "{{users, list(style: narrow)}} reacted with {{emojiName}}",
          // The tooltip for a set of message reactions where the viewer is one of
          // the users that reacted.
          reaction_with_emoji_name_including_viewer_tooltip_one: "{{users, list(style: narrow)}} reacted with {{emojiName}}",
          reaction_with_emoji_name_including_viewer_tooltip_other: "{{users, list(style: narrow)}} reacted with {{emojiName}}",
          // The strings used to display a relative timestamp on a message
          timestamp: {
            in_less_than_a_minute: "in less than a minute",
            just_now: "just now",
            in_minutes_one: "in 1 min",
            in_minutes_other: "in {{count}} mins",
            minutes_ago_one: "1 min ago",
            minutes_ago_other: "{{count}} mins ago",
            in_hours_one: "in 1 hour",
            in_hours_other: "in {{count}} hours",
            hours_ago_one: "1 hour ago",
            hours_ago_other: "{{count}} hours ago",
            yesterday_format: "[yesterday]",
            last_week_format: "dddd",
            tomorrow_format: "[tomorrow]",
            next_week_format: "dddd",
            this_year_format: "MMM D",
            other_format: "MMM D, YYYY"
          },
          // The strings used to display an absolute timestamp on a message
          absolute_timestamp: {
            today_format: "h:mm A",
            yesterday_format: "MMM D",
            last_week_format: "MMM D",
            tomorrow_format: "MMM D",
            next_week_format: "MMM D",
            this_year_format: "MMM D",
            other_format: "MMM D, YYYY",
            tooltip: "{{date, datetime(dateStyle: short; timeStyle: medium)}}"
          }
        },
        // The message_templates namespace is used for translating the body of Cord
        // messages by marking the messages with a translationKey.  See
        // https://docs.cord.com/customization/translations for more details on message
        // translation.
        message_templates: {
          cord: {
            // The message shown when a user resolves a thread
            thread_resolved: [
              {
                type: "p",
                children: [
                  {
                    type: "mention",
                    user: { id: "{{mention1.userID}}" },
                    children: [{ text: "{{mention1.text}}" }]
                  },
                  { text: " resolved this thread" }
                ]
              }
            ],
            // The message shown when a user unresolves a thread
            thread_unresolved: [
              {
                type: "p",
                children: [
                  {
                    type: "mention",
                    user: { id: "{{mention1.userID}}" },
                    children: [{ text: "{{mention1.text}}" }]
                  },
                  { text: " reopened this thread" }
                ]
              }
            ]
          }
        },
        sidebar: {
          // The text of the button that starts composing a message in a new thread
          add_comment_action: "Add comment",
          // The status text shown above the composer for a new thread
          add_comment_instruction: "Add your comment",
          // The tooltip for the button that closes the sidebar
          close_sidebar_tooltip: "Close",
          // The tooltip for the button that closes the settings in the sidebar
          close_settings_tooltip: "Close",
          // The tooltip for the button that shows the inbox
          inbox_tooltip: "All updates",
          // The text of the button that shows the thread options menu
          thread_options_menu: "Options",
          // The text shown above the list of threads
          thread_list_title: "Comments",
          // The text of the button that returns from a thread to the thread list
          return_to_list_action: "All",
          // The text shown above the composer that suggests annotating the page.
          // The <l> tag will cause the contents to be a link that starts
          // annotating.
          annotation_nudge: "Why not try <l>annotating part of the page</l>?"
        },
        notifications: {
          // The title of the notifications list
          notifications_title: "Notifications",
          // The text of the button that marks all notifications as read
          mark_all_as_read_action: "Mark all as read",
          // The text of the menu item that marks one notification as read
          mark_as_read_action: "Mark as read",
          // The text of the menu item that marks one notification as unread
          mark_as_unread_action: "Mark as unread",
          // The text of the menu item that deletes a notification
          delete_action: "Delete notification",
          // The title text shown when there are no notifications to display
          empty_state_title: "You\u2019re all caught up",
          // The body text shown when there are no notifications to display
          empty_state_body: "When someone @mentions you or replies to your comments, we\u2019ll let you know here.",
          // The tooltip for the button that shows the notification options
          notification_options_tooltip: "Options",
          // The strings used to display a relative timestamp on a message
          timestamp: {
            in_less_than_a_minute: "In less than a minute",
            just_now: "Just now",
            in_minutes_one: "In 1 min",
            in_minutes_other: "In {{count}} mins",
            minutes_ago_one: "1 min ago",
            minutes_ago_other: "{{count}} mins ago",
            in_hours_one: "In 1 hour",
            in_hours_other: "In {{count}} hours",
            hours_ago_one: "1 hour ago",
            hours_ago_other: "{{count}} hours ago",
            yesterday_format: "[Yesterday at] h:mma",
            last_week_format: "dddd",
            tomorrow_format: "[Tomorrow at] h:mma",
            next_week_format: "dddd",
            this_year_format: "MMM D, YYYY",
            other_format: "MMM D, YYYY"
          },
          absolute_timestamp: {
            today_format: "h:mm A",
            yesterday_format: "MMM D",
            last_week_format: "MMM D",
            tomorrow_format: "MMM D",
            next_week_format: "MMM D",
            this_year_format: "MMM D",
            other_format: "MMM D, YYYY",
            tooltip: "{{date, datetime(dateStyle: short; timeStyle: medium)}}"
          }
        },
        // The message_templates namespace is used for translating the body of Cord
        // notifications.
        notification_templates: {
          cord: {
            // A notification that a single user reacted to a message
            reaction_single: "<user>{{senders.0.displayName}}</user> reacted {{reaction}} to your message",
            // A notification that two users reacted to a message
            reaction_double: "<user>{{senders.0.displayName}}</user> <bold>and</bold> <user>{{senders.1.displayName}}</user> reacted {{reaction}} to your message",
            // A notification that three or more users reacted to a message
            reaction_overflow_one: "<user>{{senders.0.displayName}}</user> <bold>and 1 other</bold> reacted {{reaction}} to your message",
            reaction_overflow_other: "<user>{{senders.0.displayName}}</user> <bold>and {{count}} others</bold> reacted {{reaction}} to your message",
            // A notification that a user replied to a message
            reply: "<user>{{senders.0.displayName}}</user> replied on <bold>{{threadName}}</bold>",
            // A notification that a user mentioned the viewer in a message
            reply_mention: "<user>{{senders.0.displayName}}</user> mentioned you in <bold>{{threadName}}</bold>",
            // A notification that a user mentioned and assigned the viewer in a
            // message
            reply_mention_assign: "<user>{{senders.0.displayName}}</user> mentioned you and assigned you to a task in <bold>{{threadName}}</bold>",
            // A notification that a user mentioned and unassigned the viewer in a
            // message
            reply_mention_unassign: "<user>{{senders.0.displayName}}</user> mentioned you and unassigned you from a task in <bold>{{threadName}}</bold>",
            // A notification that a user mentioned the viewer in a message and
            // attached a file to that message
            reply_mention_attachment: "<user>{{senders.0.displayName}}</user> mentioned you and sent you a file in <bold>{{threadName}}</bold>",
            // A notification that a user assigned a task to the viewer in a message
            reply_assign: "<user>{{senders.0.displayName}}</user> assigned you to a task in <bold>{{threadName}}</bold>",
            // A notification that a user unassigned a task from the viewer in a
            // message
            reply_unassign: "<user>{{senders.0.displayName}}</user> unassigned you from a task in <bold>{{threadName}}</bold>",
            // A notification that a user created a new thread
            thread_create: "<user>{{senders.0.displayName}}</user> created a new thread named <bold>{{threadName}}</bold>",
            // A notification that a user resolved a thread
            thread_resolve: "<user>{{senders.0.displayName}}</user> resolved the thread <bold>{{threadName}}</bold>",
            // A notification that a user unresolved a thread
            thread_unresolve: "<user>{{senders.0.displayName}}</user> reopened the thread <bold>{{threadName}}</bold>"
          }
        },
        presence: {
          // The string shown when a user is currently active
          viewing: "Viewing",
          // The strings used to display a relative timestamp in a presence display
          timestamp: {
            in_less_than_a_minute: "Viewing in less than a minute",
            just_now: "Viewed just now",
            in_minutes_one: "Viewing in 1 min",
            in_minutes_other: "Viewing in {{count}} mins",
            minutes_ago_one: "Viewed 1 min ago",
            minutes_ago_other: "Viewed {{count}} mins ago",
            in_hours_one: "Viewing in 1 hour",
            in_hours_other: "Viewing in {{count}} hours",
            hours_ago_one: "Viewed 1 hour ago",
            hours_ago_other: "Viewed {{count}} hours ago",
            yesterday_format: "[Viewed yesterday at] h:mma",
            last_week_format: "[Viewed] dddd",
            tomorrow_format: "[Viewing tomorrow at] h:mma",
            next_week_format: "[Viewing] dddd",
            this_year_format: "[Viewed] MMM D, YYYY",
            other_format: "[Viewed] MMM D, YYYY"
          }
        },
        inbox: {
          // The text of the link that navigates to the page a thread is on
          go_to_page_action: "Go to page",
          // The tooltip of the button that closes the inbox
          close_tooltip: "Close",
          // The title of the list of threads in the inbox
          inbox_title: "Your Inbox",
          // The title of the list of threads across all locations
          all_pages_title: "All Pages",
          // The tooltip of the button that displays the settings
          settings_tooltip: "Collaboration settings",
          // The text of the button that marks all threads in the inbox as read
          mark_all_as_read_action: "Mark all as read",
          // The title text shown when there are no threads in the inbox
          empty_state_title: "You\u2019re all caught up",
          // The body text shown when there are no threads in the inbox
          empty_state_body: "When someone @mentions you or replies to your comments, we\u2019ll let you know here."
        },
        annotation: {
          // The instructional text shown when annotating
          click_prompt: "Click to comment",
          // The tooltip shown next to the cursor when annotating an area that does
          // not have selectable text
          click_tooltip: "Click to comment",
          // The tooltip shown next to the cursor when annotating an area that has
          // selectable text
          click_or_select_tooltip: "Click or select text to comment",
          // The text shown on the link to cancel annotating
          cancel_annotating: "Cancel",
          // The text of the pill shown for an annotation when the annotation has no
          // more specific label
          annotation: "Annotation",
          // The text shown on the button that unhides the annotation from the page
          keep_pin_on_page_action: "Keep pin on page",
          // The status text shown when the element the annotation was associated
          // with cannot be found on the page
          changed: "The annotated area has changed",
          // The text for the link next to an annotation pin that hides the
          // annotation from the page
          hide_action: "Hide for you",
          // The text for the link that shows the message associated with an
          // annotation
          show_message_action: "Click to view message"
        },
        user: {
          // The text shown for the viewer
          viewer_user: "{{user.displayName}} (you)",
          // The text shown for the viewer when further name context is needed
          viewer_user_subtitle: "{{user.secondaryDisplayName}}",
          // The text shown for a non-viewer user
          other_user: "{{user.displayName}}",
          // The text shown for a non-viewer user when further name context is
          // needed
          other_user_subtitle: "{{user.secondaryDisplayName}}",
          // Text needed for showing simple first person indication
          // (i.e. for reactions where you have reacted)
          viewer_user_short: "You"
        },
        // Cord's emoji picker is an external library, which doesn't use i18next,
        // nor conforms to Cord's patterns. You can still translate these strings
        // like you would translate any other string in this file.
        // For more context, see https://www.npmjs.com/package/emoji-picker-element#internationalization
        emoji_picker: {
          categories: {
            custom: "Custom",
            "smileys-emotion": "Smileys and emoticons",
            "people-body": "People and body",
            "animals-nature": "Animals and nature",
            "food-drink": "Food and drink",
            "travel-places": "Travel and places",
            activities: "Activities",
            objects: "Objects",
            symbols: "Symbols",
            flags: "Flags"
          },
          categoriesLabel: "Categories",
          emojiUnsupportedMessage: "Your browser does not support color emoji.",
          favoritesLabel: "Favorites",
          loadingMessage: "Loading\u2026",
          networkErrorMessage: "Could not load emoji.",
          regionLabel: "Emoji picker",
          searchDescription: "When search results are available, press up or down to select and enter to choose.",
          searchLabel: "Search",
          searchResultsLabel: "Search results",
          skinToneDescription: "When expanded, press up or down to select and enter to choose.",
          skinToneLabel: "Choose a skin tone (currently {skinTone})",
          skinTones: [
            "Default",
            "Light",
            "Medium-Light",
            "Medium",
            "Medium-Dark",
            "Dark"
          ],
          skinTonesLabel: "Skin tones"
        }
      },
      // Cord's emoji picker is an external library, which doesn't use i18next, thus it
      // doesn't support "ci mode" out of the box. So we add our own:
      cimode: {
        emoji_picker: {
          categories: {
            custom: "custom",
            "smileys-emotion": "smileys-emotion",
            "people-body": "people-body",
            "animals-nature": "animals-nature",
            "food-drink": "food-drink",
            "travel-places": "travel-places",
            activities: "activities",
            objects: "objects",
            symbols: "symbols",
            flags: "flags"
          },
          categoriesLabel: "categoriesLabel",
          emojiUnsupportedMessage: "emojiUnsupportedMessage",
          favoritesLabel: "favoritesLabel",
          loadingMessage: "loadingMessage",
          networkErrorMessage: "networkErrorMessage",
          regionLabel: "regionLabel",
          searchDescription: "searchDescription",
          searchLabel: "searchLabel",
          searchResultsLabel: "searchResultsLabel",
          skinToneDescription: "skinToneDescription",
          skinToneLabel: "skinToneLabel",
          skinTones: [
            "Default",
            "Light",
            "Medium-Light",
            "Medium",
            "Medium-Dark",
            "Dark"
          ],
          skinTonesLabel: "skinTonesLabel"
        }
      }
    };
    function isEqualLocation(a, b) {
      if (a === b) {
        return true;
      }
      if (!a || !b) {
        return false;
      }
      const aKeys = Object.keys(a);
      if (aKeys.length !== Object.keys(b).length) {
        return false;
      }
      if (!aKeys.every((aKey) => Object.prototype.hasOwnProperty.call(b, aKey))) {
        return false;
      }
      return aKeys.every((key) => a[key] === b[key]);
    }
    exports.MessageNodeType = void 0;
    (function(MessageNodeType13) {
      MessageNodeType13["ASSIGNEE"] = "assignee";
      MessageNodeType13["BULLET"] = "bullet";
      MessageNodeType13["CODE"] = "code";
      MessageNodeType13["LINK"] = "link";
      MessageNodeType13["MENTION"] = "mention";
      MessageNodeType13["NUMBER_BULLET"] = "number_bullet";
      MessageNodeType13["PARAGRAPH"] = "p";
      MessageNodeType13["QUOTE"] = "quote";
      MessageNodeType13["TODO"] = "todo";
      MessageNodeType13["MARKDOWN"] = "markdown";
    })(exports.MessageNodeType || (exports.MessageNodeType = {}));
    var MARKS = ["bold", "italic", "underline", "code"];
    var STYLED_BLOCK_TYPES = [
      exports.MessageNodeType.BULLET,
      exports.MessageNodeType.NUMBER_BULLET,
      exports.MessageNodeType.TODO,
      exports.MessageNodeType.QUOTE
    ];
    function isStyledBlockType(t) {
      return STYLED_BLOCK_TYPES.includes(t);
    }
    var COMPOSER_SIZE = ["small", "medium", "large"];
    var VIRTUALISED_LISTS = [
      "monacoEditor",
      "reactTree",
      "konvaCanvas"
    ];
    var BLUR_DISPLAY_LOCATIONS = ["everywhere", "outside_page"];
    var CAPTURE_SCREENSHOT_EVENT = [
      "new-annotation",
      "share-via-email",
      "new-thread",
      "new-message"
    ];
    function isCaptureScreenshotEvent(captureEvent) {
      return CAPTURE_SCREENSHOT_EVENT.indexOf(captureEvent) !== -1;
    }
    function isBlurDisplayLocation(behavior) {
      return BLUR_DISPLAY_LOCATIONS.indexOf(behavior) !== -1;
    }
    var ANNOTATION_MODES = [
      "everywhere",
      "custom_targets_only",
      "none"
    ];
    function isAnnotationMode(mode) {
      return ANNOTATION_MODES.indexOf(mode) !== -1;
    }
    var CORD_ANNOTATION_LOCATION_DATA_ATTRIBUTE = "data-cord-annotation-location";
    var CORD_ANNOTATION_ALLOWED_DATA_ATTRIBUTE = "data-cord-annotation-allowed";
    var CORD_COMPONENT_WRAPS_DOM_DATA_ATTRIBUTE = "data-cord-component-wraps-dom";
    var CORD_SCREENSHOT_TARGET_DATA_ATTRIBUTE = "data-cord-screenshot-target";
    function locationJson3(c) {
      return JSON.stringify(Object.fromEntries(Object.entries(c).filter(([_key, value]) => value !== void 0).sort(([keyA], [keyB]) => keyA < keyB ? -1 : 1)));
    }
    exports.ANNOTATION_MODES = ANNOTATION_MODES;
    exports.BLUR_DISPLAY_LOCATIONS = BLUR_DISPLAY_LOCATIONS;
    exports.CAPTURE_SCREENSHOT_EVENT = CAPTURE_SCREENSHOT_EVENT;
    exports.COMPOSER_SIZE = COMPOSER_SIZE;
    exports.CORD_ANNOTATION_ALLOWED_DATA_ATTRIBUTE = CORD_ANNOTATION_ALLOWED_DATA_ATTRIBUTE;
    exports.CORD_ANNOTATION_LOCATION_DATA_ATTRIBUTE = CORD_ANNOTATION_LOCATION_DATA_ATTRIBUTE;
    exports.CORD_COMPONENT_WRAPS_DOM_DATA_ATTRIBUTE = CORD_COMPONENT_WRAPS_DOM_DATA_ATTRIBUTE;
    exports.CORD_SCREENSHOT_TARGET_DATA_ATTRIBUTE = CORD_SCREENSHOT_TARGET_DATA_ATTRIBUTE;
    exports.MARKS = MARKS;
    exports.VIRTUALISED_LISTS = VIRTUALISED_LISTS;
    exports.isAnnotationMode = isAnnotationMode;
    exports.isBlurDisplayLocation = isBlurDisplayLocation;
    exports.isCaptureScreenshotEvent = isCaptureScreenshotEvent;
    exports.isEqualLocation = isEqualLocation;
    exports.isStyledBlockType = isStyledBlockType;
    exports.locationJson = locationJson3;
    exports.translationResources = resources;
  }
});

// opensource/sdk-js/packages/api-types/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "opensource/sdk-js/packages/api-types/dist/cjs/index.js"(exports) {
    "use strict";
    var schema2 = {
      CreateApplicationVariables: {
        description: "https://docs.cord.com/rest-apis/applications/",
        type: "object",
        properties: {
          emailSettings: { $ref: "#/definitions/Partial<EmailSettings>" },
          name: {
            description: "Name of the project",
            minLength: 1,
            type: "string"
          },
          iconURL: {
            description: "URL for the project icon. It should be a square image of 256x256. This\nwill be used as the avatar for messages and emails coming from your\nproject.  If not specified, the Cord logo will be used.",
            format: "uri",
            type: ["null", "string"]
          },
          eventWebhookURL: {
            description: "The URL that the events webhook is sent to",
            format: "uri",
            type: ["null", "string"]
          },
          redirectURI: {
            description: "Custom url link contained in email and slack notifications. These notifications are sent when a user is\nmentioned or thread is shared and by default, the link points to the page where the conversation happened.\nFor more information, please refer to the [API docs](/customization/redirect-link)",
            type: ["null", "string"]
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "emailSettings",
          "name",
          "iconURL",
          "eventWebhookURL",
          "redirectURI"
        ],
        required: ["name"],
        definitions: {
          "Partial<EmailSettings>": {
            type: "object",
            properties: {
              name: {
                description: "Name to show in both the subject and the body of the email.\nDefaults to your project's name.",
                type: ["null", "string"]
              },
              imageURL: {
                description: "URL for your logo image. The default for this is the Cord logo.",
                type: ["null", "string"]
              },
              sender: {
                description: "Email from which notifications for your service will be sent from.\nThis will use the provided name for your project to default to `<projectname>-notifications@cord.fyi`.",
                format: "email",
                type: ["null", "string"]
              },
              logoConfig: {
                description: 'Customization for your logo size. Providing either a height (maximum 120) or\nwidth (maximum 240) will result in the image being proportionally resized to\nfit in a container of that size. The default value is `{"width": 140}`.',
                anyOf: [
                  {
                    type: "object",
                    properties: {
                      width: { minimum: 0, maximum: 240, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["width"],
                    required: ["width"]
                  },
                  {
                    type: "object",
                    properties: {
                      height: { minimum: 0, maximum: 120, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["height"],
                    required: ["height"]
                  },
                  { type: "null" }
                ]
              },
              enableEmailNotifications: {
                description: "Whether you want your users to receive notification emails. The default value is true.",
                type: "boolean"
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "name",
              "imageURL",
              "sender",
              "logoConfig",
              "enableEmailNotifications"
            ]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdateApplicationVariables: {
        description: "https://docs.cord.com/rest-apis/applications/",
        type: "object",
        properties: {
          emailSettings: { $ref: "#/definitions/Partial<EmailSettings>" },
          name: {
            description: "Name of the project",
            minLength: 1,
            type: "string"
          },
          iconURL: {
            description: "URL for the project icon. It should be a square image of 256x256. This\nwill be used as the avatar for messages and emails coming from your\nproject.  If not specified, the Cord logo will be used.",
            format: "uri",
            type: ["null", "string"]
          },
          eventWebhookURL: {
            description: "The URL that the events webhook is sent to",
            format: "uri",
            type: ["null", "string"]
          },
          redirectURI: {
            description: "Custom url link contained in email and slack notifications. These notifications are sent when a user is\nmentioned or thread is shared and by default, the link points to the page where the conversation happened.\nFor more information, please refer to the [API docs](/customization/redirect-link)",
            type: ["null", "string"]
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "emailSettings",
          "name",
          "iconURL",
          "eventWebhookURL",
          "redirectURI"
        ],
        definitions: {
          "Partial<EmailSettings>": {
            type: "object",
            properties: {
              name: {
                description: "Name to show in both the subject and the body of the email.\nDefaults to your project's name.",
                type: ["null", "string"]
              },
              imageURL: {
                description: "URL for your logo image. The default for this is the Cord logo.",
                type: ["null", "string"]
              },
              sender: {
                description: "Email from which notifications for your service will be sent from.\nThis will use the provided name for your project to default to `<projectname>-notifications@cord.fyi`.",
                format: "email",
                type: ["null", "string"]
              },
              logoConfig: {
                description: 'Customization for your logo size. Providing either a height (maximum 120) or\nwidth (maximum 240) will result in the image being proportionally resized to\nfit in a container of that size. The default value is `{"width": 140}`.',
                anyOf: [
                  {
                    type: "object",
                    properties: {
                      width: { minimum: 0, maximum: 240, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["width"],
                    required: ["width"]
                  },
                  {
                    type: "object",
                    properties: {
                      height: { minimum: 0, maximum: 120, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["height"],
                    required: ["height"]
                  },
                  { type: "null" }
                ]
              },
              enableEmailNotifications: {
                description: "Whether you want your users to receive notification emails. The default value is true.",
                type: "boolean"
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "name",
              "imageURL",
              "sender",
              "logoConfig",
              "enableEmailNotifications"
            ]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      DeleteApplicationVariables: {
        description: "https://docs.cord.com/rest-apis/applications/",
        type: "object",
        properties: {
          secret: {
            description: "Secret key of the project that you want to delete. This can be found\nwithin the Cord Console.",
            minLength: 1,
            type: "string"
          }
        },
        additionalProperties: false,
        propertyOrder: ["secret"],
        required: ["secret"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      BatchAPIVariables: {
        description: "https://docs.cord.com/rest-apis/batch/",
        type: "object",
        properties: {
          users: {
            description: "List of user objects. Every object must include the id field. If the user\nalready exists, all other fields are optional and only updated when\npresent. If the user does not already exist, fields are required as\ndescribed in the [Create or update a\nuser](/rest-apis/users#Create-or-update-a-user)\nAPI.",
            maxItems: 1e4,
            type: "array",
            items: { $ref: "#/definitions/BatchUpdateUser" }
          },
          organizations: {
            maxItems: 1e3,
            type: "array",
            items: { $ref: "#/definitions/BatchUpdateGroup" }
          },
          groups: {
            description: "List of group objects. Every object must include the id field. If\nthe group already exists, all other fields are optional and only\nupdated when present. If the group does not already exist, fields\nare required as described in the [Create or update a\ngroup](/rest-apis/groups/#create-or-update-a-group)\nAPI.",
            maxItems: 1e3,
            type: "array",
            items: { $ref: "#/definitions/BatchUpdateGroup" }
          }
        },
        additionalProperties: false,
        propertyOrder: ["users", "organizations", "groups"],
        definitions: {
          BatchUpdateUser: {
            additionalProperties: false,
            type: "object",
            properties: {
              name: { description: "Full user name", type: ["null", "string"] },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              status: { enum: ["active", "deleted"], type: "string" },
              email: {
                description: "Email address",
                format: "email",
                type: ["null", "string"]
              },
              shortName: {
                description: "Short user name. In most cases, this will be preferred over name when set.",
                type: ["null", "string"]
              },
              short_name: { type: ["null", "string"] },
              profilePictureURL: {
                description: "This must be a valid URL, which means it needs to follow the usual URL\nformatting and encoding rules. For example, any space character will need\nto be encoded as `%20`. We recommend using your programming language's\nstandard URL encoding function, such as `encodeURI` in Javascript.",
                format: "uri",
                type: ["null", "string"]
              },
              profile_picture_url: {
                description: "Alias for profilePictureURL. This field is deprecated.",
                format: "uri",
                type: ["null", "string"]
              },
              first_name: {
                description: "User's first name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              },
              last_name: {
                description: "User's last name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              },
              id: { $ref: "#/definitions/ID" }
            },
            required: ["id"]
          },
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] },
          BatchUpdateGroup: {
            additionalProperties: false,
            type: "object",
            properties: {
              name: {
                description: "Group name. Required when creating an group.",
                type: "string"
              },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              status: {
                description: "Whether this group is active or deleted.  Attempting to log into a\ndeleted group will fail.",
                enum: ["active", "deleted"],
                type: "string"
              },
              members: {
                description: "List of partner-specific IDs of the users who are members of this group.\nThis will replace the existing members.",
                type: "array",
                items: { $ref: "#/definitions/ID" }
              },
              id: { $ref: "#/definitions/ID" }
            },
            required: ["id"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreateFileVariables: {
        type: "object",
        properties: {
          ownerID: {
            description: "The ID of the user that owns the file.  Files can only be attached to\nmessages authored by their owner.",
            type: "string"
          },
          name: {
            description: "The name of the file.  This will be shown to the user when attached to a\nmessage and will be the file's name if it's downloaded.  If not supplied,\nit will be taken from the filename of the `file` parameter.",
            type: "string"
          }
        },
        additionalProperties: false,
        propertyOrder: ["ownerID", "name"],
        required: ["ownerID"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreateMessageVariables: {
        description: "https://docs.cord.com/rest-apis/messages/",
        type: "object",
        properties: {
          addReactions: {
            description: "The reactions you want to add to this message.\nThe default timestamp is the current time.\nTrying to create a reaction that already exists for a user does nothing.\nDoing the same as before with a timestamp will update the reaction with the new timestamp.\nThe reaction users need to be an [active member of the group](/rest-apis/groups#Update-group-members) that the message and thread belong to.",
            type: "array",
            items: { $ref: "#/definitions/ServerAddReactions" }
          },
          addAttachments: {
            description: "A list of attachments to add to the message.  The same file cannot be\nattached to the same message multiple times.",
            type: "array",
            items: {
              type: "object",
              properties: {
                type: {
                  description: "The type of attachment.  This is `file` for file attachments.",
                  type: "string",
                  const: "file"
                },
                id: {
                  description: "The ID of the file to attach.  This must have been previously uploaded via\nthe [file API](/js-apis-and-hooks/file-api/uploadFile).",
                  type: "string"
                }
              },
              additionalProperties: false,
              propertyOrder: ["type", "id"],
              required: ["id", "type"]
            }
          },
          createThread: {
            description: "The parameters for creating a thread if the supplied thread doesn't exist\nyet.  If the thread doesn't exist but `createThread` isn't provided, the\ncall will generate an error.  This value is ignored if the thread already\nexists.",
            $ref: '#/definitions/Omit<ServerCreateThread,"id">'
          },
          subscribeToThread: {
            description: "Whether to subscribe the sender of the message to the thread, so that they\nget notified about replies.  If not specified, defaults to `true`.  If\nfalse, the user's subscription status will be left unchanged.",
            type: "boolean"
          },
          content: {
            $ref: "#/definitions/MessageContent",
            description: "The content of the message."
          },
          authorID: {
            description: "The ID for the user that sent the message.",
            type: "string"
          },
          type: {
            description: "The type of message this is.  A `user_message` is a message that the author\nsent.  An `action_message` is a message about something that happened, such\nas the thread being resolved.  The default value is `user_message`.",
            enum: ["action_message", "user_message"],
            type: "string"
          },
          id: {
            description: "The ID for the message.  If a message is created with no ID, a random\nUUID-based ID will be automatically created for it.",
            type: "string"
          },
          url: {
            description: "A URL where the message can be seen.  This determines where a user is sent\nwhen they click on a reference to this message, such as in a notification.\nIf unset, it defaults to the thread's URL.",
            type: ["null", "string"]
          },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          createdTimestamp: {
            description: "The timestamp when this message was created.  The default value is the\ncurrent time.",
            type: "string",
            format: "date-time"
          },
          extraClassnames: {
            description: "A optional space separated list of classnames to add to the message.",
            type: ["null", "string"]
          },
          updatedTimestamp: {
            description: "The timestamp when this message was last edited, if it ever was.  If unset,\nthe message does not show as edited.",
            anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
          },
          deletedTimestamp: {
            description: "The timestamp when this message was deleted, if it was.  If unset, the\nmessage is not deleted.",
            anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
          },
          iconURL: {
            description: "The URL of the icon to show next to the message.  This is only used for\n`action_message` messages; other messages show the avatar of the author.\nIf an `action_message` does not have an icon set, no icon is shown.",
            format: "uri",
            type: ["null", "string"]
          },
          translationKey: {
            description: "An optional translation key used for this message.  This is useful for\nsystem-generated messages where you might want to translate or customize\nthem at runtime.  See [the translations\ndocumentation](/customization/translations) for more\ninformation.",
            type: ["null", "string"]
          },
          skipLinkPreviews: {
            description: "If set, Cord won't analyze links in the message to generate previews.",
            type: "boolean"
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "addReactions",
          "addAttachments",
          "createThread",
          "subscribeToThread",
          "content",
          "authorID",
          "type",
          "id",
          "url",
          "metadata",
          "createdTimestamp",
          "extraClassnames",
          "updatedTimestamp",
          "deletedTimestamp",
          "iconURL",
          "translationKey",
          "skipLinkPreviews"
        ],
        required: ["authorID", "content"],
        definitions: {
          ServerAddReactions: {
            additionalProperties: false,
            type: "object",
            properties: {
              reaction: { description: "The emoji reaction.", type: "string" },
              userID: {
                description: "The ID of the user who reacted to the message.",
                type: "string"
              },
              timestamp: {
                description: "The timestamp of when the reaction was created.",
                type: "string",
                format: "date-time"
              }
            },
            required: ["reaction", "userID"]
          },
          'Omit<ServerCreateThread,"id">': {
            type: "object",
            properties: {
              location: {
                description: "The [location](/reference/location) of this thread.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              url: {
                description: "A URL where the thread can be seen.  This determines where a user is sent\nwhen they click on a reference to this thread, such as in a notification,\nor if they click on a reference to a message in the thread and the message\ndoesn't have its own URL.",
                type: "string"
              },
              name: {
                description: "The name of the thread.  This is shown to users when the thread is\nreferenced, such as in notifications.  This should generally be something\nlike the page title.",
                type: "string"
              },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              resolved: { type: "boolean" },
              organizationID: {
                description: "The organization ID this thread is in.",
                type: "string"
              },
              groupID: {
                description: "The group ID this thread is in.",
                type: "string"
              },
              extraClassnames: {
                description: "An optional space separated list of classnames to add to the thread.",
                type: ["null", "string"]
              },
              addSubscribers: {
                description: "A list of subscribers to add to this thread.",
                type: "array",
                items: { type: "string" }
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "location",
              "url",
              "name",
              "metadata",
              "resolved",
              "organizationID",
              "groupID",
              "extraClassnames",
              "addSubscribers"
            ],
            required: ["groupID", "location", "name", "url"]
          },
          MessageAnyNode: {
            anyOf: [
              { $ref: "#/definitions/MessageAssigneeNode" },
              { $ref: "#/definitions/MessageBulletNode" },
              { $ref: "#/definitions/MessageCodeNode" },
              { $ref: "#/definitions/MessageLinkNode" },
              { $ref: "#/definitions/MessageMentionNode" },
              { $ref: "#/definitions/MessageNumberBulletNode" },
              { $ref: "#/definitions/MessageParagraphNode" },
              { $ref: "#/definitions/MessageQuoteNode" },
              { $ref: "#/definitions/MessageTextNode" },
              { $ref: "#/definitions/MessageTodoNode" },
              { $ref: "#/definitions/MessageMarkdownNode" }
            ]
          },
          MessageAssigneeNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "assignee" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              user: {
                type: "object",
                properties: { id: { type: "string" } },
                additionalProperties: false,
                propertyOrder: ["id"],
                required: ["id"]
              }
            },
            required: ["children", "type", "user"]
          },
          MessageContent: {
            type: "array",
            items: { $ref: "#/definitions/MessageAnyNode" }
          },
          MessageBulletNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "bullet" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              indent: { type: "number" }
            },
            required: ["children", "type"]
          },
          MessageCodeNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "code" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          },
          MessageLinkNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "link" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              url: { type: "string" }
            },
            required: ["children", "type", "url"]
          },
          MessageMentionNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "mention" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              user: {
                type: "object",
                properties: { id: { type: "string" } },
                additionalProperties: false,
                propertyOrder: ["id"],
                required: ["id"]
              }
            },
            required: ["children", "type", "user"]
          },
          MessageNumberBulletNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "number_bullet" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              bulletNumber: { type: "number" },
              indent: { type: "number" }
            },
            required: ["bulletNumber", "children", "type"]
          },
          MessageParagraphNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "p" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          },
          MessageQuoteNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "quote" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          },
          MessageTextNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: {
                enum: [
                  "assignee",
                  "bullet",
                  "code",
                  "link",
                  "markdown",
                  "mention",
                  "number_bullet",
                  "p",
                  "quote",
                  "todo"
                ],
                type: "string"
              },
              class: { type: "string" },
              text: { type: "string" },
              bold: { type: "boolean" },
              code: { type: "boolean" },
              italic: { type: "boolean" },
              underline: { type: "boolean" }
            },
            required: ["text"]
          },
          MessageTodoNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "todo" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              todoID: { type: "string" },
              done: { type: "boolean" }
            },
            required: ["children", "done", "todoID", "type"]
          },
          MessageMarkdownNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "markdown" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdateMessageVariables: {
        description: "https://docs.cord.com/rest-apis/messages/",
        type: "object",
        properties: {
          deleted: {
            description: "Whether we want to mark this message as deleted. Setting this to `true` without\nproviding a value for `deletedTimestamp` is equivalent to setting `deletedTimestamp` to current\ntime and setting this to `false` is equivalent to setting `deletedTimestamp` to `null`.",
            type: "boolean"
          },
          deletedTimestamp: {
            description: "The timestamp when this message was deleted, if it was. If set to null, the message is not deleted.\nDeleting a message this way will only soft delete it, replacing the content of the message with a\nrecord of the deletion on the frontend. If you'd like to permanently delete it instead, use the\n[delete message endpoint](/rest-apis/messages#Delete-a-message).",
            anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
          },
          removeReactions: {
            description: "The reactions you want to remove from this message.\nRemoving a reaction that does not exist will have no effect and will not return an error.\nAn error is returned if a reaction is both added and deleted in the same request.",
            type: "array",
            items: { $ref: "#/definitions/ServerRemoveReactions" }
          },
          removeAttachments: {
            description: "The attachments you want to remove from this message.  Removing an\nattachment that doesn't exist has no effect and won't return an error.\nAttempting to add and remove the same attachment in one request is an\nerror.",
            type: "array",
            items: { $ref: "#/definitions/RemoveAttachment" }
          },
          type: {
            description: "The type of message this is.  A `user_message` is a message that the author\nsent.  An `action_message` is a message about something that happened, such\nas the thread being resolved.  The default value is `user_message`.",
            enum: ["action_message", "user_message"],
            type: "string"
          },
          id: {
            description: "The ID for the message.  If a message is created with no ID, a random\nUUID-based ID will be automatically created for it.",
            type: "string"
          },
          url: {
            description: "A URL where the message can be seen.  This determines where a user is sent\nwhen they click on a reference to this message, such as in a notification.\nIf unset, it defaults to the thread's URL.",
            type: ["null", "string"]
          },
          content: {
            description: "The content of the message.",
            $ref: "#/definitions/MessageContent"
          },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          createdTimestamp: {
            description: "The timestamp when this message was created.  The default value is the\ncurrent time.",
            type: "string",
            format: "date-time"
          },
          authorID: {
            description: "The ID for the user that sent the message.",
            type: "string"
          },
          extraClassnames: {
            description: "A optional space separated list of classnames to add to the message.",
            type: ["null", "string"]
          },
          updatedTimestamp: {
            description: "The timestamp when this message was last edited, if it ever was.  If unset,\nthe message does not show as edited.",
            anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
          },
          iconURL: {
            description: "The URL of the icon to show next to the message.  This is only used for\n`action_message` messages; other messages show the avatar of the author.\nIf an `action_message` does not have an icon set, no icon is shown.",
            format: "uri",
            type: ["null", "string"]
          },
          translationKey: {
            description: "An optional translation key used for this message.  This is useful for\nsystem-generated messages where you might want to translate or customize\nthem at runtime.  See [the translations\ndocumentation](/customization/translations) for more\ninformation.",
            type: ["null", "string"]
          },
          skipLinkPreviews: {
            description: "If set, Cord won't analyze links in the message to generate previews.",
            type: "boolean"
          },
          addReactions: {
            description: "The reactions you want to add to this message.\nThe default timestamp is the current time.\nTrying to create a reaction that already exists for a user does nothing.\nDoing the same as before with a timestamp will update the reaction with the new timestamp.\nThe reaction users need to be an [active member of the group](/rest-apis/groups#Update-group-members) that the message and thread belong to.",
            type: "array",
            items: { $ref: "#/definitions/ServerAddReactions" }
          },
          addAttachments: {
            description: "A list of attachments to add to the message.  The same file cannot be\nattached to the same message multiple times.",
            type: "array",
            items: {
              type: "object",
              properties: {
                type: {
                  description: "The type of attachment.  This is `file` for file attachments.",
                  type: "string",
                  const: "file"
                },
                id: {
                  description: "The ID of the file to attach.  This must have been previously uploaded via\nthe [file API](/js-apis-and-hooks/file-api/uploadFile).",
                  type: "string"
                }
              },
              additionalProperties: false,
              propertyOrder: ["type", "id"],
              required: ["id", "type"]
            }
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "deleted",
          "deletedTimestamp",
          "removeReactions",
          "removeAttachments",
          "type",
          "id",
          "url",
          "content",
          "metadata",
          "createdTimestamp",
          "authorID",
          "extraClassnames",
          "updatedTimestamp",
          "iconURL",
          "translationKey",
          "skipLinkPreviews",
          "addReactions",
          "addAttachments"
        ],
        definitions: {
          ServerRemoveReactions: {
            type: "object",
            properties: {
              reaction: { description: "The emoji reaction.", type: "string" },
              userID: {
                description: "The ID of the user who reacted to the message.",
                type: "string"
              }
            },
            additionalProperties: false,
            propertyOrder: ["reaction", "userID"],
            required: ["reaction", "userID"]
          },
          RemoveAttachment: {
            anyOf: [
              {
                type: "object",
                properties: {
                  type: {
                    description: "The type of attachment to remove.  This is `file` for file attachments.",
                    type: "string",
                    const: "file"
                  },
                  id: {
                    description: "The ID of the file attachment to remove.",
                    type: "string"
                  }
                },
                additionalProperties: false,
                propertyOrder: ["type", "id"],
                required: ["id", "type"]
              },
              {
                type: "object",
                properties: {
                  type: {
                    description: "The type of attachment to remove.  This is `link_preview` for link preview attachments.",
                    type: "string",
                    const: "link_preview"
                  },
                  id: {
                    description: "The ID of the link preview attachment to remove.",
                    type: "string"
                  }
                },
                additionalProperties: false,
                propertyOrder: ["type", "id"],
                required: ["id", "type"]
              }
            ]
          },
          MessageAnyNode: {
            anyOf: [
              { $ref: "#/definitions/MessageAssigneeNode" },
              { $ref: "#/definitions/MessageBulletNode" },
              { $ref: "#/definitions/MessageCodeNode" },
              { $ref: "#/definitions/MessageLinkNode" },
              { $ref: "#/definitions/MessageMentionNode" },
              { $ref: "#/definitions/MessageNumberBulletNode" },
              { $ref: "#/definitions/MessageParagraphNode" },
              { $ref: "#/definitions/MessageQuoteNode" },
              { $ref: "#/definitions/MessageTextNode" },
              { $ref: "#/definitions/MessageTodoNode" },
              { $ref: "#/definitions/MessageMarkdownNode" }
            ]
          },
          MessageAssigneeNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "assignee" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              user: {
                type: "object",
                properties: { id: { type: "string" } },
                additionalProperties: false,
                propertyOrder: ["id"],
                required: ["id"]
              }
            },
            required: ["children", "type", "user"]
          },
          MessageContent: {
            type: "array",
            items: { $ref: "#/definitions/MessageAnyNode" }
          },
          MessageBulletNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "bullet" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              indent: { type: "number" }
            },
            required: ["children", "type"]
          },
          MessageCodeNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "code" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          },
          MessageLinkNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "link" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              url: { type: "string" }
            },
            required: ["children", "type", "url"]
          },
          MessageMentionNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "mention" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              user: {
                type: "object",
                properties: { id: { type: "string" } },
                additionalProperties: false,
                propertyOrder: ["id"],
                required: ["id"]
              }
            },
            required: ["children", "type", "user"]
          },
          MessageNumberBulletNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "number_bullet" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              bulletNumber: { type: "number" },
              indent: { type: "number" }
            },
            required: ["bulletNumber", "children", "type"]
          },
          MessageParagraphNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "p" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          },
          MessageQuoteNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "quote" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          },
          MessageTextNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: {
                enum: [
                  "assignee",
                  "bullet",
                  "code",
                  "link",
                  "markdown",
                  "mention",
                  "number_bullet",
                  "p",
                  "quote",
                  "todo"
                ],
                type: "string"
              },
              class: { type: "string" },
              text: { type: "string" },
              bold: { type: "boolean" },
              code: { type: "boolean" },
              italic: { type: "boolean" },
              underline: { type: "boolean" }
            },
            required: ["text"]
          },
          MessageTodoNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "todo" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" },
              todoID: { type: "string" },
              done: { type: "boolean" }
            },
            required: ["children", "done", "todoID", "type"]
          },
          MessageMarkdownNode: {
            additionalProperties: false,
            type: "object",
            properties: {
              type: { type: "string", const: "markdown" },
              class: { type: "string" },
              children: { $ref: "#/definitions/MessageContent" }
            },
            required: ["children", "type"]
          },
          ServerAddReactions: {
            additionalProperties: false,
            type: "object",
            properties: {
              reaction: { description: "The emoji reaction.", type: "string" },
              userID: {
                description: "The ID of the user who reacted to the message.",
                type: "string"
              },
              timestamp: {
                description: "The timestamp of when the reaction was created.",
                type: "string",
                format: "date-time"
              }
            },
            required: ["reaction", "userID"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ListThreadMessageParameters: {
        description: "https://docs.cord.com/rest-apis/messages/",
        type: "object",
        properties: {
          sortDirection: {
            description: "Return messages in ascending or descending order of creation timestamp.  'descending' is the default.",
            enum: ["ascending", "descending"],
            type: "string"
          }
        },
        additionalProperties: false,
        propertyOrder: ["sortDirection"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ListMessageParameters: {
        description: "https://docs.cord.com/rest-apis/messages/",
        type: "object",
        properties: {
          limit: {
            description: "Number of messages to return. Defaults to 1000.",
            type: "number"
          },
          token: {
            description: "Pagination token. This is returned in the `pagination` object of a previous response.",
            type: "string"
          },
          filter: {
            description: "Messages will be matched against the filters specified.\nThis is a partial match, which means any keys other than the ones you specify are ignored\nwhen checking for a match. Please note that because this is a query parameter in a REST API,\nthis JSON object must be URI encoded before being sent.",
            type: "object",
            properties: {
              metadata: {
                description: "Arbitrary key-value pairs of data associated with the message.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              location: {
                description: "The [location](/reference/location) of the thread containing the message.",
                type: "string"
              },
              authorID: {
                description: "If provided, will return messages created by this author.",
                type: "string"
              }
            },
            additionalProperties: false,
            propertyOrder: ["metadata", "location", "authorID"]
          }
        },
        additionalProperties: false,
        propertyOrder: ["limit", "token", "filter"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      AppendMessageVariables: {
        type: "object",
        properties: {
          text: {
            description: "The text that will be appended to the markdown node in the message.",
            type: "string"
          }
        },
        additionalProperties: false,
        propertyOrder: ["text"],
        required: ["text"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreateNotificationVariables: {
        description: "https://docs.cord.com/rest-apis/notifications/",
        type: "object",
        properties: {
          actorID: {
            description: 'ID of user who is the "actor" sending the notification, i.e., the user\ntaking the action the notification is about.\n\nRequired if `template` includes `{{actor}}`.',
            type: "string"
          },
          actor_id: { type: "string" },
          recipientID: {
            description: "ID of user receiving the notification.",
            type: "string"
          },
          recipient_id: { type: "string" },
          template: {
            description: "Template for the header of the notification. The expressions `{{actor}}`\nand `{{recipient}}` will be replaced respectively with the notification's\nactor and recipient. (See below for an example.)",
            type: "string"
          },
          url: {
            description: "URL of page to go to when the notification is clicked.",
            type: "string"
          },
          iconUrl: {
            description: "URL of an icon image if a specific one is desired. For notifications with\nan `actor_id` this will default to the sender's profile picture, otherwise\nit will default to a bell icon.",
            type: "string"
          },
          type: {
            description: "Currently must be set to `url`. In the future this may specify different\ntypes of notifications, but for now only `url` is defined.",
            type: "string",
            const: "url"
          },
          metadata: {
            description: "An arbitrary JSON object that can be used to set additional metadata on the\nnotification. When displaying a [list of\nnotifications](/components/cord-notification-list),\nyou can filter the list by metadata value.\n\nKeys are strings, and values can be strings, numbers or booleans.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          extraClassnames: {
            description: "An optional space separated list of classnames to add to the notification.",
            type: ["null", "string"]
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "actorID",
          "actor_id",
          "recipientID",
          "recipient_id",
          "template",
          "url",
          "iconUrl",
          "type",
          "metadata",
          "extraClassnames"
        ],
        required: ["template", "type", "url"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdatePlatformOrganizationVariables: {
        type: "object",
        properties: {
          name: {
            description: "Organization name. Required when creating an organization.",
            type: "string"
          },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          status: {
            description: "Whether this organization is active or deleted.  Attempting to log into a\ndeleted organization will fail.",
            enum: ["active", "deleted"],
            type: "string"
          },
          members: {
            description: "List of partner-specific IDs of the users who are members of this organization.\nThis will replace the existing members.",
            type: "array",
            items: { $ref: "#/definitions/ID" }
          }
        },
        additionalProperties: false,
        propertyOrder: ["name", "metadata", "status", "members"],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdatePlatformOrganizationMembersVariables: {
        type: "object",
        properties: {
          add: {
            description: "The IDs of users to add to this organization.",
            type: "array",
            items: { $ref: "#/definitions/ID" }
          },
          remove: {
            description: "The IDs of users to remove from this organization.",
            type: "array",
            items: { $ref: "#/definitions/ID" }
          }
        },
        additionalProperties: false,
        propertyOrder: ["add", "remove"],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreatePlatformOrganizationVariables: {
        type: "object",
        properties: {
          id: { $ref: "#/definitions/ID", description: "ID of the organization" },
          name: {
            description: "Organization name. Required when creating an organization.",
            type: "string"
          },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          status: {
            description: "Whether this organization is active or deleted.  Attempting to log into a\ndeleted organization will fail.",
            enum: ["active", "deleted"],
            type: "string"
          },
          members: {
            description: "List of partner-specific IDs of the users who are members of this organization",
            type: "array",
            items: { $ref: "#/definitions/ID" }
          }
        },
        additionalProperties: false,
        propertyOrder: ["id", "name", "metadata", "status", "members"],
        required: ["id", "name"],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdatePlatformGroupVariables: {
        description: "https://docs.cord.com/rest-apis/groups/",
        type: "object",
        properties: {
          name: {
            description: "Group name. Required when creating an group.",
            type: "string"
          },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          status: {
            description: "Whether this group is active or deleted.  Attempting to log into a\ndeleted group will fail.",
            enum: ["active", "deleted"],
            type: "string"
          },
          members: {
            description: "List of partner-specific IDs of the users who are members of this group.\nThis will replace the existing members.",
            type: "array",
            items: { $ref: "#/definitions/ID" }
          }
        },
        additionalProperties: false,
        propertyOrder: ["name", "metadata", "status", "members"],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdatePlatformGroupMembersVariables: {
        description: "https://docs.cord.com/rest-apis/groups/",
        type: "object",
        properties: {
          add: {
            description: "The IDs of users to add to this group.",
            type: "array",
            items: { $ref: "#/definitions/ID" }
          },
          remove: {
            description: "The IDs of users to remove from this group.",
            type: "array",
            items: { $ref: "#/definitions/ID" }
          }
        },
        additionalProperties: false,
        propertyOrder: ["add", "remove"],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdateUserPreferenceVariables: {
        description: "https://docs.cord.com/rest-apis/preferences/",
        type: "object",
        properties: {
          key: {
            description: "The preference key. `notification_channels` controls how users get notified about Cord activity.",
            type: "string",
            const: "notification_channels"
          },
          value: {
            $ref: "#/definitions/Partial<NotificationPreferences>",
            description: 'The updated preference value. This will update only the keys that are passed along.\nFor example, to disable Slack notification, but leave email untouched, you can use this value:\n\n```json\n{\n   "value": { "sendViaSlack": "false" },\n}\n```'
          }
        },
        additionalProperties: false,
        propertyOrder: ["key", "value"],
        required: ["key", "value"],
        definitions: {
          "Partial<NotificationPreferences>": {
            type: "object",
            properties: {
              sendViaSlack: {
                description: "Whether notifications should be sent via slack.",
                type: "boolean"
              },
              sendViaEmail: {
                description: "Whether notifications should be sent via email.",
                type: "boolean"
              }
            },
            additionalProperties: false,
            propertyOrder: ["sendViaSlack", "sendViaEmail"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdateUserPresenceVariables: {
        description: "https://docs.cord.com/rest-apis/presence/",
        type: "object",
        properties: {
          organizationID: { type: "string" },
          exclusiveWithin: {
            description: 'Sets an "exclusivity region" for the ephemeral presence set by this update.\nA user can only be present at one location for a given value of exclusiveWithin.\nIf the user becomes present at a different location with the same value of\nexclusiveWithin, they automatically become no longer present at all other\nlocations with that value of exclusive_within.\nThis is useful to more easily track presence as a user moves among sub-locations.\nFor example, suppose we\'d like to track which specific paragraph on a page\na user is present. We could make those updates like this:\n\n```json\n{\n   "groupID": "<GROUP_ID>",\n   "location": { "page": "<PAGE_ID>", "paragraph": "<PARAGRAPH_ID>" },\n   "exclusiveWithin": { "page": "<PAGE_ID>" }\n}\n```\n\nAs a user moves around a page, their paragraphID will change, while their\npageID will remain the same. The above call to setPresent will mark them\npresent at their specific paragraph. However, since every update uses the\nsame exclusiveWithin, each time they are marked present at one paragraph\nthey will become no longer present at their previous paragraph.',
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          location: {
            description: "The [location](/reference/location) you want the user to be in.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          groupID: {
            description: "The ID of the group which should be able to see this presence update",
            type: "string"
          },
          durable: {
            description: "When `true`, this is a [durable presence](/js-apis-and-hooks/presence-api)\nupdate, when `false`, or is not used, it is an [ephemeral presence](/js-apis-and-hooks/presence-api) update.\n\nThis value defaults to `false.`",
            type: "boolean"
          },
          absent: {
            description: "When `true`, this is an *absence* update, meaning that the user has just left\nthis [location](/reference/location).\nIf the user is currently present at that location, it is cleared.\nThis cannot be used with a [durable presence](/js-apis-and-hooks/presence-api) update.\n\nThis value defaults to `false.` The user will be set as present at the location.",
            type: "boolean"
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "organizationID",
          "exclusiveWithin",
          "location",
          "groupID",
          "durable",
          "absent"
        ],
        required: ["location"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreateProjectVariables: {
        description: "https://docs.cord.com/rest-apis/projects/",
        type: "object",
        properties: {
          emailSettings: { $ref: "#/definitions/Partial<EmailSettings>" },
          name: {
            description: "Name of the project",
            minLength: 1,
            type: "string"
          },
          iconURL: {
            description: "URL for the project icon. It should be a square image of 256x256. This\nwill be used as the avatar for messages and emails coming from your\nproject.  If not specified, the Cord logo will be used.",
            format: "uri",
            type: ["null", "string"]
          },
          eventWebhookURL: {
            description: "The URL that the events webhook is sent to",
            format: "uri",
            type: ["null", "string"]
          },
          redirectURI: {
            description: "Custom url link contained in email and slack notifications. These notifications are sent when a user is\nmentioned or thread is shared and by default, the link points to the page where the conversation happened.\nFor more information, please refer to the [API docs](/customization/redirect-link)",
            type: ["null", "string"]
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "emailSettings",
          "name",
          "iconURL",
          "eventWebhookURL",
          "redirectURI"
        ],
        required: ["name"],
        definitions: {
          "Partial<EmailSettings>": {
            type: "object",
            properties: {
              name: {
                description: "Name to show in both the subject and the body of the email.\nDefaults to your project's name.",
                type: ["null", "string"]
              },
              imageURL: {
                description: "URL for your logo image. The default for this is the Cord logo.",
                type: ["null", "string"]
              },
              sender: {
                description: "Email from which notifications for your service will be sent from.\nThis will use the provided name for your project to default to `<projectname>-notifications@cord.fyi`.",
                format: "email",
                type: ["null", "string"]
              },
              logoConfig: {
                description: 'Customization for your logo size. Providing either a height (maximum 120) or\nwidth (maximum 240) will result in the image being proportionally resized to\nfit in a container of that size. The default value is `{"width": 140}`.',
                anyOf: [
                  {
                    type: "object",
                    properties: {
                      width: { minimum: 0, maximum: 240, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["width"],
                    required: ["width"]
                  },
                  {
                    type: "object",
                    properties: {
                      height: { minimum: 0, maximum: 120, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["height"],
                    required: ["height"]
                  },
                  { type: "null" }
                ]
              },
              enableEmailNotifications: {
                description: "Whether you want your users to receive notification emails. The default value is true.",
                type: "boolean"
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "name",
              "imageURL",
              "sender",
              "logoConfig",
              "enableEmailNotifications"
            ]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdateProjectVariables: {
        description: "https://docs.cord.com/rest-apis/projects/",
        type: "object",
        properties: {
          emailSettings: { $ref: "#/definitions/Partial<EmailSettings>" },
          name: {
            description: "Name of the project",
            minLength: 1,
            type: "string"
          },
          iconURL: {
            description: "URL for the project icon. It should be a square image of 256x256. This\nwill be used as the avatar for messages and emails coming from your\nproject.  If not specified, the Cord logo will be used.",
            format: "uri",
            type: ["null", "string"]
          },
          eventWebhookURL: {
            description: "The URL that the events webhook is sent to",
            format: "uri",
            type: ["null", "string"]
          },
          redirectURI: {
            description: "Custom url link contained in email and slack notifications. These notifications are sent when a user is\nmentioned or thread is shared and by default, the link points to the page where the conversation happened.\nFor more information, please refer to the [API docs](/customization/redirect-link)",
            type: ["null", "string"]
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "emailSettings",
          "name",
          "iconURL",
          "eventWebhookURL",
          "redirectURI"
        ],
        definitions: {
          "Partial<EmailSettings>": {
            type: "object",
            properties: {
              name: {
                description: "Name to show in both the subject and the body of the email.\nDefaults to your project's name.",
                type: ["null", "string"]
              },
              imageURL: {
                description: "URL for your logo image. The default for this is the Cord logo.",
                type: ["null", "string"]
              },
              sender: {
                description: "Email from which notifications for your service will be sent from.\nThis will use the provided name for your project to default to `<projectname>-notifications@cord.fyi`.",
                format: "email",
                type: ["null", "string"]
              },
              logoConfig: {
                description: 'Customization for your logo size. Providing either a height (maximum 120) or\nwidth (maximum 240) will result in the image being proportionally resized to\nfit in a container of that size. The default value is `{"width": 140}`.',
                anyOf: [
                  {
                    type: "object",
                    properties: {
                      width: { minimum: 0, maximum: 240, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["width"],
                    required: ["width"]
                  },
                  {
                    type: "object",
                    properties: {
                      height: { minimum: 0, maximum: 120, type: "number" }
                    },
                    additionalProperties: false,
                    propertyOrder: ["height"],
                    required: ["height"]
                  },
                  { type: "null" }
                ]
              },
              enableEmailNotifications: {
                description: "Whether you want your users to receive notification emails. The default value is true.",
                type: "boolean"
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "name",
              "imageURL",
              "sender",
              "logoConfig",
              "enableEmailNotifications"
            ]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      DeleteProjectVariables: {
        description: "https://docs.cord.com/rest-apis/projects/",
        type: "object",
        properties: {
          secret: {
            description: "Secret key of the project that you want to delete. This can be found\nwithin the Cord Console.",
            minLength: 1,
            type: "string"
          }
        },
        additionalProperties: false,
        propertyOrder: ["secret"],
        required: ["secret"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreateThreadVariables: {
        description: "https://docs.cord.com/rest-apis/threads/",
        type: "object",
        properties: {
          location: {
            description: "The [location](/reference/location) of this thread.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          id: { description: "The ID for this thread.", type: "string" },
          url: {
            description: "A URL where the thread can be seen.  This determines where a user is sent\nwhen they click on a reference to this thread, such as in a notification,\nor if they click on a reference to a message in the thread and the message\ndoesn't have its own URL.",
            type: "string"
          },
          name: {
            description: "The name of the thread.  This is shown to users when the thread is\nreferenced, such as in notifications.  This should generally be something\nlike the page title.",
            type: "string"
          },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          groupID: {
            description: "The group ID this thread is in.",
            type: "string"
          },
          extraClassnames: {
            description: "An optional space separated list of classnames to add to the thread.",
            type: ["null", "string"]
          },
          addSubscribers: {
            description: "A list of subscribers to add to this thread.",
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "location",
          "id",
          "url",
          "name",
          "metadata",
          "groupID",
          "extraClassnames",
          "addSubscribers"
        ],
        required: ["groupID", "location", "name", "url"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdateThreadVariables: {
        description: "https://docs.cord.com/rest-apis/threads/",
        type: "object",
        properties: {
          location: {
            description: "The [location](/reference/location) of this thread.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          id: { description: "The ID for this thread.", type: "string" },
          url: {
            description: "A URL where the thread can be seen.  This determines where a user is sent\nwhen they click on a reference to this thread, such as in a notification,\nor if they click on a reference to a message in the thread and the message\ndoesn't have its own URL.",
            type: "string"
          },
          name: {
            description: "The name of the thread.  This is shown to users when the thread is\nreferenced, such as in notifications.  This should generally be something\nlike the page title.",
            type: "string"
          },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          organizationID: {
            description: "The organization ID this thread is in.",
            type: "string"
          },
          groupID: {
            description: "The group ID this thread is in.",
            type: "string"
          },
          extraClassnames: {
            description: "An optional space separated list of classnames to add to the thread.",
            type: ["null", "string"]
          },
          resolvedTimestamp: {
            description: "The timestamp when this thread was resolved. Set to `null` if this thread\nis not resolved.",
            anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
          },
          userID: {
            description: `Certain changes to the thread may post a message into the thread -- in
particular, resolving or unresolving a thread posts a message into the
thread saying "User un/resolved this thread". This parameter is the ID of
the User who will be listed as the author of that message. It's optional
-- if no user is specified, then those messages won't get posted.`,
            type: "string"
          },
          typing: {
            description: "Marks the specified users as typing in this thread.  The typing indicator\nexpires after 3 seconds, so to continually show the indicator it needs to\nbe called on an interval.  Pass an empty array to clear all users' typing indicators.",
            type: "array",
            items: { type: "string" }
          },
          resolved: {
            description: "Whether the thread is resolved.  Setting this to `true` is equivalent to\nsetting `resolvedTimestamp` to the current time, and setting this to\n`false` is equivalent to setting `resolvedTimestamp` to `null`.",
            type: "boolean"
          },
          seenByUsers: {
            description: "Marks the specified users as having seen/not seen this thread. If a user\nis not included in this list, the seen status will not be changed.",
            type: "array",
            items: { $ref: "#/definitions/ServerThreadSeenUser" }
          },
          addSubscribers: {
            description: "A list of subscribers to add to this thread.",
            type: "array",
            items: { type: "string" }
          },
          removeSubscribers: {
            description: "A list of subscribers to remove from this thread.",
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "location",
          "id",
          "url",
          "name",
          "metadata",
          "organizationID",
          "groupID",
          "extraClassnames",
          "resolvedTimestamp",
          "userID",
          "typing",
          "resolved",
          "seenByUsers",
          "addSubscribers",
          "removeSubscribers"
        ],
        definitions: {
          ServerThreadSeenUser: {
            description: "https://docs.cord.com/rest-apis/threads/",
            type: "object",
            properties: {
              userID: {
                description: "ID of the user that has seen/not seen the thread.",
                type: "string"
              },
              seen: {
                description: "Whether the user has seen the thread or not.",
                type: "boolean"
              }
            },
            additionalProperties: false,
            propertyOrder: ["userID", "seen"],
            required: ["seen", "userID"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ListThreadQueryParameters: {
        description: "https://docs.cord.com/rest-apis/threads/",
        type: "object",
        properties: {
          filter: {
            description: "Threads will be matched against the filters specified.\nThis is a partial match, which means any keys other than the ones you specify are ignored\nwhen checking for a match. Please note that because this is a query parameter in a REST API,\nthis JSON object must be URI encoded before being sent.",
            $ref: "#/definitions/ServerListThreadFilter"
          },
          limit: {
            description: "Number of threads to return. Defaults to 1000.",
            type: "number"
          },
          token: {
            description: "Pagination token. This is returned in the `pagination` object of a previous response.",
            type: "string"
          }
        },
        additionalProperties: false,
        propertyOrder: ["filter", "limit", "token"],
        definitions: {
          ServerListThreadFilter: {
            type: "object",
            properties: {
              location: {
                description: "The [Location](/reference/location) of the threads.\nThis can either be just the location value or an object with a value for\nboth the location and partialMatch properties.\n\nThe value for partialMatch will default to false if only location is provided.",
                anyOf: [
                  {
                    type: "object",
                    additionalProperties: { type: ["string", "number", "boolean"] },
                    propertyOrder: []
                  },
                  {
                    type: "object",
                    properties: {
                      value: {
                        description: "The [Location](/reference/location) of the threads.",
                        type: "object",
                        additionalProperties: {
                          type: ["string", "number", "boolean"]
                        },
                        propertyOrder: []
                      },
                      partialMatch: {
                        description: "If `true`, perform [partial matching](/reference/location#Partial-Matching)\non the specified location. If `false`, fetch information for only exactly the\nlocation specified.",
                        type: "boolean"
                      }
                    },
                    additionalProperties: false,
                    propertyOrder: ["value", "partialMatch"],
                    required: ["partialMatch", "value"]
                  }
                ]
              },
              metadata: {
                description: "Return only objects containing these metadata keys and values. (Metadata is\narbitrary key-value pairs of data that you can associate with an object.)",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              groupID: {
                description: "Return only threads [belonging to this\ngroup](/reference/permissions).",
                type: "string"
              },
              firstMessageTimestamp: {
                description: 'Return only threads with a "first message timestamp" within this range. The\n"first message timestamp" of a thread is the timestamp when the first\nmessage in the thread was created. (This is typically when the thread was\ncreated.)',
                type: "object",
                properties: {
                  from: {
                    description: "Timestamp from where to start the interval. The thread's timestamp must be\n*newer* than (or equal to) this in order to match the filter.\n\nIf not present, the interval will have no start date and any data will\ninclude everything older than the provided `to` timestamp.",
                    type: "string",
                    format: "date-time"
                  },
                  to: {
                    description: "Timestamp where to end the interval. The thread's timestamp must be *older*\nthan (or equal to) this in order to match the filter.\n\nIf not present, the interval will have no end date and any data will\ninclude everything newer than the provided `from` timestamp.",
                    type: "string",
                    format: "date-time"
                  }
                },
                additionalProperties: false,
                propertyOrder: ["from", "to"]
              },
              mostRecentMessageTimestamp: {
                description: 'Return only threads with a "most recent message timestamp" within this\nrange. The "most recent message timestamp" of a thread is the timestamp\nwhen the most recent message in the thread was created or updated. (This is\ntypically when the thread was most recently replied to.)',
                type: "object",
                properties: {
                  from: {
                    description: "Timestamp from where to start the interval. The thread's timestamp must be\n*newer* than (or equal to) this in order to match the filter.\n\nIf not present, the interval will have no start date and any data will\ninclude everything older than the provided `to` timestamp.",
                    type: "string",
                    format: "date-time"
                  },
                  to: {
                    description: "Timestamp where to end the interval. The thread's timestamp must be *older*\nthan (or equal to) this in order to match the filter.\n\nIf not present, the interval will have no end date and any data will\ninclude everything newer than the provided `from` timestamp.",
                    type: "string",
                    format: "date-time"
                  }
                },
                additionalProperties: false,
                propertyOrder: ["from", "to"]
              },
              resolvedStatus: {
                description: "If set to `resolved`, only resolved threads will be returned. If set to `unresolved`,\nonly unresolved threads will be returned. If set to `any`, both resolved and\nunresolved threads will be returned.\n\nIf unset, defaults to `any`.",
                enum: ["any", "resolved", "unresolved"],
                type: "string"
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "location",
              "metadata",
              "groupID",
              "firstMessageTimestamp",
              "mostRecentMessageTimestamp",
              "resolvedStatus"
            ]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      UpdatePlatformUserVariables: {
        description: "https://docs.cord.com/rest-apis/users/",
        type: "object",
        properties: {
          name: { description: "Full user name", type: ["null", "string"] },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          status: { enum: ["active", "deleted"], type: "string" },
          email: {
            description: "Email address",
            format: "email",
            type: ["null", "string"]
          },
          shortName: {
            description: "Short user name. In most cases, this will be preferred over name when set.",
            type: ["null", "string"]
          },
          short_name: { type: ["null", "string"] },
          profilePictureURL: {
            description: "This must be a valid URL, which means it needs to follow the usual URL\nformatting and encoding rules. For example, any space character will need\nto be encoded as `%20`. We recommend using your programming language's\nstandard URL encoding function, such as `encodeURI` in Javascript.",
            format: "uri",
            type: ["null", "string"]
          },
          profile_picture_url: {
            description: "Alias for profilePictureURL. This field is deprecated.",
            format: "uri",
            type: ["null", "string"]
          },
          first_name: {
            description: "User's first name. This field is deprecated and has no effect.",
            type: ["null", "string"]
          },
          last_name: {
            description: "User's last name. This field is deprecated and has no effect.",
            type: ["null", "string"]
          },
          addGroups: {
            description: "A list of group IDs this user should be made a member of.  It is an error\nto specify a group that doesn't exist or one that is also being removed in\nthe same call.  It is not an error to add a user to a group they're already\na member of.",
            type: "array",
            items: { type: "string" }
          },
          removeGroups: {
            description: "A list of group IDs this user should stop being a member of.  It is an\nerror to specify a group that doesn't exist or one that is also being added\nin the same call.  It is not an error to remove a user from a group they\nare not a member of.",
            type: "array",
            items: { type: "string" }
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "name",
          "metadata",
          "status",
          "email",
          "shortName",
          "short_name",
          "profilePictureURL",
          "profile_picture_url",
          "first_name",
          "last_name",
          "addGroups",
          "removeGroups"
        ],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreatePlatformUserVariables: {
        description: "https://docs.cord.com/rest-apis/users/",
        type: "object",
        properties: {
          name: { description: "Full user name", type: ["null", "string"] },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          status: { enum: ["active", "deleted"], type: "string" },
          email: {
            description: "Email address",
            format: "email",
            type: ["null", "string"]
          },
          shortName: {
            description: "Short user name. In most cases, this will be preferred over name when set.",
            type: ["null", "string"]
          },
          short_name: { type: ["null", "string"] },
          profilePictureURL: {
            description: "This must be a valid URL, which means it needs to follow the usual URL\nformatting and encoding rules. For example, any space character will need\nto be encoded as `%20`. We recommend using your programming language's\nstandard URL encoding function, such as `encodeURI` in Javascript.",
            format: "uri",
            type: ["null", "string"]
          },
          profile_picture_url: {
            description: "Alias for profilePictureURL. This field is deprecated.",
            format: "uri",
            type: ["null", "string"]
          },
          first_name: {
            description: "User's first name. This field is deprecated and has no effect.",
            type: ["null", "string"]
          },
          last_name: {
            description: "User's last name. This field is deprecated and has no effect.",
            type: ["null", "string"]
          },
          id: { $ref: "#/definitions/ID", description: "Provided ID for the user" }
        },
        additionalProperties: false,
        propertyOrder: [
          "name",
          "metadata",
          "status",
          "email",
          "shortName",
          "short_name",
          "profilePictureURL",
          "profile_picture_url",
          "first_name",
          "last_name",
          "id"
        ],
        required: ["id"],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ListPlatformUserVariables: {
        description: "https://docs.cord.com/rest-apis/users/",
        type: "object",
        properties: {
          email: { type: ["null", "string"] },
          id: { $ref: "#/definitions/ID", description: "Provided ID for the user" },
          name: { description: "Full user name", type: ["null", "string"] },
          metadata: {
            description: "Arbitrary key-value pairs that can be used to store additional information.",
            type: "object",
            additionalProperties: { type: ["string", "number", "boolean"] },
            propertyOrder: []
          },
          status: { enum: ["active", "deleted"], type: "string" },
          createdTimestamp: {
            description: "Creation timestamp",
            anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
          },
          shortName: {
            description: "Short user name. In most cases, this will be preferred over name when set.",
            type: ["null", "string"]
          },
          short_name: { type: ["null", "string"] },
          profilePictureURL: {
            description: "This must be a valid URL, which means it needs to follow the usual URL\nformatting and encoding rules. For example, any space character will need\nto be encoded as `%20`. We recommend using your programming language's\nstandard URL encoding function, such as `encodeURI` in Javascript.",
            format: "uri",
            type: ["null", "string"]
          },
          profile_picture_url: {
            description: "Alias for profilePictureURL. This field is deprecated.",
            format: "uri",
            type: ["null", "string"]
          },
          first_name: {
            description: "User's first name. This field is deprecated and has no effect.",
            type: ["null", "string"]
          },
          last_name: {
            description: "User's last name. This field is deprecated and has no effect.",
            type: ["null", "string"]
          }
        },
        additionalProperties: false,
        propertyOrder: [
          "email",
          "id",
          "name",
          "metadata",
          "status",
          "createdTimestamp",
          "shortName",
          "short_name",
          "profilePictureURL",
          "profile_picture_url",
          "first_name",
          "last_name"
        ],
        required: [
          "createdTimestamp",
          "email",
          "first_name",
          "id",
          "last_name",
          "metadata",
          "name",
          "profilePictureURL",
          "profile_picture_url",
          "shortName",
          "short_name",
          "status"
        ],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ListUsersResponseWithoutPagination: {
        description: "https://docs.cord.com/rest-apis/users/",
        type: "array",
        items: { $ref: "#/definitions/ServerListUser" },
        definitions: {
          ServerListUser: {
            description: "https://docs.cord.com/rest-apis/users/",
            type: "object",
            properties: {
              email: { type: ["null", "string"] },
              id: {
                $ref: "#/definitions/ID",
                description: "Provided ID for the user"
              },
              name: { description: "Full user name", type: ["null", "string"] },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              status: { enum: ["active", "deleted"], type: "string" },
              createdTimestamp: {
                description: "Creation timestamp",
                anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
              },
              shortName: {
                description: "Short user name. In most cases, this will be preferred over name when set.",
                type: ["null", "string"]
              },
              short_name: { type: ["null", "string"] },
              profilePictureURL: {
                description: "This must be a valid URL, which means it needs to follow the usual URL\nformatting and encoding rules. For example, any space character will need\nto be encoded as `%20`. We recommend using your programming language's\nstandard URL encoding function, such as `encodeURI` in Javascript.",
                format: "uri",
                type: ["null", "string"]
              },
              profile_picture_url: {
                description: "Alias for profilePictureURL. This field is deprecated.",
                format: "uri",
                type: ["null", "string"]
              },
              first_name: {
                description: "User's first name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              },
              last_name: {
                description: "User's last name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "email",
              "id",
              "name",
              "metadata",
              "status",
              "createdTimestamp",
              "shortName",
              "short_name",
              "profilePictureURL",
              "profile_picture_url",
              "first_name",
              "last_name"
            ],
            required: [
              "createdTimestamp",
              "email",
              "first_name",
              "id",
              "last_name",
              "metadata",
              "name",
              "profilePictureURL",
              "profile_picture_url",
              "shortName",
              "short_name",
              "status"
            ]
          },
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ListUsersResponse: {
        description: "https://docs.cord.com/rest-apis/users/",
        type: "object",
        properties: {
          users: { type: "array", items: { $ref: "#/definitions/ServerListUser" } },
          pagination: { $ref: "#/definitions/PaginationDetails" }
        },
        additionalProperties: false,
        propertyOrder: ["users", "pagination"],
        required: ["pagination", "users"],
        definitions: {
          ServerListUser: {
            description: "https://docs.cord.com/rest-apis/users/",
            type: "object",
            properties: {
              email: { type: ["null", "string"] },
              id: {
                $ref: "#/definitions/ID",
                description: "Provided ID for the user"
              },
              name: { description: "Full user name", type: ["null", "string"] },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              status: { enum: ["active", "deleted"], type: "string" },
              createdTimestamp: {
                description: "Creation timestamp",
                anyOf: [{ type: "string", format: "date-time" }, { type: "null" }]
              },
              shortName: {
                description: "Short user name. In most cases, this will be preferred over name when set.",
                type: ["null", "string"]
              },
              short_name: { type: ["null", "string"] },
              profilePictureURL: {
                description: "This must be a valid URL, which means it needs to follow the usual URL\nformatting and encoding rules. For example, any space character will need\nto be encoded as `%20`. We recommend using your programming language's\nstandard URL encoding function, such as `encodeURI` in Javascript.",
                format: "uri",
                type: ["null", "string"]
              },
              profile_picture_url: {
                description: "Alias for profilePictureURL. This field is deprecated.",
                format: "uri",
                type: ["null", "string"]
              },
              first_name: {
                description: "User's first name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              },
              last_name: {
                description: "User's last name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              }
            },
            additionalProperties: false,
            propertyOrder: [
              "email",
              "id",
              "name",
              "metadata",
              "status",
              "createdTimestamp",
              "shortName",
              "short_name",
              "profilePictureURL",
              "profile_picture_url",
              "first_name",
              "last_name"
            ],
            required: [
              "createdTimestamp",
              "email",
              "first_name",
              "id",
              "last_name",
              "metadata",
              "name",
              "profilePictureURL",
              "profile_picture_url",
              "shortName",
              "short_name",
              "status"
            ]
          },
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] },
          PaginationDetails: {
            type: "object",
            properties: {
              token: {
                description: "The token to use to get the next page of results. If empty, there are no more results.",
                type: ["null", "string"]
              },
              total: {
                description: 'Total number of results. Might be bigger than the number of results returned on the query. Useful to display a "total" counter.',
                type: "number"
              }
            },
            additionalProperties: false,
            propertyOrder: ["token", "total"],
            required: ["token", "total"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ListUserQueryParameters: {
        description: "https://docs.cord.com/rest-apis/users/",
        type: "object",
        properties: {
          limit: {
            description: "Number of users to return.\nThe default limit is set to 1000.",
            type: "number"
          },
          token: {
            description: "Pagination token. This is returned in the `pagination` object of a previous response.",
            type: "string"
          },
          filter: {
            description: "This is a JSON object with one optional entry.  Users will be matched\nagainst the filter specified. This is a partial match, which means any keys\nother than the ones you specify are ignored when checking for a match.\nPlease note that because this is a query parameter in a REST API, this JSON\nobject must be URI encoded before being sent.",
            $ref: '#/definitions/Pick<FilterParameters,"metadata">'
          }
        },
        additionalProperties: false,
        propertyOrder: ["limit", "token", "filter"],
        definitions: {
          'Pick<FilterParameters,"metadata">': {
            type: "object",
            properties: {
              metadata: {
                description: "Return only objects containing these metadata keys and values. (Metadata is\narbitrary key-value pairs of data that you can associate with an object.)",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              }
            },
            additionalProperties: false,
            propertyOrder: ["metadata"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      DeleteUserVariables: {
        description: "https://docs.cord.com/rest-apis/users/",
        type: "object",
        properties: {
          permanently_delete: {
            description: "The user will be deleted only if this value is true.",
            type: "boolean"
          }
        },
        additionalProperties: false,
        propertyOrder: ["permanently_delete"],
        required: ["permanently_delete"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      CreateWebhookVariables: {
        type: "object",
        properties: {
          url: {
            description: "The URL to register that will receive webhook events",
            format: "uri",
            type: "string"
          },
          events: {
            description: "The events which you will receive",
            type: "array",
            items: {
              enum: [
                "notification-created",
                "thread-message-added",
                "url-verification"
              ],
              type: "string"
            }
          }
        },
        additionalProperties: false,
        propertyOrder: ["url", "events"],
        required: ["events", "url"],
        $schema: "http://json-schema.org/draft-07/schema#"
      },
      ClientAuthTokenData: {
        description: "https://docs.cord.com/reference/authentication/",
        additionalProperties: true,
        type: "object",
        properties: {
          app_id: { format: "uuid", type: "string" },
          project_id: {
            description: "Your project ID",
            format: "uuid",
            type: "string"
          },
          user_id: { $ref: "#/definitions/ID", description: "The ID for the user" },
          organization_id: {
            minLength: 1,
            maxLength: 128,
            type: ["string", "number"]
          },
          group_id: {
            minLength: 1,
            maxLength: 128,
            description: "The ID for the user\u2019s group",
            type: ["string", "number"]
          },
          user_details: {
            description: "If present, update\u2019s the user\u2019s details, or creates a user with those\ndetails if the user_id is new to Cord. This is an object that contains the\nsame fields as the [user management REST\nendpoint](/rest-apis/users/)",
            $ref: "#/definitions/ServerUpdateUser"
          },
          organization_details: {
            $ref: '#/definitions/Partial<Omit<ServerOrganizationData,"id"|"members"|"connectedToSlack">&{members?:ID[]|undefined;}>'
          },
          group_details: {
            description: "If present, updates the group's details, or creates a group\nwith those details if the group_id is new to Cord. This is an object\nthat contains the same fields as the [group management REST\nendpoint](/rest-apis/groups/)",
            $ref: '#/definitions/Partial<Omit<ServerGroupData,"id"|"members"|"connectedToSlack">&{members?:ID[]|undefined;}>'
          }
        },
        propertyOrder: [
          "app_id",
          "project_id",
          "user_id",
          "organization_id",
          "group_id",
          "user_details",
          "organization_details",
          "group_details"
        ],
        required: ["user_id"],
        definitions: {
          ID: { minLength: 1, maxLength: 128, type: ["string", "number"] },
          ServerUpdateUser: {
            description: "https://docs.cord.com/rest-apis/users/",
            additionalProperties: false,
            type: "object",
            properties: {
              name: { description: "Full user name", type: ["null", "string"] },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              status: { enum: ["active", "deleted"], type: "string" },
              email: {
                description: "Email address",
                format: "email",
                type: ["null", "string"]
              },
              shortName: {
                description: "Short user name. In most cases, this will be preferred over name when set.",
                type: ["null", "string"]
              },
              short_name: { type: ["null", "string"] },
              profilePictureURL: {
                description: "This must be a valid URL, which means it needs to follow the usual URL\nformatting and encoding rules. For example, any space character will need\nto be encoded as `%20`. We recommend using your programming language's\nstandard URL encoding function, such as `encodeURI` in Javascript.",
                format: "uri",
                type: ["null", "string"]
              },
              profile_picture_url: {
                description: "Alias for profilePictureURL. This field is deprecated.",
                format: "uri",
                type: ["null", "string"]
              },
              first_name: {
                description: "User's first name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              },
              last_name: {
                description: "User's last name. This field is deprecated and has no effect.",
                type: ["null", "string"]
              },
              addGroups: {
                description: "A list of group IDs this user should be made a member of.  It is an error\nto specify a group that doesn't exist or one that is also being removed in\nthe same call.  It is not an error to add a user to a group they're already\na member of.",
                type: "array",
                items: { type: "string" }
              },
              removeGroups: {
                description: "A list of group IDs this user should stop being a member of.  It is an\nerror to specify a group that doesn't exist or one that is also being added\nin the same call.  It is not an error to remove a user from a group they\nare not a member of.",
                type: "array",
                items: { type: "string" }
              }
            }
          },
          'Partial<Omit<ServerOrganizationData,"id"|"members"|"connectedToSlack">&{members?:ID[]|undefined;}>': {
            type: "object",
            properties: {
              name: {
                description: "Organization name. Required when creating an organization.",
                type: "string"
              },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              status: {
                description: "Whether this organization is active or deleted.  Attempting to log into a\ndeleted organization will fail.",
                enum: ["active", "deleted"],
                type: "string"
              },
              members: {
                description: "List of partner-specific IDs of the users who are members of this organization.\nThis will replace the existing members.",
                type: "array",
                items: { $ref: "#/definitions/ID" }
              }
            },
            additionalProperties: false,
            propertyOrder: ["name", "metadata", "status", "members"]
          },
          'Partial<Omit<ServerGroupData,"id"|"members"|"connectedToSlack">&{members?:ID[]|undefined;}>': {
            type: "object",
            properties: {
              name: {
                description: "Group name. Required when creating an group.",
                type: "string"
              },
              metadata: {
                description: "Arbitrary key-value pairs that can be used to store additional information.",
                type: "object",
                additionalProperties: { type: ["string", "number", "boolean"] },
                propertyOrder: []
              },
              status: {
                description: "Whether this group is active or deleted.  Attempting to log into a\ndeleted group will fail.",
                enum: ["active", "deleted"],
                type: "string"
              },
              members: {
                description: "List of partner-specific IDs of the users who are members of this group.\nThis will replace the existing members.",
                type: "array",
                items: { $ref: "#/definitions/ID" }
              }
            },
            additionalProperties: false,
            propertyOrder: ["name", "metadata", "status", "members"]
          }
        },
        $schema: "http://json-schema.org/draft-07/schema#"
      }
    };
    exports.schema = schema2;
  }
});

// opensource/sdk-js/packages/server/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "opensource/sdk-js/packages/server/dist/cjs/index.js"(exports) {
    "use strict";
    var jwt11 = __require("jsonwebtoken");
    var crypto9 = __require("crypto");
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    var jwt__namespace = /* @__PURE__ */ _interopNamespaceDefault(jwt11);
    function getClientAuthToken3(project_id, project_secret, payload, options = {}) {
      if (!payload || !payload.user_id) {
        throw new Error("Missing user_id. A token without a user_id can be misinterpreted as an administrative server auth token (which should never be given to clients). If you intended to generate a server auth token, call getServerAuthToken instead.");
      }
      return jwt__namespace.sign({ ...payload, project_id }, project_secret, {
        algorithm: "HS512",
        expiresIn: options.expires ?? "1 min"
      });
    }
    function getServerAuthToken(project_id, project_secret, options = {}) {
      return jwt__namespace.sign({ app_id: project_id }, project_secret, {
        algorithm: "HS512",
        expiresIn: options.expires ?? "1 min"
      });
    }
    function getApplicationManagementAuthToken(customer_id, customer_secret, options = {}) {
      return jwt__namespace.sign({ customer_id }, customer_secret, {
        algorithm: "HS512",
        expiresIn: options.expires ?? "1 min"
      });
    }
    function getProjectManagementAuthToken(customer_id, customer_secret) {
      return jwt__namespace.sign({ customer_id }, customer_secret, {
        algorithm: "HS512",
        expiresIn: "1 min"
      });
    }
    async function fetchCordRESTApi(endpoint, { method = "GET", project_id, project_secret, api_url = "https://api-comment-dev.spendflo.com/", body }) {
      const encodedBody = typeof body === "undefined" || typeof body === "string" ? body : JSON.stringify(body);
      const serverAuthToken = getServerAuthToken(project_id, project_secret);
      const response = await fetch(`${api_url}${endpoint}`, {
        method,
        body: encodedBody,
        headers: {
          Authorization: `Bearer ${serverAuthToken}`,
          "Content-Type": "application/json"
        }
      });
      if (response.ok) {
        return await response.json();
      } else {
        const responseText = await response.text();
        throw new Error(`Error making Cord API call: ${response.status} ${response.statusText} ${responseText}`);
      }
    }
    function validateWebhookSignature(body, cordTimestamp, cordSignature, projectSecret, options = {}) {
      if (!cordSignature) {
        throw new Error("Webhook signature is missing");
      }
      if (!cordTimestamp) {
        throw new Error("Webhook signature timestamp is missing");
      }
      const acceptAgeSeconds = options.acceptAgeSeconds ?? 60 * 5;
      if (Number.isNaN(Number(cordTimestamp)) || Math.abs(Date.now() - Number(cordTimestamp)) > 1e3 * acceptAgeSeconds) {
        throw new Error("Webhook signature timestamp invalid or too old.");
      }
      const verifyStr = cordTimestamp + ":" + body;
      const hmac = crypto9.createHmac("sha256", projectSecret);
      hmac.update(verifyStr);
      const incomingSignature = hmac.digest("base64");
      if (cordSignature !== incomingSignature) {
        throw new Error("Unable to verify webhook signature");
      }
    }
    function tryValidateWebhookSignature(body, timestamp, signature, clientSecret) {
      try {
        validateWebhookSignature(body, timestamp, signature, clientSecret);
      } catch (e) {
        return false;
      }
      return true;
    }
    function parseWebhookBody(body) {
      const payload = JSON.parse(body);
      switch (payload.type) {
        case "thread-message-added":
          return payload;
        case "notification-created":
          return payload;
        case "url-verification":
          return payload;
        default:
          throw new Error("Unknown webhook request type.");
      }
    }
    exports.fetchCordRESTApi = fetchCordRESTApi;
    exports.getApplicationManagementAuthToken = getApplicationManagementAuthToken;
    exports.getClientAuthToken = getClientAuthToken3;
    exports.getProjectManagementAuthToken = getProjectManagementAuthToken;
    exports.getServerAuthToken = getServerAuthToken;
    exports.parseWebhookBody = parseWebhookBody;
    exports.tryValidateWebhookSignature = tryValidateWebhookSignature;
    exports.validateWebhookSignature = validateWebhookSignature;
  }
});

// server/src/asyncTier/pgboss.ts
import PgBoss from "pg-boss";

// server/src/config/MagicEnv.ts
var RequiredVariable = class {
  constructor() {
    this.req = true;
  }
};
var OptionalVariable = class {
  constructor() {
    this.opt = true;
  }
};
var VariableWithDefaultValue = class {
  constructor(defaultValue2) {
    this.defaultValue = defaultValue2;
  }
};
var required = new RequiredVariable();
var optional = new OptionalVariable();
var defaultValue = (defaultValue2) => new VariableWithDefaultValue(defaultValue2);
function magicEnv(processEnv, envDefinition) {
  const env = {};
  for (const key of Object.keys(envDefinition)) {
    const value = processEnv[key];
    const fieldDefinition = envDefinition[key];
    if (fieldDefinition.req) {
      if (value === void 0) {
        throw new Error(`Missing key ${key} in environment`);
      } else {
        env[key] = value;
      }
    } else if (fieldDefinition.opt) {
      env[key] = value;
    } else {
      if (value === void 0) {
        env[key] = fieldDefinition.defaultValue;
      } else {
        env[key] = value;
      }
    }
  }
  return env;
}

// server/src/config/Env.ts
var Env_default = magicEnv(process.env, {
  // `process.env.NODE_ENV` is used in our code, but also in many third party
  // libraries we import, to switch between development and production mode.
  // Just to make sure it is set in the process environment, we include it here.
  NODE_ENV: required,
  // Normally one of `prod`, `staging`, `dev`, `test`, or `loadtest`
  CORD_TIER: required,
  // Accept connections on these ports
  API_SERVER_PORT: optional,
  ADMIN_SERVER_PORT: optional,
  METRICS_SERVER_PORT: optional,
  STATUS_SERVER_PORT: optional,
  CONSOLE_SERVER_PORT: optional,
  DOCS_SERVER_PORT: optional,
  // PostgreSQL connection configuration - required
  POSTGRES_HOST: required,
  POSTGRES_PORT: required,
  POSTGRES_USER: required,
  POSTGRES_PASSWORD: required,
  POSTGRES_DB: required,
  // PostgreSQL read-only server, if there is one (user/password/db setting same
  // as above)
  POSTGRES_READ_HOST: optional,
  POSTGRES_READ_PORT: optional,
  // Redis connection configuration
  REDIS_PORT: required,
  REDIS_HOST: required,
  PREDIS_PORT: required,
  PREDIS_HOST: required,
  // URLs pointing to our own endpoints
  TOP_SERVER_HOST: required,
  APP_SERVER_HOST: required,
  API_SERVER_HOST: required,
  API_SERVER_HOST_PRODUCTION: required,
  ADMIN_SERVER_HOST: required,
  MARKETING_SERVER_HOST: required,
  PUBLIC_UPLOADS_HOST: required,
  CONSOLE_SERVER_HOST: required,
  CORD_TO_HOST: required,
  DOCS_SERVER_HOST: required,
  CLACK_SERVER_HOST: optional,
  COMMUNITY_SERVER_HOST: required,
  // Slack App credentials - required
  SLACK_APP_CLIENT_SECRET: required,
  SLACK_DEV_APP_CLIENT_SECRET: required,
  SLACK_ADMIN_LOGIN_REDIRECT_HOST: optional,
  SLACK_APP_REDIRECT_HOST: optional,
  SLACK_SIGNING_SECRET: required,
  SLACK_ADMIN_CLIENT_SECRET: required,
  SLACK_ADMIN_SIGNING_SECRET: required,
  SLACK_INTERNAL_BOT_TOKEN: required,
  SLACK_INTERNAL_SIGNING_SECRET: required,
  SLACK_CUSTOMER_UPDATES_BOT_TOKEN: required,
  // S3 Bucket File storage
  S3_ACCESS_KEY_ID: optional,
  S3_ACCESS_KEY_SECRET: optional,
  S3_REGION: required,
  S3_BUCKET: required,
  S3_PUBLIC_BUCKET: required,
  S3_ENDPOINT: required,
  S3_USE_PATH_BASED_URLS: required,
  EMAIL_LINKS_TOKEN_SECRET: required,
  // Jira App credentials - required
  JIRA_APP_CLIENT_ID: required,
  JIRA_APP_CLIENT_SECRET: required,
  // Asana App credentials - required
  ASANA_APP_CLIENT_ID: required,
  ASANA_APP_CLIENT_SECRET: required,
  // Linear App credentials - required
  LINEAR_APP_CLIENT_ID: required,
  LINEAR_APP_CLIENT_SECRET: required,
  // Trello App credentials - required
  TRELLO_APP_CLIENT_ID: required,
  TRELLO_APP_CLIENT_SECRET: required,
  // Monday App credentials - required
  MONDAY_APP_CLIENT_ID: required,
  MONDAY_APP_CLIENT_SECRET: required,
  // Secret for session tokens - required
  JWT_SIGNING_SECRET: required,
  // Secret for signing OAuth flow state variables encoding the user and org IDs
  OAUTH_STATE_SIGNING_SECRET: required,
  // Secret for signing Slack OAuth flow state variables encoding the user and org IDs
  SLACK_OAUTH_STATE_SIGNING_SECRET: required,
  // Log level for console logging - optional ('info' if not provided)
  LOGLEVEL: defaultValue("info"),
  // Post error messages to this Slack channel,
  CORD_OPS_SLACK_CHANNEL_ID: optional,
  // Post informational changes to prod setup, including deploy and db migration
  // messages, to this Slack channel
  PROD_CHANGES_SLACK_CHANNEL_ID: optional,
  // Post security/SOC2 compliance messages to this Slack channel,
  CORD_SECURITY_SLACK_CHANNEL_ID: optional,
  // Post info about go redirects to this Slack channel
  CORD_GO_REDIRECTS_SLACK_CHANNEL_ID: optional,
  // Post messages from customers to this Slack channel
  CORD_ALL_CUSTOMERS_SLACK_CHANNEL_ID: optional,
  // Post client request messages to this Slack channel
  CORD_CLIENT_REQUESTS_SLACK_CHANNEL_ID: optional,
  // For sending search queries from the docs site to Slack
  CORD_DOCS_SEARCH_SLACK_CHANNEL_ID: optional,
  // Cloudwatch config - optional. If these are not provided, Cloudwatch
  // logging is disabled
  CLOUDWATCH_LOGLEVEL: optional,
  CLOUDWATCH_AWS_REGION: defaultValue("eu-west-2"),
  // our default region, London
  CLOUDWATCH_LOG_GROUP_NAME: optional,
  CLOUDWATCH_LOG_STREAM_NAME: optional,
  // Host used when developing locally but an externally accessible url is
  // needed. (example: d92dd1d1fa99.ngrok.io)
  EXTERNAL_API_HOST_FOR_DEVELOPMENT: optional,
  // path to static files for the admin app
  ADMIN_SERVER_STATIC_PATH: defaultValue("dist/server/admin"),
  // path to static files for the console app
  CONSOLE_SERVER_STATIC_PATH: defaultValue("dist/server/console"),
  // path to static files for the docs app
  DOCS_SERVER_STATIC_PATH: defaultValue("dist/docs/static"),
  // API key used to send transactional email notifications through Sendgrid.
  SENDGRID_API_KEY: required,
  // HTTP Basic Auth name and password for SendGrid's Inbound Parse webhooks
  SENDGRID_INBOUND_WEBHOOK_USER: required,
  SENDGRID_INBOUND_WEBHOOK_PASSWORD: required,
  // API key used to fetch feature flags from LaunchDarkly
  LAUNCHDARKLY_API_KEY: optional,
  // Number of extra workers to run the api server in: 'auto' makes one per CPU; otherwise a specific number can be used
  NUM_WORKERS: optional,
  // Encryption key used when storing secrets in the database
  PLATFORM_SECRETS_ENCRYPTION_KEY: required,
  // Encryption key used when generating file permalinks
  FILE_PROXY_SIGNING_SECRET_KEY: required,
  // sentry.io environment setting
  SENTRY_ENVIRONMENT: optional,
  SENTRY_RELEASE: optional,
  SENTRY_TRACE_SAMPLE_RATE: optional,
  // Auth0 Environment variables
  // 1) For SPA application
  AUTH0_CLIENT_ID: required,
  AUTH0_CUSTOM_LOGIN_DOMAIN: required,
  // 2) For verifying incoming events
  AUTH0_WEBHOOK_SECRET: required,
  // 3) For server to server communication
  AUTH0_MTM_CLIENT_ID: required,
  AUTH0_MTM_CLIENT_SECRET: required,
  AUTH0_GENERAL_DOMAIN: required,
  // console.cord.com cord app credentials
  DEV_CONSOLE_CORD_APP_SECRET: required,
  // secret for signing admin tokens to serve as proof user is logged in to
  // admin
  ADMIN_TOKEN_SECRET: required,
  // flag whether the SDK testbed should be built and served
  INCLUDE_SDK_TESTBED: optional,
  // secret for cookies on the docs web site
  DOCS_COOKIE_PARSER_SECRET: optional,
  // set email for all notifications when testing with users on testbed
  TESTBED_USERS_EMAIL: optional,
  // secret for creating searchable embeddings and generating search
  // results within our docs
  OPENAI_API_SECRET: required,
  // secret for getting geographic information from an IP address
  IPSTACK_API_SECRET: optional,
  // Host for where we generate the ai chat bot in the docs
  DOCS_AI_CHATBOT_SERVER_HOST: required,
  // Google analytic events
  GA_MEASUREMENT_ID: required,
  GA_MEASUREMENT_PROTOCOL_API_SECRET: required,
  // secret for stripe
  STRIPE_SECRET_KEY: required,
  STRIPE_WEBHOOK_SECRET_KEY: required,
  DEMO_APPS_SHARED_SECRET: required,
  // loops.so for sending newletters
  LOOPS_SO_API_KEY: required
});

// server/src/logging/Logger.ts
import { hostname, userInfo } from "os";
import { serializeError } from "serialize-error";
import winston from "winston";
import WinstonCloudWatch from "winston-cloudwatch";
import Transport from "winston-transport";
import * as Sentry from "@sentry/node";

// server/src/entity/application/ApplicationEntity.ts
import { Table as Table4, Column as Column4, Model as Model4 } from "sequelize-typescript";
import { DataTypes as DataTypes4 } from "sequelize";

// server/src/featureflags/index.ts
import * as LaunchDarkly from "@launchdarkly/node-server-sdk";

// common/const/FeatureFlags.ts
var FeatureFlags = {
  USE_NEW_CSS_COMPONENTS: {
    key: "Use_new_CSS_components",
    defaultValue: {}
  },
  SUPPORT_CHAT_ENABLED: {
    key: "support_chat_enabled",
    defaultValue: false
  },
  ENABLE_ANNOTATIONS_SCREENSHOTS: {
    key: "enable_annotations_screenshots",
    defaultValue: true
  },
  ENABLE_PLAINTEXT_ANNOTATIONS: {
    key: "enable_plaintext_annotations",
    defaultValue: true
  },
  ENABLE_ATTACHMENTS: {
    key: "enable_attachments",
    defaultValue: true
  },
  EMAIL_SHARING: {
    key: "email_sharing",
    defaultValue: true
  },
  ENABLE_FORCE_REFRESH_PROVIDER: {
    key: "enable_force_refresh_provider",
    defaultValue: false
  },
  MONDAY_TASKS: {
    key: "monday_tasks",
    defaultValue: false
  },
  TAKE_SCREENSHOT_WHEN_CREATING_THREAD: {
    key: "take_screenshot_when_creating_thread",
    defaultValue: false
  },
  TAKE_SCREENSHOT_WHEN_SENDING_MESSAGE: {
    key: "take_screenshot_when_sending_message",
    defaultValue: false
  },
  OPEN_THREAD_SAME_PAGE: {
    key: "open_thread_same_page",
    defaultValue: false
  },
  SHOW_ACTIVATION_WELCOME_MESSAGE_NUX: {
    key: "show_activation_welcome_message_nux",
    defaultValue: false
  },
  ENABLE_SLACK_FEATURES: {
    key: "enable-slack-features",
    defaultValue: true
  },
  ENABLE_DEV_CONSOLE_SELF_SERVE: {
    key: "enable-dev-console-self-serve",
    defaultValue: false
  },
  // TODO: remove - no longer used
  THREAD_STYLING_TWEAKS: {
    key: "thread_styling_tweaks",
    defaultValue: false
  },
  REMOVE_TASKS_FEATURE: {
    key: "remove_tasks_feature",
    defaultValue: false
  },
  SHOW_COMMUNITY_IN_CONSOLE: {
    key: "show-community-in-console",
    defaultValue: true
  },
  SHOW_CUSTOMER_ISSUES_IN_CONSOLE: {
    key: "show-customer-issues-in-console",
    defaultValue: false
  },
  TAKE_SCREENSHOT_OF_CANVAS_ONLY: {
    key: "take_screenshot_of_canvas_only",
    defaultValue: false
  },
  SHOW_EVENTS_TAB_IN_CONSOLE: {
    key: "show_events_tab_in_console",
    defaultValue: true
  },
  ENABLE_TEXT_ANNOTATIONS: {
    key: "enable_text_annotations",
    defaultValue: true
  },
  ENABLE_EMAIL_NOTIFICATIONS: {
    key: "enable_email_notifications",
    defaultValue: true
  },
  ENABLE_ANNOTATIONS_OVERLAY: {
    key: "enable_annotations_overlay",
    defaultValue: true
  },
  ENABLE_SENTRY: {
    key: "enable_sentry",
    defaultValue: true
  },
  CONSOLE_WEBINAR_BANNER: {
    key: "console_webinar_banner",
    defaultValue: {}
  },
  ENABLE_VIDEO_CAPABILITIES: {
    key: "enable_video_capabilities",
    defaultValue: false
  },
  SHOW_LINK_PREVIEWS: {
    key: "show-link-previews",
    defaultValue: true
  },
  BILLING_ENABLED_IN_CONSOLE: {
    key: "billing_enabled_in_console",
    defaultValue: true
  },
  MENTION_NOTIFICATION_EMAIL_TEMPLATE_ID: {
    key: "mention_notification_email_template_id",
    defaultValue: "d-6309e6ccb36a4a769957795f475c8130"
  },
  SHOW_CONSOLE_LANDING_PAGE: {
    key: "show_console_landing_page",
    defaultValue: false
  }
};
var defaults = Object.fromEntries(
  Object.entries(FeatureFlags).map(([_, v]) => [v.key, v.defaultValue])
);

// server/src/email/index.ts
import * as sgMail from "@sendgrid/mail";
import * as jwt from "jsonwebtoken";

// common/types/index.ts
import jsonStableStringify from "fast-json-stable-stringify";

// opensource/sdk-js/packages/react/common/lib/fast-deep-equal.ts
function equal(a, b) {
  if (a === b) {
    return true;
  }
  if (a && b && typeof a == "object" && typeof b == "object") {
    if (a.constructor !== b.constructor) {
      return false;
    }
    let length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (!equal(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    if (a instanceof Map && b instanceof Map) {
      if (a.size !== b.size) {
        return false;
      }
      for (i of a.entries()) {
        if (!b.has(i[0])) {
          return false;
        }
      }
      for (i of a.entries()) {
        if (!equal(i[1], b.get(i[0]))) {
          return false;
        }
      }
      return true;
    }
    if (a instanceof Set && b instanceof Set) {
      if (a.size !== b.size) {
        return false;
      }
      for (i of a.entries()) {
        if (!b.has(i[0])) {
          return false;
        }
      }
      return true;
    }
    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) {
        return false;
      }
      for (i = length; i-- !== 0; ) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    if (a.constructor === RegExp) {
      return a.source === b.source && a.flags === b.flags;
    }
    if (a.valueOf !== Object.prototype.valueOf) {
      return a.valueOf() === b.valueOf();
    }
    if (a.toString !== Object.prototype.toString) {
      return a.toString() === b.toString();
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (!equal(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
var isEqual = equal;

// common/types/index.ts
var import_types = __toESM(require_cjs(), 1);
var import_types2 = __toESM(require_cjs(), 1);
function isValidFlatJsonObject(obj) {
  if (!obj) {
    return false;
  }
  if (typeof obj !== "object" || Array.isArray(obj)) {
    return false;
  }
  for (const [_, value] of Object.entries(obj)) {
    const t = typeof value;
    if (t !== "string" && t !== "number" && t !== "boolean") {
      return false;
    }
  }
  return true;
}
function isLocation(obj) {
  return isValidFlatJsonObject(obj);
}
function isValidMetadata(obj) {
  return isValidFlatJsonObject(obj);
}
function toLocation(obj) {
  return isLocation(obj) ? obj : null;
}
function getLocationFilter(obj) {
  if (!obj) {
    return void 0;
  }
  if (isLocation(obj)) {
    return { value: obj, partialMatch: false };
  }
  if (isLocation(obj.value)) {
    return obj;
  }
  return void 0;
}
function getViewerThreadFilter(viewerStatus) {
  if (!viewerStatus) {
    return [];
  }
  if (typeof viewerStatus === "string") {
    return [viewerStatus];
  }
  return viewerStatus;
}
function metadataMatches(metadata, matcher) {
  for (const [key, value] of Object.entries(matcher)) {
    if (metadata[key] !== value) {
      return false;
    }
  }
  return true;
}
function locationMatches(context, matcher) {
  for (const [key, value] of Object.entries(matcher)) {
    if (context[key] !== value) {
      return false;
    }
  }
  return true;
}
function flatJsonObjectEqual(a, b) {
  if (a === null && b === null) {
    return true;
  }
  if (a === null || b === null) {
    return false;
  }
  if (Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const [key, value] of Object.entries(a)) {
    if (b[key] !== value) {
      return false;
    }
  }
  return true;
}
function locationEqual(a, b) {
  return flatJsonObjectEqual(a, b);
}
function metadataEqual(a, b) {
  return flatJsonObjectEqual(a, b);
}
function locationCompare(a, b) {
  const lengthA = Object.keys(a).length;
  const lengthB = Object.keys(b).length;
  if (lengthA !== lengthB) {
    return lengthA - lengthB;
  }
  return (0, import_types2.locationJson)(a).localeCompare((0, import_types2.locationJson)(b));
}
function toPageContext(pageContext) {
  if (!pageContext) {
    return null;
  }
  const { providerID, data } = pageContext;
  if (!isLocation(data)) {
    throw new Error("Invalid context");
  }
  return {
    providerID: providerID ?? null,
    data
  };
}
function parseElementIdentifierVersion(val) {
  if (val === "1" || val === "2") {
    return val;
  }
  return null;
}
var ThreadCreatedTypeName = "ThreadCreated";
var ThreadMessageAddedTypeName = "ThreadMessageAdded";
var ThreadMessageUpdatedTypeName = "ThreadMessageUpdated";
var ThreadMessageContentAppendedTypeName = "ThreadMessageContentAppended";
var ThreadMessageRemovedTypeName = "ThreadMessageRemoved";
var ThreadParticipantsUpdatedIncrementalTypeName = "ThreadParticipantsUpdatedIncremental";
var ThreadTypingUsersUpdatedTypeName = "ThreadTypingUsersUpdated";
var ThreadShareToSlackTypeName = "ThreadShareToSlack";
var ThreadPropertiesUpdatedTypeName = "ThreadPropertiesUpdated";
var ThreadSubscriberUpdatedTypeName = "ThreadSubscriberUpdated";
var ThreadDeletedTypeName = "ThreadDeleted";
var PageThreadAddedTypeName = "PageThreadAdded";
var PageThreadDeletedTypename = "PageThreadDeleted";
var ThreadFilterablePropertiesMatchTypeName = "ThreadFilterablePropertiesMatch";
var ThreadFilterablePropertiesUnmatchTypeName = "ThreadFilterablePropertiesUnmatch";
var NotificationAddedTypeName = "NotificationAdded";
var NotificationReadStateUpdatedTypeName = "NotificationReadStateUpdated";
var NotificationDeletedTypeName = "NotificationDeleted";
var OrgMemberAddedTypeName = "OrgMemberAdded";
var OrgMemberRemovedTypeName = "OrgMemberRemoved";
var DEPLOYMENT_TYPES = ["sdk"];
function isDeploymentType(s) {
  if (DEPLOYMENT_TYPES.includes(s)) {
    return true;
  }
  return false;
}
function toDeploymentType(s) {
  if (s && isDeploymentType(s)) {
    return s;
  }
  return null;
}

// server/src/entity/email_notification/EmailOutboundNotificationEntity.ts
import { Table, Column, Model } from "sequelize-typescript";
import { DataTypes } from "sequelize";
var EmailOutboundNotificationEntity = class extends Model {
};
__decorateClass([
  Column({
    type: DataTypes.UUID,
    allowNull: false,
    primaryKey: true,
    defaultValue: DataTypes.UUIDV4
  })
], EmailOutboundNotificationEntity.prototype, "id", 2);
__decorateClass([
  Column({
    type: DataTypes.UUID,
    allowNull: false
  })
], EmailOutboundNotificationEntity.prototype, "userID", 2);
__decorateClass([
  Column({
    type: DataTypes.UUID,
    allowNull: false
  })
], EmailOutboundNotificationEntity.prototype, "orgID", 2);
__decorateClass([
  Column({
    type: DataTypes.UUID,
    allowNull: false
  })
], EmailOutboundNotificationEntity.prototype, "threadOrgID", 2);
__decorateClass([
  Column({
    type: DataTypes.UUID,
    allowNull: false
  })
], EmailOutboundNotificationEntity.prototype, "threadID", 2);
__decorateClass([
  Column({
    type: DataTypes.TEXT,
    allowNull: false
  })
], EmailOutboundNotificationEntity.prototype, "email", 2);
EmailOutboundNotificationEntity = __decorateClass([
  Table({
    tableName: "email_notifications",
    timestamps: false
  })
], EmailOutboundNotificationEntity);

// server/src/email/utils.ts
import addrs from "email-addresses";
import isUUID from "validator/lib/isUUID.js";
import replyParser from "node-email-reply-parser";
function parseEmailAddress(emailAddress) {
  const parsedAddress = addrs.parseAddressList(emailAddress)?.find((email) => email.type === "mailbox");
  if (parsedAddress === void 0) {
    throw new Error(`failed to parse email address: ${emailAddress}`);
  }
  return parsedAddress;
}
function getReplyToEmailAddress(logger, senderEmailAddress, notificationId) {
  try {
    const parsedAddress = parseEmailAddress(senderEmailAddress);
    const replyToAddress = `${parsedAddress.local}-${notificationId}@cord.fyi`;
    if (parsedAddress.name) {
      return `${parsedAddress.name} <${replyToAddress}>`;
    }
    return replyToAddress;
  } catch (e) {
    logger.logException("failed to parse email address", e);
    return senderEmailAddress;
  }
}
function extractCordEmailUUID(emailAddress) {
  try {
    const parsedAddress = parseEmailAddress(emailAddress);
    const uuidLength = 36;
    if (parsedAddress.local.length < 1 + uuidLength || parsedAddress.local.slice(-(1 + uuidLength))[0] !== "-") {
      return null;
    }
    const maybeUUID = parsedAddress.local.slice(-uuidLength);
    return isUUID.default(maybeUUID) ? maybeUUID : null;
  } catch (e) {
    anonymousLogger().logException(
      "failed to parse email address",
      e,
      {},
      void 0,
      "warn"
    );
    return null;
  }
}
function emailTextToMessageContent(emailText, attachments) {
  const replyFragments = replyParser(emailText).getFragments();
  let replyBeforeQuotedText = "";
  for (const fragment of replyFragments) {
    if (fragment.isQuoted()) {
      break;
    }
    replyBeforeQuotedText += fragment.getContent();
  }
  let replyText = replyParser(replyBeforeQuotedText).getVisibleText({
    // from the docs of replyParser:
    // Using aggressive mode runs the risk of losing visible lines which are
    // interspersed with quoted lines, but is useful when parsing e.g. emails
    // from a 'reply by email' feature which contain a large block of quoted
    // text.
    aggressive: true
  });
  if (Number(attachments) > 0) {
    replyText = replyText + `
(Unable to display attached files)`;
  }
  return replyText.split(/\r?\n/).filter((l) => l.length > 0).map((line) => ({
    type: import_types2.MessageNodeType.PARAGRAPH,
    children: [{ text: line }]
  }));
}
async function getNotification(toAddress, inReplyToHeader, fromEmail, logger) {
  const notificationID = extractCordEmailUUID(toAddress);
  if (notificationID) {
    return await EmailOutboundNotificationEntity.findOne({
      where: { id: notificationID }
    });
  }
  if (inReplyToHeader) {
    logger.debug(
      "Unable to find notificationId in toAddress, will try to find from inReplyTo header",
      {
        toAddress,
        inReplyToHeader,
        fromEmail
      }
    );
    const threadOrNotificationID = extractCordEmailUUID(inReplyToHeader);
    if (threadOrNotificationID) {
      const notification = await EmailOutboundNotificationEntity.findOne({
        where: { id: threadOrNotificationID }
      });
      if (notification) {
        return notification;
      }
    }
    let parsedFromEmail;
    try {
      const email = parseEmailAddress(fromEmail);
      parsedFromEmail = email.address;
    } catch (e) {
      logger.warn("Error parsing from email", e);
    }
    if (threadOrNotificationID && parsedFromEmail) {
      return await EmailOutboundNotificationEntity.findOne({
        where: { threadID: threadOrNotificationID, email: parsedFromEmail }
      });
    }
  }
  return null;
}
function getHeader(key, input) {
  const pattern = new RegExp(`^${key}: (.+)$`, "gm");
  const match = pattern.exec(input);
  return match?.[1];
}
function parseRelevantHeaders(headersString) {
  const messageID = getHeader("Message-Id", headersString);
  const inReplyTo = getHeader("In-Reply-To", headersString);
  const autoSubmitted = getHeader("Auto-Submitted", headersString);
  return { messageID, inReplyTo, autoSubmitted };
}

// server/src/entity/event/EventEntity.ts
import { Table as Table2, Column as Column2, PrimaryKey, Model as Model2 } from "sequelize-typescript";
import { DataTypes as DataTypes2 } from "sequelize";
var EventEntity = class extends Model2 {
};
__decorateClass([
  PrimaryKey,
  Column2({
    type: DataTypes2.UUID,
    defaultValue: DataTypes2.UUIDV4
  })
], EventEntity.prototype, "id", 2);
__decorateClass([
  Column2({
    type: DataTypes2.UUID
  })
], EventEntity.prototype, "pageLoadID", 2);
__decorateClass([
  Column2({
    type: DataTypes2.UUID
  })
], EventEntity.prototype, "installationID", 2);
__decorateClass([
  Column2({
    type: DataTypes2.TEXT
  })
], EventEntity.prototype, "version", 2);
__decorateClass([
  Column2({
    type: DataTypes2.JSONB
  })
], EventEntity.prototype, "utmParameters", 2);
__decorateClass([
  Column2({
    type: DataTypes2.UUID
  })
], EventEntity.prototype, "userID", 2);
__decorateClass([
  Column2({
    type: DataTypes2.UUID
  })
], EventEntity.prototype, "orgID", 2);
__decorateClass([
  Column2({
    type: DataTypes2.UUID
  })
], EventEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column2({
    type: DataTypes2.NUMBER
  })
], EventEntity.prototype, "eventNumber", 2);
__decorateClass([
  Column2({
    type: DataTypes2.TIME
  })
], EventEntity.prototype, "clientTimestamp", 2);
__decorateClass([
  Column2({
    type: DataTypes2.TIME
  })
], EventEntity.prototype, "serverTimestamp", 2);
__decorateClass([
  Column2({
    type: DataTypes2.STRING
  })
], EventEntity.prototype, "type", 2);
__decorateClass([
  Column2({
    type: DataTypes2.JSONB,
    defaultValue: {}
  })
], EventEntity.prototype, "payload", 2);
__decorateClass([
  Column2({
    type: DataTypes2.JSONB,
    defaultValue: {}
  })
], EventEntity.prototype, "metadata", 2);
__decorateClass([
  Column2({
    type: DataTypes2.ENUM("prod", "staging", "test", "dev"),
    allowNull: false,
    primaryKey: true
  })
], EventEntity.prototype, "tier", 2);
EventEntity = __decorateClass([
  Table2({
    tableName: "events",
    timestamps: false
  })
], EventEntity);

// server/src/util/backgroundPromise.ts
var backgroundPromises = /* @__PURE__ */ new Set();
function backgroundPromise(p, _logger) {
  backgroundPromises.add(p);
  p.catch((e) => {
    const logger = _logger ?? anonymousLogger();
    logger.logException(`Error resolving background promise`, e);
  }).finally(() => {
    backgroundPromises.delete(p);
  });
}

// server/src/entity/event/EventMutator.ts
var EventMutator = class {
  constructor(session) {
    this.session = session;
  }
  async createEvent(input, version2, deployment) {
    if (process.env.NODE_ENV === "production" && // in production
    !!version2 && // if an event has a version defined
    !version2.includes(".")) {
      return null;
    }
    const {
      utmParameters,
      viewer: { userID, orgID, platformApplicationID }
    } = this.session;
    const platformApplication = await ApplicationEntity.findByPk(
      platformApplicationID
    );
    const enabled = await getTypedFeatureFlagValue(
      FeatureFlags2.WRITE_TO_EVENTS_TABLE,
      {
        userID: userID ?? "anonymous",
        orgID,
        platformApplicationID: platformApplicationID ?? "extension",
        version: version2 ?? null,
        customerID: platformApplication?.customerID
      }
    );
    if (!enabled) {
      return null;
    }
    const metadata = {
      ...input.metadata,
      deployment
    };
    return await EventEntity.create({
      ...input,
      metadata,
      userID,
      orgID,
      platformApplicationID,
      version: version2,
      utmParameters,
      tier: Env_default.CORD_TIER
    });
  }
};
function logServerEvent(args) {
  const mutator = new EventMutator(args.session);
  backgroundPromise(
    mutator.createEvent({
      pageLoadID: null,
      clientTimestamp: null,
      installationID: null,
      eventNumber: null,
      logLevel: args.logLevel,
      type: args.type,
      payload: args.payload ?? {},
      metadata: args.metadata ?? {}
    })
  );
}

// common/const/Sizes.ts
var XSMALL = 2;
var SMALL = 4;
var MEDIUM = 8;
var LARGE = 16;
var XLARGE = 24;
var XXLARGE = 32;
var XXXLARGE = 48;
var AVATAR_BORDER_WIDTH_PX = XSMALL;
var CHECKBOX_DEFAULT_SIZE_PX = LARGE;
var MAIN_CHAT_AVATAR_SIZE_PX = XLARGE + AVATAR_BORDER_WIDTH_PX * 2;
var MAIN_CHAT_AVATAR_MARGIN_RIGHT_PX = MEDIUM;
var Sizes = {
  // Sidebar
  SIDEBAR_COMPACT_WIDTH: 312,
  // used when viewport width is <= VIEWPORT_WIDTH_BREAKPOINT
  SIDEBAR_NORMAL_WIDTH: 416,
  // used when viewport width is > VIEWPORT_WIDTH_BREAKPOINT
  SIDEBAR_MAX_WIDTH: 500,
  VIEWPORT_WIDTH_BREAKPOINT: 1440,
  // Navigation top bar
  NAVIGATION_ITEM_SPACING_COMPACT: 12,
  NAVIGATION_ITEM_SPACING_NORMAL: LARGE,
  // subtract MEDIUM here, add it to the sidebar App.tsx container paddingBottom, to allow shadows to be visible
  SIDEBAR_BOTTOM_SPACE: 96 - MEDIUM,
  // Text
  X_SMALL_TEXT_SIZE_PX: 10,
  SMALL_TEXT_SIZE_PX: 12,
  DEFAULT_TEXT_SIZE_PX: 14,
  LARGE_TEXT_SIZE_PX: 18,
  X_LARGE_TEXT_SIZE_PX: 24,
  SMALL_LINE_HEIGHT_PX: 16,
  DEFAULT_LINE_HEIGHT_PX: 20,
  LARGE_LINE_HEIGHT_PX: 24,
  X_LARGE_LINE_HEIGHT_PX: 32,
  BOLD_TEXT_WEIGHT: 700,
  NORMAL_TEXT_WEIGHT: 400,
  // Spacing
  SMALL_PADDING_PX: 6,
  DEFAULT_PADDING_PX: 12,
  DEFAULT_BORDER_RADIUS: SMALL,
  LARGE_BORDER_RADIUS: MEDIUM,
  SMALL_BORDER_RADIUS: XSMALL,
  // Icon
  DEFAULT_ICON_PADDING_PX: 4,
  // Profile pics
  PAGE_VISITORS_AVATAR_SIZE_PX: XLARGE + AVATAR_BORDER_WIDTH_PX * 2,
  MAIN_CHAT_AVATAR_SIZE_PX,
  MAIN_CHAT_AVATAR_MARGIN_RIGHT_PX,
  MESSAGE_LEFT_PADDING: MAIN_CHAT_AVATAR_SIZE_PX + MAIN_CHAT_AVATAR_MARGIN_RIGHT_PX,
  AVATAR_BORDER_WIDTH_PX,
  FACEPILE_AVATAR_OVERLAP_SIZE_PX: SMALL,
  NOTIFICATION_FACEPILE_SIZE: LARGE + AVATAR_BORDER_WIDTH_PX * 2,
  // Composer
  COMPOSER_ADD_BUTTON_HEIGHT_PX: XXLARGE,
  COMPOSER_ADD_BUTTON_WIDTH_PX: XXLARGE,
  COMPOSER_HORIZONTAL_PADDING: MEDIUM,
  COMPOSER_VERTICAL_PADDING: 18,
  MAX_COMPOSER_EDITOR_HEIGHT: 448,
  // Messages
  MESSAGE_BLOCK_BOTTOM_MARGIN: XLARGE,
  MESSAGE_BOTTOM_MARGIN: MEDIUM * 1.5,
  MESSAGE_CONTENTS_TOP_MARGIN: 5,
  MESSAGE_PARAGRAPH_TOP_MARGIN: MEDIUM,
  MESSAGE_REACTIONS_TOP_MARGIN: SMALL,
  MESSAGE_REACTIONS_BOTTOM_MARGIN: -MEDIUM,
  MESSAGE_SEEN_BY_BOTTOM_MARGIN: MEDIUM,
  MESSAGE_REACTIONS_FACEPILE_OVERLAP: 6,
  MESSAGE_PAST_REACTION_HEIGHT: LARGE,
  MESSAGE_ANNOTATION_HEIGHT_PX: 40,
  MESSAGES_KEBAB_MENU_WIDTH_PX: 196,
  MESSAGE_HEIGHT_TRUNCATE_AT_PX: 300,
  MESSAGE_HEIGHT_TRUNCATE_TO_PX: 200,
  INFINITE_SCROLL_THRESHOLD_PX: 400,
  MESSAGE_ATTACHMENT_PLACEHOLDER_HEIGHT_PX: 92,
  // 277 is the height of kebab menu for your own message, with one line of 'seen by'
  // We set the minHeight of the share to slack menu to this
  MIN_KEBAB_SLACK_MENU_HEIGHT: 277,
  // Distance between kebab menu and kebab menu icon
  KEBAB_MENU_OFFSET: SMALL,
  // Bullets / numbered / todo lists
  BULLET_PADDING_LEFT: CHECKBOX_DEFAULT_SIZE_PX + MEDIUM,
  // Todo - feed this into the menu itself (prob via more dynamic svg)
  MESSAGE_MENU_HEIGHT: 32,
  // Tooltip
  TOOLTIP_HORIZONTAL_PADDING_PX: MEDIUM,
  TOOLTIP_VERTICAL_PADDING_PX: SMALL,
  TOOLTIP_LINE_HEIGHT_PX: LARGE,
  TOOLTIP_MAX_WIDTH_PX: 180,
  ANNOTATION_TOOLTIP_MAX_WIDTH_PX: 180,
  // Attachments
  ATTACHMENT_THUMBNAIL_PX: 58,
  PDF_ATTACHMENT_PX: 90,
  // Modal
  MODAL_SELECT_CHANNELS_MAX_HEIGHT_PX: 240,
  // ImageModal
  IMAGE_MODAL_SMALL_SCALE: 0.66,
  IMAGE_MODAL_BUTTON_HEIGHT_SCALE_PX: 40,
  IMAGE_MODAL_MENU_MAX_WIDTH_PX: 180,
  IMAGE_MODAL_MENU_TOP_POSITION_PX: 44,
  // Success Popup
  SUCCESS_POPUP_HEIGHT: 36,
  // Annotation pointer
  ANNOTATION_POINTER_MIN_GAP_VS_SCREEN_EDGE: MEDIUM,
  ANNOTATION_POINTER_SMALL_SIZE_PX: 34,
  // 32 + 1 for border on each side, which is included in the svg
  // Annotation arrow
  ANNOTATION_ARROW_CIRCLE_RADIUS: 4,
  ANNOTATION_ARROW_HORIZONTAL_MARGIN_FOR_TOOLTIP: XXLARGE,
  // Charts in webpage
  MIN_CHART_SIZE_PX: 50,
  MAX_CHART_CONTAINER_SIZE_RATIO: 1.25,
  // Login
  LOGIN_BUTTON_WIDTH_PX: 354,
  LOGIN_BUTTON_HEIGHT_PX: 56,
  LOGIN_MARGIN_PX: 56,
  LOGIN_BUTTON_TEXT_SIZE_PX: 18,
  LOGIN_TITLE_TEXT_SIZE_PX: 36,
  EMAIL_PROMPT_HEIGHT_PX: 128,
  EMAIL_PROMPT_INPUT_VERTICAL_PADDING_PX: 14,
  // Welcome
  WELCOME_PARAGRAPH_MAX_WIDTH_PX: 400,
  WELCOME_VIDEO_MAX_HEIGHT_PX: 300,
  WELCOME_VIDEO_MAX_WIDTH_PX: 600,
  // Workspace
  WORKSPACE_HORIZONTAL_MARGIN_PX: 56,
  WORKSPACE_VERTICAL_GAP_PX: 40,
  WORKSPACE_VERTICAL_GAP_SMALL_PX: 32,
  WORKSPACE_SMALL_PADDING_PX: 12,
  WORKSPACE_XSMALL_PADDING_PX: 6,
  WORKSPACE_PARAGRAPH_MAX_WIDTH_PX: 480,
  WORKSPACE_WIDTH_PX: 576,
  WORKSPACE_LOGIN_WIDTH_PX: 640,
  WORKSPACE_LOGIN_BUTTON_HEIGHT_PX: 48,
  WORKSPACE_LOGIN_ORG_IMAGE_SIZE_PX: XXXLARGE,
  WORKSPACE_GET_STARTED_STEP_MAX_WIDTH_PX: 290,
  WORKSPACE_GET_STARTED_STEP_MIN_WIDTH_PX: 230,
  RECENTLY_SHARED_MIN_WIDTH_PX: 120,
  RECENTLY_SHARED_MAX_WIDTH_PX: 240,
  UPDATES_MAX_WIDTH_PX: 320,
  // Extension popup
  EXTENSION_POPUP_WIDTH: 360,
  EXTENSION_POPUP_HEIGHT: 540,
  EXTENSION_POPUP_START_CONVERSATION_BUTTON_HEIGHT: 60,
  SPINNER_DEFAULT_HEIGHT_PX: 20,
  SPINNER_LARGE_HEIGHT_PX: 40,
  CHECKBOX_DEFAULT_SIZE_PX,
  DEFAULT_ICON_SIZE: 24,
  SMALL_ICON_SIZE: 16,
  X_SMALL_ICON_SIZE: 12,
  DEFAULT_BORDER_WIDTH: 1,
  COLLAPSED_THREAD_MESSAGE_HEIGHT: 44,
  ADD_THREAD_BUTTONS_HEIGHT: 60,
  GAP_BETWEEN_THREADS: XLARGE,
  GAP_BETWEEN_GROUPED_THREADS: MEDIUM,
  LOAD_OLDER_MESSAGES_BUTTON_HEIGHT: 33,
  THREAD_MESSAGE_PADDING: MEDIUM,
  SCREENSHOT_BLUR_PX: 10,
  //Screen Size for Embed
  MINIMUM_SCREEN_WIDTH: 600,
  MINIMUM_SCREEN_HEIGHT: 600,
  // Puppet Auth
  PUPPET_MODAL_TOP_MARGIN: 60,
  PUPPET_MODAL_TOP_PADDING: 36,
  PUPPET_MODAL_PADDING: 40,
  PUPPET_MODAL_VERTICAL_PADDING_BUTTON: 10,
  PUPPET_MODAL_VERTICAL_PADDING_TEXT_FIELD: 10,
  // Launcher / Close sidebar button
  LAUNCHER_ICON_HEIGHT: 60,
  LAUNCHER_ICON_WIDTH: 60,
  CLOSE_SIDEBAR_ICON_HEIGHT: 60,
  CLOSE_SIDEBAR_ICON_WIDTH: 60,
  LAUNCHER_FIXED_RIGHT_LENGTH: 16,
  LAUNCHER_FIXED_BOTTOM_LENGTH: 16,
  XSMALL,
  SMALL,
  MEDIUM,
  LARGE,
  XLARGE,
  XXLARGE,
  XXXLARGE
};
var FontSizes = {
  xSmall: Sizes.X_SMALL_TEXT_SIZE_PX,
  small: Sizes.SMALL_TEXT_SIZE_PX,
  default: Sizes.DEFAULT_TEXT_SIZE_PX,
  large: Sizes.LARGE_TEXT_SIZE_PX,
  xLarge: Sizes.X_LARGE_TEXT_SIZE_PX,
  inherit: "inherit"
};
var LineHeights = {
  xSmall: `${Sizes.SMALL_LINE_HEIGHT_PX}px`,
  small: `${Sizes.SMALL_LINE_HEIGHT_PX}px`,
  default: `${Sizes.DEFAULT_LINE_HEIGHT_PX}px`,
  large: `${Sizes.LARGE_LINE_HEIGHT_PX}px`,
  xLarge: `${Sizes.X_LARGE_LINE_HEIGHT_PX}px`,
  inherit: "inherit"
};
var DEFAULT_EMAIL_LOGO_WIDTH = "140";

// common/const/Urls.ts
var TOP_SERVER_HOST = process.env.TOP_SERVER_HOST;
var APP_SERVER_HOST = process.env.APP_SERVER_HOST;
var API_SERVER_HOST = process.env.API_SERVER_HOST;
var API_SERVER_HOST_PRODUCTION = process.env.API_SERVER_HOST_PRODUCTION;
var ADMIN_SERVER_HOST = process.env.ADMIN_SERVER_HOST;
var CONSOLE_SERVER_HOST = process.env.CONSOLE_SERVER_HOST;
var MARKETING_SERVER_HOST = process.env.MARKETING_SERVER_HOST;
var CORD_TO_HOST = process.env.CORD_TO_HOST;
var AUTH0_CUSTOM_LOGIN_DOMAIN = process.env.AUTH0_CUSTOM_LOGIN_DOMAIN;
var DOCS_SERVER_HOST = process.env.DOCS_SERVER_HOST;
var SLACK_APP_REDIRECT_HOST = process.env.SLACK_APP_REDIRECT_HOST;
var TOP_ORIGIN = "https://" + process.env.TOP_SERVER_HOST;
var APP_ORIGIN = "https://" + process.env.APP_SERVER_HOST;
var API_ORIGIN = "https://" + process.env.API_SERVER_HOST;
var ADMIN_ORIGIN = "https://" + process.env.ADMIN_SERVER_HOST;
var CONSOLE_ORIGIN = "https://" + process.env.CONSOLE_SERVER_HOST;
var MARKETING_ORIGIN = "https://" + process.env.MARKETING_SERVER_HOST;
var CORD_TO_ORIGIN = "https://" + process.env.CORD_TO_HOST;
var AUTH0_ORIGIN = "https://" + process.env.AUTH0_CUSTOM_LOGIN_DOMAIN;
var DOCS_ORIGIN = "https://" + process.env.DOCS_SERVER_HOST;
var DOCS_AI_CHATBOT_SERVER_HOST = process.env.DOCS_AI_CHATBOT_SERVER_HOST;
var COMMUNITY_ORIGIN = "https://" + process.env.COMMUNITY_SERVER_HOST;
var DEMO_APPS_WEBHOOK_URL = "https://cord-interactive-demos.vercel.app/events";

// common/const/Ids.ts
var RADICAL_ORG_ID = "6bba8678-b14e-4af7-b2f2-05ee807dfa82";
var CORD_SLACK_TEAM_ID = "T012Y0TBQLW";
var CORD_TEST_SLACK_TEAM_ID = "T015UJY6YQK";
var SLACK_APP_CLIENT_ID = "1100027398710.1180115520790";
var SLACK_APP_ID = "A015A3DFAP8";
var SLACK_DEV_APP_CLIENT_ID = "1198644236835.1943446227956";
var SLACK_ADMIN_LOGIN_APP_ID = "A02CVJG9EAH";
var SLACK_DEV_APP_ID = "A01TRD46PU4";
var SLACK_INTERNAL_TOOLS_APP_ID = "A04JKM945CM";
var CORD_SLACK_APP_IDS = [
  SLACK_APP_ID,
  SLACK_DEV_APP_ID,
  SLACK_ADMIN_LOGIN_APP_ID,
  SLACK_INTERNAL_TOOLS_APP_ID
];
var CORD_SDK_TEST_APPLICATION_ID = "b6501bf5-46f7-4db7-9996-c42dd9f758b0";
var CORD_SAMPLE_TOKEN_CUSTOMER_ID = "1c367aca-37c9-4733-8bef-e9f11a7d0f17";
var CORD_DEMO_APPS_TOKEN_CUSTOMER_ID = "4383cf39-8b6a-4c33-9d8a-71567ed47a60";
var CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID = "aeb2797f-f0a3-485c-a317-4986e2c8343b";
var CORD_AUTOMATED_TESTS_APPLICATION_ID = "dfa86152-9e7e-4d2d-acd6-bfddef71f58e";
var CLACK_APPLICATION_ID = "5fa22ba9-5446-4af8-bc93-7ce54a9aa0ba";
var CORD_HOMEPAGE_APPLICATION_ID = "29e6499a-bbed-4eb2-b057-b36d60ad76c9";
var AUTH0_CLIENT_ID = process.env.AUTH0_CLIENT_ID;
var CORD_CUSTOMER_ID = "12ed6251-28d5-4686-9a75-20a15bd31499";
var CSS_CUSTOMIZATION_ON_DOCS_PREFIX = "css-customization-";
var BETA_V2_DOCS_PREFIX = "beta2-";
var LIVE_CSS_ON_DOCS_THREAD_ID_PREFIX = "live-css-docs-thread-";
var LIVE_COMPONENT_ON_DOCS_THREAD_ID_PREFIX = "live-component-docs-thread-";
var LIVE_COMPONENT_INBOX_THREAD_ID_PREFIX = "live_component-docs-inbox-thread-";
var LIVE_COMPONENT_INBOX_LAUNCHER_THREAD_ID_PREFIX = "live_component-docs-inbox-launcher-thread-";
var LIVE_COMPONENT_ON_DOCS_COMPOSER_THREAD_ID_PREFIX = "live-component-docs-composer-thread-";
var LIVE_COMPONENT_ON_DOCS_MESSAGE_THREAD_ID_PREFIX = "live-component-docs-message-thread-";
var LIVE_COMPONENT_ON_DOCS_MESSAGE_CONTENT_THREAD_ID_PREFIX = "live-component-docs-message-content-thread-";
var LIVE_COMPONENT_ON_DOCS_REACTIONS_THREAD_ID_PREFIX = "live-component-docs-reactions-thread-";
var LIVE_COMPONENT_ON_DOCS_EXTERNAL_NOTIFICATION_PREFIX = "live-component-docs-external-notification-";
var LIVE_CUSTOMIZATION_ON_DOCS_REPLACEMENTS_THREAD_ID_PREFIX = "live-customization-docs-replacements-thread-";
var DOCS_TOKEN_KEY = "docs-token";
var LIVE_COMPONENT_ON_DOCS_NO_AVATAR_USER_ID = "noavatar";
var DOCS_LIVE_PAGE_LOCATIONS = {
  cssCustomization: "css-customization",
  liveCss: "live-css-docs",
  liveThread: "live-thread",
  liveThreadList: "live-thread-list",
  livePin: "live-pin",
  livePinChartExample: "live-pin-chart-example",
  liveFloatingThreads: "live-floating-threads",
  liveSelectionComments: "live-selection-comments",
  liveSidebar: "live-sidebar",
  liveInbox: "live-inbox",
  liveInboxLauncher: "live-inbox-launcher",
  liveSidebarLauncher: "live-sidebar-launcher",
  livePagePresence: "live-page-presence",
  livePresenceFacepile: "live-presence-facepile",
  liveComposer: "live-composer",
  liveMessage: "live-message",
  liveMessageContent: "live-message-content",
  liveNotificationList: "live-notification-list",
  liveThreadedComments: "live-threaded-comments",
  liveReactions: "live-reactions",
  liveReplacementsTutorial: "live-replacements-tutorial",
  liveBetaV2Thread: "live-beta-v2-thread",
  liveBetaV2Threads: "live-beta-v2-threads"
};
var DOCS_URLS = {
  tutorials: {
    getProductionReady: {
      addYourBranding: `${DOCS_ORIGIN}/get-started/live-css-editor`
    },
    integrationGuide: `${DOCS_ORIGIN}/get-started/integration-guide`,
    demoApps: `${DOCS_ORIGIN}/get-started/demo-apps`
  },
  components: {
    thread: `${DOCS_ORIGIN}/components/cord-thread`,
    threadList: `${DOCS_ORIGIN}/components/cord-thread-list`,
    threadedComments: `${DOCS_ORIGIN}/components/cord-threaded-comments`,
    sidebar: `${DOCS_ORIGIN}/components/cord-sidebar`,
    inbox: `${DOCS_ORIGIN}/components/cord-inbox`,
    inboxLauncher: `${DOCS_ORIGIN}/components/cord-inbox-launcher`,
    sidebarLauncher: `${DOCS_ORIGIN}/components/cord-sidebar-launcher`,
    composer: `${DOCS_ORIGIN}/components/cord-composer`,
    message: `${DOCS_ORIGIN}/components/cord-message`,
    messageContent: `${DOCS_ORIGIN}/components/cord-message-content`,
    reactions: `${DOCS_ORIGIN}/components/cord-reactions`
  },
  howTo: {
    customThreadedComments: `${DOCS_ORIGIN}/customization/custom-threaded-comments`,
    cssCustomization: `${DOCS_ORIGIN}/customization/css`,
    replacements: `${DOCS_ORIGIN}/customization/custom-react-components/tutorial`
  },
  getStarted: {
    authenticateYourUser: `${DOCS_ORIGIN}/get-started/integration-guide/generate-an-auth-token`
  },
  betaV2Components: {
    threads: `${DOCS_ORIGIN}/components/cord-threads?version=2.0`,
    thread: `${DOCS_ORIGIN}/components/cord-thread?version=2.0`
  }
};
var CORD_DEV_CONSOLE_LOGGING_SLACK_CHANNEL_ID = "C05FAVBSSN7";
var CORD_SELF_SERVE_SLACK_CHANNEL_ID = "C05GR4WSV5Z";
var DEMO_APPS_APP_GROUP_ID = "my-first-group";

// server/src/entity/customer/CustomerEntity.ts
import { Table as Table3, Column as Column3, Model as Model3 } from "sequelize-typescript";
import { DataTypes as DataTypes3 } from "sequelize";
var CustomerEntity = class extends Model3 {
};
__decorateClass([
  Column3({
    type: DataTypes3.UUID,
    allowNull: false,
    primaryKey: true,
    defaultValue: DataTypes3.UUIDV4
  })
], CustomerEntity.prototype, "id", 2);
__decorateClass([
  Column3({
    type: DataTypes3.TEXT,
    allowNull: false
  })
], CustomerEntity.prototype, "name", 2);
__decorateClass([
  Column3({
    type: DataTypes3.TEXT
  })
], CustomerEntity.prototype, "sharedSecret", 2);
__decorateClass([
  Column3({
    type: DataTypes3.ENUM("verified", "sample"),
    defaultValue: "verified",
    allowNull: false
  })
], CustomerEntity.prototype, "type", 2);
__decorateClass([
  Column3({
    type: DataTypes3.VIRTUAL(DataTypes3.BOOLEAN, ["addons"]),
    get() {
      const addons = this.getDataValue("addons");
      return addons["custom_s3_bucket"] ?? false;
    }
  })
], CustomerEntity.prototype, "enableCustomS3Bucket", 2);
__decorateClass([
  Column3({
    type: DataTypes3.VIRTUAL(DataTypes3.BOOLEAN, ["addons"]),
    get() {
      const addons = this.getDataValue("addons");
      return addons["custom_segment_write_key"] ?? false;
    }
  })
], CustomerEntity.prototype, "enableCustomSegmentWriteKey", 2);
__decorateClass([
  Column3({
    type: DataTypes3.VIRTUAL(DataTypes3.BOOLEAN, ["addons"]),
    get() {
      const addons = this.getDataValue("addons");
      return addons["customer_support"] ?? false;
    }
  })
], CustomerEntity.prototype, "enableCustomerSupport", 2);
__decorateClass([
  Column3({
    type: DataTypes3.ENUM(
      "launched",
      "implementing",
      "proof_of_concept",
      "inactive"
    ),
    allowNull: false,
    defaultValue: "proof_of_concept"
  })
], CustomerEntity.prototype, "implementationStage", 2);
__decorateClass([
  Column3({
    type: DataTypes3.TIME,
    allowNull: true
  })
], CustomerEntity.prototype, "launchDate", 2);
__decorateClass([
  Column3({
    type: DataTypes3.TEXT,
    allowNull: true
  })
], CustomerEntity.prototype, "slackChannel", 2);
__decorateClass([
  Column3({
    type: DataTypes3.TEXT,
    allowNull: true
  })
], CustomerEntity.prototype, "signupCoupon", 2);
__decorateClass([
  Column3({
    type: DataTypes3.TEXT,
    allowNull: true
  })
], CustomerEntity.prototype, "stripeCustomerID", 2);
__decorateClass([
  Column3({
    type: DataTypes3.ENUM("free", "pro", "scale"),
    allowNull: true,
    defaultValue: "free"
  })
], CustomerEntity.prototype, "pricingTier", 2);
__decorateClass([
  Column3({
    type: DataTypes3.ENUM("active", "inactive"),
    allowNull: true,
    defaultValue: "inactive"
  })
], CustomerEntity.prototype, "billingStatus", 2);
__decorateClass([
  Column3({
    type: DataTypes3.ENUM("stripe", "manual"),
    allowNull: true,
    defaultValue: null
  })
], CustomerEntity.prototype, "billingType", 2);
__decorateClass([
  Column3({
    type: DataTypes3.JSONB,
    allowNull: false,
    defaultValue: {}
  })
], CustomerEntity.prototype, "addons", 2);
__decorateClass([
  Column3({
    type: DataTypes3.TIME,
    allowNull: true
  })
], CustomerEntity.prototype, "renewalDate", 2);
__decorateClass([
  Column3({
    type: DataTypes3.ARRAY(DataTypes3.TEXT),
    defaultValue: [],
    allowNull: false
  })
], CustomerEntity.prototype, "planDescription", 2);
CustomerEntity = __decorateClass([
  Table3({
    tableName: "customers",
    timestamps: false
  })
], CustomerEntity);

// server/src/email/index.ts
sgMail.default.setApiKey(Env_default.SENDGRID_API_KEY);
var DEFAULT_MENTION_NOTIFICATION_V2_TEMPLATE_ID = "d-6309e6ccb36a4a769957795f475c8130";
var MENTION_NOTIFICATION_NO_POWERED_BY_CORD_TEMPLATE_ID = "d-8a8088e59eed4622b2d09078de372fe8";
var DEFAULT_SHARE_TO_EMAIL_TEMPLATE_ID = "d-fecc876acf684ff2bca887748d86e4e1";
var SHARE_TO_EMAIL_NO_POWERED_BY_CORD_TEMPLATE_ID = "d-b70dc2c71ee541ee9e0c5f4cd84b32e3";
var DEFAULT_THREAD_RESOLVE_TEMPLATE_ID = "d-93aa618e7d0b4ba593c346f9a1f664c5";
var THREAD_RESOLVE_NO_POWERED_BY_CORD_TEMPLATE_ID = "d-37c14e17cc9649afb70495f029b3833d";
var encodeUnsubscribeThreadToken = (data) => jwt.sign(data, Env_default.EMAIL_LINKS_TOKEN_SECRET, { algorithm: "HS512" });
var decodeUnsubscribeThreadToken = (token) => jwt.verify(token, Env_default.EMAIL_LINKS_TOKEN_SECRET, {
  algorithms: ["HS512"]
});
async function sendActionEmailNotification({
  context,
  recipientEmail,
  actionText,
  actionIconType,
  pageName,
  pageURL,
  providerName,
  unsubscribeURL,
  partnerDetails,
  threadDetails,
  emailNotification,
  /** You can edit templates in SendGrid */
  templateId,
  notificationType
}) {
  if (process.env.IS_TEST) {
    return;
  }
  const {
    firstMessageDetails,
    firstMessageUserDetails,
    previousMessageDetails,
    previousMessageUserDetails,
    currentMessageDetails,
    currentMessageUserDetails,
    messagesCountLeft
  } = threadDetails;
  const threadingHeaders = await getThreadingHeaders(emailNotification);
  const noAutoResponseHeader = { "X-Auto-Response-Suppress": "OOF" };
  const unsubscribeHeaders = {
    "List-Unsubscribe": `<${unsubscribeURL}>`,
    "List-Unsubscribe-Post": "List-Unsubscribe=One-Click"
  };
  let eventType = "";
  let emailType = "";
  if (notificationType === "reply") {
    eventType = "email-mention-notification-sent-v2";
    emailType = "mention v2";
  } else if (notificationType === "thread_action") {
    eventType = "email-thread-action-notification-sent";
    emailType = "thread action";
  }
  const mailData = {
    from: partnerDetails?.sender ?? "Cord <cord@cord.fyi>",
    to: recipientEmail,
    replyTo: getReplyToEmailAddress(
      context.logger,
      partnerDetails?.sender ?? `Cord <cord@cord.fyi>`,
      emailNotification.id
    ),
    templateId,
    headers: {
      ...threadingHeaders,
      ...noAutoResponseHeader,
      ...unsubscribeHeaders
    },
    dynamicTemplateData: {
      Action: actionText,
      Action_Icon: actionIconType,
      Page_Name: pageName,
      Page_URL: pageURL,
      Tool_Name: providerName,
      First_Message_Details: firstMessageDetails,
      First_Message_User_Details: firstMessageUserDetails,
      Previous_Message_Details: previousMessageDetails,
      Previous_Message_User_Details: previousMessageUserDetails,
      Current_Message_Details: currentMessageDetails,
      Current_Message_User_Details: currentMessageUserDetails,
      Messages_Count_Left: messagesCountLeft,
      Preview_Text: currentMessageDetails.message_preview,
      Unsubscribe_URL: unsubscribeURL,
      Partner_Name: partnerDetails?.partnerName,
      Partner_Image_URL: partnerDetails?.imageURL,
      Add_Explainer: false,
      Image_Height: partnerDetails?.logoConfig?.height ?? "auto",
      Image_Width: partnerDetails?.logoConfig?.width ?? DEFAULT_EMAIL_LOGO_WIDTH
    }
  };
  return await sgMail.default.send(mailData).then(() => {
    context.logger.info(`Sent ${emailType} email to ${recipientEmail}`);
    logServerEvent({
      session: context.session,
      type: eventType,
      logLevel: "debug" /* DEBUG */,
      payload: { from: mailData.from, to: mailData.to }
    });
    return true;
  }).catch((error) => {
    context.logger.error(
      `Failed sending ${emailType} email to ${recipientEmail}`,
      {
        error: error.response.body.errors,
        from_address: mailData.from,
        to_address: mailData.to
      }
    );
    return false;
  });
}
function sendShareThreadToEmailEmail(context, recipientEmail, pageName, pageURL, partnerDetails, threadDetails, emailNotification, templateID) {
  if (process.env.IS_TEST) {
    return true;
  }
  const {
    senderName,
    firstMessageDetails,
    firstMessageUserDetails,
    previousMessageDetails,
    previousMessageUserDetails,
    currentMessageDetails,
    currentMessageUserDetails,
    messagesCountLeft
  } = threadDetails;
  const mailData = {
    from: partnerDetails?.sender ?? "Cord <cord@cord.fyi>",
    to: recipientEmail,
    replyTo: emailNotification ? getReplyToEmailAddress(
      context.logger,
      partnerDetails?.sender ?? `Cord <cord@cord.fyi>`,
      emailNotification.id
    ) : partnerDetails?.sender ?? `Cord <cord@cord.fyi>`,
    templateId: templateID,
    dynamicTemplateData: {
      Page_Name: pageName,
      Page_URL: pageURL,
      Sender_Name: senderName,
      First_Message_Details: firstMessageDetails,
      First_Message_User_Details: firstMessageUserDetails,
      Previous_Message_Details: previousMessageDetails,
      Previous_Message_User_Details: previousMessageUserDetails,
      Current_Message_Details: currentMessageDetails,
      Current_Message_User_Details: currentMessageUserDetails,
      Messages_Count_Left: messagesCountLeft,
      Preview_Text: currentMessageDetails.message_preview,
      Partner_Name: partnerDetails?.partnerName,
      Partner_Image_URL: partnerDetails?.imageURL,
      Image_Height: partnerDetails?.logoConfig?.height ?? "auto",
      Image_Width: partnerDetails?.logoConfig?.width ?? DEFAULT_EMAIL_LOGO_WIDTH
    }
  };
  return sgMail.default.send(mailData).then(() => {
    context.logger.info(`Sent shareThreadToEmail email to ${recipientEmail}`);
    logServerEvent({
      session: context.session,
      type: "email-share-thread-to-email-sent",
      logLevel: "debug" /* DEBUG */,
      payload: { from: mailData.from, to: mailData.to }
    });
    return true;
  }).catch((error) => {
    context.logger.error(
      `Failed sending shareThreadToEmail email to ${recipientEmail}`,
      {
        error: error.response.body.errors
      }
    );
    return false;
  });
}
async function getThreadingHeaders(emailNotification) {
  const isFirstEmail = await EmailOutboundNotificationEntity.count({
    where: {
      email: emailNotification.email,
      threadID: emailNotification.threadID
    }
  }) === 1;
  if (isFirstEmail) {
    return {
      "Message-ID": `<thread-${emailNotification.threadID}@cord.fyi>`
    };
  } else {
    return {
      "Message-ID": `<notif-${emailNotification.id}@cord.fyi>`,
      "In-Reply-To": `<thread-${emailNotification.threadID}@cord.fyi>`,
      References: `<thread-${emailNotification.threadID}@cord.fyi>`
    };
  }
}

// server/src/featureflags/index.ts
var client = void 0;
var clientReady = false;
var ServerOnlyFeatureFlags = {
  QUERY_PARAM_DEEP_LINKS: {
    key: "query_param_deep_links",
    defaultValue: false
  },
  NOTIFY_PAGE_VISITORS_OF_EVERY_MESSAGE: {
    key: "notify_page_visitors_of_every_new_message",
    defaultValue: false
  },
  USER_IS_BLOCKED: {
    key: "user_is_blocked",
    defaultValue: false
  },
  SHOW_CORD_COPY_IN_TASKS: {
    key: "show-cord-copy-in-tasks",
    defaultValue: true
  },
  LOADER_CACHES: {
    key: "loader_caches",
    defaultValue: true
  },
  SUBSCRIBE_ALL_ORG_MEMBERS: {
    key: "subscribe_all_org_members",
    defaultValue: false
  },
  WRITE_TO_EVENTS_TABLE: {
    key: "write_to_events_table",
    defaultValue: true
  },
  ALLOW_MAGIC_GRAPHQL_ORG_ID_OVERRIDE: {
    key: "allow-magic-graph-ql-org-id-override",
    defaultValue: true
  },
  GRANULAR_PERMISSIONS: {
    key: "granular-permissions",
    defaultValue: false
  },
  SKIP_PUBLISH_USER_IDENTITY_UPDATE: {
    key: "skip_publish_user_identity_update",
    defaultValue: false
  },
  RATE_LIMITS: {
    key: "rate_limits",
    defaultValue: { maxCount: 5e4, seconds: 5 * 60 }
  },
  EMAIL_NOTIFICATION_TEMPLATE_ID: {
    key: "email-notification-template-id",
    defaultValue: {
      mention: DEFAULT_MENTION_NOTIFICATION_V2_TEMPLATE_ID,
      share_to_email: DEFAULT_SHARE_TO_EMAIL_TEMPLATE_ID,
      thread_resolve: DEFAULT_THREAD_RESOLVE_TEMPLATE_ID
    }
  }
};
var FeatureFlags2 = {
  ...FeatureFlags,
  ...ServerOnlyFeatureFlags
};
var mockClient;
async function initFeatureFlags() {
  if (client) {
    throw new Error("Feature flags already initialized");
  }
  if (!Env_default.LAUNCHDARKLY_API_KEY) {
    return;
  }
  client = LaunchDarkly.init(Env_default.LAUNCHDARKLY_API_KEY);
  await client.waitForInitialization();
  clientReady = true;
}
function flagsUserFromViewer(viewer) {
  return {
    userID: viewer.userID ?? "anonymous",
    orgID: viewer.orgID,
    platformApplicationID: viewer.platformApplicationID ?? "extension",
    version: null
  };
}
function flagsUserFromContext(context) {
  return {
    ...flagsUserFromViewer(context.session.viewer),
    version: context.clientVersion,
    customerID: context.application?.customerID
  };
}
function flagsUserFromApplication(app) {
  return {
    userID: "anonymous",
    platformApplicationID: app.id,
    version: null,
    customerID: app.customerID
  };
}
async function getTypedFeatureFlagValue(feature, user) {
  const value = await getFeatureFlagValue(feature.key, user);
  return value === null ? feature.defaultValue : value;
}
async function getFeatureFlagValue(key, user) {
  if (mockClient) {
    return await mockClient(key, user);
  }
  if (!client || !clientReady) {
    return null;
  }
  const versionValue = versionToNumber(user.version);
  const ldUser = {
    // The choice of delimiter here is restricted by LaunchDarkly's website
    // currently being flaky for users with a key that contains characters that
    // need to be percent-encoded, so we need to choose something that doesn't
    // get encoded.
    key: user.orgID ? `${user.userID}_${user.orgID}` : user.userID,
    custom: {
      userID: user.userID,
      ...user.orgID && { orgID: user.orgID },
      platformApplicationID: user.platformApplicationID,
      ...versionValue && { version: versionValue },
      ...user.customerID && { customerID: user.customerID },
      ...user.appEnvironment && { appEnvironment: user.appEnvironment }
    }
  };
  return await client.variation(key, ldUser, null);
}
function versionToNumber(version2) {
  if (!version2) {
    return null;
  }
  if (version2.startsWith("dev-")) {
    return -1;
  }
  const match = version2.match(/^(\d+)[.](\d+)[.](\d+)$/);
  if (!match) {
    return null;
  }
  return 1e5 * (parseInt(match[1], 10) - 1) + parseInt(match[2], 10);
}

// server/src/entity/application/ApplicationEntity.ts
var ApplicationEntity = class extends Model4 {
  async isSupportChatEnabled() {
    const isSupportFlagEnabled = await getTypedFeatureFlagValue(
      FeatureFlags.SUPPORT_CHAT_ENABLED,
      {
        userID: "anonymous",
        orgID: void 0,
        platformApplicationID: this.id,
        version: null,
        customerID: this.customerID
      }
    );
    return Boolean(
      isSupportFlagEnabled && this.supportBotID && this.supportOrgID && this.supportSlackChannelID
    );
  }
  getCustomSlackAppDetails() {
    const details = this.customSlackAppDetails;
    if (details && typeof details === "object" && !Array.isArray(details) && typeof details.clientID === "string" && typeof details.clientSecret === "string" && typeof details.signingSecret === "string") {
      return {
        clientID: details.clientID,
        clientSecret: details.clientSecret,
        signingSecret: details.signingSecret
      };
    }
    return null;
  }
};
__decorateClass([
  Column4({
    type: DataTypes4.UUID,
    allowNull: false,
    primaryKey: true,
    defaultValue: DataTypes4.UUIDV4
  })
], ApplicationEntity.prototype, "id", 2);
__decorateClass([
  Column4({
    type: DataTypes4.TEXT,
    allowNull: false
  })
], ApplicationEntity.prototype, "name", 2);
__decorateClass([
  Column4({
    type: DataTypes4.TEXT
  })
], ApplicationEntity.prototype, "sharedSecret", 2);
__decorateClass([
  Column4({ type: DataTypes4.TIME })
], ApplicationEntity.prototype, "createdTimestamp", 2);
__decorateClass([
  Column4({
    type: DataTypes4.JSONB
  })
], ApplicationEntity.prototype, "customEmailTemplate", 2);
__decorateClass([
  Column4({
    type: DataTypes4.BOOLEAN,
    defaultValue: true
  })
], ApplicationEntity.prototype, "enableEmailNotifications", 2);
__decorateClass([
  Column4({
    type: DataTypes4.JSONB
  })
], ApplicationEntity.prototype, "customLinks", 2);
__decorateClass([
  Column4({
    type: DataTypes4.UUID,
    defaultValue: null
  })
], ApplicationEntity.prototype, "customS3Bucket", 2);
__decorateClass([
  Column4({
    type: DataTypes4.TEXT,
    defaultValue: null
  })
], ApplicationEntity.prototype, "segmentWriteKey", 2);
__decorateClass([
  Column4({
    type: DataTypes4.JSONB
  })
], ApplicationEntity.prototype, "customNUX", 2);
__decorateClass([
  Column4({
    type: DataTypes4.TEXT
  })
], ApplicationEntity.prototype, "iconURL", 2);
__decorateClass([
  Column4({
    type: DataTypes4.ENUM("free", "starter", "premium"),
    defaultValue: "free",
    allowNull: false
  })
], ApplicationEntity.prototype, "type", 2);
__decorateClass([
  Column4({
    type: DataTypes4.ENUM(
      "production",
      "staging",
      "sample",
      "sampletoken",
      "demo"
    ),
    defaultValue: "production",
    allowNull: false
  })
], ApplicationEntity.prototype, "environment", 2);
__decorateClass([
  Column4({
    type: DataTypes4.UUID
  })
], ApplicationEntity.prototype, "supportOrgID", 2);
__decorateClass([
  Column4({
    type: DataTypes4.UUID
  })
], ApplicationEntity.prototype, "supportBotID", 2);
__decorateClass([
  Column4({
    type: DataTypes4.TEXT
  })
], ApplicationEntity.prototype, "supportSlackChannelID", 2);
__decorateClass([
  Column4({
    type: DataTypes4.TEXT
  })
], ApplicationEntity.prototype, "redirectURI", 2);
__decorateClass([
  Column4({
    type: DataTypes4.UUID,
    defaultValue: null
  })
], ApplicationEntity.prototype, "customerID", 2);
__decorateClass([
  Column4({
    type: DataTypes4.BOOLEAN,
    defaultValue: false
  })
], ApplicationEntity.prototype, "slackConnectAllOrgs", 2);
__decorateClass([
  Column4({
    type: DataTypes4.STRING,
    defaultValue: null
  })
], ApplicationEntity.prototype, "eventWebhookURL", 2);
__decorateClass([
  Column4({
    type: DataTypes4.ARRAY(DataTypes4.TEXT),
    defaultValue: null
  })
], ApplicationEntity.prototype, "eventWebhookSubscriptions", 2);
__decorateClass([
  Column4({
    type: DataTypes4.TEXT,
    defaultValue: null
  })
], ApplicationEntity.prototype, "customSlackAppID", 2);
__decorateClass([
  Column4({
    type: DataTypes4.JSONB,
    defaultValue: null
  })
], ApplicationEntity.prototype, "customSlackAppDetails", 2);
ApplicationEntity = __decorateClass([
  Table4({
    tableName: "applications",
    timestamps: false
  })
], ApplicationEntity);

// server/src/logging/Logger.ts
import "@sentry/tracing";

// server/src/logging/flatFormat.ts
import { format } from "winston";
import stringify from "fast-json-stable-stringify";
var MESSAGE = Symbol.for("message");
var flatFormat = format((info) => {
  const { level, timestamp, message, splat: _, ...meta } = info;
  let stringifiedMeta;
  try {
    stringifiedMeta = stringify(meta);
  } catch (err) {
    stringifiedMeta = `! stringify exception: ${err}`;
  }
  const formattedMessage = `${level.substr(0, 1).toUpperCase()} ${timestamp}: ${message} ${stringifiedMeta}`;
  info[MESSAGE] = formattedMessage;
  return info;
});

// package.json
var package_default = {
  name: "radical",
  version: "1.1093.0",
  description: "The monorepo for Radical",
  main: "index.js",
  repository: "ssh://radical@vault.phacility.com/source/monorepo.git",
  author: "jack@getradical.co",
  license: "NONE",
  private: true,
  type: "module",
  scripts: {
    test: "NODE_OPTIONS=--experimental-vm-modules jest",
    migrate: "sequelize-cli db:migrate",
    "migrate-down": "sequelize-cli db:migrate:undo",
    build: "npm run tsc-once && ./build/index.mjs --mode=production --clean",
    "build-demo-apps": "demo-apps/build-demo-apps.sh",
    "build-sample-apps": "npm run build-demo-apps",
    "check-database-schema": "./build/index.mjs --mode=development --target=scripts/check-database-schema.ts && ./dist/scripts/check-database-schema.js --check",
    codegen: "node ./build/index.mjs --mode=development --target=scripts/generate-graphql-types.ts && node ./dist/scripts/generate-graphql-types.js && node ./scripts/generate-dayjs.mjs > opensource/sdk-js/packages/react/common/dayjs.ts",
    "docs-codegen": "./scripts/docs-codegen.sh",
    "local-dev": "./ops/local-dev.sh",
    watch: "./build/index.mjs --mode=development --clean && (./build/index.mjs --mode=development --watch --skipInitialBuild & npm run start-external-dev & npm run start-local-s3 & nodemon --config nodemon-server.json & nodemon --config nodemon-docs-server.json & npm run tsc)",
    "watch-external": "./build/index.mjs --mode=development --watch --target=external",
    "watch-server": "./build/index.mjs --mode=development --watch --target=server",
    "db-ssh-tunnel": "lsof -i '@localhost:15432' >/dev/null || ssh -f -N -L 15432:database-prod-read.int.cord.com:5432 zero",
    "db-ssh-tunnel-write": "lsof -i '@localhost:25432' >/dev/null || ssh -f -N -L 25432:database-prod.int.cord.com:5432 zero",
    "start-external-dev": "http-server ./dist/external -c-1 -a :: --silent --port 8179",
    "start-local-s3": "cat ./localhost/localhost.key ./localhost/localhost.crt > ./localhost/localhost.packed && cd ops && docker-compose up localstack",
    "start-postgres": ". ./.env && export POSTGRES_USER POSTGRES_DB POSTGRES_PORT POSTGRES_PASSWORD && cd ops && docker-compose up postgres",
    "start-redis": "cd ops && docker-compose up redis",
    "start-server-dev": 'NODE_EXTRA_CA_CERTS="$(mkcert -CAROOT)/rootCA.pem" node -r dotenv/config --enable-source-maps ./dist/server/index.js',
    "start-server-dev-snapshots": 'NODE_EXTRA_CA_CERTS="$(mkcert -CAROOT)/rootCA.pem" node -r dotenv/config --enable-source-maps --heapsnapshot-signal=SIGUSR2 ./dist/server/index.js',
    "start-server-prod": "node -r dotenv/config dist/generic/server/index.js",
    "start-asyncWorker-dev": "node -r dotenv/config --enable-source-maps ./dist/asyncWorker/asyncWorker.js",
    "start-asyncWorker-prod": "node -r dotenv/config dist/generic/asyncWorker/asyncWorker.js",
    "start-docs-server-dev": 'NODE_EXTRA_CA_CERTS="$(mkcert -CAROOT)/rootCA.pem" node -r dotenv/config --enable-source-maps ./dist/docs/server/index.js',
    "start-docs-server-prod": "node -r dotenv/config dist/generic/docs/server/index.js",
    tsc: "tsc --incremental false --noEmit --skipLibCheck --watch --preserveWatchOutput",
    "tsc-once": "tsc --incremental false --noEmit --skipLibCheck",
    "wipe-postgres": "cd ops && POSTGRES_USER= POSTGRES_DB= POSTGRES_PASSWORD= docker-compose down --volumes",
    install: "find node_modules/@sentry/ -type f -print0 | grep -z -E '\\.(js|js\\.map|d\\.ts)$' | if sed --version >/dev/null 2>&1 ; then xargs -0 sed --in-place 's/\\b__SENTRY__\\b/_CORDSNTRY/g;'; else xargs -0 sed -i '' -E 's/[[:<:]]__SENTRY__[[:>:]]/_CORDSNTRY/g;'; fi",
    postinstall: "patch-package",
    repl: "./build/index.mjs --mode=development --target=repl && node ./dist/repl/index.js",
    "generate-docs-embeddings": "./build/index.mjs --mode=development --target=scripts/docs-generate-search-data.ts && ./dist/scripts/docs-generate-search-data.js",
    "extract-demo-apps-to-sandpack-object": "./build/index.mjs --mode=development --target=scripts/extract-demo-apps-to-sandpack-file-object.ts && ./dist/scripts/extract-demo-apps-to-sandpack-file-object.js",
    prepare: '[ "$(git config core.hooksPath)" = ".githooks" ] && git config --unset core.hooksPath ; ln -s ../../.githooks/prepare-commit-msg .git/hooks/ > /dev/null 2>&1 || true'
  },
  jest: {
    extensionsToTreatAsEsm: [
      ".ts",
      ".tsx",
      ".graphql"
    ],
    transform: {
      "^.+\\.(tsx?$)|(js$)|(graphql$)": "<rootDir>/jest/transformer.mjs"
    },
    resolver: "<rootDir>/jest/resolver.cjs",
    moduleDirectories: [
      "<rootDir>",
      "node_modules"
    ],
    setupFiles: [
      "<rootDir>/jest/setup-jest-env.js"
    ],
    testPathIgnorePatterns: [
      "/node_modules/",
      "<rootDir>/dist/",
      "<rootDir>/screenshotsDiff",
      "<rootDir>/opensource/"
    ],
    transformIgnorePatterns: [
      "/node_modules/"
    ]
  },
  workspaces: [
    "opensource/sdk-js/packages/*"
  ],
  dependencies: {
    "@apollo/client": "~3.10.4",
    "@auth0/auth0-react": "^1.8.0",
    "@aws-sdk/client-auto-scaling": "^3.363.0",
    "@aws-sdk/client-cloudfront": "^3.363.0",
    "@aws-sdk/client-cloudwatch-logs": "^3.363.0",
    "@aws-sdk/client-ec2": "^3.363.0",
    "@aws-sdk/client-ecr": "^3.363.0",
    "@aws-sdk/client-elastic-load-balancing-v2": "^3.363.0",
    "@aws-sdk/client-iam": "^3.363.0",
    "@aws-sdk/client-s3": "^3.363.0",
    "@aws-sdk/client-secrets-manager": "^3.363.0",
    "@aws-sdk/credential-provider-node": "^3.363.0",
    "@codesandbox/sandpack-react": "^2.6.9",
    "@emotion/react": "^11.11.1",
    "@emotion/server": "^11.10.0",
    "@emotion/styled": "^11.11.0",
    "@floating-ui/react-dom": "^1.3.0",
    "@giphy/js-fetch-api": "^5.4.0",
    "@giphy/react-components": "^9.4.1",
    "@graphql-tools/schema": "^8.5.0",
    "@graphql-tools/utils": "^8.13.1",
    "@heroicons/react": "^2.0.18",
    "@launchdarkly/node-server-sdk": "^8.2.4",
    "@leeoniya/ufuzzy": "^0.7.0",
    "@material-ui/core": "^4.12.4",
    "@material-ui/styles": "^4.11.5",
    "@mui/material": "^5.13.7",
    "@phosphor-icons/react": "^2.0.15",
    "@pyroscope/nodejs": "^0.3.11",
    "@radix-ui/react-label": "^2.0.2",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-slot": "^1.0.2",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@segment/analytics-node": "^2.0.0",
    "@sendgrid/mail": "^8.1.0",
    "@sentry/browser": "^7.57.0",
    "@sentry/node": "^7.59.3",
    "@sentry/react": "^7.57.0",
    "@sentry/tracing": "^7.59.3",
    "@sentry/types": "^7.59.3",
    "@slack/events-api": "^3.0.1",
    "@slack/web-api": "6.11.1",
    "@slack/webhook": "^7.0.2",
    "@tanstack/react-query": "^4.32.6",
    "@tanstack/react-virtual": "^3.5.0",
    "@types/blueimp-md5": "^2.7.0",
    "@types/emoji-js": "^3.5.2",
    "@types/jsdom": "^16.2.5",
    "@types/parse5": "^7.0.0",
    "@types/ua-parser-js": "^0.7.36",
    "@types/valid-data-url": "^2.0.0",
    "@types/wcag-contrast": "^3.0.0",
    ajv: "^8.11.0",
    "ajv-formats": "^2.1.1",
    "apollo-server-core": "^3.12.1",
    "apollo-server-express": "^3.12.1",
    "at-least-node": "^1.0.0",
    auth0: "^3.7.2",
    axios: "^1.6.8",
    backo2: "^1.0.2",
    bluebird: "^3.7.2",
    "blueimp-md5": "^2.18.0",
    buffer: "^5.6.0",
    cheerio: "^1.0.0-rc.12",
    classnames: "^2.5.1",
    cookie: "^0.4.1",
    "cookie-parser": "^1.4.6",
    cors: "^2.8.5",
    dataloader: "^2.0.0",
    dayjs: "^1.11.11",
    dockerode: "^3.3.0",
    dotenv: "^8.2.0",
    "email-addresses": "^5.0.0",
    "emoji-js": "^3.8.0",
    "emoji-picker-element": "^1.16.0",
    express: "^4.19.2",
    "express-basic-auth": "^1.2.0",
    "fast-json-stable-stringify": "^2.1.0",
    "form-data": "^3.0.1",
    "framer-motion": "^6.5.1",
    "free-email-domains": "^1.2.4",
    graphql: "^15.8.0",
    "graphql-iso-date": "^3.6.1",
    "graphql-redis-subscriptions": "^2.5.0",
    "graphql-subscriptions": "^2.0.0",
    "graphql-tag": "^2.12.6",
    "graphql-type-json": "^0.3.2",
    "graphql-type-uuid": "^0.2.0",
    handlebars: "^4.7.7",
    highcharts: "^10.2.1",
    "highcharts-react-official": "^3.1.0",
    "html-entities": "^2.1.0",
    i18next: "^23.8.2",
    ioredis: "^5.2.2",
    "ipaddr.js": "^2.2.0",
    "is-hotkey": "^0.2.0",
    iterall: "^1.3.0",
    jose: "^4.15.5",
    jotai: "^2.6.3",
    "js-base64": "^3.7.7",
    jsdom: "^24.0.0",
    jsonwebtoken: "^9.0.2",
    jss: "^10.9.0",
    "jwks-rsa": "^2.0.5",
    "jwt-encode": "^1.0.1",
    "linkify-react": "^4.1.3",
    linkifyjs: "^4.1.3",
    "markdown-to-jsx": "^7.4.0",
    multer: "^1.4.4-lts.1",
    nanoid: "^3.3.6",
    "neat-csv": "^7.0.0",
    "node-cache": "^5.1.2",
    "node-email-reply-parser": "^0.1.4",
    "node-fetch": "^3.3.2",
    oauth: "^0.9.15",
    open: "^8.4.2",
    openai: "^4.22.0",
    parse5: "^7.1.2",
    "patch-package": "^6.5.1",
    pg: "^8.11.5",
    "pg-boss": "^8.4.2",
    "pg-copy-streams": "^5.1.1",
    "prom-client": "^15.1.2",
    "query-string": "^7.1.3",
    querystring: "^0.2.0",
    radash: "^11.0.0",
    react: "^18.2.0",
    "react-bootstrap": "^1.6.6",
    "react-country-region-selector": "^3.6.1",
    "react-dom": "^18.2.0",
    "react-helmet": "^6.1.0",
    "react-i18next": "^13.2.2",
    "react-jss": "^10.9.0",
    "react-markdown": "^8.0.5",
    "react-popper": "^2.3.0",
    "react-router-dom": "^6.8.2",
    "react-sticky-box": "^2.0.5",
    "react-syntax-highlighter": "^15.5.0",
    "react-window": "^1.8.10",
    redlock: "^v5.0.0-beta.2",
    "reflect-metadata": "^0.1.13",
    "response-time": "^2.3.2",
    sequelize: "^6.37.0",
    "sequelize-cli": "^6.6.1",
    "sequelize-typescript": "^2.1.6",
    "serialize-error": "^11.0.3",
    "sha.js": "^2.4.11",
    sharp: "^0.32.6",
    "slack-markdown": "0.1.1",
    slate: "^0.100.0",
    "slate-history": "^0.100.0",
    "slate-hyperscript": "^0.100.0",
    "slate-react": "^0.100.1",
    stripe: "^15.4.0",
    "subscriptions-transport-ws": "^0.9.19",
    supertest: "^6.1.6",
    "typed-emitter": "^1.3.1",
    "ua-parser-js": "^1.0.33",
    url: "^0.11.0",
    "url-pattern": "^1.0.3",
    "use-sync-external-store": "^1.2.0",
    uuid: "^8.3.2",
    "valid-data-url": "^3.0.0",
    validator: "^13.7.0",
    "wcag-contrast": "^3.0.0",
    winston: "^3.7.2",
    "winston-cloudwatch": "^6.2.0",
    "winston-transport": "^4.5.0",
    ws: "^7.5.3"
  },
  devDependencies: {
    "@cspell/eslint-plugin": "^6.31.1",
    "@luckycatfactory/esbuild-graphql-loader": "^3.7.0",
    "@microsoft/tsdoc": "^0.14.2",
    "@sentry/cli": "^2.10.0",
    "@types/analytics-node": "^3.1.5",
    "@types/auth0": "^3.3.3",
    "@types/backo2": "^1.0.1",
    "@types/bluebird": "^3.5.32",
    "@types/chrome": "^0.0.112",
    "@types/cookie": "^0.4.0",
    "@types/cookie-parser": "^1.4.3",
    "@types/dockerode": "^3.2.6",
    "@types/express": "^4.17.14",
    "@types/jest": "^29.5.3",
    "@types/jscodeshift": "^0.11.6",
    "@types/jsonwebtoken": "^8.5.9",
    "@types/multer": "^1.4.7",
    "@types/node": "^14.18.54",
    "@types/oauth": "^0.9.1",
    "@types/pg": "^8.11.5",
    "@types/pg-copy-streams": "^1.2.1",
    "@types/query-string": "^6.3.0",
    "@types/react": "^18.2.25",
    "@types/react-dom": "^18.2.18",
    "@types/react-helmet": "^6.1.6",
    "@types/react-syntax-highlighter": "^15.5.6",
    "@types/react-window": "^1.8.8",
    "@types/response-time": "^2.3.5",
    "@types/sha.js": "^2.4.0",
    "@types/supertest": "^2.0.11",
    "@types/uuid": "^8.3.4",
    "@types/validator": "^13.7.3",
    "@types/ws": "^7.2.5",
    "@typescript-eslint/eslint-plugin": "^7.5.0",
    "@typescript-eslint/parser": "^7.5.0",
    "@vanilla-extract/css": "^1.15.2",
    "@vanilla-extract/esbuild-plugin": "^2.2.2",
    chokidar: "^3.5.3",
    csstype: "^3.1.3",
    esbuild: "^0.21.3",
    "esbuild-plugin-svgr": "0.0.1",
    eslint: "^8.31.0",
    "eslint-config-prettier": "^8.6.0",
    "eslint-import-resolver-typescript": "^3.6.1",
    "eslint-plugin-cypress": "^2.12.1",
    "eslint-plugin-i18next": "^6.0.3",
    "eslint-plugin-import": "^2.28.1",
    "eslint-plugin-jest": "^27.9.0",
    "eslint-plugin-no-lookahead-lookbehind-regexp": "^0.1.0",
    "eslint-plugin-no-relative-import-paths": "^v1.5.2",
    "eslint-plugin-prettier": "^5.0.1",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "fake-indexeddb": "^3.1.7",
    glob: "^10.3.10",
    "http-server": "^14.0.0",
    "ioredis-mock": "^7.4.0",
    jest: "^29.7.0",
    "jest-environment-jsdom": "^29.6.1",
    jscodeshift: "^0.14.0",
    "lint-staged": "12.3.5",
    nodemon: "^3.0.1",
    "pg-formatter": "^1.2.0",
    prettier: "^3.0.3",
    "schema-dts": "^1.1.2",
    "ts-prune": "latest",
    typescript: "~5.1.6",
    yargs: "^17.7.2"
  },
  overrides: {
    "@auth0/auth0-react": {
      react: "^18.2.0",
      "react-dom": "^18.2.0"
    },
    "@material-ui/core": {
      react: "^18.2.0",
      "react-dom": "^18.2.0",
      "@types/react": "^18.2.18",
      "@types/react-dom": "^18.0.11"
    },
    "@material-ui/styles": {
      react: "^18.2.0",
      "react-dom": "^18.2.0",
      "@types/react": "^18.2.18"
    },
    "@sentry/cli": {
      "strip-ansi": "^7.0.1"
    },
    "@slack/events-api": {
      debug: "^3.1.0"
    },
    "apollo-server-express": {
      debug: "^3.1.0"
    },
    "eslint-plugin-import": {
      debug: "^3.1.0"
    },
    "graphql-iso-date": {
      graphql: "$graphql"
    },
    "graphql-postgres-subscriptions": {
      graphql: "$graphql"
    },
    "postgres-date": "2.1.0"
  }
};

// server/src/logging/prometheus.ts
import * as url from "url";
import * as prom from "prom-client";
var register = new prom.Registry();
if (process.env.CORD_WORKER_NAME) {
  const sanitizedWorkerName = process.env.CORD_WORKER_NAME.replace(
    /[^A-Za-z0-9 _-]/g,
    ""
  );
  register.setDefaultLabels({ worker: sanitizedWorkerName });
}
prom.AggregatorRegistry.setRegistries([register]);
prom.collectDefaultMetrics({
  register,
  prefix: `${"asyncWorker"}_`
});
var Counter2 = (configuration) => new prom.Counter({ registers: [register], ...configuration });
var Gauge2 = (configuration) => new prom.Gauge({ registers: [register], ...configuration });
var TimeHistogram = (configuration) => new prom.Histogram({
  registers: [register],
  buckets: logBuckets(1e-3, 10, 13),
  ...configuration
});
function logBuckets(min, max, buckets) {
  const logMin = Math.log10(min);
  const logMax = Math.log10(max);
  const step = (logMax - logMin) / (buckets - 1);
  return [...Array(buckets).keys()].map((i) => min * 10 ** (i * step));
}
function incCounterWithAppID(viewer, counter8, labels = {}, value = 1) {
  counter8.inc(
    { appID: viewer.platformApplicationID || "null", ...labels },
    value
  );
}
var aggregatorRegistry = new prom.AggregatorRegistry();

// server/src/auth/index.ts
import { JwksClient } from "jwks-rsa";

// server/src/util/CordError.ts
var CordError = class extends Error {
  constructor(message, loggingMetadata, loggingTags) {
    super(message);
    this.loggingMetadata = loggingMetadata;
    this.loggingTags = loggingTags;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// server/src/util/ClientFacingError.ts
var ClientFacingError = class extends CordError {
  constructor(message, loggingMetadata, loggingTags) {
    super(message, loggingMetadata, loggingTags);
    this.message = message;
  }
};

// server/src/entity/org_members/OrgMembersEntity.ts
import { Table as Table5, Column as Column5, Model as Model5 } from "sequelize-typescript";
import { DataTypes as DataTypes5 } from "sequelize";
var OrgMembersEntity = class extends Model5 {
};
__decorateClass([
  Column5({
    type: DataTypes5.UUID,
    primaryKey: true,
    allowNull: false
  })
], OrgMembersEntity.prototype, "userID", 2);
__decorateClass([
  Column5({
    type: DataTypes5.UUID,
    primaryKey: true,
    allowNull: false
  })
], OrgMembersEntity.prototype, "orgID", 2);
__decorateClass([
  Column5({
    type: DataTypes5.UUID,
    allowNull: true
  })
], OrgMembersEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column5({
    type: DataTypes5.TIME
  })
], OrgMembersEntity.prototype, "createdTimestamp", 2);
OrgMembersEntity = __decorateClass([
  Table5({
    tableName: "org_members",
    timestamps: false
  })
], OrgMembersEntity);

// server/src/auth/index.ts
var SERVICE_USER_ID = "service_user";
var jwksClient = new JwksClient({
  jwksUri: `https://${Env_default.AUTH0_CUSTOM_LOGIN_DOMAIN}/.well-known/jwks.json`
});
function createAnonymousSession() {
  return {
    viewer: Viewer.createAnonymousViewer()
  };
}
var Viewer = class _Viewer {
  constructor(userID, orgID, platformApplicationID, externalUserID, externalOrgID, developerUserID, originalOrgID, relevantOrgIDs) {
    this.userID = userID;
    this.orgID = orgID;
    this.platformApplicationID = platformApplicationID;
    this.externalUserID = externalUserID;
    this.externalOrgID = externalOrgID;
    this.developerUserID = developerUserID;
    this.originalOrgID = originalOrgID;
    this.relevantOrgIDs = relevantOrgIDs;
    if (orgID !== void 0 && relevantOrgIDs !== void 0) {
      if (relevantOrgIDs.length !== 1 || relevantOrgIDs[0] !== orgID) {
        throw new Error(
          "You specified both a single orgID and relevantOrgIDs. You should pass undefined for the orgID to catch places not using relevantOrgIDs. Be bold!"
        );
      }
    } else if (orgID !== void 0) {
      this.relevantOrgIDs = [orgID];
    }
  }
  static async createLoggedInPlatformViewer({
    user,
    org
  }) {
    if (!user.platformApplicationID) {
      throw new Error("Platform viewer must have platformApplicationID");
    }
    const relevantOrgIDs = org ? void 0 : (
      // OrgMembersLoader.loadAllImmediateOrgIDsForUser but we can't call that since we
      // don't have a viewer yet!
      (await OrgMembersEntity.findAll({
        where: {
          userID: user.id
        }
      })).map((e) => e.orgID)
    );
    return new _Viewer(
      user.id,
      org?.id,
      user.platformApplicationID,
      user.externalID,
      org?.externalID,
      void 0,
      void 0,
      relevantOrgIDs
    );
  }
  static createLoggedInViewer(userID, orgID) {
    return new _Viewer(userID, orgID);
  }
  static createOrgViewer(orgID, platformApplicationID) {
    return new _Viewer(void 0, orgID, platformApplicationID);
  }
  static createServiceViewer() {
    return new _Viewer(SERVICE_USER_ID, void 0);
  }
  static createAnonymousViewer() {
    return new _Viewer(void 0, void 0);
  }
  static createConsoleViewer(devUserID) {
    return new _Viewer(
      void 0,
      void 0,
      void 0,
      void 0,
      void 0,
      devUserID
    );
  }
  static createFromSerializedState(serializedViewer) {
    const {
      userID,
      orgID,
      platformApplicationID,
      externalUserID,
      externalOrgID,
      developerUserID,
      originalOrgID,
      relevantOrgIDs,
      ...rest
    } = serializedViewer;
    const _ = rest;
    return new _Viewer(
      userID,
      orgID,
      platformApplicationID,
      externalUserID,
      externalOrgID,
      developerUserID,
      originalOrgID,
      relevantOrgIDs
    );
  }
  /**
   * Returns a version of this Viewer with the orgID set to the given org ID,
   * used in situations where a user logged into one org wants to take an action
   * as themselves in another org, such as sending a message from the unified
   * inbox.  If the orgID given is the same as this Viewer's org ID, just
   * returns this Viewer again.
   */
  viewerInOtherOrg(orgID, externalOrgID, relevantOrgIDs) {
    if (orgID === this.orgID && orgID !== void 0) {
      return this;
    }
    if (orgID === void 0 && relevantOrgIDs === void 0) {
      throw new Error("viewerInOtherOrg provided with no orgs at all");
    }
    return new _Viewer(
      this.userID,
      orgID,
      this.platformApplicationID,
      this.externalUserID,
      externalOrgID,
      this.developerUserID,
      this.originalOrgID ?? this.orgID,
      relevantOrgIDs
    );
  }
};
var assertViewerHasIdentity = (viewer) => {
  if (!viewer.userID || !viewer.orgID) {
    throw new Error("Viewer must not be anonymous.");
  }
  return {
    userID: viewer.userID,
    orgID: viewer.orgID
  };
};
function assertViewerHasPlatformIdentity(viewer) {
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  if (!viewer.externalUserID || !viewer.externalOrgID || !viewer.platformApplicationID) {
    throw new Error("Viewer must be a platform viewer");
  }
  return {
    userID,
    orgID,
    platformApplicationID: viewer.platformApplicationID,
    externalUserID: viewer.externalUserID,
    externalOrgID: viewer.externalOrgID
  };
}
function viewerHasIdentity(viewer) {
  return !!viewer.userID && !!viewer.orgID;
}
function assertViewerHasUser(viewer) {
  const { userID } = viewer;
  if (!userID) {
    throw new Error("Viewer user must not be anonymous.");
  }
  return userID;
}
function assertViewerHasOrg(viewer) {
  const { orgID } = viewer;
  if (!orgID) {
    throw new Error("Viewer org must not be anonymous.");
  }
  return orgID;
}
function assertViewerHasSingleOrgForWrite(viewer, error) {
  const { orgID } = viewer;
  if (!orgID) {
    throw new ClientFacingError(error);
  }
  return orgID;
}
function assertViewerHasOrgs(viewer) {
  const { relevantOrgIDs } = viewer;
  if (!relevantOrgIDs) {
    throw new Error("Viewer orgs must be nonempty.");
  }
  return relevantOrgIDs;
}
function assertViewerHasPlatformUser(viewer) {
  const { userID, externalUserID, platformApplicationID } = viewer;
  if (!userID || !externalUserID || !platformApplicationID) {
    throw new Error("Viewer must have a platform user");
  }
  return { userID, externalUserID, platformApplicationID };
}
function assertViewerHasPlatformApplicationID(viewer) {
  const { platformApplicationID } = viewer;
  if (!platformApplicationID) {
    throw new Error("Viewer must have a platform app ID");
  }
  return platformApplicationID;
}
function assertServiceViewer(viewer) {
  if (viewer.userID !== SERVICE_USER_ID) {
    throw new Error("Viewer must be service user.");
  }
}
function viewerIsUsingOrgsAsFilter(viewer) {
  return viewer.orgID !== void 0;
}

// server/src/logging/Logger.ts
var logLevel = Env_default.LOGLEVEL;
var defaultMeta = {
  process: "asyncWorker",
  serverVersion: package_default.version,
  serverGitCommit: process.env.COMMIT_HASH || process.env.npm_package_gitHead,
  serverHost: hostname()
};
if (process.env.CORD_WORKER_NAME) {
  defaultMeta.workerName = process.env.CORD_WORKER_NAME;
}
var sentryLogging = !!Env_default.SENTRY_ENVIRONMENT;
if (sentryLogging) {
  Sentry.init({
    dsn: "https://66e0e856dbbd4a35aacca91a2bf45751@o951476.ingest.sentry.io/5985122",
    environment: Env_default.SENTRY_ENVIRONMENT,
    release: Env_default.SENTRY_RELEASE,
    tracesSampleRate: parseFloat(Env_default.SENTRY_TRACE_SAMPLE_RATE ?? "0"),
    attachStacktrace: true,
    normalizeDepth: 10
  });
}
var winstonLogger = winston.createLogger({ defaultMeta });
winstonLogger.add(
  new winston.transports.Console({
    level: logLevel,
    format: winston.format.combine(winston.format.timestamp(), flatFormat()),
    handleExceptions: true
  })
);
var counter = Counter2({
  name: "ServerLogging",
  help: "Number of log messages emitted by server",
  labelNames: ["level"]
});
var LEVEL = Symbol.for("level");
var MetricLogger = class extends Transport {
  log(info, next) {
    counter.inc({ level: info[LEVEL] });
    next();
  }
};
winstonLogger.add(new MetricLogger({ level: "silly" }));
var winstonCW = void 0;
if (Env_default.CLOUDWATCH_LOGLEVEL && !process.env.IS_TEST) {
  if (!Env_default.CLOUDWATCH_LOG_GROUP_NAME) {
    throw new Error(
      `CloudWatch logging is enabled (CLOUDWATCH_LOGLEVEL is set), so
       CLOUDWATCH_LOG_GROUP_NAME must be provided, too!`
    );
  }
  const defaultStreamName = () => `${(/* @__PURE__ */ new Date()).toISOString().replace(/:/g, ".")} ${userInfo().username} ${hostname()}(${process.pid})`;
  winstonCW = new WinstonCloudWatch({
    // "name" is optional with default value "CloudWatch" but the
    // typedefinition has name as required. See
    // https://githubmemory.com/repo/lazywithclass/winston-cloudwatch/issues/155
    name: "CloudWatch",
    level: Env_default.CLOUDWATCH_LOGLEVEL,
    logGroupName: Env_default.CLOUDWATCH_LOG_GROUP_NAME,
    logStreamName: Env_default.CLOUDWATCH_LOG_STREAM_NAME || defaultStreamName(),
    awsRegion: Env_default.CLOUDWATCH_AWS_REGION,
    jsonMessage: true
  });
  winstonLogger.add(winstonCW);
} else {
  if (Env_default.CLOUDWATCH_LOG_GROUP_NAME || Env_default.CLOUDWATCH_LOG_STREAM_NAME) {
    throw new Error(
      `Some CLOUDWATCH_* variables are set, but CLOUDWATCH_LOGLEVEL is not.`
    );
  }
}
var SENTRY_LOG_LEVEL = {
  error: "error",
  warn: "warning"
};
var cleanupSequelizeError = (error) => {
  const suberrors = error.errors;
  if (Array.isArray(suberrors)) {
    suberrors.forEach((error2) => delete error2.instance);
  }
};
var MAX_ORG_IDS_TO_LOG = 50;
var Logger = class _Logger {
  constructor(viewer, additionalMeta) {
    /**
      Useful when dealing with promises:
    
      ```
      promise.catch(exceptionLogger('something broke'))
      ```
    */
    this.exceptionLogger = (message, meta, tags) => (error) => this.logException(
      message,
      error,
      { ...this.metadata, ...meta },
      tags,
      "error"
    );
    this.truncatedViewer = { ...viewer };
    this.metadata = { ...defaultMeta, ...additionalMeta };
    if (viewer.relevantOrgIDs && viewer.relevantOrgIDs.length > MAX_ORG_IDS_TO_LOG) {
      this.truncatedViewer.relevantOrgIDs = [
        ...viewer.relevantOrgIDs.slice(0, MAX_ORG_IDS_TO_LOG),
        `(truncated from ${viewer.relevantOrgIDs.length} orgs)`
      ];
    }
    void this.addAppName(viewer);
  }
  childLogger(viewer, additionalMeta) {
    return new _Logger(viewer, { ...this.metadata, ...additionalMeta });
  }
  viewerToLog() {
    return {
      ...this.truncatedViewer,
      ...this.appName && { appName: this.appName }
    };
  }
  log(level, message, meta, options) {
    if (sentryLogging && !process.env.IS_TEST) {
      const sentryLevel = SENTRY_LOG_LEVEL[level];
      if (sentryLevel) {
        const sentryEventID = Sentry.captureMessage(message, {
          level: sentryLevel,
          extra: { ...defaultMeta, ...meta },
          tags: { loggingProcessName: "asyncWorker" },
          fingerprint: options?.sentryFingerPrint,
          user: this.viewerToLog()
        });
        meta = { ...this.metadata, ...meta, sentryEventID };
      }
    }
    winstonLogger.log(level, message, {
      viewer: this.viewerToLog(),
      ...this.metadata,
      ...meta
    });
  }
  debug(message, meta, options) {
    this.log("debug", message, meta, options);
  }
  info(message, meta, options) {
    this.log("info", message, meta, options);
  }
  warn(message, meta, options) {
    this.log("warn", message, meta, options);
  }
  error(message, meta, options) {
    this.log("error", message, meta, options);
  }
  logLoggerInfo() {
    this.info(
      `Logging through winston. Console log level set to "${logLevel}", CloudWatch logging is ${Env_default.CLOUDWATCH_LOGLEVEL === void 0 ? "disabled" : `set to "${Env_default.CLOUDWATCH_LOGLEVEL}"`}`
    );
  }
  /**
    To be used imperatively:
  
    ```
    try {
      // ...
    } catch (e) {
      logException('something broke', e)
    }
    ```
  */
  logException(message, error, meta, tags, level = "error") {
    if (error.name?.startsWith("Sequelize")) {
      cleanupSequelizeError(error);
    }
    let serializedError = void 0;
    try {
      serializedError = serializeError(error, { maxDepth: 50 });
    } catch (e) {
      winstonLogger.log(
        level,
        `logException: serializeError threw an exception (${message})`,
        {
          error: `${error}`,
          viewer: this.viewerToLog(),
          ...this.metadata,
          ...meta
        }
      );
    }
    if (serializedError !== void 0) {
      if (!message) {
        try {
          message = `${serializedError.name}: ${serializedError.message}`;
        } catch (e) {
          message = `${serializedError}`;
        }
      }
      winstonLogger.log(level, message, {
        error: serializedError,
        viewer: this.viewerToLog(),
        ...this.metadata,
        ...meta
      });
    }
    if ((level === "warn" || level === "error") && !process.env.IS_TEST) {
      Sentry.withScope((scope) => {
        scope.setTags({
          ...error instanceof CordError && error.loggingTags,
          ...tags
        });
        if (serializedError && error instanceof CordError) {
          delete serializedError.loggingMetadata;
          delete serializedError.loggingTags;
        }
        scope.setExtra("error", serializedError);
        scope.setExtra("message", message);
        scope.setExtra("meta", {
          ...this.metadata,
          ...error instanceof CordError && error.loggingMetadata,
          ...meta
        });
        scope.setExtra("user", this.viewerToLog());
        Sentry.captureException(error, {
          level: SENTRY_LOG_LEVEL[level]
        });
      });
    }
  }
  async addAppName(viewer) {
    if (!viewer?.platformApplicationID) {
      return;
    }
    const app = await ApplicationEntity.findByPk(viewer.platformApplicationID);
    this.appName = app?.name;
  }
};
var _anonymousLogger = void 0;
function anonymousLogger() {
  if (_anonymousLogger === void 0) {
    _anonymousLogger = new Logger(Viewer.createAnonymousViewer());
  }
  return _anonymousLogger;
}

// server/src/asyncTier/pgboss.ts
var boss;
function getBoss() {
  if (boss === void 0) {
    throw new Error("PgBoss has not been initialised");
  }
  return boss;
}
async function initBoss() {
  if (boss !== void 0) {
    throw new Error("PgBoss has been already initialised");
  }
  const logger = anonymousLogger();
  const schema2 = `pgboss_${Env_default.CORD_TIER}`;
  const newBoss = new PgBoss({
    host: Env_default.POSTGRES_HOST,
    port: Number(Env_default.POSTGRES_PORT),
    database: Env_default.POSTGRES_DB,
    user: Env_default.POSTGRES_USER,
    password: Env_default.POSTGRES_PASSWORD,
    schema: schema2
  });
  newBoss.on("error", logger.exceptionLogger("pgboss error"));
  await newBoss.start();
  logger.info("pg-boss is ready", { schema: schema2 });
  boss = newBoss;
  return boss;
}

// server/src/entity/sequelize.ts
import { Sequelize as Sequelize7 } from "sequelize-typescript";
import { DatabaseError, QueryTypes, Transaction } from "sequelize";

// common/util/sleep.ts
function sleep(ms) {
  return new Promise((resolve2) => setTimeout(resolve2, ms));
}

// server/src/entity/message/MessageEntity.ts
import {
  Table as Table6,
  Column as Column6,
  PrimaryKey as PrimaryKey2,
  Model as Model6,
  DefaultScope
} from "sequelize-typescript";
import { DataTypes as DataTypes6, Sequelize } from "sequelize";

// common/util/index.ts
import md5 from "blueimp-md5";
import jsonStableStringify2 from "fast-json-stable-stringify";
import { unique } from "radash";
import shajs from "sha.js";
import dayjs from "dayjs";
import Calendar from "dayjs/plugin/calendar.js";
import isBetween from "dayjs/plugin/isBetween.js";

// opensource/sdk-js/packages/react/common/lib/messageNode.ts
var import_types5 = __toESM(require_cjs(), 1);
import { Element } from "slate";
import { v4 as uuid } from "uuid";

// opensource/sdk-js/packages/react/common/lib/trim.ts
function trimStart(s, c) {
  return trimImpl(s, c, { front: true, end: false });
}
function trimEnd(s, c) {
  return trimImpl(s, c, { front: false, end: true });
}
function trimImpl(s, c, { front, end }) {
  if (c.length !== 1) {
    throw new Error(`${c} must be a single character`);
  }
  let idxStart = 0;
  let idxEnd = s.length;
  if (front) {
    while (idxStart < idxEnd && s[idxStart] === c) {
      idxStart++;
    }
  }
  if (end) {
    while (idxEnd > idxStart && s[idxEnd - 1] === c) {
      idxEnd--;
    }
  }
  return s.slice(idxStart, idxEnd);
}

// opensource/sdk-js/packages/react/common/lib/messageNode.ts
var MAX_BULLET_INDENT = 4;
function createMessageNode(nodeType, nodeAttributes) {
  return {
    type: nodeType,
    ...nodeAttributes
  };
}
function createMessageTextNode(text) {
  return {
    text
  };
}
function createFormattedMessageTextNode(input) {
  return input;
}
function isMessageNodeType(node, nodeType) {
  return Boolean(node && Element.isElement(node) && node.type === nodeType);
}
function isMessageNodeText(node) {
  return !node.type && "text" in node;
}
function createParagraphNode(text = "") {
  return createMessageNode(import_types5.MessageNodeType.PARAGRAPH, {
    children: [{ text }]
  });
}
function createMentionNode(userID, name) {
  return createMessageNode(import_types5.MessageNodeType.MENTION, {
    user: { id: userID },
    children: [{ text: `@${name}` }]
  });
}
function createLinkNode(url6, text) {
  return createMessageNode(import_types5.MessageNodeType.LINK, {
    url: url6,
    children: [{ text }]
  });
}
var findTodoNodesInSubtree = (parent, accumulator) => {
  if (parent.type === import_types5.MessageNodeType.TODO) {
    accumulator.push(parent);
  } else {
    const children = getMessageNodeChildren(parent);
    if (children) {
      for (const node of children) {
        findTodoNodesInSubtree(node, accumulator);
      }
    }
  }
};
var todoNodesFromMessage = (messageContent) => {
  const accumulator = [];
  for (const node of messageContent) {
    findTodoNodesInSubtree(node, accumulator);
  }
  return accumulator;
};
function getMessageNodeChildren(node) {
  return node.children;
}
var textFromNodeRecursive = (node) => {
  let textArr = [];
  if (isMessageNodeText(node)) {
    return node.text;
  }
  const children = getMessageNodeChildren(node);
  if (children) {
    textArr = textArr.concat(
      children.map((child) => textFromNodeRecursive(child))
    );
  }
  const result = textArr.join("");
  return result;
};
function convertStructuredMessageToText(messageContent) {
  return messageContent.map((node) => textFromNodeRecursive(node)).join("\n").trim();
}
function taskTitleFromMessageNodes(nodes) {
  let pending = "";
  let text = "";
  for (const node of nodes) {
    if (node.type === import_types5.MessageNodeType.ASSIGNEE) {
      if (text.trim() === "") {
        continue;
      }
      pending += trimStart(textFromNodeRecursive(node), "+");
      continue;
    }
    let newText = "";
    if (isMessageNodeText(node)) {
      newText = node.text;
    } else if (node.type === import_types5.MessageNodeType.MENTION) {
      newText = trimStart(textFromNodeRecursive(node), "@");
    }
    const isEmpty2 = newText.trim() === "";
    if (isEmpty2) {
      pending += newText;
    } else {
      text += pending + newText;
      pending = "";
    }
  }
  return trimEnd(text.trim(), ":").trim();
}
function taskTitleFromMessageContent(messageContent) {
  for (let i = 0; i < messageContent.length; i++) {
    const nodes = [];
    flattenMessage(messageContent[i], nodes);
    const title = taskTitleFromMessageNodes(nodes);
    if (title.length > 0) {
      return title;
    }
  }
  return "Task created using Cord";
}
function flattenMessage(node, accumulator) {
  if (isMessageNodeText(node) || node.type === import_types5.MessageNodeType.ASSIGNEE || node.type === import_types5.MessageNodeType.MENTION) {
    accumulator.push(node);
    return;
  }
  const children = getMessageNodeChildren(node);
  if (!children) {
    return;
  }
  for (const child of children) {
    flattenMessage(child, accumulator);
  }
}

// common/util/index.ts
var uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;
var isInternalSlackOrg = (slackTeamID) => slackTeamID === CORD_SLACK_TEAM_ID || slackTeamID === CORD_TEST_SLACK_TEAM_ID;
var assertUUID = (value) => {
  if (!uuidRegex.test(value)) {
    throw new Error(`Invalid UUID ${value}`);
  } else {
    return value;
  }
};
function isNotNull(value) {
  return value !== null;
}
function isDefined(value) {
  return value !== null && value !== void 0;
}
function getMentionedUserIDs(content) {
  let users = [];
  for (const node of content) {
    if (node.type === import_types2.MessageNodeType.MENTION) {
      users.push(node.user.id);
    } else {
      const children = getMessageNodeChildren(node);
      if (children) {
        users = [...users, ...getMentionedUserIDs(children)];
      }
    }
  }
  return unique(users);
}
function getReferencedUserIDs(content) {
  const accumulator = /* @__PURE__ */ new Set();
  gatherReferencedUserIDs(content, accumulator);
  return [...accumulator];
}
function gatherReferencedUserIDs(nodes, accumulator) {
  for (const node of nodes) {
    if (node.type === import_types2.MessageNodeType.MENTION || node.type === import_types2.MessageNodeType.ASSIGNEE) {
      accumulator.add(node.user.id);
      continue;
    }
    const children = getMessageNodeChildren(node);
    if (children) {
      gatherReferencedUserIDs(children, accumulator);
    }
  }
}
function replaceAll(str, replace, replaceWith) {
  return str.split(replace).join(replaceWith);
}
function assert(predicate, message) {
  if (!predicate) {
    throw new Error(message);
  }
}
function combine(combiner, items) {
  if (items.length === 0) {
    return "";
  } else if (items.length === 1) {
    return items[0];
  } else if (items.length === 2) {
    return `${items[0]} ${combiner} ${items[1]}`;
  } else {
    return `${items.slice(0, -1).join(", ")}, ${combiner} ${items[items.length - 1]}`;
  }
}
var CORD_DEEP_LINK_QUERY_PARAM = "cord_link";
function extractDeepLinkQueryParams(url6) {
  try {
    const parsed = new URL(url6);
    return extractDeepLinkQueryParamsV1(parsed);
  } catch (e) {
    return null;
  }
}
function extractDeepLinkQueryParamsV1(url6) {
  const [version2, threadID, messageID] = (url6.searchParams.get(CORD_DEEP_LINK_QUERY_PARAM) ?? "").split("_");
  if (version2 !== "v1" || !threadID || !messageID) {
    return null;
  }
  return {
    threadID,
    messageID
  };
}
dayjs.extend(Calendar);
dayjs.extend(isBetween);
function createDefaultSenderEmailName(applicationName) {
  return applicationName.toLowerCase().split(/\W/).join("") + "-notifications";
}
function getEmailInfoFromSenderData(sender) {
  if (!sender) {
    return void 0;
  }
  const mentionMatchingPattern = new RegExp(
    "(<)([^@]+)(@)([^>]+)",
    // then match anything that's not an > symbol and is at least 1 char
    "gm"
  );
  let info = void 0;
  let match;
  while (match = mentionMatchingPattern.exec(sender)) {
    info = {
      username: match[2],
      domain: match[4],
      emailAddress: match[0].substring(1)
    };
  }
  return info;
}

// server/src/entity/message/MessageEntity.ts
var MessageEntity = class extends Model6 {
  isDeleted() {
    return this.deletedTimestamp !== null;
  }
};
__decorateClass([
  PrimaryKey2,
  Column6({
    type: DataTypes6.UUID,
    defaultValue: DataTypes6.UUIDV4
  })
], MessageEntity.prototype, "id", 2);
__decorateClass([
  Column6({ type: DataTypes6.STRING })
], MessageEntity.prototype, "externalID", 2);
__decorateClass([
  Column6({
    type: DataTypes6.UUID
  })
], MessageEntity.prototype, "orgID", 2);
__decorateClass([
  Column6({
    type: DataTypes6.UUID
  })
], MessageEntity.prototype, "threadID", 2);
__decorateClass([
  Column6({
    type: DataTypes6.UUID,
    allowNull: false
  })
], MessageEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column6({
    type: DataTypes6.UUID
  })
], MessageEntity.prototype, "sourceID", 2);
__decorateClass([
  Column6({
    type: DataTypes6.JSONB,
    get() {
      return cleanseMessageContent(this.getDataValue("content"));
    }
  })
], MessageEntity.prototype, "content", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TEXT
  })
], MessageEntity.prototype, "url", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TIME
  })
], MessageEntity.prototype, "timestamp", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TIME
  })
], MessageEntity.prototype, "deletedTimestamp", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TIME
  })
], MessageEntity.prototype, "lastUpdatedTimestamp", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TEXT
  })
], MessageEntity.prototype, "importedSlackChannelID", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TEXT
  })
], MessageEntity.prototype, "importedSlackMessageTS", 2);
__decorateClass([
  Column6({
    type: DataTypes6.ENUM("reply", "supportBotReply"),
    defaultValue: null
  })
], MessageEntity.prototype, "importedSlackMessageType", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TEXT
  })
], MessageEntity.prototype, "importedSlackMessageThreadTS", 2);
__decorateClass([
  Column6({
    type: DataTypes6.UUID,
    defaultValue: null
  })
], MessageEntity.prototype, "replyToEmailNotificationID", 2);
__decorateClass([
  Column6({
    type: DataTypes6.ENUM("action_message", "user_message"),
    defaultValue: "user_message"
  })
], MessageEntity.prototype, "type", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TEXT
  })
], MessageEntity.prototype, "iconURL", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TEXT
  })
], MessageEntity.prototype, "translationKey", 2);
__decorateClass([
  Column6({
    type: DataTypes6.JSONB,
    allowNull: false,
    defaultValue: {}
  })
], MessageEntity.prototype, "metadata", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TEXT,
    defaultValue: ""
  })
], MessageEntity.prototype, "extraClassnames", 2);
__decorateClass([
  Column6({
    type: DataTypes6.TSVECTOR
  })
], MessageEntity.prototype, "contentTsVector", 2);
__decorateClass([
  Column6({
    type: DataTypes6.VIRTUAL
  })
], MessageEntity.prototype, "createdAtWithMicros", 2);
__decorateClass([
  Column6({
    type: DataTypes6.BOOLEAN,
    allowNull: false,
    defaultValue: false
  })
], MessageEntity.prototype, "skipLinkPreviews", 2);
MessageEntity = __decorateClass([
  DefaultScope(() => ({
    attributes: {
      include: [
        [
          // We're sorting on this, so the format matters, and sorting alphabetically equals sorting chronologically.
          Sequelize.literal(`TO_CHAR("timestamp", 'YYYY-MM-DD HH24:MI:SS.US')`),
          "createdAtWithMicros"
        ]
      ]
    }
  })),
  Table6({
    tableName: "messages",
    timestamps: false
  })
], MessageEntity);
function cleanseMessageContent(content) {
  if (!content) {
    return [];
  }
  return content.map(cleanseNode).filter(isDefined);
}
function cleanseNode(node) {
  if (node.type === "annotation" /* ANNOTATION */) {
    return void 0;
  } else if (node.type === "a" /* LINK_DEPRECATED */) {
    return {
      type: import_types2.MessageNodeType.LINK,
      url: node.url,
      children: [{ text: node.text }]
    };
  }
  if ("children" in node) {
    return {
      ...node,
      children: cleanseMessageContent(node.children)
    };
  }
  return node;
}

// server/src/entity/org/OrgEntity.ts
import { Table as Table8, Column as Column8, PrimaryKey as PrimaryKey3, Model as Model8 } from "sequelize-typescript";
import { DataTypes as DataTypes8 } from "sequelize";

// server/src/entity/linked_orgs/LinkedOrgsEntity.ts
import { Table as Table7, Column as Column7, Model as Model7 } from "sequelize-typescript";
import { DataTypes as DataTypes7 } from "sequelize";
var LinkedOrgsEntity = class extends Model7 {
};
__decorateClass([
  Column7({
    type: DataTypes7.UUID,
    primaryKey: true,
    unique: true
  })
], LinkedOrgsEntity.prototype, "sourceOrgID", 2);
__decorateClass([
  Column7({
    type: DataTypes7.ENUM("slack", "platform")
  })
], LinkedOrgsEntity.prototype, "sourceExternalProvider", 2);
__decorateClass([
  Column7({
    type: DataTypes7.UUID,
    primaryKey: true
  })
], LinkedOrgsEntity.prototype, "linkedOrgID", 2);
__decorateClass([
  Column7({
    type: DataTypes7.ENUM("slack", "platform")
  })
], LinkedOrgsEntity.prototype, "linkedExternalProvider", 2);
__decorateClass([
  Column7({
    type: DataTypes7.UUID
  })
], LinkedOrgsEntity.prototype, "mergerUserID", 2);
__decorateClass([
  Column7({
    type: DataTypes7.TIME
  })
], LinkedOrgsEntity.prototype, "linkedTimestamp", 2);
LinkedOrgsEntity = __decorateClass([
  Table7({
    tableName: "linked_orgs",
    timestamps: false
  })
], LinkedOrgsEntity);

// server/src/slack/types.ts
function asSlackBotUserAuthData(x) {
  if (x && typeof x === "object" && !Array.isArray(x) && typeof x.bot_user_id === "string" && typeof x.bot_access_token === "string") {
    return {
      bot_user_id: x.bot_user_id,
      bot_access_token: x.bot_access_token
    };
  }
  return null;
}

// server/src/entity/org/OrgEntity.ts
var OrgEntity = class extends Model8 {
  async getLinkedOrg() {
    if (this.externalProvider !== "platform") {
      return null;
    }
    return await OrgEntity.findOne({
      include: {
        model: LinkedOrgsEntity,
        required: true,
        where: {
          sourceOrgID: this.id,
          sourceExternalProvider: this.externalProvider
        }
      }
    });
  }
  async loadLinkedSlackOrg() {
    if (this.externalProvider === "slack") {
      return this;
    }
    const slackOrg = await this.getLinkedOrg();
    return slackOrg?.externalProvider === "slack" ? slackOrg : null;
  }
  async getSlackBotCredentials() {
    const slackOrg = await this.loadLinkedSlackOrg();
    if (slackOrg) {
      const authData = asSlackBotUserAuthData(slackOrg.externalAuthData);
      if (authData) {
        return { org: slackOrg, ...authData };
      }
    }
    return null;
  }
};
__decorateClass([
  PrimaryKey3,
  Column8({
    type: DataTypes8.UUID,
    defaultValue: DataTypes8.UUIDV4
  })
], OrgEntity.prototype, "id", 2);
__decorateClass([
  Column8({ type: DataTypes8.TIME })
], OrgEntity.prototype, "createdTimestamp", 2);
__decorateClass([
  Column8({ type: DataTypes8.ENUM("inactive", "active") })
], OrgEntity.prototype, "state", 2);
__decorateClass([
  Column8({ type: DataTypes8.STRING })
], OrgEntity.prototype, "name", 2);
__decorateClass([
  Column8({ type: DataTypes8.STRING, allowNull: true })
], OrgEntity.prototype, "domain", 2);
__decorateClass([
  Column8({ type: DataTypes8.STRING, unique: "AppExternalIDUniqueness" })
], OrgEntity.prototype, "externalID", 2);
__decorateClass([
  Column8({
    type: DataTypes8.ENUM("slack", "platform"),
    unique: "AppExternalIDUniqueness"
  })
], OrgEntity.prototype, "externalProvider", 2);
__decorateClass([
  Column8({ type: DataTypes8.JSONB })
], OrgEntity.prototype, "externalAuthData", 2);
__decorateClass([
  Column8({ type: DataTypes8.UUID, unique: "AppExternalIDUniqueness" })
], OrgEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column8({ type: DataTypes8.BOOLEAN, defaultValue: false, allowNull: false })
], OrgEntity.prototype, "internal", 2);
__decorateClass([
  Column8({
    type: DataTypes8.JSONB,
    allowNull: false,
    defaultValue: {}
  })
], OrgEntity.prototype, "metadata", 2);
__decorateClass([
  Column8({
    type: DataTypes8.TEXT
  })
], OrgEntity.prototype, "customSlackAppID", 2);
OrgEntity = __decorateClass([
  Table8({
    tableName: "orgs",
    timestamps: false
  })
], OrgEntity);

// server/src/entity/user/UserEntity.ts
import { Table as Table9, Column as Column9, PrimaryKey as PrimaryKey4, Model as Model9 } from "sequelize-typescript";
import { DataTypes as DataTypes9 } from "sequelize";
var UserEntity = class extends Model9 {
};
__decorateClass([
  PrimaryKey4,
  Column9({
    type: DataTypes9.UUID,
    defaultValue: DataTypes9.UUIDV4
  })
], UserEntity.prototype, "id", 2);
__decorateClass([
  Column9({ type: DataTypes9.TIME })
], UserEntity.prototype, "createdTimestamp", 2);
__decorateClass([
  Column9({ type: DataTypes9.TIME })
], UserEntity.prototype, "updatedTimestamp", 2);
__decorateClass([
  Column9({ type: DataTypes9.ENUM("person", "bot"), defaultValue: "person" })
], UserEntity.prototype, "userType", 2);
__decorateClass([
  Column9({ type: DataTypes9.BOOLEAN, defaultValue: false })
], UserEntity.prototype, "admin", 2);
__decorateClass([
  Column9({
    type: DataTypes9.ENUM("active", "deleted"),
    defaultValue: "active",
    allowNull: false
  })
], UserEntity.prototype, "state", 2);
__decorateClass([
  Column9({ type: DataTypes9.STRING })
], UserEntity.prototype, "name", 2);
__decorateClass([
  Column9({ type: DataTypes9.DATE })
], UserEntity.prototype, "nameUpdatedTimestamp", 2);
__decorateClass([
  Column9({ type: DataTypes9.STRING })
], UserEntity.prototype, "screenName", 2);
__decorateClass([
  Column9({ type: DataTypes9.STRING })
], UserEntity.prototype, "email", 2);
__decorateClass([
  Column9({ type: DataTypes9.STRING })
], UserEntity.prototype, "profilePictureURL", 2);
__decorateClass([
  Column9({ type: DataTypes9.DATE })
], UserEntity.prototype, "profilePictureURLUpdatedTimestamp", 2);
__decorateClass([
  Column9({ type: DataTypes9.STRING, unique: "AppExternalIDUniqueness" })
], UserEntity.prototype, "externalID", 2);
__decorateClass([
  Column9({ type: DataTypes9.ENUM("slack", "platform") })
], UserEntity.prototype, "externalProvider", 2);
__decorateClass([
  Column9({ type: DataTypes9.UUID, unique: "AppExternalIDUniqueness" })
], UserEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column9({
    type: DataTypes9.JSONB,
    allowNull: false,
    defaultValue: {}
  })
], UserEntity.prototype, "metadata", 2);
UserEntity = __decorateClass([
  Table9({
    tableName: "users",
    timestamps: false
  })
], UserEntity);

// server/src/entity/file/FileEntity.ts
import { Table as Table11, Column as Column11, PrimaryKey as PrimaryKey5, Model as Model11 } from "sequelize-typescript";
import { DataTypes as DataTypes11 } from "sequelize";

// server/src/files/upload.ts
import * as crypto2 from "crypto";
import dayjs2 from "dayjs";
import utc from "dayjs/plugin/utc.js";
import * as credentialProviderNode from "@aws-sdk/credential-provider-node";

// common/const/Timing.ts
var UPLOAD_URL_TTL_SECONDS = 60 * 5;
var DOWNLOAD_URL_TTL_SECONDS = 60 * 60 * 4;
var DELETE_URL_TTL_SECONDS = 60 * 10;
var TYPING_TIMEOUT_TTL_SECONDS = 3;
var PAGE_PRESENCE_LOSS_TTL_SECONDS = 30;
var PRESENCE_UPDATE_INTERVAL_MS = PAGE_PRESENCE_LOSS_TTL_SECONDS * 1e3 / 2;
var DURABLE_PRESENCE_THROTTLE_MS = 60 * 1e3;
var MAX_FILE_UPLOADING_TIME_SECONDS = 60;
var ACCESS_TOKEN_CLOCK_TOLERANCE_SECONDS = 30;
var ACCESS_TOKEN_MAX_AGE_SECONDS = 60 * 60 * 24;
var DEEP_LINK_THREAD_ID_TTL_SECONDS = 30;
var CLIENT_VERSION_MAX_DAYS_OLD = 60;
var SAMPLE_TOKEN_EXPIRY_SECONDS = 24 * 60 * 60 * 7;
var DOCS_TOKEN_EXPIRY_SECONDS = 24 * 60 * 60;

// common/util/setTimeoutAsync.ts
function setTimeoutAsync(f, ms) {
  return setTimeout(() => void f(), ms);
}

// server/src/files/upload.ts
dayjs2.extend(utc);
var {
  S3_ACCESS_KEY_ID,
  S3_ACCESS_KEY_SECRET,
  S3_BUCKET,
  S3_ENDPOINT,
  S3_REGION,
  S3_PUBLIC_BUCKET
} = Env_default;
var defaultS3Bucket = {
  bucket: S3_BUCKET,
  region: S3_REGION
};
var publicS3Bucket = {
  bucket: S3_PUBLIC_BUCKET,
  region: S3_REGION
};
var credentials = null;
function getCredentials() {
  if (!credentials) {
    throw new Error("Link signing credentials not initialized");
  }
  return credentials;
}
async function initializeLinkSigningCredentials() {
  if (S3_ACCESS_KEY_ID && S3_ACCESS_KEY_SECRET) {
    credentials = {
      accessKeyId: S3_ACCESS_KEY_ID,
      secretAccessKey: S3_ACCESS_KEY_SECRET
    };
    return;
  }
  return await refreshLinkSigningCredentials();
}
async function refreshLinkSigningCredentials() {
  try {
    credentials = await credentialProviderNode.defaultProvider({})();
    let refreshInMilliseconds = 5 * 60 * 60 * 1e3;
    if (credentials.expiration) {
      const millisecondsUntilExpiration = credentials.expiration.getTime() - Date.now();
      const maxTtlSeconds = Math.max(
        DOWNLOAD_URL_TTL_SECONDS,
        UPLOAD_URL_TTL_SECONDS,
        DELETE_URL_TTL_SECONDS
      );
      const needNewCredentialsInMilliseconds = millisecondsUntilExpiration - (maxTtlSeconds + 5 * 60) * 1e3;
      if (needNewCredentialsInMilliseconds < 60 * 1e3) {
        refreshInMilliseconds = 6e4;
      } else if (needNewCredentialsInMilliseconds < refreshInMilliseconds) {
        refreshInMilliseconds = needNewCredentialsInMilliseconds;
      }
    }
    anonymousLogger().info("Refreshed AWS credentials for S3 link signing", {
      accessKeyId: credentials.accessKeyId,
      nextRefreshInSeconds: refreshInMilliseconds / 1e3
    });
    setTimeoutAsync(refreshLinkSigningCredentials, refreshInMilliseconds);
  } catch (err) {
    anonymousLogger().logException("refreshLinkSigningCredentials", err);
    await sleep(1e3);
    return await refreshLinkSigningCredentials();
  }
}
var sha256 = (text) => crypto2.createHash("sha256").update(text).digest();
var hmac256 = (text, key) => crypto2.createHmac("sha256", key).update(text).digest();
var sortedEntries = (object) => Object.entries(object).sort(([key1], [key2]) => key1 < key2 ? -1 : 1);
var getSignedDownloadURL = (fileId, filename, config) => getSignedURL(fileId, DOWNLOAD_URL_TTL_SECONDS, config, "GET", void 0, {
  "response-content-disposition": `attachment; filename="${encodeURIComponent(
    filename
  )}"`
});
var getSignedUploadURL = (key, size, mimeType, config) => getSignedURL(key, UPLOAD_URL_TTL_SECONDS, config, "PUT", {
  "Content-Length": `${size}`,
  "Content-Type": mimeType
});
var getSignedDeleteURL = (key, config) => getSignedURL(key, DELETE_URL_TTL_SECONDS, config, "DELETE");
function getPublicBucketDownloadURL(filename) {
  return `https://${Env_default.PUBLIC_UPLOADS_HOST}/${getPublicBucketKey(filename)}`;
}
function getPublicBucketKey(key) {
  return Env_default.S3_USE_PATH_BASED_URLS === "true" ? Env_default.S3_PUBLIC_BUCKET + "/" + key : key;
}
var getSignedURL = (key, expirationSeconds = 60, config = defaultS3Bucket, verb = "GET", additionalHeaders = {}, additionalQueryParams = {}) => {
  const credentials2 = config.accessKeyID && config.accessKeySecret ? {
    accessKeyId: config.accessKeyID,
    secretAccessKey: config.accessKeySecret
  } : getCredentials();
  let now = dayjs2().utc();
  if (expirationSeconds > 2 * 60) {
    now = now.second(0);
  }
  if (expirationSeconds > 2 * 60 * 60) {
    now = now.minute(0);
  }
  const time = now.format("YYYYMMDD[T]HHmmss[Z]");
  const date = now.format("YYYYMMDD");
  const s3Endpoint = S3_ENDPOINT.replace("<REGION>", config.region);
  const path2 = "/" + encodeRFC3986URIComponent(config.bucket) + "/" + key.split("/").map(encodeRFC3986URIComponent).join("/");
  const host = new URL(s3Endpoint).host;
  const headers = {
    host,
    ...additionalHeaders
  };
  const signedHeaders = Object.keys(headers).map((header) => header.toLowerCase()).sort().join(";");
  const credential = [
    credentials2.accessKeyId,
    date,
    config.region,
    "s3",
    "aws4_request"
  ].join("/");
  const query = {
    "X-Amz-Algorithm": "AWS4-HMAC-SHA256",
    "X-Amz-Credential": credential,
    "X-Amz-Date": time,
    "X-Amz-Expires": `${expirationSeconds}`,
    "X-Amz-SignedHeaders": signedHeaders,
    ...additionalQueryParams
  };
  if (credentials2.sessionToken) {
    query["X-Amz-Security-Token"] = credentials2.sessionToken;
  }
  const canonicalQueryString = sortedEntries(query).map(
    // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
    ([key2, value]) => `${encodeRFC3986URIComponent(key2)}=${encodeRFC3986URIComponent(value)}`
  ).join("&");
  const canonicalHeaders = sortedEntries(headers).map(([key2, value]) => `${key2.toLowerCase()}:${value.trim()}
`).join("");
  const canonicalRequestString = [
    verb,
    path2,
    canonicalQueryString,
    canonicalHeaders,
    signedHeaders,
    "UNSIGNED-PAYLOAD"
  ].join("\n");
  const stringToSign = [
    "AWS4-HMAC-SHA256",
    time,
    [date, config.region, "s3", "aws4_request"].join("/"),
    sha256(canonicalRequestString).toString("hex")
  ].join("\n");
  const dateKey = hmac256(date, "AWS4" + credentials2.secretAccessKey);
  const regionKey = hmac256(config.region, dateKey);
  const serviceKey = hmac256("s3", regionKey);
  const signingKey = hmac256("aws4_request", serviceKey);
  const signature = hmac256(stringToSign, signingKey).toString("hex");
  return `${s3Endpoint}${path2}?${canonicalQueryString}&X-Amz-Signature=${signature}`;
};
function encodeRFC3986URIComponent(str) {
  return encodeURIComponent(str).replace(
    /[!'()*]/g,
    (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`
  );
}

// server/src/entity/s3_bucket/S3BucketLoader.ts
import DataLoader from "dataloader";

// server/src/entity/s3_bucket/S3BucketEntity.ts
import * as crypto3 from "crypto";
import { Table as Table10, Column as Column10, Model as Model10 } from "sequelize-typescript";
import { DataTypes as DataTypes10 } from "sequelize";
var S3BucketEntity = class extends Model10 {
  // encrypted
  getS3BucketConfig_DO_NOT_EXPOSE_TO_CLIENT() {
    const [encrypted, authTag, iv] = this.accessKeySecret.split(":");
    const decipher = crypto3.createDecipheriv(
      "aes-256-gcm",
      Env_default.PLATFORM_SECRETS_ENCRYPTION_KEY,
      Buffer.from(iv, "hex")
    );
    decipher.setAuthTag(Buffer.from(authTag, "hex"));
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final();
    return {
      bucket: this.name,
      region: this.region,
      accessKeyID: this.accessKeyID,
      accessKeySecret: decrypted
    };
  }
};
__decorateClass([
  Column10({
    type: DataTypes10.UUID,
    allowNull: false,
    primaryKey: true,
    defaultValue: DataTypes10.UUIDV4
  })
], S3BucketEntity.prototype, "id", 2);
__decorateClass([
  Column10({
    type: DataTypes10.TEXT,
    allowNull: false
  })
], S3BucketEntity.prototype, "name", 2);
__decorateClass([
  Column10({
    type: DataTypes10.TEXT,
    allowNull: false
  })
], S3BucketEntity.prototype, "region", 2);
__decorateClass([
  Column10({
    type: DataTypes10.TEXT,
    allowNull: false
  })
], S3BucketEntity.prototype, "accessKeyID", 2);
__decorateClass([
  Column10({
    type: DataTypes10.TEXT,
    allowNull: false
  })
], S3BucketEntity.prototype, "accessKeySecret", 2);
S3BucketEntity = __decorateClass([
  Table10({
    tableName: "s3_buckets",
    timestamps: false
  })
], S3BucketEntity);

// server/src/entity/base/util.ts
function indexedMap(entities, f) {
  const m = /* @__PURE__ */ new Map();
  entities.forEach((e) => m.set(f(e), e));
  return m;
}
function indexedMapGrouped(entities, f) {
  const m = /* @__PURE__ */ new Map();
  entities.forEach((e) => {
    const k = f(e);
    let values = m.get(k);
    if (values === void 0) {
      values = [];
      m.set(k, values);
    }
    values.push(e);
  });
  return m;
}
function inKeyOrder(entities, keys) {
  return inKeyOrderCustom(entities, keys, (e) => e.id);
}
function inKeyOrderCustom(entities, keys, f) {
  const m = indexedMap(entities, f);
  return keys.map((k) => m.get(k) ?? null);
}
function inKeyOrderOrNull(entities, keys) {
  return inKeyOrderOrNullCustom(entities, keys, (e) => e.id);
}
function inKeyOrderOrNullCustom(entities, keys, f) {
  const m = indexedMap(entities, f);
  return keys.map((k) => m.get(k) ?? null);
}
function inKeyOrderGroupedCustom(entities, keys, f) {
  const m = indexedMapGrouped(entities, f);
  return keys.map((k) => m.get(k) ?? []);
}

// server/src/entity/s3_bucket/S3BucketLoader.ts
var S3BucketLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader(
      async (keys) => {
        const buckets = await S3BucketEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrder(buckets, keys);
      },
      { cache: false }
    );
  }
  async load(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("S3Bucket dataloader error", e);
      return null;
    }
  }
  async loadAll() {
    return await S3BucketEntity.findAll();
  }
  async loadForApplication(application) {
    if (application.customS3Bucket) {
      return await this.load(application.customS3Bucket);
    } else {
      return null;
    }
  }
};

// server/src/files/download.ts
import * as crypto4 from "crypto";
function encodeFileProxyToken(payload) {
  const data = JSON.stringify({
    ...payload,
    time: Date.now()
  });
  const iv = crypto4.randomBytes(12);
  const cipher = crypto4.createCipheriv(
    "aes-256-gcm",
    Env_default.FILE_PROXY_SIGNING_SECRET_KEY,
    iv
  );
  const encrypted = Buffer.concat([
    cipher.update(data, "utf8"),
    cipher.final()
  ]);
  const authTag = cipher.getAuthTag();
  return [
    "v1",
    encrypted.toString("hex"),
    authTag.toString("hex"),
    iv.toString("hex")
  ].join(":");
}
function decodeFileProxyToken(token) {
  const [_version, encrypted, authTag, iv] = token.split(":");
  const decipher = crypto4.createDecipheriv(
    "aes-256-gcm",
    Env_default.FILE_PROXY_SIGNING_SECRET_KEY,
    Buffer.from(iv, "hex")
  );
  decipher.setAuthTag(Buffer.from(authTag, "hex"));
  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final();
  return JSON.parse(decrypted);
}

// server/src/entity/file/FileEntity.ts
var FileEntity = class extends Model11 {
  // URL that points to S3, expires after 24 hours
  async getSignedDownloadURL(s3BucketLoader = new S3BucketLoader(
    Viewer.createAnonymousViewer()
  )) {
    const s3Bucket = this.s3Bucket ? await s3BucketLoader.load(this.s3Bucket) : void 0;
    return getSignedDownloadURL(
      this.id,
      this.name,
      s3Bucket?.getS3BucketConfig_DO_NOT_EXPOSE_TO_CLIENT()
    );
  }
  // URL that points to our FileProxyHandler, never expires
  getPermanentDownloadURL() {
    return `${API_ORIGIN}/file?token=${encodeURIComponent(
      encodeFileProxyToken({
        id: this.id
      })
    )}`;
  }
  async getSignedUploadURL(s3BucketLoader = new S3BucketLoader(
    Viewer.createAnonymousViewer()
  )) {
    const s3Bucket = this.s3Bucket ? await s3BucketLoader.load(this.s3Bucket) : void 0;
    return getSignedUploadURL(
      this.id,
      this.size,
      this.mimeType,
      s3Bucket?.getS3BucketConfig_DO_NOT_EXPOSE_TO_CLIENT()
    );
  }
  async getDeleteURL(s3BucketLoader = new S3BucketLoader(
    Viewer.createAnonymousViewer()
  )) {
    const s3Bucket = this.s3Bucket ? await s3BucketLoader.load(this.s3Bucket) : void 0;
    return getSignedDeleteURL(
      this.id,
      s3Bucket?.getS3BucketConfig_DO_NOT_EXPOSE_TO_CLIENT()
    );
  }
};
__decorateClass([
  PrimaryKey5,
  Column11({
    defaultValue: DataTypes11.UUIDV4,
    type: DataTypes11.UUID
  })
], FileEntity.prototype, "id", 2);
__decorateClass([
  Column11({
    type: DataTypes11.UUID
  })
], FileEntity.prototype, "userID", 2);
__decorateClass([
  Column11({
    type: DataTypes11.UUID,
    allowNull: false
  })
], FileEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column11({
    type: DataTypes11.STRING
  })
], FileEntity.prototype, "name", 2);
__decorateClass([
  Column11({
    type: DataTypes11.STRING
  })
], FileEntity.prototype, "mimeType", 2);
__decorateClass([
  Column11({
    type: DataTypes11.INTEGER
  })
], FileEntity.prototype, "size", 2);
__decorateClass([
  Column11({
    type: DataTypes11.TIME
  })
], FileEntity.prototype, "timestamp", 2);
__decorateClass([
  Column11({
    type: DataTypes11.STRING
  })
], FileEntity.prototype, "uploadStatus", 2);
__decorateClass([
  Column11({
    type: DataTypes11.UUID
  })
], FileEntity.prototype, "s3Bucket", 2);
FileEntity = __decorateClass([
  Table11({
    tableName: "files",
    timestamps: false
  })
], FileEntity);

// server/src/entity/message_attachment/MessageAttachmentEntity.ts
import { Table as Table12, Column as Column12, PrimaryKey as PrimaryKey6, Model as Model12 } from "sequelize-typescript";
import { DataTypes as DataTypes12 } from "sequelize";
var MessageAttachmentEntity = class extends Model12 {
  getFileIDs() {
    switch (this.type) {
      case "file" /* FILE */:
        return [this.data.fileID];
      case "annotation" /* ANNOTATION */: {
        const data = this.data;
        return [data.blurredScreenshotFileID, data.screenshotFileID].filter(
          isDefined
        );
      }
      case "screenshot" /* SCREENSHOT */: {
        const data = this.data;
        return [data.blurredScreenshotFileID, data.screenshotFileID].filter(
          isDefined
        );
      }
      default:
        return [];
    }
  }
};
__decorateClass([
  PrimaryKey6,
  Column12({
    defaultValue: DataTypes12.UUIDV4,
    type: DataTypes12.UUID
  })
], MessageAttachmentEntity.prototype, "id", 2);
__decorateClass([
  Column12({
    type: DataTypes12.UUID
  })
], MessageAttachmentEntity.prototype, "messageID", 2);
__decorateClass([
  Column12({
    type: DataTypes12.STRING
  })
], MessageAttachmentEntity.prototype, "type", 2);
__decorateClass([
  Column12({
    defaultValue: {},
    type: DataTypes12.JSONB
  })
], MessageAttachmentEntity.prototype, "data", 2);
__decorateClass([
  Column12({
    type: DataTypes12.TIME
  })
], MessageAttachmentEntity.prototype, "timestamp", 2);
MessageAttachmentEntity = __decorateClass([
  Table12({
    tableName: "message_attachments",
    timestamps: false
  })
], MessageAttachmentEntity);

// server/src/entity/message_reaction/MessageReactionEntity.ts
import { Table as Table13, Column as Column13, PrimaryKey as PrimaryKey7, Model as Model13 } from "sequelize-typescript";
import { DataTypes as DataTypes13 } from "sequelize";
var REACTION_MAX_LENGTH = 127;
var MessageReactionEntity = class extends Model13 {
};
__decorateClass([
  PrimaryKey7,
  Column13({
    type: DataTypes13.UUID,
    defaultValue: DataTypes13.UUIDV4
  })
], MessageReactionEntity.prototype, "id", 2);
__decorateClass([
  Column13({
    type: DataTypes13.UUID
  })
], MessageReactionEntity.prototype, "userID", 2);
__decorateClass([
  Column13({
    type: DataTypes13.UUID
  })
], MessageReactionEntity.prototype, "messageID", 2);
__decorateClass([
  Column13({
    type: DataTypes13.TEXT,
    validate: {
      len: [1, REACTION_MAX_LENGTH]
    }
  })
], MessageReactionEntity.prototype, "unicodeReaction", 2);
__decorateClass([
  Column13({
    type: DataTypes13.TIME
  })
], MessageReactionEntity.prototype, "timestamp", 2);
MessageReactionEntity = __decorateClass([
  Table13({
    tableName: "message_reactions",
    timestamps: false
  })
], MessageReactionEntity);

// server/src/entity/message_mention/MessageMentionEntity.ts
import { Table as Table14, Column as Column14, Model as Model14 } from "sequelize-typescript";
import { DataTypes as DataTypes14 } from "sequelize";
var MessageMentionEntity = class extends Model14 {
};
__decorateClass([
  Column14({
    type: DataTypes14.UUID,
    primaryKey: true
  })
], MessageMentionEntity.prototype, "userID", 2);
__decorateClass([
  Column14({
    type: DataTypes14.UUID,
    primaryKey: true
  })
], MessageMentionEntity.prototype, "messageID", 2);
__decorateClass([
  Column14({
    type: DataTypes14.TIME
  })
], MessageMentionEntity.prototype, "timestamp", 2);
MessageMentionEntity = __decorateClass([
  Table14({
    tableName: "message_mentions",
    timestamps: false
  })
], MessageMentionEntity);

// server/src/entity/slack_channel/SlackChannelEntity.ts
import { Table as Table15, Column as Column15, Model as Model15 } from "sequelize-typescript";
import { DataTypes as DataTypes15 } from "sequelize";
var SlackChannelEntity = class extends Model15 {
};
__decorateClass([
  Column15({
    type: DataTypes15.UUID,
    primaryKey: true
  })
], SlackChannelEntity.prototype, "orgID", 2);
__decorateClass([
  Column15({
    type: DataTypes15.TEXT,
    primaryKey: true
  })
], SlackChannelEntity.prototype, "slackID", 2);
__decorateClass([
  Column15({
    type: DataTypes15.TEXT,
    allowNull: false
  })
], SlackChannelEntity.prototype, "name", 2);
__decorateClass([
  Column15({
    type: DataTypes15.BOOLEAN
  })
], SlackChannelEntity.prototype, "added", 2);
__decorateClass([
  Column15({
    type: DataTypes15.BOOLEAN
  })
], SlackChannelEntity.prototype, "archived", 2);
__decorateClass([
  Column15({
    type: DataTypes15.NUMBER,
    allowNull: false
  })
], SlackChannelEntity.prototype, "users", 2);
SlackChannelEntity = __decorateClass([
  Table15({
    tableName: "slack_channels",
    timestamps: false
  })
], SlackChannelEntity);

// server/src/entity/slack_message/SlackMessageEntity.ts
import { Table as Table16, Column as Column16, Model as Model16 } from "sequelize-typescript";
import { DataTypes as DataTypes16 } from "sequelize";
var SlackMessageEntity = class extends Model16 {
};
__decorateClass([
  Column16({
    type: DataTypes16.UUID
  })
], SlackMessageEntity.prototype, "slackOrgID", 2);
__decorateClass([
  Column16({
    type: DataTypes16.TEXT,
    primaryKey: true
  })
], SlackMessageEntity.prototype, "slackChannelID", 2);
__decorateClass([
  Column16({
    type: DataTypes16.TEXT,
    primaryKey: true
  })
], SlackMessageEntity.prototype, "slackMessageTimestamp", 2);
__decorateClass([
  Column16({
    type: DataTypes16.UUID
  })
], SlackMessageEntity.prototype, "messageID", 2);
__decorateClass([
  Column16({
    type: DataTypes16.UUID
  })
], SlackMessageEntity.prototype, "sharerOrgID", 2);
__decorateClass([
  Column16({
    type: DataTypes16.UUID
  })
], SlackMessageEntity.prototype, "sharerUserID", 2);
__decorateClass([
  Column16({
    type: DataTypes16.TIME
  })
], SlackMessageEntity.prototype, "timestamp", 2);
SlackMessageEntity = __decorateClass([
  Table16({
    tableName: "slack_messages",
    timestamps: false
  })
], SlackMessageEntity);

// server/src/entity/user_preference/UserPreferenceEntity.ts
import { Table as Table17, Column as Column17, Model as Model17 } from "sequelize-typescript";
import { DataTypes as DataTypes17 } from "sequelize";
var UserPreferenceEntity = class extends Model17 {
};
__decorateClass([
  Column17({
    type: DataTypes17.UUID,
    primaryKey: true
  })
], UserPreferenceEntity.prototype, "userID", 2);
__decorateClass([
  Column17({
    type: DataTypes17.TEXT,
    primaryKey: true
  })
], UserPreferenceEntity.prototype, "key", 2);
__decorateClass([
  Column17({
    type: DataTypes17.JSONB
  })
], UserPreferenceEntity.prototype, "value", 2);
UserPreferenceEntity = __decorateClass([
  Table17({
    tableName: "user_preferences",
    timestamps: false
  })
], UserPreferenceEntity);

// server/src/entity/task/TaskEntity.ts
import { Table as Table18, Column as Column18, Model as Model18, PrimaryKey as PrimaryKey8 } from "sequelize-typescript";
import { DataTypes as DataTypes18 } from "sequelize";
var TaskEntity = class extends Model18 {
};
__decorateClass([
  PrimaryKey8,
  Column18({
    defaultValue: DataTypes18.UUIDV4,
    type: DataTypes18.UUID,
    primaryKey: true
  })
], TaskEntity.prototype, "id", 2);
__decorateClass([
  Column18({
    type: DataTypes18.UUID
  })
], TaskEntity.prototype, "messageID", 2);
__decorateClass([
  Column18({
    type: DataTypes18.UUID
  })
], TaskEntity.prototype, "orgID", 2);
__decorateClass([
  Column18({
    type: DataTypes18.BOOLEAN
  })
], TaskEntity.prototype, "done", 2);
__decorateClass([
  Column18({
    type: DataTypes18.UUID
  })
], TaskEntity.prototype, "doneStatusLastUpdatedBy", 2);
__decorateClass([
  Column18({
    type: DataTypes18.TIME
  })
], TaskEntity.prototype, "timestamp", 2);
TaskEntity = __decorateClass([
  Table18({
    tableName: "tasks",
    timestamps: false
  })
], TaskEntity);

// server/src/entity/task_todo/TaskTodoEntity.ts
import { Table as Table19, Column as Column19, Model as Model19, PrimaryKey as PrimaryKey9 } from "sequelize-typescript";
import { DataTypes as DataTypes19 } from "sequelize";
var TaskTodoEntity = class extends Model19 {
};
__decorateClass([
  PrimaryKey9,
  Column19({
    defaultValue: DataTypes19.UUIDV4,
    type: DataTypes19.UUID,
    primaryKey: true
  })
], TaskTodoEntity.prototype, "id", 2);
__decorateClass([
  Column19({
    type: DataTypes19.UUID
  })
], TaskTodoEntity.prototype, "taskID", 2);
__decorateClass([
  Column19({
    type: DataTypes19.UUID
  })
], TaskTodoEntity.prototype, "orgID", 2);
__decorateClass([
  Column19({
    type: DataTypes19.BOOLEAN
  })
], TaskTodoEntity.prototype, "done", 2);
__decorateClass([
  Column19({
    type: DataTypes19.TIME
  })
], TaskTodoEntity.prototype, "timestamp", 2);
TaskTodoEntity = __decorateClass([
  Table19({
    tableName: "task_todos",
    timestamps: false
  })
], TaskTodoEntity);

// server/src/entity/task_assignee/TaskAssigneeEntity.ts
import { Table as Table20, Column as Column20, Model as Model20 } from "sequelize-typescript";
import { DataTypes as DataTypes20 } from "sequelize";
var TaskAssigneeEntity = class extends Model20 {
};
__decorateClass([
  Column20({
    type: DataTypes20.UUID,
    primaryKey: true
  })
], TaskAssigneeEntity.prototype, "taskID", 2);
__decorateClass([
  Column20({
    type: DataTypes20.UUID,
    primaryKey: true
  })
], TaskAssigneeEntity.prototype, "userID", 2);
__decorateClass([
  Column20({
    type: DataTypes20.UUID
  })
], TaskAssigneeEntity.prototype, "orgID", 2);
__decorateClass([
  Column20({
    type: DataTypes20.UUID
  })
], TaskAssigneeEntity.prototype, "assignerID", 2);
__decorateClass([
  Column20({
    type: DataTypes20.TIME
  })
], TaskAssigneeEntity.prototype, "timestamp", 2);
TaskAssigneeEntity = __decorateClass([
  Table20({
    tableName: "task_assignees",
    timestamps: false
  })
], TaskAssigneeEntity);

// server/src/entity/third_party_connection/ThirdPartyConnectionEntity.ts
import { Table as Table21, Column as Column21, Model as Model21 } from "sequelize-typescript";
import { DataTypes as DataTypes22 } from "sequelize";

// server/src/entity/common.ts
import { DataTypes as DataTypes21, Sequelize as Sequelize2 } from "sequelize";
var ThirdPartyConnectionDataType = DataTypes21.ENUM(
  "asana",
  "jira",
  "linear"
);
var MAX_IDS_PER_QUERY = 1e3;
function keyFor(userOrgID) {
  return `${userOrgID.userID}/${userOrgID.orgID}`;
}
function keyForPlatformID(platformID) {
  return `${platformID.platformApplicationID}/${platformID.externalID}`;
}
var timestampSubquery = (id) => Sequelize2.literal(
  `(
      SELECT "timestamp"
      FROM "${MessageEntity.tableName}"
      WHERE "id" = '${assertUUID(id)}'
    )`
);

// server/src/entity/third_party_connection/ThirdPartyConnectionEntity.ts
var ThirdPartyConnectionEntity = class extends Model21 {
};
__decorateClass([
  Column21({ type: DataTypes22.UUID, primaryKey: true })
], ThirdPartyConnectionEntity.prototype, "userID", 2);
__decorateClass([
  Column21({ type: DataTypes22.UUID, primaryKey: true })
], ThirdPartyConnectionEntity.prototype, "orgID", 2);
__decorateClass([
  Column21({ type: ThirdPartyConnectionDataType, primaryKey: true })
], ThirdPartyConnectionEntity.prototype, "type", 2);
__decorateClass([
  Column21({ type: DataTypes22.TEXT })
], ThirdPartyConnectionEntity.prototype, "externalID", 2);
__decorateClass([
  Column21({ type: DataTypes22.TEXT })
], ThirdPartyConnectionEntity.prototype, "externalEmail", 2);
__decorateClass([
  Column21({ type: DataTypes22.JSONB })
], ThirdPartyConnectionEntity.prototype, "externalAuthData", 2);
__decorateClass([
  Column21({ type: DataTypes22.TIME })
], ThirdPartyConnectionEntity.prototype, "connectedTimestamp", 2);
ThirdPartyConnectionEntity = __decorateClass([
  Table21({
    tableName: "third_party_connections",
    timestamps: false
  })
], ThirdPartyConnectionEntity);

// server/src/entity/task_third_party_reference/TaskThirdPartyReferenceEntity.ts
import { Table as Table22, Column as Column22, Model as Model22 } from "sequelize-typescript";
import { DataTypes as DataTypes23, Op } from "sequelize";
var TaskThirdPartyReference = class extends Model22 {
  static async findForTask(taskID, externalConnectionType) {
    return await TaskThirdPartyReference.findOne({
      where: {
        taskID,
        taskTodoID: null,
        externalConnectionType
      }
    });
  }
  static async findAllForTask(taskID) {
    return await TaskThirdPartyReference.findAll({
      where: {
        taskID,
        taskTodoID: { [Op.is]: null }
      }
    });
  }
  static async findAllForTaskTodos(taskID, taskTodoIDs) {
    return await TaskThirdPartyReference.findAll({
      where: {
        taskID,
        taskTodoID: taskTodoIDs
      }
    });
  }
  static async findTaskWithExternalID(externalID, externalConnectionType) {
    return await TaskThirdPartyReference.findOne({
      where: {
        externalID,
        externalConnectionType,
        taskTodoID: { [Op.is]: null }
      }
    });
  }
};
__decorateClass([
  Column22({ type: DataTypes23.UUID, primaryKey: true })
], TaskThirdPartyReference.prototype, "taskID", 2);
__decorateClass([
  Column22({ type: DataTypes23.UUID })
], TaskThirdPartyReference.prototype, "taskTodoID", 2);
__decorateClass([
  Column22({ type: DataTypes23.TEXT, primaryKey: true })
], TaskThirdPartyReference.prototype, "externalID", 2);
__decorateClass([
  Column22({ type: ThirdPartyConnectionDataType, primaryKey: true })
], TaskThirdPartyReference.prototype, "externalConnectionType", 2);
__decorateClass([
  Column22({ type: DataTypes23.TEXT })
], TaskThirdPartyReference.prototype, "externalLocationID", 2);
__decorateClass([
  Column22({ type: DataTypes23.JSONB })
], TaskThirdPartyReference.prototype, "previewData", 2);
__decorateClass([
  Column22({ type: DataTypes23.BOOLEAN })
], TaskThirdPartyReference.prototype, "imported", 2);
TaskThirdPartyReference = __decorateClass([
  Table22({
    tableName: "task_third_party_references",
    timestamps: false
  })
], TaskThirdPartyReference);

// server/src/entity/page/PageEntity.ts
import { Table as Table23, Column as Column23, Model as Model23 } from "sequelize-typescript";
import { DataTypes as DataTypes24 } from "sequelize";
var PageEntity = class extends Model23 {
  get pageContext() {
    return {
      data: this.contextData,
      providerID: null
    };
  }
};
__decorateClass([
  Column23({
    type: DataTypes24.UUID,
    allowNull: false,
    primaryKey: true,
    unique: "orgID-providerID-contextHash-unique"
  })
], PageEntity.prototype, "orgID", 2);
__decorateClass([
  Column23({
    type: DataTypes24.UUID,
    allowNull: false,
    primaryKey: true,
    unique: "orgID-providerID-contextHash-unique"
  })
], PageEntity.prototype, "contextHash", 2);
__decorateClass([
  Column23({
    type: DataTypes24.JSONB,
    allowNull: false
  })
], PageEntity.prototype, "contextData", 2);
PageEntity = __decorateClass([
  Table23({
    tableName: "pages",
    timestamps: false
  })
], PageEntity);

// server/src/entity/thread/ThreadEntity.ts
import { Table as Table24, Column as Column24, Model as Model24 } from "sequelize-typescript";
import { DataTypes as DataTypes25, Sequelize as Sequelize3 } from "sequelize";

// server/src/entity/org_members/OrgMembersLoader.ts
import DataLoader3 from "dataloader";

// server/src/entity/org/OrgLoader.ts
import { Op as Op2 } from "sequelize";
import DataLoader2 from "dataloader";
var OrgLoader = class {
  constructor(viewer, cache2 = false) {
    this.viewer = viewer;
    this.platformOrgDataloader = new DataLoader2(
      async (keys) => {
        const orgsByApplication = /* @__PURE__ */ new Map();
        for (const key of keys) {
          if (!orgsByApplication.has(key.platformApplicationID)) {
            orgsByApplication.set(key.platformApplicationID, /* @__PURE__ */ new Set());
          }
          orgsByApplication.get(key.platformApplicationID).add(key.externalID);
        }
        const promises = [];
        for (const [platformApplicationID, orgIDSet] of orgsByApplication) {
          const externalOrgIDs = [...orgIDSet];
          for (let offset = 0; offset < externalOrgIDs.length; offset += MAX_IDS_PER_QUERY) {
            promises.push(
              OrgEntity.findAll({
                where: {
                  externalProvider: "platform" /* PLATFORM */,
                  platformApplicationID,
                  externalID: externalOrgIDs.slice(
                    offset,
                    offset + MAX_IDS_PER_QUERY
                  )
                }
              })
            );
          }
        }
        const orgs = (await Promise.all(promises)).flat();
        const index = /* @__PURE__ */ new Map();
        for (const org of orgs) {
          index.set(
            keyForPlatformID({
              platformApplicationID: org.platformApplicationID,
              externalID: org.externalID
            }),
            org
          );
        }
        return keys.map(
          (platformId) => index.get(keyForPlatformID(platformId)) ?? null
        );
      },
      { cache: cache2 }
    );
    this.orgByIdDataloader = new DataLoader2(
      async (keys) => {
        const orgs = await OrgEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrderOrNull(orgs, keys);
      },
      { cache: cache2 }
    );
  }
  async loadOrg(id) {
    return await this.orgByIdDataloader.load(id);
  }
  async loadSlackOrg(slackTeamID, slackAppID) {
    const customSlackAppID = CORD_SLACK_APP_IDS.includes(slackAppID) ? null : slackAppID;
    return await OrgEntity.findOne({
      where: {
        externalProvider: "slack" /* SLACK */,
        externalID: slackTeamID,
        customSlackAppID,
        // Technically redundant, but allows postgres to use an index.
        platformApplicationID: null
      }
    });
  }
  async loadPlatformOrg(platformApplicationID, externalOrgID) {
    return await this.platformOrgDataloader.load({
      platformApplicationID,
      externalID: externalOrgID
    });
  }
  async loadByDomain(externalProvider, domain) {
    return await OrgEntity.findOne({
      where: { externalProvider, domain }
    });
  }
  async loadAllActiveSlackOrgs() {
    return await OrgEntity.findAll({
      where: {
        state: "active",
        externalProvider: "slack" /* SLACK */,
        externalAuthData: { [Op2.ne]: null }
      }
    });
  }
};

// server/src/entity/org_members/OrgMembersLoader.ts
var OrgMembersLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader3(
      async (keys) => await this.loadBatch(keys),
      { cache: false }
    );
  }
  async loadBatch(keys, transaction) {
    const usersByOrg = /* @__PURE__ */ new Map();
    const orgsByUser = /* @__PURE__ */ new Map();
    for (const key of keys) {
      if (!usersByOrg.has(key.orgID)) {
        usersByOrg.set(key.orgID, /* @__PURE__ */ new Set());
      }
      usersByOrg.get(key.orgID).add(key.userID);
      if (!orgsByUser.has(key.userID)) {
        orgsByUser.set(key.userID, /* @__PURE__ */ new Set());
      }
      orgsByUser.get(key.userID).add(key.orgID);
    }
    const promises = [];
    if (usersByOrg.size < orgsByUser.size) {
      for (const [orgID, userIDSet] of usersByOrg) {
        const userIDs = [...userIDSet];
        for (let offset = 0; offset < userIDs.length; offset += MAX_IDS_PER_QUERY) {
          promises.push(
            OrgMembersEntity.findAll({
              where: {
                orgID,
                userID: userIDs.slice(offset, offset + MAX_IDS_PER_QUERY)
              },
              transaction
            })
          );
        }
      }
    } else {
      for (const [userID, orgIDSet] of orgsByUser) {
        const orgIDs = [...orgIDSet];
        for (let offset = 0; offset < orgIDs.length; offset += MAX_IDS_PER_QUERY) {
          promises.push(
            OrgMembersEntity.findAll({
              where: {
                userID,
                orgID: orgIDs.slice(offset, offset + MAX_IDS_PER_QUERY)
              },
              transaction
            })
          );
        }
      }
    }
    const orgMembers = (await Promise.all(promises)).flat();
    const index = /* @__PURE__ */ new Map();
    for (const orgMember of orgMembers) {
      index.set(
        keyFor({ userID: orgMember.userID, orgID: orgMember.orgID }),
        orgMember
      );
    }
    return keys.map((userOrgId) => index.get(keyFor(userOrgId)) ?? null);
  }
  async loadUserOrgMembership(userID, orgID, transaction) {
    try {
      const key = { userID, orgID };
      if (transaction) {
        return (await this.loadBatch([key], transaction))[0];
      } else {
        return await this.dataloader.load(key);
      }
    } catch (e) {
      anonymousLogger().logException("Org members dataloader error", e);
      return null;
    }
  }
  async viewerCanAccessOrg(orgID, transaction) {
    if ((this.viewer.relevantOrgIDs ?? []).includes(orgID)) {
      return true;
    }
    const userID = assertViewerHasUser(this.viewer);
    const membership = await this.loadUserOrgMembership(
      userID,
      orgID,
      transaction
    );
    return !!membership;
  }
  async viewerCanAccessOrgExternalID(externalOrgID) {
    const userID = assertViewerHasUser(this.viewer);
    const platformApplicationID = assertViewerHasPlatformApplicationID(
      this.viewer
    );
    const orgLoader = new OrgLoader(this.viewer);
    const org = await orgLoader.loadPlatformOrg(
      platformApplicationID,
      externalOrgID
    );
    if (!org) {
      return false;
    }
    const membership = await this.loadUserOrgMembership(userID, org.id);
    return !!membership;
  }
  // I.e. all orgs they are literally a member of, but not Slack connected orgs
  async loadAllImmediateOrgIDsForUser() {
    const entities = await OrgMembersEntity.findAll({
      where: {
        userID: this.viewer.userID
      },
      raw: true
    });
    return entities.map((e) => e.orgID);
  }
  // I.e. all orgs they are literally a member of, but not Slack connected orgs
  async loadAllImmediateOrgsForUser() {
    const orgIds = await this.loadAllImmediateOrgIDsForUser();
    return await OrgEntity.findAll({
      where: {
        id: orgIds
      }
    });
  }
  async loadAllOrgIDsForUser() {
    const platformOrgIDs = await this.loadAllImmediateOrgIDsForUser();
    const slackOrgs = await LinkedOrgsEntity.findAll({
      where: {
        sourceOrgID: platformOrgIDs
      }
    });
    const slackOrgsIDs = slackOrgs.map((e) => e.linkedOrgID);
    return [...platformOrgIDs, ...slackOrgsIDs];
  }
  // Use this function if you want to load orgMembership for a user that might
  // not exist in a specified platform org but might exist in the Slack org linked
  // to that specified platform org.
  async loadForSpecifiedPlatformOrgOrLinkedSlackOrg(context, userID, orgID) {
    const orgMembership = await this.loadUserOrgMembership(userID, orgID);
    if (orgMembership) {
      return orgMembership;
    }
    const linkedOrgID = await context.loaders.linkedOrgsLoader.getConnectedSlackOrgID(orgID);
    if (!linkedOrgID) {
      return null;
    }
    return await this.loadUserOrgMembership(userID, linkedOrgID);
  }
  async loadNotifiableOrgMembers(limit) {
    const orgID = assertViewerHasOrg(this.viewer);
    return await OrgMembersEntity.findAll({
      where: {
        orgID
      },
      include: [
        {
          model: UserEntity,
          required: true,
          where: { userType: "person" },
          // dont bother fetching UserEntity attributes
          attributes: []
        }
      ],
      limit
    });
  }
};

// server/src/entity/thread/ThreadEntity.ts
var ThreadEntity = class extends Model24 {
  async belongsToViewerOrgs(viewer) {
    const { orgID } = assertViewerHasIdentity(viewer);
    if (this.orgID === orgID) {
      return true;
    }
    const orgMembersLoader = new OrgMembersLoader(viewer);
    return await orgMembersLoader.viewerCanAccessOrg(this.orgID);
  }
};
__decorateClass([
  Column24({
    type: DataTypes25.UUID,
    allowNull: false,
    primaryKey: true
  })
], ThreadEntity.prototype, "id", 2);
__decorateClass([
  Column24({
    type: DataTypes25.UUID,
    allowNull: false
  })
], ThreadEntity.prototype, "orgID", 2);
__decorateClass([
  Column24({
    type: DataTypes25.TEXT
  })
], ThreadEntity.prototype, "name", 2);
__decorateClass([
  Column24({
    type: DataTypes25.TIME
  })
], ThreadEntity.prototype, "resolvedTimestamp", 2);
__decorateClass([
  Column24({
    type: DataTypes25.UUID
  })
], ThreadEntity.prototype, "resolverUserID", 2);
__decorateClass([
  Column24({
    type: DataTypes25.TEXT,
    allowNull: false
  })
], ThreadEntity.prototype, "url", 2);
__decorateClass([
  Column24({
    type: DataTypes25.ENUM("open", "closed"),
    defaultValue: null
  })
], ThreadEntity.prototype, "supportStatus", 2);
__decorateClass([
  Column24({
    type: DataTypes25.TEXT
  })
], ThreadEntity.prototype, "externalID", 2);
__decorateClass([
  Column24({
    type: DataTypes25.UUID,
    allowNull: false
  })
], ThreadEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column24({
    type: DataTypes25.UUID,
    allowNull: false
  })
], ThreadEntity.prototype, "pageContextHash", 2);
__decorateClass([
  Column24({
    type: DataTypes25.TIME,
    allowNull: false,
    defaultValue: Sequelize3.literal("NOW()")
  })
], ThreadEntity.prototype, "createdTimestamp", 2);
__decorateClass([
  Column24({
    type: DataTypes25.JSONB,
    allowNull: false,
    defaultValue: {}
  })
], ThreadEntity.prototype, "metadata", 2);
__decorateClass([
  Column24({
    type: DataTypes25.TEXT
  })
], ThreadEntity.prototype, "extraClassnames", 2);
ThreadEntity = __decorateClass([
  Table24({
    tableName: "threads",
    timestamps: false
  })
], ThreadEntity);

// server/src/entity/thread_participant/ThreadParticipantEntity.ts
import { Table as Table25, Column as Column25, Model as Model25 } from "sequelize-typescript";
import { DataTypes as DataTypes26 } from "sequelize";
var ThreadParticipantEntity = class extends Model25 {
};
__decorateClass([
  Column25({
    type: DataTypes26.UUID,
    allowNull: false,
    primaryKey: true
  })
], ThreadParticipantEntity.prototype, "threadID", 2);
__decorateClass([
  Column25({
    type: DataTypes26.UUID,
    allowNull: false,
    primaryKey: true
  })
], ThreadParticipantEntity.prototype, "userID", 2);
__decorateClass([
  Column25({
    type: DataTypes26.UUID,
    allowNull: false,
    primaryKey: true
  })
], ThreadParticipantEntity.prototype, "orgID", 2);
__decorateClass([
  Column25({
    type: DataTypes26.TIME
  })
], ThreadParticipantEntity.prototype, "lastSeenTimestamp", 2);
__decorateClass([
  Column25({
    type: DataTypes26.TIME
  })
], ThreadParticipantEntity.prototype, "lastUnseenMessageTimestamp", 2);
__decorateClass([
  Column25({
    type: DataTypes26.TIME
  })
], ThreadParticipantEntity.prototype, "lastUnseenReactionTimestamp", 2);
__decorateClass([
  Column25({
    type: DataTypes26.BOOLEAN,
    allowNull: false
  })
], ThreadParticipantEntity.prototype, "subscribed", 2);
ThreadParticipantEntity = __decorateClass([
  Table25({
    tableName: "thread_participants",
    timestamps: false
  })
], ThreadParticipantEntity);

// server/src/entity/page_visitor/PageVisitorEntity.ts
import { Table as Table26, Column as Column26, Model as Model26 } from "sequelize-typescript";
import { DataTypes as DataTypes27 } from "sequelize";
var PageVisitorEntity = class extends Model26 {
};
__decorateClass([
  Column26({
    type: DataTypes27.UUID,
    allowNull: false,
    primaryKey: true
  })
], PageVisitorEntity.prototype, "pageContextHash", 2);
__decorateClass([
  Column26({
    type: DataTypes27.UUID,
    allowNull: false,
    primaryKey: true
  })
], PageVisitorEntity.prototype, "userID", 2);
__decorateClass([
  Column26({
    type: DataTypes27.UUID,
    allowNull: false,
    primaryKey: true
  })
], PageVisitorEntity.prototype, "orgID", 2);
__decorateClass([
  Column26({
    type: DataTypes27.TIME
  })
], PageVisitorEntity.prototype, "lastPresentTimestamp", 2);
PageVisitorEntity = __decorateClass([
  Table26({
    tableName: "page_visitors",
    timestamps: false
  })
], PageVisitorEntity);

// server/src/entity/session/SessionEntity.ts
import { Table as Table27, Column as Column27, Model as Model27 } from "sequelize-typescript";
import { DataTypes as DataTypes28, Sequelize as Sequelize4 } from "sequelize";
var SessionEntity = class extends Model27 {
};
__decorateClass([
  Column27({
    type: DataTypes28.UUID,
    defaultValue: DataTypes28.UUIDV4,
    allowNull: false,
    primaryKey: true
  })
], SessionEntity.prototype, "id", 2);
__decorateClass([
  Column27({
    type: DataTypes28.UUID,
    allowNull: false
  })
], SessionEntity.prototype, "applicationID", 2);
__decorateClass([
  Column27({
    type: DataTypes28.TIME,
    allowNull: false,
    defaultValue: Sequelize4.literal("NOW()")
  })
], SessionEntity.prototype, "issuedAt", 2);
__decorateClass([
  Column27({
    type: DataTypes28.TIME
  })
], SessionEntity.prototype, "expiresAt", 2);
SessionEntity = __decorateClass([
  Table27({
    tableName: "sessions",
    timestamps: false
  })
], SessionEntity);

// server/src/logging/performance.ts
import { AsyncLocalStorage } from "async_hooks";
import * as Sentry2 from "@sentry/node";
import { v4 as uuid2 } from "uuid";
var asyncLocalStorage = new AsyncLocalStorage();
var graphQlMetric = TimeHistogram({
  name: `GraphQlExecTime`,
  help: `Execution time of GraphQL operations in seconds`,
  labelNames: ["operation"]
});
var graphQLCounter = Counter2({
  name: "GraphQlExecCount",
  help: "Total number of GraphQL operations executed",
  labelNames: ["operation", "appID"]
});
var openWebsocketMetric = Gauge2({
  name: "OpenWebsockets",
  help: "Number of open websocket connections",
  labelNames: ["appID", "clientVersion", "endpoint", "deployment"]
});

// server/src/entity/heimdall/HeimdallEntity.ts
import { Table as Table28, Column as Column28, Model as Model28 } from "sequelize-typescript";
import { DataTypes as DataTypes29 } from "sequelize";
var HeimdallEntity = class extends Model28 {
  // boolean is the only value supported for now.
  isOn() {
    return this.value;
  }
};
__decorateClass([
  Column28({
    type: DataTypes29.ENUM("prod", "staging", "test", "dev"),
    allowNull: false,
    primaryKey: true
  })
], HeimdallEntity.prototype, "tier", 2);
__decorateClass([
  Column28({
    type: DataTypes29.TEXT,
    allowNull: false,
    primaryKey: true
  })
], HeimdallEntity.prototype, "key", 2);
__decorateClass([
  Column28({
    type: DataTypes29.BOOLEAN,
    allowNull: false
  })
], HeimdallEntity.prototype, "value", 2);
HeimdallEntity = __decorateClass([
  Table28({
    tableName: "heimdall",
    timestamps: false
  })
], HeimdallEntity);

// server/src/entity/email_subscription/EmailSubscriptionEntity.ts
import { Table as Table29, Column as Column29, Model as Model29 } from "sequelize-typescript";
import { DataTypes as DataTypes30 } from "sequelize";
var EmailSubscriptionEntity = class extends Model29 {
};
__decorateClass([
  Column29({
    type: DataTypes30.UUID,
    allowNull: false,
    primaryKey: true
  })
], EmailSubscriptionEntity.prototype, "userID", 2);
__decorateClass([
  Column29({
    type: DataTypes30.UUID,
    allowNull: false,
    primaryKey: true
  })
], EmailSubscriptionEntity.prototype, "threadID", 2);
__decorateClass([
  Column29({
    type: DataTypes30.BOOLEAN,
    allowNull: false,
    defaultValue: false
  })
], EmailSubscriptionEntity.prototype, "subscribed", 2);
EmailSubscriptionEntity = __decorateClass([
  Table29({
    tableName: "email_subscription",
    timestamps: false
  })
], EmailSubscriptionEntity);

// server/src/entity/linked_users/LinkedUsersEntity.ts
import { Table as Table30, Column as Column30, Model as Model30 } from "sequelize-typescript";
import { DataTypes as DataTypes31 } from "sequelize";
var LinkedUsersEntity = class extends Model30 {
};
__decorateClass([
  Column30({
    type: DataTypes31.UUID,
    primaryKey: true,
    allowNull: false
  })
], LinkedUsersEntity.prototype, "sourceUserID", 2);
__decorateClass([
  Column30({
    type: DataTypes31.UUID,
    primaryKey: true,
    allowNull: false
  })
], LinkedUsersEntity.prototype, "sourceOrgID", 2);
__decorateClass([
  Column30({
    type: DataTypes31.UUID,
    primaryKey: true,
    allowNull: false
  })
], LinkedUsersEntity.prototype, "linkedUserID", 2);
__decorateClass([
  Column30({
    type: DataTypes31.UUID,
    primaryKey: true,
    allowNull: false
  })
], LinkedUsersEntity.prototype, "linkedOrgID", 2);
__decorateClass([
  Column30({
    type: DataTypes31.TIME
  })
], LinkedUsersEntity.prototype, "linkedTimestamp", 2);
LinkedUsersEntity = __decorateClass([
  Table30({
    tableName: "linked_users",
    timestamps: false
  })
], LinkedUsersEntity);

// server/src/entity/slack_mirrored_thread/SlackMirroredThreadEntity.ts
import { Table as Table31, Column as Column31, Model as Model31 } from "sequelize-typescript";
import { DataTypes as DataTypes32 } from "sequelize";
var SlackMirroredThreadEntity = class extends Model31 {
};
__decorateClass([
  Column31({
    type: DataTypes32.UUID,
    primaryKey: true
  })
], SlackMirroredThreadEntity.prototype, "threadID", 2);
__decorateClass([
  Column31({
    type: DataTypes32.UUID
  })
], SlackMirroredThreadEntity.prototype, "threadOrgID", 2);
__decorateClass([
  Column31({
    type: DataTypes32.UUID
  })
], SlackMirroredThreadEntity.prototype, "slackOrgID", 2);
__decorateClass([
  Column31({
    type: DataTypes32.TEXT
  })
], SlackMirroredThreadEntity.prototype, "slackChannelID", 2);
__decorateClass([
  Column31({
    type: DataTypes32.TEXT
  })
], SlackMirroredThreadEntity.prototype, "slackMessageTimestamp", 2);
__decorateClass([
  Column31({
    type: DataTypes32.TIME
  })
], SlackMirroredThreadEntity.prototype, "timestamp", 2);
SlackMirroredThreadEntity = __decorateClass([
  Table31({
    tableName: "slack_mirrored_threads",
    timestamps: false
  })
], SlackMirroredThreadEntity);

// server/src/entity/message_notification/MessageOutboundNotificationEntity.ts
import { Table as Table32, Column as Column32, Model as Model32, DataType } from "sequelize-typescript";
import { DataTypes as DataTypes33, Sequelize as Sequelize5 } from "sequelize";
var MessageOutboundNotificationEntity = class extends Model32 {
};
__decorateClass([
  Column32({
    type: DataTypes33.TEXT,
    primaryKey: true
  })
], MessageOutboundNotificationEntity.prototype, "id", 2);
__decorateClass([
  Column32({
    type: DataTypes33.UUID
  })
], MessageOutboundNotificationEntity.prototype, "messageID", 2);
__decorateClass([
  Column32({
    type: DataTypes33.ENUM(
      "slack",
      "email",
      "slackEmailMatched",
      "sharedToSlackChannel",
      "sharedToEmail"
    )
  })
], MessageOutboundNotificationEntity.prototype, "type", 2);
__decorateClass([
  Column32({
    type: DataTypes33.TEXT
  })
], MessageOutboundNotificationEntity.prototype, "url", 2);
__decorateClass([
  Column32({
    type: DataTypes33.UUID
  })
], MessageOutboundNotificationEntity.prototype, "targetUserID", 2);
__decorateClass([
  Column32({
    type: DataTypes33.UUID
  })
], MessageOutboundNotificationEntity.prototype, "targetOrgID", 2);
__decorateClass([
  Column32({
    type: DataType.TIME,
    allowNull: false,
    defaultValue: Sequelize5.literal("NOW()")
  })
], MessageOutboundNotificationEntity.prototype, "timestamp", 2);
__decorateClass([
  Column32({
    type: DataTypes33.JSONB,
    allowNull: false,
    defaultValue: {}
  })
], MessageOutboundNotificationEntity.prototype, "metadata", 2);
__decorateClass([
  Column32({
    type: DataTypes33.UUID,
    allowNull: true
  })
], MessageOutboundNotificationEntity.prototype, "sharerUserID", 2);
__decorateClass([
  Column32({
    type: DataTypes33.UUID,
    allowNull: true
  })
], MessageOutboundNotificationEntity.prototype, "sharerOrgID", 2);
__decorateClass([
  Column32({
    type: DataTypes33.JSONB
  })
], MessageOutboundNotificationEntity.prototype, "location", 2);
MessageOutboundNotificationEntity = __decorateClass([
  Table32({
    tableName: "message_notifications",
    timestamps: false
  })
], MessageOutboundNotificationEntity);

// server/src/entity/user/ConsoleUserEntity.ts
import { Table as Table33, Column as Column33, PrimaryKey as PrimaryKey10, Model as Model33 } from "sequelize-typescript";
import { DataTypes as DataTypes34 } from "sequelize";
var ConsoleUserEntity = class extends Model33 {
  get idForLogging() {
    const authSource = this.auth0UserID?.includes("|") ? this.auth0UserID.substring(0, this.auth0UserID.indexOf("|")) : "unknown";
    return `${this.email} [${authSource}]`;
  }
};
__decorateClass([
  PrimaryKey10,
  Column33({
    type: DataTypes34.UUID,
    defaultValue: DataTypes34.UUIDV4
  })
], ConsoleUserEntity.prototype, "id", 2);
__decorateClass([
  Column33({ type: DataTypes34.STRING, unique: true })
], ConsoleUserEntity.prototype, "email", 2);
__decorateClass([
  Column33({
    type: DataTypes34.STRING,
    allowNull: true
  })
], ConsoleUserEntity.prototype, "name", 2);
__decorateClass([
  Column33({ type: DataTypes34.STRING, allowNull: true })
], ConsoleUserEntity.prototype, "picture", 2);
__decorateClass([
  Column33({
    type: DataTypes34.UUID,
    defaultValue: null
  })
], ConsoleUserEntity.prototype, "customerID", 2);
__decorateClass([
  Column33({
    type: DataTypes34.BOOLEAN,
    defaultValue: false
  })
], ConsoleUserEntity.prototype, "verified", 2);
__decorateClass([
  Column33({
    type: DataTypes34.STRING,
    allowNull: true
  })
], ConsoleUserEntity.prototype, "auth0UserID", 2);
__decorateClass([
  Column33({
    type: DataTypes34.UUID,
    defaultValue: null
  })
], ConsoleUserEntity.prototype, "pendingCustomerID", 2);
__decorateClass([
  Column33({
    type: DataTypes34.UUID,
    defaultValue: null
  })
], ConsoleUserEntity.prototype, "loopsUserID", 2);
ConsoleUserEntity = __decorateClass([
  Table33({
    tableName: "console_users",
    timestamps: false
  })
], ConsoleUserEntity);

// server/src/entity/user_hidden_annotations/UserHiddenAnnotationsEntity.ts
import { Table as Table34, Column as Column34, Model as Model34 } from "sequelize-typescript";
import { DataTypes as DataTypes35 } from "sequelize";
var UserHiddenAnnotationsEntity = class extends Model34 {
};
__decorateClass([
  Column34({
    type: DataTypes35.UUID,
    primaryKey: true
  })
], UserHiddenAnnotationsEntity.prototype, "userID", 2);
__decorateClass([
  Column34({
    type: DataTypes35.UUID,
    primaryKey: true
  })
], UserHiddenAnnotationsEntity.prototype, "annotationID", 2);
__decorateClass([
  Column34({
    type: DataTypes35.UUID
  })
], UserHiddenAnnotationsEntity.prototype, "pageContextHash", 2);
__decorateClass([
  Column34({
    type: DataTypes35.UUID
  })
], UserHiddenAnnotationsEntity.prototype, "orgID", 2);
UserHiddenAnnotationsEntity = __decorateClass([
  Table34({
    tableName: "user_hidden_annotations",
    timestamps: false
  })
], UserHiddenAnnotationsEntity);

// server/src/entity/extrernal_asset/ExternalAssetEntity.ts
import { Table as Table35, Column as Column35, Model as Model35 } from "sequelize-typescript";
import { DataTypes as DataTypes36 } from "sequelize";
var ExternalAssetEntity = class extends Model35 {
};
__decorateClass([
  Column35({
    type: DataTypes36.TEXT,
    primaryKey: true,
    allowNull: false
  })
], ExternalAssetEntity.prototype, "url", 2);
__decorateClass([
  Column35({
    type: DataTypes36.TIME,
    allowNull: false
  })
], ExternalAssetEntity.prototype, "downloadTimestamp", 2);
__decorateClass([
  Column35({
    type: DataTypes36.TEXT,
    allowNull: false
  })
], ExternalAssetEntity.prototype, "sha384", 2);
ExternalAssetEntity = __decorateClass([
  Table35({
    tableName: "external_assets",
    timestamps: false
  })
], ExternalAssetEntity);

// server/src/entity/image_variant/ImageVariantEntity.ts
import { Table as Table36, Column as Column36, Model as Model36 } from "sequelize-typescript";
import { DataTypes as DataTypes37 } from "sequelize";
var ImageVariantEntity = class extends Model36 {
};
__decorateClass([
  Column36({
    type: DataTypes37.TEXT,
    primaryKey: true,
    allowNull: false
  })
], ImageVariantEntity.prototype, "sourceSha384", 2);
__decorateClass([
  Column36({
    type: DataTypes37.TEXT,
    primaryKey: true,
    allowNull: false
  })
], ImageVariantEntity.prototype, "variant", 2);
__decorateClass([
  Column36({
    type: DataTypes37.TIME,
    allowNull: false
  })
], ImageVariantEntity.prototype, "timestamp", 2);
__decorateClass([
  Column36({
    type: DataTypes37.TEXT,
    allowNull: false
  })
], ImageVariantEntity.prototype, "filename", 2);
ImageVariantEntity = __decorateClass([
  Table36({
    tableName: "image_variants",
    timestamps: false
  })
], ImageVariantEntity);

// server/src/entity/slack_mirrored_support_thread/SlackMirroredSupportThreadEntity.ts
import { Column as Column37, Table as Table37, Model as Model37 } from "sequelize-typescript";
import { DataTypes as DataTypes38, Sequelize as Sequelize6 } from "sequelize";
var SlackMirroredSupportThreadEntity = class extends Model37 {
};
__decorateClass([
  Column37({
    type: DataTypes38.UUID,
    primaryKey: true,
    allowNull: false
  })
], SlackMirroredSupportThreadEntity.prototype, "threadID", 2);
__decorateClass([
  Column37({
    type: DataTypes38.UUID,
    allowNull: false
  })
], SlackMirroredSupportThreadEntity.prototype, "threadOrgID", 2);
__decorateClass([
  Column37({
    type: DataTypes38.UUID,
    allowNull: false
  })
], SlackMirroredSupportThreadEntity.prototype, "slackOrgID", 2);
__decorateClass([
  Column37({
    type: DataTypes38.TEXT,
    allowNull: false
  })
], SlackMirroredSupportThreadEntity.prototype, "slackChannelID", 2);
__decorateClass([
  Column37({
    type: DataTypes38.TEXT,
    allowNull: false
  })
], SlackMirroredSupportThreadEntity.prototype, "slackMessageTimestamp", 2);
__decorateClass([
  Column37({
    type: DataTypes38.TIME,
    defaultValue: Sequelize6.literal("CURRENT_TIMESTAMP")
  })
], SlackMirroredSupportThreadEntity.prototype, "timestamp", 2);
SlackMirroredSupportThreadEntity = __decorateClass([
  Table37({
    tableName: "slack_mirrored_support_threads",
    timestamps: false
  })
], SlackMirroredSupportThreadEntity);

// server/src/entity/deploys/DeploysEntity.ts
import { Table as Table38, Column as Column38, PrimaryKey as PrimaryKey11, Model as Model38 } from "sequelize-typescript";
import { DataTypes as DataTypes39 } from "sequelize";
var DeploysEntity = class extends Model38 {
};
__decorateClass([
  PrimaryKey11,
  Column38({
    type: DataTypes39.UUID,
    defaultValue: DataTypes39.UUIDV4
  })
], DeploysEntity.prototype, "id", 2);
__decorateClass([
  Column38({
    type: DataTypes39.ENUM("prod", "staging", "test", "dev")
  })
], DeploysEntity.prototype, "tier", 2);
__decorateClass([
  Column38({
    type: DataTypes39.DATE
  })
], DeploysEntity.prototype, "deployStartTime", 2);
__decorateClass([
  Column38({
    type: DataTypes39.TIME
  })
], DeploysEntity.prototype, "deployFinishTime", 2);
__decorateClass([
  Column38({
    type: DataTypes39.BOOLEAN
  })
], DeploysEntity.prototype, "success", 2);
__decorateClass([
  Column38({
    type: DataTypes39.TEXT
  })
], DeploysEntity.prototype, "error", 2);
__decorateClass([
  Column38({
    type: DataTypes39.TEXT
  })
], DeploysEntity.prototype, "gitCommitHash", 2);
__decorateClass([
  Column38({
    type: DataTypes39.TEXT
  })
], DeploysEntity.prototype, "dockerImage", 2);
__decorateClass([
  Column38({
    type: DataTypes39.TEXT
  })
], DeploysEntity.prototype, "packageVersion", 2);
DeploysEntity = __decorateClass([
  Table38({
    tableName: "deploys",
    timestamps: false
  })
], DeploysEntity);

// server/src/entity/task_third_party_subscription/TaskThirdPartySubscriptionEntity.ts
import { Table as Table39, Column as Column39, Model as Model39 } from "sequelize-typescript";
import { DataTypes as DataTypes40 } from "sequelize";
var TaskThirdPartySubscriptionEntity = class extends Model39 {
};
__decorateClass([
  Column39({ type: DataTypes40.UUID, primaryKey: true })
], TaskThirdPartySubscriptionEntity.prototype, "id", 2);
__decorateClass([
  Column39({ type: DataTypes40.UUID })
], TaskThirdPartySubscriptionEntity.prototype, "userID", 2);
__decorateClass([
  Column39({ type: DataTypes40.UUID })
], TaskThirdPartySubscriptionEntity.prototype, "orgID", 2);
__decorateClass([
  Column39({ type: ThirdPartyConnectionDataType })
], TaskThirdPartySubscriptionEntity.prototype, "externalConnectionType", 2);
__decorateClass([
  Column39({ type: DataTypes40.JSONB })
], TaskThirdPartySubscriptionEntity.prototype, "subscriptionDetails", 2);
__decorateClass([
  Column39({ type: DataTypes40.TIME })
], TaskThirdPartySubscriptionEntity.prototype, "createdTimestamp", 2);
TaskThirdPartySubscriptionEntity = __decorateClass([
  Table39({
    tableName: "task_third_party_subscriptions",
    timestamps: false
  })
], TaskThirdPartySubscriptionEntity);

// server/src/entity/application_usage_metric/ApplicationUsageMetricEntity.ts
import { Table as Table40, Column as Column40, Model as Model40 } from "sequelize-typescript";
import { DataTypes as DataTypes41 } from "sequelize";
var ApplicationUsageMetricEntity = class extends Model40 {
};
__decorateClass([
  Column40({
    type: DataTypes41.UUID,
    primaryKey: true
  })
], ApplicationUsageMetricEntity.prototype, "applicationID", 2);
__decorateClass([
  Column40({
    type: DataTypes41.UUID,
    primaryKey: true
  })
], ApplicationUsageMetricEntity.prototype, "metricID", 2);
__decorateClass([
  Column40({
    type: DataTypes41.DATE,
    primaryKey: true
  })
], ApplicationUsageMetricEntity.prototype, "date", 2);
__decorateClass([
  Column40({
    type: DataTypes41.INTEGER,
    allowNull: false
  })
], ApplicationUsageMetricEntity.prototype, "value", 2);
ApplicationUsageMetricEntity = __decorateClass([
  Table40({
    tableName: "application_usage_metrics",
    timestamps: false
  })
], ApplicationUsageMetricEntity);

// server/src/entity/application_usage_metric/ApplicationUsageMetricTypeEntity.ts
import { Table as Table41, Column as Column41, Model as Model41 } from "sequelize-typescript";
import { DataTypes as DataTypes42 } from "sequelize";
var ApplicationUsageMetricTypeEntity = class extends Model41 {
};
__decorateClass([
  Column41({
    type: DataTypes42.UUID,
    primaryKey: true
  })
], ApplicationUsageMetricTypeEntity.prototype, "id", 2);
__decorateClass([
  Column41({
    type: DataTypes42.TEXT,
    allowNull: false
  })
], ApplicationUsageMetricTypeEntity.prototype, "metric", 2);
ApplicationUsageMetricTypeEntity = __decorateClass([
  Table41({
    tableName: "application_usage_metric_types",
    timestamps: false
  })
], ApplicationUsageMetricTypeEntity);

// server/src/entity/notification/NotificationEntity.ts
import { Table as Table42, Column as Column42, Model as Model42 } from "sequelize-typescript";
import { literal, DataTypes as DataTypes43 } from "sequelize";
var NotificationEntity = class extends Model42 {
};
__decorateClass([
  Column42({
    type: DataTypes43.UUID,
    allowNull: false,
    primaryKey: true,
    defaultValue: DataTypes43.UUIDV4
  })
], NotificationEntity.prototype, "id", 2);
__decorateClass([
  Column42({ type: DataTypes43.UUID })
], NotificationEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column42({ type: DataTypes43.UUID })
], NotificationEntity.prototype, "externalID", 2);
__decorateClass([
  Column42({ type: DataTypes43.UUID, allowNull: false })
], NotificationEntity.prototype, "recipientID", 2);
__decorateClass([
  Column42({ type: DataTypes43.UUID, allowNull: true })
], NotificationEntity.prototype, "senderID", 2);
__decorateClass([
  Column42({ type: DataTypes43.TEXT, allowNull: true })
], NotificationEntity.prototype, "iconUrl", 2);
__decorateClass([
  Column42({
    type: DataTypes43.ENUM("reply", "reaction", "external", "thread_action"),
    allowNull: false
  })
], NotificationEntity.prototype, "type", 2);
__decorateClass([
  Column42({ type: DataTypes43.TEXT, allowNull: true })
], NotificationEntity.prototype, "aggregationKey", 2);
__decorateClass([
  Column42({
    type: DataTypes43.ENUM("unread", "read"),
    allowNull: false,
    defaultValue: "unread"
  })
], NotificationEntity.prototype, "readStatus", 2);
__decorateClass([
  Column42({
    type: DataTypes43.TIME,
    allowNull: false,
    defaultValue: literal("CURRENT_TIMESTAMP")
  })
], NotificationEntity.prototype, "createdTimestamp", 2);
__decorateClass([
  Column42({ type: DataTypes43.UUID, allowNull: true })
], NotificationEntity.prototype, "messageID", 2);
__decorateClass([
  Column42({ type: DataTypes43.ARRAY(DataTypes43.TEXT), allowNull: true })
], NotificationEntity.prototype, "replyActions", 2);
__decorateClass([
  Column42({ type: DataTypes43.UUID, allowNull: true })
], NotificationEntity.prototype, "reactionID", 2);
__decorateClass([
  Column42({ type: DataTypes43.UUID, allowNull: true })
], NotificationEntity.prototype, "threadID", 2);
__decorateClass([
  Column42({ type: DataTypes43.ENUM("resolve", "unresolve"), allowNull: true })
], NotificationEntity.prototype, "threadActionType", 2);
__decorateClass([
  Column42({ type: DataTypes43.TEXT, allowNull: true })
], NotificationEntity.prototype, "externalTemplate", 2);
__decorateClass([
  Column42({ type: DataTypes43.TEXT, allowNull: true })
], NotificationEntity.prototype, "externalURL", 2);
__decorateClass([
  Column42({ type: DataTypes43.TEXT, allowNull: true })
], NotificationEntity.prototype, "extraClassnames", 2);
__decorateClass([
  Column42({
    type: DataTypes43.JSONB,
    allowNull: false,
    defaultValue: {}
  })
], NotificationEntity.prototype, "metadata", 2);
NotificationEntity = __decorateClass([
  Table42({
    tableName: "notifications",
    timestamps: false
  })
], NotificationEntity);

// server/src/entity/go_redirect/AdminGoRedirectEntity.ts
import { Table as Table43, Column as Column43, Model as Model43 } from "sequelize-typescript";
import { DataTypes as DataTypes44 } from "sequelize";
var AdminGoRedirectEntity = class extends Model43 {
};
__decorateClass([
  Column43({
    type: DataTypes44.UUID,
    allowNull: false,
    primaryKey: true,
    defaultValue: DataTypes44.UUIDV4
  })
], AdminGoRedirectEntity.prototype, "id", 2);
__decorateClass([
  Column43({
    type: DataTypes44.TEXT,
    allowNull: false
  })
], AdminGoRedirectEntity.prototype, "name", 2);
__decorateClass([
  Column43({
    type: DataTypes44.TEXT,
    allowNull: false
  })
], AdminGoRedirectEntity.prototype, "url", 2);
__decorateClass([
  Column43({
    type: DataTypes44.UUID,
    allowNull: false
  })
], AdminGoRedirectEntity.prototype, "creatorUserID", 2);
__decorateClass([
  Column43({
    type: DataTypes44.UUID,
    allowNull: false
  })
], AdminGoRedirectEntity.prototype, "updaterUserID", 2);
__decorateClass([
  Column43({
    type: DataTypes44.INTEGER,
    allowNull: false,
    defaultValue: 0
  })
], AdminGoRedirectEntity.prototype, "redirectCount", 2);
AdminGoRedirectEntity = __decorateClass([
  Table43({
    tableName: "admin_go_redirects",
    timestamps: false
  })
], AdminGoRedirectEntity);

// server/src/entity/admin_crt/AdminCRTCustomerIssueEntity.ts
import { Table as Table44, Column as Column44, PrimaryKey as PrimaryKey12, Model as Model44 } from "sequelize-typescript";
import { DataTypes as DataTypes45 } from "sequelize";
var AdminCRTCustomerIssueEntity = class extends Model44 {
};
__decorateClass([
  PrimaryKey12,
  Column44({
    defaultValue: DataTypes45.UUIDV4,
    type: DataTypes45.UUID
  })
], AdminCRTCustomerIssueEntity.prototype, "id", 2);
__decorateClass([
  Column44({
    type: DataTypes45.UUID
  })
], AdminCRTCustomerIssueEntity.prototype, "customerID", 2);
__decorateClass([
  Column44({
    type: DataTypes45.TEXT
  })
], AdminCRTCustomerIssueEntity.prototype, "title", 2);
__decorateClass([
  Column44({
    type: DataTypes45.TEXT
  })
], AdminCRTCustomerIssueEntity.prototype, "body", 2);
__decorateClass([
  Column44({
    type: DataTypes45.ENUM("them", "us")
  })
], AdminCRTCustomerIssueEntity.prototype, "comingFrom", 2);
__decorateClass([
  Column44({
    type: DataTypes45.ENUM("done", "pending", "accepted", "rejected")
  })
], AdminCRTCustomerIssueEntity.prototype, "decision", 2);
__decorateClass([
  Column44({
    type: DataTypes45.ENUM(
      "none",
      "request_acked",
      "decision_sent",
      "decision_acked"
    )
  })
], AdminCRTCustomerIssueEntity.prototype, "communicationStatus", 2);
__decorateClass([
  Column44({
    type: DataTypes45.TIME,
    allowNull: true
  })
], AdminCRTCustomerIssueEntity.prototype, "lastTouch", 2);
__decorateClass([
  Column44({
    type: DataTypes45.ENUM("request", "bug", "onboarding_step"),
    allowNull: true
  })
], AdminCRTCustomerIssueEntity.prototype, "type", 2);
__decorateClass([
  Column44({
    type: DataTypes45.ENUM("blocker", "high", "low"),
    allowNull: true
  })
], AdminCRTCustomerIssueEntity.prototype, "priority", 2);
__decorateClass([
  Column44({
    type: DataTypes45.UUID,
    allowNull: true
  })
], AdminCRTCustomerIssueEntity.prototype, "assignee", 2);
__decorateClass([
  Column44({
    type: DataTypes45.TIME
  })
], AdminCRTCustomerIssueEntity.prototype, "createdTimestamp", 2);
__decorateClass([
  Column44({
    type: DataTypes45.BOOLEAN,
    defaultValue: false
  })
], AdminCRTCustomerIssueEntity.prototype, "externallyVisible", 2);
AdminCRTCustomerIssueEntity = __decorateClass([
  Table44({
    tableName: "admin_crt_customer_issues",
    timestamps: false
  })
], AdminCRTCustomerIssueEntity);

// server/src/entity/admin_crt/AdminCRTCustomerIssueChangeEntity.ts
import { Table as Table45, Column as Column45, PrimaryKey as PrimaryKey13, Model as Model45 } from "sequelize-typescript";
import { DataTypes as DataTypes46 } from "sequelize";
var AdminCRTCustomerIssueChangeEntity = class extends Model45 {
};
__decorateClass([
  PrimaryKey13,
  Column45({
    defaultValue: DataTypes46.UUIDV4,
    type: DataTypes46.UUID
  })
], AdminCRTCustomerIssueChangeEntity.prototype, "id", 2);
__decorateClass([
  Column45({
    type: DataTypes46.UUID
  })
], AdminCRTCustomerIssueChangeEntity.prototype, "issueID", 2);
__decorateClass([
  Column45({
    type: DataTypes46.UUID
  })
], AdminCRTCustomerIssueChangeEntity.prototype, "userID", 2);
__decorateClass([
  Column45({
    type: DataTypes46.JSONB
  })
], AdminCRTCustomerIssueChangeEntity.prototype, "changeDetail", 2);
__decorateClass([
  Column45({
    type: DataTypes46.TIME
  })
], AdminCRTCustomerIssueChangeEntity.prototype, "timestamp", 2);
AdminCRTCustomerIssueChangeEntity = __decorateClass([
  Table45({
    tableName: "admin_crt_customer_issue_changes",
    timestamps: false
  })
], AdminCRTCustomerIssueChangeEntity);

// server/src/entity/admin_crt/AdminCRTCustomerIssueSubscriptionEntity.ts
import { Table as Table46, Column as Column46, Model as Model46 } from "sequelize-typescript";
import { DataTypes as DataTypes47 } from "sequelize";
var AdminCRTCustomerIssueSubscriptionEntity = class extends Model46 {
};
__decorateClass([
  Column46({
    type: DataTypes47.UUID,
    primaryKey: true,
    allowNull: false
  })
], AdminCRTCustomerIssueSubscriptionEntity.prototype, "issueID", 2);
__decorateClass([
  Column46({
    type: DataTypes47.UUID,
    primaryKey: true,
    allowNull: false
  })
], AdminCRTCustomerIssueSubscriptionEntity.prototype, "userID", 2);
AdminCRTCustomerIssueSubscriptionEntity = __decorateClass([
  Table46({
    tableName: "admin_crt_customer_issue_subscriptions",
    timestamps: false
  })
], AdminCRTCustomerIssueSubscriptionEntity);

// server/src/entity/message_link_preview/MessageLinkPreviewEntity.ts
import { Table as Table47, Column as Column47, PrimaryKey as PrimaryKey14, Model as Model47 } from "sequelize-typescript";
import { DataTypes as DataTypes48 } from "sequelize";
var MessageLinkPreviewEntity = class extends Model47 {
};
__decorateClass([
  PrimaryKey14,
  Column47({
    type: DataTypes48.UUID,
    defaultValue: DataTypes48.UUIDV4
  })
], MessageLinkPreviewEntity.prototype, "id", 2);
__decorateClass([
  Column47({
    type: DataTypes48.UUID
  })
], MessageLinkPreviewEntity.prototype, "messageID", 2);
__decorateClass([
  Column47({
    type: DataTypes48.TEXT
  })
], MessageLinkPreviewEntity.prototype, "url", 2);
__decorateClass([
  Column47({
    type: DataTypes48.TEXT
  })
], MessageLinkPreviewEntity.prototype, "img", 2);
__decorateClass([
  Column47({
    type: DataTypes48.TEXT
  })
], MessageLinkPreviewEntity.prototype, "title", 2);
__decorateClass([
  Column47({
    type: DataTypes48.TEXT
  })
], MessageLinkPreviewEntity.prototype, "description", 2);
__decorateClass([
  Column47({
    type: DataTypes48.TIME
  })
], MessageLinkPreviewEntity.prototype, "lastScrapedTimestamp", 2);
__decorateClass([
  Column47({
    type: DataTypes48.BOOLEAN
  })
], MessageLinkPreviewEntity.prototype, "hidden", 2);
MessageLinkPreviewEntity = __decorateClass([
  Table47({
    tableName: "message_link_previews",
    timestamps: false
  })
], MessageLinkPreviewEntity);

// server/src/entity/application_webhook/ApplicationWebhookEntity.ts
import { Table as Table48, Column as Column48, Model as Model48 } from "sequelize-typescript";
import { DataTypes as DataTypes49 } from "sequelize";
var ApplicationWebhookEntity = class extends Model48 {
};
__decorateClass([
  Column48({
    type: DataTypes49.UUID,
    allowNull: false,
    primaryKey: true,
    defaultValue: DataTypes49.UUIDV4
  })
], ApplicationWebhookEntity.prototype, "id", 2);
__decorateClass([
  Column48({
    type: DataTypes49.UUID,
    allowNull: false,
    unique: "AppURLUniqueness"
  })
], ApplicationWebhookEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column48({
    type: DataTypes49.STRING,
    allowNull: false,
    unique: "AppURLUniqueness"
  })
], ApplicationWebhookEntity.prototype, "eventWebhookURL", 2);
__decorateClass([
  Column48({
    type: DataTypes49.ARRAY(DataTypes49.TEXT),
    defaultValue: null
  })
], ApplicationWebhookEntity.prototype, "eventWebhookSubscriptions", 2);
ApplicationWebhookEntity = __decorateClass([
  Table48({
    tableName: "application_webhooks",
    timestamps: false
  })
], ApplicationWebhookEntity);

// server/src/entity/demo/WarmDemoUserEntity.ts
import { Table as Table49, Column as Column49, PrimaryKey as PrimaryKey15, Model as Model49 } from "sequelize-typescript";
import { DataTypes as DataTypes50 } from "sequelize";
var WarmDemoUserEntity = class extends Model49 {
};
__decorateClass([
  PrimaryKey15,
  Column49({
    defaultValue: DataTypes50.UUIDV4,
    type: DataTypes50.UUID
  })
], WarmDemoUserEntity.prototype, "id", 2);
__decorateClass([
  Column49({
    type: DataTypes50.TEXT,
    allowNull: false
  })
], WarmDemoUserEntity.prototype, "demoGroup", 2);
__decorateClass([
  Column49({
    type: DataTypes50.INTEGER,
    allowNull: false
  })
], WarmDemoUserEntity.prototype, "version", 2);
__decorateClass([
  Column49({
    type: DataTypes50.UUID,
    allowNull: false
  })
], WarmDemoUserEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column49({
    type: DataTypes50.TEXT,
    allowNull: false
  })
], WarmDemoUserEntity.prototype, "userID", 2);
__decorateClass([
  Column49({
    type: DataTypes50.TEXT,
    allowNull: false
  })
], WarmDemoUserEntity.prototype, "orgID", 2);
WarmDemoUserEntity = __decorateClass([
  Table49({
    tableName: "warm_demo_users",
    timestamps: false
  })
], WarmDemoUserEntity);

// server/src/entity/preallocated_thread_id/PreallocatedThreadIDEntity.ts
import { Table as Table50, Column as Column50, Model as Model50 } from "sequelize-typescript";
import { DataTypes as DataTypes51 } from "sequelize";
var PreallocatedThreadIDEntity = class extends Model50 {
};
__decorateClass([
  Column50({
    type: DataTypes51.UUID,
    allowNull: false,
    primaryKey: true
  })
], PreallocatedThreadIDEntity.prototype, "id", 2);
__decorateClass([
  Column50({
    type: DataTypes51.TEXT,
    allowNull: false
  })
], PreallocatedThreadIDEntity.prototype, "externalID", 2);
__decorateClass([
  Column50({
    type: DataTypes51.UUID,
    allowNull: false
  })
], PreallocatedThreadIDEntity.prototype, "platformApplicationID", 2);
PreallocatedThreadIDEntity = __decorateClass([
  Table50({
    tableName: "preallocated_thread_ids",
    timestamps: false
  })
], PreallocatedThreadIDEntity);

// server/src/entity/permission/PermisssionRuleEntity.ts
import { DataTypes as DataTypes52 } from "sequelize";
import { Column as Column51, Model as Model51, PrimaryKey as PrimaryKey16, Table as Table51 } from "sequelize-typescript";
var PermissionValues = [
  "thread:read",
  "thread:send-message",
  "thread-participant:read",
  "message:read"
];
var PermissionRuleEntity = class extends Model51 {
};
__decorateClass([
  PrimaryKey16,
  Column51({
    type: DataTypes52.UUID,
    defaultValue: DataTypes52.UUIDV4
  })
], PermissionRuleEntity.prototype, "id", 2);
__decorateClass([
  Column51({ type: DataTypes52.UUID, allowNull: false })
], PermissionRuleEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column51({ type: DataTypes52.STRING, allowNull: false })
], PermissionRuleEntity.prototype, "resourceSelector", 2);
__decorateClass([
  Column51({ type: DataTypes52.STRING, allowNull: false })
], PermissionRuleEntity.prototype, "userSelector", 2);
__decorateClass([
  Column51({
    type: DataTypes52.ARRAY(DataTypes52.ENUM(...PermissionValues)),
    allowNull: false
  })
], PermissionRuleEntity.prototype, "permissions", 2);
PermissionRuleEntity = __decorateClass([
  Table51({
    tableName: "permission_rules",
    timestamps: false
  })
], PermissionRuleEntity);

// server/src/entity/org_org_members/OrgOrgMembersEntity.ts
import { Table as Table52, Column as Column52, Model as Model52 } from "sequelize-typescript";
import { DataTypes as DataTypes53 } from "sequelize";
var OrgOrgMembersEntity = class extends Model52 {
};
__decorateClass([
  Column52({
    type: DataTypes53.UUID,
    primaryKey: true,
    allowNull: false
  })
], OrgOrgMembersEntity.prototype, "childOrgID", 2);
__decorateClass([
  Column52({
    type: DataTypes53.UUID,
    primaryKey: true,
    allowNull: false
  })
], OrgOrgMembersEntity.prototype, "parentOrgID", 2);
__decorateClass([
  Column52({
    type: DataTypes53.UUID,
    allowNull: false
  })
], OrgOrgMembersEntity.prototype, "platformApplicationID", 2);
__decorateClass([
  Column52({
    type: DataTypes53.TIME
  })
], OrgOrgMembersEntity.prototype, "createdTimestamp", 2);
OrgOrgMembersEntity = __decorateClass([
  Table52({
    tableName: "org_org_members",
    timestamps: false
  })
], OrgOrgMembersEntity);

// server/src/entity/sequelize.ts
var {
  POSTGRES_HOST,
  POSTGRES_DB,
  POSTGRES_PASSWORD,
  POSTGRES_PORT,
  POSTGRES_USER
} = Env_default;
var MAX_QUERY_LOG_LENGTH = 1e4;
var queryExecutionTimeMetric = TimeHistogram({
  name: "SequelizeQueryTime",
  help: "Execution time of Sequelize queries",
  labelNames: ["type", "appID"]
});
var openDbConnectionsMetric = Gauge2({
  name: "OpenDatabaseConnections",
  help: "Number of open database connections"
});
var acquireTimeMetric = TimeHistogram({
  name: "SequelizePoolAcquireTime",
  help: "Time spent waiting to acquire a Sequelize connection",
  // Like our default buckets, but extend the lower bound down to 10us because
  // connection acquire should be very fast.
  buckets: logBuckets(1e-5, 10, 19)
});
var _availableConnectionsMetric = Gauge2({
  name: "SequelizePoolAvailable",
  help: "Number of available connections in the Sequelize connection pool",
  collect() {
    if (sequelize) {
      this.set(sequelize.connectionManager.pool.available);
    }
  }
});
var _usingConnectionsMetric = Gauge2({
  name: "SequelizePoolUsed",
  help: "Number of in-use connections in the Sequelize connection pool",
  collect() {
    if (sequelize) {
      this.set(sequelize.connectionManager.pool.using);
    }
  }
});
var _waitingConnectionsMetric = Gauge2({
  name: "SequelizePoolWaiting",
  help: "Number of requests waiting for a Sequelize connection",
  collect() {
    if (sequelize) {
      this.set(sequelize.connectionManager.pool.waiting);
    }
  }
});
var acquireStarts = /* @__PURE__ */ new WeakMap();
var apiSequelizeOptions = {
  dialect: "postgres",
  host: POSTGRES_HOST,
  port: Number(POSTGRES_PORT),
  username: POSTGRES_USER,
  password: POSTGRES_PASSWORD,
  database: POSTGRES_DB,
  schema: "cord",
  models: [
    EventEntity,
    MessageEntity,
    MessageAttachmentEntity,
    MessageLinkPreviewEntity,
    ThreadParticipantEntity,
    PageVisitorEntity,
    OrgEntity,
    UserEntity,
    FileEntity,
    PageEntity,
    ThreadEntity,
    PreallocatedThreadIDEntity,
    MessageReactionEntity,
    MessageMentionEntity,
    SlackChannelEntity,
    SlackMessageEntity,
    UserPreferenceEntity,
    DeploysEntity,
    TaskEntity,
    TaskTodoEntity,
    TaskAssigneeEntity,
    ThirdPartyConnectionEntity,
    TaskThirdPartyReference,
    TaskThirdPartySubscriptionEntity,
    ApplicationEntity,
    CustomerEntity,
    SessionEntity,
    OrgMembersEntity,
    S3BucketEntity,
    HeimdallEntity,
    EmailSubscriptionEntity,
    LinkedOrgsEntity,
    LinkedUsersEntity,
    SlackMirroredThreadEntity,
    MessageOutboundNotificationEntity,
    ConsoleUserEntity,
    UserHiddenAnnotationsEntity,
    ExternalAssetEntity,
    ImageVariantEntity,
    EmailOutboundNotificationEntity,
    SlackMirroredSupportThreadEntity,
    ApplicationUsageMetricEntity,
    ApplicationUsageMetricTypeEntity,
    NotificationEntity,
    AdminGoRedirectEntity,
    AdminCRTCustomerIssueEntity,
    AdminCRTCustomerIssueChangeEntity,
    AdminCRTCustomerIssueSubscriptionEntity,
    ApplicationWebhookEntity,
    WarmDemoUserEntity,
    PermissionRuleEntity,
    OrgOrgMembersEntity
  ],
  benchmark: true,
  logging: (...args) => {
    const [msg, timing_ms, sequelizeInfo] = args;
    const truncatedMsg = msg.length <= MAX_QUERY_LOG_LENGTH ? msg : msg.substring(0, MAX_QUERY_LOG_LENGTH) + ` (truncated from ${msg.length} bytes)`;
    const { type, bind, tableNames } = sequelizeInfo;
    const storage = asyncLocalStorage?.getStore();
    const logger = storage?.logger ?? anonymousLogger();
    logger.debug(`Sequelize: ${truncatedMsg}`, {
      sequelize: { type, bind, tableNames },
      timing_ms,
      operationName: storage?.operationName,
      operationID: storage?.operationID,
      platformApplicationID: storage?.platformApplicationID
    });
    queryExecutionTimeMetric.observe(
      { type, appID: storage?.platformApplicationID },
      timing_ms / 1e3
    );
  },
  pool: {
    // Maximum number of connection in pool
    max: 50,
    // Minimum number of connection in pool
    min: 50,
    // The number of times a connection can be used before discarding it for a
    // replacement
    maxUses: 500,
    // Time out if the pool doesn't manage to establish a new connection within
    // 10 seconds
    acquire: 1e4
  },
  hooks: {
    // on any new database connection we set the search path, so when
    // database objects (tables, types, functions etc.) are given without
    // explicitly specifying the schema they are in, they are found if
    // they are in either cord or public.
    // This is also done in `.sequelize-config.js` so that it applies in
    // migrations, where statements such as `CREATE TABLE` will create
    // objects in the first schema of the search_path (`cord`).
    afterConnect: async (connection) => {
      await connection.query("SET search_path=cord,public;");
      openDbConnectionsMetric.inc(1);
    },
    afterDisconnect: (_connection) => {
      openDbConnectionsMetric.dec(1);
    },
    beforePoolAcquire: (options) => {
      acquireStarts.set(options, performance.now());
    },
    afterPoolAcquire: (_connection, options) => {
      const start = acquireStarts.get(options);
      if (start) {
        const elapsed = performance.now() - start;
        acquireStarts.delete(options);
        acquireTimeMetric.observe(elapsed / 1e3);
      }
    }
  },
  dialectOptions: {
    // any SQL statement should timeout after 10s (10s is very conservative, we
    // might want to reduce it further eventually).
    statement_timeout: 1e4,
    // a transaction that does not send a statement for 5s should timeout
    idle_in_transaction_session_timeout: 5e3
  }
};
function initializeEntityRelationships() {
  MessageEntity.hasMany(MessageMentionEntity, {
    as: "mentions",
    foreignKey: "messageID"
  });
  MessageEntity.hasMany(TaskEntity, {
    as: "tasks",
    foreignKey: "messageID"
  });
  TaskEntity.hasMany(TaskAssigneeEntity, {
    as: "assignees",
    foreignKey: "taskID"
  });
  TaskEntity.hasOne(MessageEntity, {
    sourceKey: "messageID",
    foreignKey: "id",
    as: "message"
  });
  TaskThirdPartyReference.hasOne(TaskEntity, {
    as: "task",
    sourceKey: "taskID",
    foreignKey: "id"
  });
  OrgEntity.hasOne(LinkedOrgsEntity, {
    sourceKey: "id",
    foreignKey: "linkedOrgID"
  });
  OrgMembersEntity.hasOne(UserEntity, {
    sourceKey: "userID",
    foreignKey: "id"
  });
  MessageEntity.hasOne(ThreadEntity, {
    as: "thread",
    sourceKey: "threadID",
    foreignKey: "id"
  });
}
var sequelize;
function getSequelize() {
  if (sequelize === void 0) {
    throw new Error("Sequelize has not been initialised");
  }
  return sequelize;
}
function getSequelizeOptions(workerType) {
  switch (workerType) {
    case "api":
    case "test":
    case "master":
    case "script":
      return apiSequelizeOptions;
    case "async":
      return {
        ...apiSequelizeOptions,
        dialectOptions: {
          // Set the statement timeout to 2 minutes (in milliseconds), to allow
          // longer-running SQL statements in async jobs
          ...apiSequelizeOptions.dialectOptions,
          statement_timeout: 2 * 60 * 1e3
        }
      };
    case "admin":
    case "console":
      return {
        ...apiSequelizeOptions,
        pool: {
          ...apiSequelizeOptions.pool,
          max: 20,
          min: 0
        }
      };
    default: {
      const _exhaustiveSwitchGuard = workerType;
      throw new Error("Invalid worker type " + workerType);
    }
  }
}
async function initSequelize(workerType) {
  if (sequelize !== void 0) {
    throw new Error("Sequelize has been already initialised");
  }
  const opts = getSequelizeOptions(workerType);
  const seq = new Sequelize7(opts);
  initializeEntityRelationships();
  await seq.authenticate();
  sequelize = seq;
}
var MAX_RETRIES = 5;
async function serializableTransactionWithRetries(body) {
  let lastException;
  for (let retryCount = 0; retryCount < MAX_RETRIES; retryCount++) {
    try {
      return await getSequelize().transaction(
        {
          isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE
        },
        body
      );
    } catch (e) {
      if (e instanceof DatabaseError && "code" in e.original && (e.original.code === "40001" || e.original.code === "40P01")) {
        lastException = e;
        const exp = 2 ** retryCount;
        const baseMs = 50 * exp;
        const randMs = 50 * exp * Math.random();
        await sleep(baseMs + randMs);
        continue;
      }
      throw e;
    }
  }
  throw lastException;
}
async function assertTransactionIsSerializable(transaction) {
  const type = await getSequelize().query(
    `SELECT current_setting('transaction_isolation') AS isolation_level`,
    {
      type: QueryTypes.SELECT,
      transaction
    }
  );
  const isSerializable = type[0].isolation_level === Transaction.ISOLATION_LEVELS.SERIALIZABLE.toLowerCase();
  if (!isSerializable) {
    throw new Error("Transaction must be serializable");
  }
}

// server/src/redis/index.ts
import Redis from "ioredis";
import Redlock from "redlock";
var compareAndDelete = "compareAndDelete";
var incrAndExpire = "incrAndExpire";
var redis;
function getRedis() {
  if (redis === void 0) {
    throw new Error("Redis has not been initialised");
  }
  return redis;
}
var predis;
function getPredis() {
  if (predis === void 0) {
    throw new Error("Predis has not been initialised");
  }
  return predis;
}
var redlock;
function getRedlock() {
  if (redlock === void 0) {
    throw new Error("Redis has not been initialised");
  }
  return redlock;
}
function addOurCommands(redisClient) {
  redisClient.defineCommand(compareAndDelete, {
    numberOfKeys: 1,
    lua: `
local currVal = redis.call("get", KEYS[1])
if currVal == ARGV[1] then
  return redis.call("del", KEYS[1])
else
  return 0
end`
  });
  redisClient.defineCommand(incrAndExpire, {
    numberOfKeys: 1,
    // this lua script increments a value (which sets it to 1 if it did not
    // exist before). If the value was just created, an expiry is set on the value.
    lua: `
local currVal = redis.call("incr", KEYS[1])
if currVal == 1 then
  redis.call("expire", KEYS[1], ARGV[1])
end
return currVal
`
  });
}
function initRedis() {
  const redisClient = createRedisClient();
  const predisClient = createPredisClient();
  [redisClient, predisClient].forEach((client2) => addOurCommands(client2));
  redis = redisClient;
  predis = predisClient;
  redlock = new Redlock([redis]);
}
function createRedisClient() {
  return new Redis.default(Number(Env_default.REDIS_PORT), Env_default.REDIS_HOST);
}
function createPredisClient() {
  return new Redis.default(Number(Env_default.PREDIS_PORT), Env_default.PREDIS_HOST);
}
function multiOperationSucceeded(errsAndVals, message) {
  if (!errsAndVals) {
    anonymousLogger().logException(
      message,
      new Error("Return value was empty")
    );
    return false;
  }
  const errs = errsAndVals.map((errAndVal) => errAndVal[0]).filter(isNotNull).map((err) => err.message);
  if (errs.length > 0) {
    anonymousLogger().logException(message, errs[0], { allErrors: errs });
    return false;
  }
  return true;
}

// server/src/pubsub/index.ts
import * as crypto5 from "crypto";
import { PubSub } from "graphql-subscriptions";
import { RedisPubSub } from "graphql-redis-subscriptions";
import jsonStableStringify3 from "fast-json-stable-stringify";

// server/src/entity/linked_users/LinkedUsersLoader.ts
import DataLoader4 from "dataloader";
import { Op as Op3 } from "sequelize";
import { unique as unique2 } from "radash";
var LinkedUsersLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.connectedUserDataloader = new DataLoader4(
      async (userOrgIDs) => {
        const uniqUserOrgIDs = unique2(
          userOrgIDs,
          ({ userID, orgID }) => `${userID}/${orgID}`
        );
        const linkedUsers = await LinkedUsersEntity.findAll({
          where: {
            [Op3.or]: uniqUserOrgIDs.map(({ userID, orgID }) => ({
              [Op3.or]: [
                { sourceUserID: userID, sourceOrgID: orgID },
                { linkedUserID: userID, linkedOrgID: orgID }
              ]
            }))
          }
        });
        const index = /* @__PURE__ */ new Map();
        for (const linkedUser of linkedUsers) {
          index.set(
            keyFor({
              userID: linkedUser.sourceUserID,
              orgID: linkedUser.sourceOrgID
            }),
            linkedUser
          );
          index.set(
            keyFor({
              userID: linkedUser.linkedUserID,
              orgID: linkedUser.linkedOrgID
            }),
            linkedUser
          );
        }
        return userOrgIDs.map(
          (userOrgID) => index.get(keyFor(userOrgID)) ?? null
        );
      },
      { cache: false }
    );
    this.loadLinkedUserFromSourceOrgScopedDataloader = new DataLoader4(
      async (userOrgIDs) => {
        const uniqUserOrgIDs = unique2(
          userOrgIDs,
          ({ userID, orgID }) => `${userID}/${orgID}`
        );
        const linkedUsers = await LinkedUsersEntity.findAll({
          where: {
            [Op3.or]: uniqUserOrgIDs.map(({ userID, orgID }) => ({
              sourceUserID: userID,
              sourceOrgID: orgID
            }))
          }
        });
        const index = /* @__PURE__ */ new Map();
        for (const linkedUser of linkedUsers) {
          index.set(
            keyFor({
              userID: linkedUser.sourceUserID,
              orgID: linkedUser.sourceOrgID
            }),
            linkedUser
          );
        }
        return userOrgIDs.map(
          (userOrgID) => index.get(keyFor(userOrgID)) ?? null
        );
      },
      { cache: false }
    );
    this.loadPlatformUserFromLinkedDataloader = new DataLoader4(
      async (input) => {
        const uniqCombinations = unique2(
          input,
          ({ linkedUserID, linkedOrgID, sourceOrgID }) => `${linkedUserID}/${linkedOrgID}/${sourceOrgID}`
        );
        const linkedUsers = await LinkedUsersEntity.findAll({
          where: {
            [Op3.or]: uniqCombinations.map(
              ({ linkedUserID, linkedOrgID, sourceOrgID }) => ({
                linkedUserID,
                linkedOrgID,
                sourceOrgID
              })
            )
          }
        });
        const keyForLinkedUserLinkedOrgSourceOrg = ({
          linkedUserID,
          linkedOrgID,
          sourceOrgID
        }) => `${linkedUserID}/${linkedOrgID}/${sourceOrgID}`;
        const index = /* @__PURE__ */ new Map();
        for (const linkedUser of linkedUsers) {
          index.set(
            keyForLinkedUserLinkedOrgSourceOrg({
              linkedUserID: linkedUser.linkedUserID,
              linkedOrgID: linkedUser.linkedOrgID,
              sourceOrgID: linkedUser.sourceOrgID
            }),
            linkedUser
          );
        }
        return input.map(
          // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
          (input2) => index.get(
            keyForLinkedUserLinkedOrgSourceOrg({
              linkedUserID: input2.linkedUserID,
              linkedOrgID: input2.linkedOrgID,
              sourceOrgID: input2.sourceOrgID
            })
          ) ?? null
        );
      },
      { cache: false }
    );
    this.loadPlatformUserFromLinkedUserIDDataloader = new DataLoader4(
      async (input) => {
        const uniqCombinations = unique2(
          input,
          ({ linkedUserID, sourceOrgID }) => `${linkedUserID}/${sourceOrgID}`
        );
        const linkedUsers = await LinkedUsersEntity.findAll({
          where: {
            [Op3.or]: uniqCombinations.map(({ linkedUserID, sourceOrgID }) => ({
              linkedUserID,
              sourceOrgID
            }))
          }
        });
        const keyForLinkedUserSourceOrg = ({
          linkedUserID,
          sourceOrgID
        }) => `${linkedUserID}/${sourceOrgID}`;
        const index = /* @__PURE__ */ new Map();
        for (const linkedUser of linkedUsers) {
          index.set(
            keyForLinkedUserSourceOrg({
              linkedUserID: linkedUser.linkedUserID,
              sourceOrgID: linkedUser.sourceOrgID
            }),
            linkedUser
          );
        }
        const toReturn = input.map(
          // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
          (input2) => index.get(
            keyForLinkedUserSourceOrg({
              linkedUserID: input2.linkedUserID,
              sourceOrgID: input2.sourceOrgID
            })
          ) ?? null
        );
        return toReturn;
      },
      { cache: false }
    );
    this.loadLatestLinkedUserFromSourceAllOrgsDataloader = new DataLoader4(
      async (sourceUserIDs) => {
        const uniqUserIDs = unique2(sourceUserIDs);
        const linkedUsers = await LinkedUsersEntity.findAll({
          where: {
            sourceUserID: uniqUserIDs
          },
          order: [["linkedTimestamp", "ASC"]]
        });
        const index = /* @__PURE__ */ new Map();
        for (const linkedUser of linkedUsers) {
          index.set(linkedUser.sourceUserID, linkedUser);
        }
        return sourceUserIDs.map(
          (sourceUserID) => index.get(sourceUserID) ?? null
        );
      },
      { cache: false }
    );
  }
  // If we ever need to use this function, then its implementation needs to be
  // fixed. The bug in the current implementation is that a single Slack user
  // can be linked to multiple platform users. This can happen if EITHER within
  // the same platform org multiple users decide to link with the same Slack
  // user OR if multiple platform orgs link with the same Slack org.
  loadConnectedUser_DEPRECATED(userID, orgID) {
    return this.connectedUserDataloader.load({ userID, orgID });
  }
  async loadLinkedUserFromSourceOrgScoped(sourceUserID, sourceOrgID) {
    return await this.loadLinkedUserFromSourceOrgScopedDataloader.load({
      userID: sourceUserID,
      orgID: sourceOrgID
    });
  }
  async loadLatestLinkedUserFromSourceAllOrgs(sourceUserID) {
    return await this.loadLatestLinkedUserFromSourceAllOrgsDataloader.load(
      sourceUserID
    );
  }
  // find linking of a Slack user to a user in a known platform org
  loadPlatformUserFromLinked({
    linkedUserID,
    linkedOrgID,
    sourceOrgID
  }) {
    return this.loadPlatformUserFromLinkedDataloader.load({
      linkedUserID,
      linkedOrgID,
      sourceOrgID
    });
  }
  // find linking of a Slack user to a user in a known platform org (w/o passing
  // slack org id too)
  loadPlatformUserFromLinkedUserID({
    linkedUserID,
    sourceOrgID
  }) {
    return this.loadPlatformUserFromLinkedUserIDDataloader.load({
      linkedUserID,
      sourceOrgID
    });
  }
  static async loadConnectedUsers(userID, orgIDs) {
    const links = await LinkedUsersEntity.findAll({
      where: {
        [Op3.or]: [
          { sourceUserID: userID, sourceOrgID: orgIDs },
          { linkedUserID: userID, linkedOrgID: orgIDs }
        ]
      }
    });
    return links.map(
      (link) => link.sourceUserID === userID ? { userID: link.linkedUserID, orgID: link.linkedOrgID } : { userID: link.sourceUserID, orgID: link.sourceOrgID }
    );
  }
};

// server/src/pubsub/index.ts
var pubSub;
var publishCounter = Counter2({
  name: "PubSubEventPublished",
  help: "Pub-sub events published",
  labelNames: ["name"]
});
var subscribeCounter = Counter2({
  name: "PubSubEventSubscribed",
  help: "Pub-sub events subscribed to",
  labelNames: ["name"]
});
async function initPubSub() {
  if (pubSub !== void 0) {
    throw new Error("PubSub has been already initialised");
  }
  if (process.env.IS_TEST) {
    pubSub = new PubSub();
  } else {
    pubSub = new RedisPubSub({
      publisher: createRedisClient(),
      subscriber: createRedisClient()
    });
  }
}
function getPubSub() {
  if (pubSub === void 0) {
    throw new Error("PubSub has not been initialised");
  }
  return pubSub;
}
function channelName(name, args) {
  return channelNameWithLimit(jsonStableStringify3({ name, args }));
}
function pubSubAsyncIterator(...events) {
  events.forEach(([name]) => subscribeCounter.inc({ name }));
  return getPubSub().asyncIterator(
    events.map(([name, args]) => channelName(name, args))
  );
}
async function subscribeToPubSubEvent(name, args, callback) {
  subscribeCounter.inc({ name });
  return await getPubSub().subscribe(channelName(name, args), callback, {});
}
function unsubscribeFromPubSub(subscriptionID) {
  getPubSub().unsubscribe(subscriptionID);
}
function publishPubSubEvent(name, args, ...payload) {
  publishCounter.inc({ name });
  const event = { name, args, payload: payload[0] ?? null };
  return getPubSub().publish(channelName(name, args), event);
}
async function publishUserIdentityUpdate({
  userID,
  orgID,
  platformApplicationID
}) {
  const skipPublish = await getTypedFeatureFlagValue(
    FeatureFlags2.SKIP_PUBLISH_USER_IDENTITY_UPDATE,
    {
      userID,
      orgID,
      platformApplicationID,
      version: null
    }
  );
  if (skipPublish) {
    anonymousLogger().debug(
      "Returning early from publishUserIdentityUpdate because LaunchDarkly flag is true",
      { userID, orgID, platformApplicationID }
    );
    return;
  }
  const orgIDs = orgID ? [orgID] : (await OrgMembersEntity.findAll({
    where: {
      userID
    }
  })).map((org) => org.orgID);
  const linkedUsers = await LinkedUsersLoader.loadConnectedUsers(
    userID,
    orgIDs
  );
  return await Promise.all([
    publishPubSubEvent("user-identity", { userID }),
    // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
    ...orgIDs.map(
      (orgID2) => publishPubSubEvent("org-user-identity", { orgID: orgID2 }, { userID })
    ),
    // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
    ...linkedUsers.map(
      ({ userID: userID2, orgID: orgID2 }) => publishPubSubEvent("org-user-identity", { orgID: orgID2 }, { userID: userID2 })
    )
  ]);
}
var MAX_CHANNEL_NAME_LENGTH = 1024;
var channelNameWithLimit = (channel) => {
  if (channel.length <= MAX_CHANNEL_NAME_LENGTH) {
    return channel;
  }
  const sha1 = crypto5.createHash("sha1").update(channel).digest("hex");
  return `${sha1}:${channel}`.substring(0, MAX_CHANNEL_NAME_LENGTH);
};

// server/src/asyncTier/jobs/applicationUsageMetrics.ts
import Pg from "pg";

// server/src/util/readReplicaDatabase.ts
function getReadReplicaDbConfigFromEnv(env) {
  return {
    host: env.POSTGRES_READ_HOST ?? env.POSTGRES_HOST,
    port: Number(env.POSTGRES_READ_PORT ?? env.POSTGRES_PORT),
    database: env.POSTGRES_DB,
    user: env.POSTGRES_USER,
    password: env.POSTGRES_PASSWORD
  };
}

// server/src/entity/application_usage_metric/ApplicationUsageMetricMutator.ts
import { QueryTypes as QueryTypes2 } from "sequelize";
var ApplicationUsageMetricMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  /**
   * Persist a batch of application usage metrics.
   *
   * Overwrites any existing values.
   *
   * @param metricID the metric ID for all rows to be written
   * @param data objects containing `applicationID`/`date`/`value` fields
   */
  async writeMetrics(metricID, data) {
    assertServiceViewer(this.viewer);
    await getSequelize().query(
      `INSERT INTO
       application_usage_metrics ("metricID", "applicationID", "date", "value")
       SELECT $1, *
       FROM unnest($2::uuid[], $3::date[], $4::integer[])
       ON CONFLICT ("metricID", "applicationID", "date")
       DO UPDATE SET value=EXCLUDED.value;`,
      {
        type: QueryTypes2.INSERT,
        bind: [
          metricID,
          data.map((d) => d.applicationID),
          data.map((d) => d.date),
          data.map((d) => d.value)
        ]
      }
    );
  }
};

// server/src/entity/application_usage_metric/ApplicationUsageMetricTypeMutator.ts
import { Sequelize as Sequelize8 } from "sequelize";
var ApplicationUsageMetricTypeMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async getOrCreateMetricID(metric) {
    assertServiceViewer(this.viewer);
    const [entity] = await ApplicationUsageMetricTypeEntity.findOrCreate({
      where: { metric },
      defaults: { id: Sequelize8.literal("DEFAULT") }
    });
    return entity.id;
  }
};

// server/src/metrics/applicationUsageMetrics.ts
var applicationUsageMetricTypes = [
  "number_of_messages",
  "users_sent_message",
  "users_sent_message_7d",
  "users_sent_message_28d",
  "users_activated",
  "users_activated_7d",
  "users_activated_28d",
  "users_exposed_to_cord",
  "users_exposed_to_cord_7d",
  "users_exposed_to_cord_28d"
];
function isApplicationUsageMetricType(x) {
  return typeof x === "string" && applicationUsageMetricTypes.includes(x);
}
var applicationUsageMetricsQueries = () => ({
  number_of_messages: {
    // Group all messages by application ID (via their orgID) and the date part
    // of the timestamp and count the number of messages with each appID/date
    // combination. That simply gives us the number of messages written per day
    // in an application.
    query: `
        SELECT
            o."platformApplicationID" AS "applicationID",
            metrics_day(m.timestamp) AS "date",
            COUNT(m) AS "value"
        FROM messages m
        INNER JOIN orgs o ON m."orgID"=o.id
        WHERE o."platformApplicationID" IS NOT NULL
        GROUP BY 1, 2`
  },
  users_sent_message: usersSentMessage(1),
  users_sent_message_7d: usersSentMessage(7),
  users_sent_message_28d: usersSentMessage(28),
  users_activated: usersActivated(1),
  users_activated_7d: usersActivated(7),
  users_activated_28d: usersActivated(28),
  users_exposed_to_cord: usersExposedToCord(1),
  users_exposed_to_cord_7d: usersExposedToCord(7),
  users_exposed_to_cord_28d: usersExposedToCord(28)
});
function usersSentMessage(windowDays) {
  return {
    query: `
      SELECT
        o."platformApplicationID" AS "applicationID",
        metrics_day(m.timestamp) + s.shift AS "date",
        COUNT(DISTINCT m."sourceID") AS "value"
      FROM (SELECT generate_series(0, $1-1) AS shift) s
      CROSS JOIN messages m
      INNER JOIN orgs o ON m."orgID"=o.id
      WHERE o."platformApplicationID" IS NOT NULL
      GROUP BY 1, 2`,
    bind: [windowDays]
  };
}
function usersActivated(windowDays) {
  return {
    query: `
      WITH thread_actions AS NOT MATERIALIZED (
        SELECT DISTINCT
          "threadID",
          "sourceID" AS "userID",
          "orgID",
          metrics_day(timestamp) AS "day"
        FROM messages
        UNION
        SELECT m."threadID", mr."userID", m."orgID", metrics_day(mr.timestamp)
        FROM message_reactions mr INNER JOIN messages m ON mr."messageID"=m.id
      ), thread_user_first_action AS NOT MATERIALIZED (
        SELECT
          "threadID", "userID", "orgID",
          min("day") AS "day"
        FROM thread_actions GROUP BY 1, 2, 3
      ), thread_becomes_active AS (
        SELECT DISTINCT
          "threadID",
          nth_value(day, 2) OVER w AS day
        FROM thread_user_first_action
        WINDOW w AS (PARTITION BY "threadID" ORDER BY day ASC)
      )
      SELECT
        o."platformApplicationID" AS "applicationID",
        ta.day + s.shift AS "date",
        COUNT(DISTINCT ta."userID") AS "value"
      FROM (SELECT generate_series(0, $1-1) AS shift) s
      CROSS JOIN thread_actions ta
      INNER JOIN orgs o ON ta."orgID"=o.id
      INNER JOIN thread_becomes_active tba USING("threadID")
      WHERE o."platformApplicationID" IS NOT NULL
      AND ta.day >= tba.day
      GROUP BY 1, 2`,
    bind: [windowDays]
  };
}
function usersExposedToCord(windowDays) {
  return {
    query: `
      SELECT
        e."platformApplicationID" AS "applicationID",
        metrics_day(e."serverTimestamp") + s.shift AS "date",
        COUNT(DISTINCT e."userID") AS "value"
      FROM (SELECT generate_series(0, $1-1) AS shift) s
      CROSS JOIN events e
      WHERE e."platformApplicationID" IS NOT NULL
      AND e.type = 'sdk-components-used'
      GROUP BY 1,2`,
    bind: [windowDays]
  };
}

// server/src/asyncTier/jobDefinition.ts
var DEFAULT_CONCURRENCY = 25;
var AsyncTierJobDefinition = class {
  constructor(name, func, opts = { concurrency: DEFAULT_CONCURRENCY }) {
    this.name = name;
    this.func = func;
    this.opts = opts;
    this.schedules = [];
  }
  schedule(schedule) {
    this.schedules.push(schedule);
    return this;
  }
  /**
   * Register this job and their schedules with pgboss
   *
   * @param boss The pgboss insance to use
   * @param tier Name of the tier we're running in ('prod', 'staging', 'dev')
   * @param existingSchedulesByName an object mapping schedule names to
   * `PgBoss.Schedule` object. These are the schedules present in the database.
   */
  async register(boss2, tier3, existingSchedulesByName) {
    const handler = async (data, logger) => await this.func(data, logger);
    const wrappedHandler = (job) => {
      const logger = new Logger(Viewer.createAnonymousViewer(), {
        job: {
          id: job.id,
          name: job.name,
          data: job.data
        }
      });
      logger.debug(`Starting job '${job.name}':${job.id}`);
      handler(job.data, logger).then(
        (result) => {
          job.done(null, result);
          logger.debug(`Completed job '${job.name}':${job.id}`);
        },
        (err) => {
          try {
            logger.logException(
              `Exception thrown by job '${job.name}':${job.id} : ${err}`,
              err
            );
          } catch {
          }
          job.done(err);
        }
      );
    };
    const bossOpts = this.opts.concurrency > 1 ? {
      teamSize: this.opts.concurrency,
      teamConcurrency: this.opts.concurrency,
      teamRefill: true
    } : {};
    await boss2.work(this.name, bossOpts, wrappedHandler);
    for (const schedule of this.schedules) {
      if (schedule.tier === "all" || schedule.tier === tier3) {
        const scheduledJobName = `schedule:${this.name}:${schedule.name}`;
        const existingSchedule = existingSchedulesByName.get(scheduledJobName);
        if (existingSchedule) {
          existingSchedulesByName.delete(scheduledJobName);
        }
        const existingScheduleUpToDate = existingSchedule && existingSchedule.cron === schedule.cron && isEqual(existingSchedule.data, schedule.data);
        if (!existingScheduleUpToDate) {
          if (existingSchedule) {
            await boss2.unschedule(scheduledJobName);
          }
          await boss2.schedule(scheduledJobName, schedule.cron, schedule.data, {
            tz: "UTC"
          });
        }
        await boss2.work(scheduledJobName, wrappedHandler);
      }
    }
  }
};

// server/src/asyncTier/jobs/applicationUsageMetrics.ts
var applicationUsageMetrics_default = new AsyncTierJobDefinition(
  "applicationUsageMetrics",
  applicationUsageMetricsJob
).schedule({
  tier: "staging",
  name: "daily",
  cron: "30 6 * * *",
  // At 6:30am UTC every day
  data: {}
});
async function applicationUsageMetricsJob(options, logger) {
  const config = getReadReplicaDbConfigFromEnv(Env_default);
  const pg = new Pg.Client(config);
  await pg.connect();
  await pg.query("SET search_path=cord,public;");
  const metricQueries = applicationUsageMetricsQueries();
  const metrics = options.metrics ?? Object.keys(metricQueries);
  for (const metric of metrics) {
    if (isApplicationUsageMetricType(metric)) {
      await materialiseMetric(
        pg,
        logger,
        metric,
        metricQueries[metric],
        options.days,
        options.overwriteDays
      );
    } else {
      logger.warn(
        "applicationUsageMetricsJob: invalid metric given in job data",
        { metric }
      );
    }
  }
}
async function materialiseMetric(pg, logger, metric, definition, days, overwriteDays) {
  const { query } = definition;
  const metricID = await new ApplicationUsageMetricTypeMutator(
    Viewer.createServiceViewer()
  ).getOrCreateMetricID(metric);
  const bind = definition.bind ? [...definition.bind] : [];
  bind.push(days ?? definition.days ?? 30);
  const daysPlaceholder = `$${bind.length}`;
  bind.push(overwriteDays ?? 2);
  const overwriteDaysPlaceholder = `$${bind.length}`;
  bind.push(metricID);
  const metricIDPlaceholder = `$${bind.length}`;
  const wrappedQuery = `    WITH q AS (${query.trim()})
    SELECT
      a.id AS "applicationID",
      d.date::text AS "date",
      COALESCE(q.value, 0)::integer AS "value"
    FROM applications a
    CROSS JOIN (
      SELECT CURRENT_DATE-generate_series(1,${daysPlaceholder}) AS "date"
    ) d
    LEFT OUTER JOIN q ON (q."applicationID", q."date")=(a."id", d."date")
    LEFT OUTER JOIN application_usage_metrics exm
    ON (exm."applicationID", exm."metricID", exm."date")=
      (a."id", ${metricIDPlaceholder}, d."date")
    WHERE d."date" >= a."createdTimestamp"::date
    AND (
      exm IS NULL
      OR d."date" >= (CURRENT_DATE-${overwriteDaysPlaceholder}::integer)
    );`;
  const startTime = performance.now();
  const { rows } = await pg.query(wrappedQuery, bind).finally(() => {
    const endTime = performance.now();
    logger.info("applicationUsageMetricsJob: materialiseMetric - query", {
      metric,
      query: wrappedQuery,
      bind,
      durationMS: endTime - startTime
    });
  });
  if (rows.length) {
    logger.info("applicationUsageMetricsJob: materialiseMetric - write", {
      metric,
      rows: rows.length
    });
    await new ApplicationUsageMetricMutator(
      Viewer.createServiceViewer()
    ).writeMetrics(metricID, rows);
  }
}

// server/src/asyncTier/jobs/asyncWorkerHealthCheck.ts
var asyncWorkerHealthCheck_default = new AsyncTierJobDefinition(
  "asyncWorkerHealthCheck",
  asyncWorkerHealthCheck
).schedule({
  tier: "all",
  name: "everyOtherMinute",
  cron: "*/2 * * * *",
  // At every 2nd minute https://crontab.guru/#*/2_*_*_*_*
  data: {}
});
async function asyncWorkerHealthCheck(_, logger) {
  try {
    await getSequelize().query("SELECT 1;");
  } catch (e) {
    logger.logException("PgBoss health check failed to read table", e);
  }
  try {
    await publishPubSubEvent("pub-sub-health-check", null);
  } catch (e) {
    logger.logException("PgBoss health check failed to publish to pubsub", e);
  }
}

// server/src/asyncTier/jobs/checkAWSCredentials.ts
import { GetCredentialReportCommand, IAMClient } from "@aws-sdk/client-iam";

// ops/aws/src/radical-stack/Config.ts
var AWS_REGION = "eu-west-2";

// server/src/slack/util.ts
import * as url5 from "url";
import { v4 as uuid24 } from "uuid";
import * as jwt10 from "jsonwebtoken";
import { Op as Op25 } from "sequelize";

// server/src/entity/user/util.ts
async function loadLinkedSlackUserOrgScoped(user, context, orgID) {
  if (user.externalProvider === "slack") {
    return user;
  }
  const linkedUser = await context.loaders.linkedUsersLoader.loadLinkedUserFromSourceOrgScoped(
    user.id,
    orgID
  );
  if (!linkedUser) {
    return null;
  }
  return await context.loaders.userLoader.loadUser(linkedUser.linkedUserID);
}
async function detailsForDisplay(user, context) {
  async function determineUser() {
    let platformUser = user.externalProvider === "platform" ? user : null;
    if (user.externalProvider === "slack") {
      if (!context.session.viewer.platformApplicationID) {
        return {
          id: user.id,
          ...getUnifiedProfile(null, user, void 0)
        };
      }
      let linking = null;
      if (context.session.viewer.orgID) {
        linking = await context.loaders.linkedUsersLoader.loadPlatformUserFromLinkedUserID(
          {
            linkedUserID: user.id,
            sourceOrgID: context.session.viewer.orgID
          }
        );
      }
      platformUser = linking ? await context.loaders.userLoader.loadUser(linking.sourceUserID) : null;
      if (platformUser?.state === "deleted") {
        platformUser = null;
      }
    }
    if (!platformUser) {
      return {
        id: user.id,
        ...getUnifiedProfile(null, user, void 0)
      };
    }
    const mostRecentLinking = await context.loaders.linkedUsersLoader.loadLatestLinkedUserFromSourceAllOrgs(
      platformUser.id
    );
    const mostRecentLinkedProfile = mostRecentLinking ? await context.loaders.userLoader.loadUser(
      mostRecentLinking.linkedUserID
    ) : null;
    const displayDetails = getUnifiedProfile(
      platformUser,
      mostRecentLinkedProfile,
      mostRecentLinking?.linkedTimestamp
    );
    return {
      id: user.id,
      name: displayDetails.name ?? emailUsername(user.email, context.logger) ?? "Unknown",
      screenName: displayDetails.screenName,
      profilePictureURL: displayDetails.profilePictureURL ?? null
    };
  }
  const consolidatedUser = await determineUser();
  return {
    ...consolidatedUser,
    displayName: userDisplayName(consolidatedUser),
    fullName: userFullName(consolidatedUser)
  };
}
function emailUsername(email, logger) {
  if (!email) {
    return null;
  }
  const atIndex = email.lastIndexOf("@");
  if (atIndex === -1) {
    logger.error("profile with strange email - @ missing", {
      email
    });
    return email;
  }
  return email.substring(0, atIndex);
}
function getUnifiedProfile(platformUser, slackUser, linkedTimestamp) {
  if (!platformUser && !slackUser) {
    throw new Error("Must have at least one profile");
  }
  if (!platformUser) {
    return {
      name: slackUser.name,
      screenName: slackUser.screenName,
      profilePictureURL: slackUser.profilePictureURL
    };
  }
  const nameOptions = [
    {
      // Api uploaded via platform api
      timestamp: platformUser.nameUpdatedTimestamp,
      fields: {
        name: platformUser.name,
        // in practice screenName can only be set via Slack
        screenName: platformUser.screenName
      }
    },
    // Linked info: a platform user linked to a Slack user
    {
      timestamp: linkedTimestamp,
      fields: {
        name: slackUser?.name ?? null,
        screenName: slackUser?.screenName ?? null
      }
    }
  ];
  const profilePictureOptions = [
    // Api uploaded: via slack for extension user, or platform api for sdk user
    {
      timestamp: platformUser.profilePictureURLUpdatedTimestamp,
      fields: {
        profilePictureURL: platformUser.profilePictureURL
      }
    },
    // Linked info: a platform user linked to a Slack user
    {
      timestamp: linkedTimestamp,
      fields: {
        profilePictureURL: slackUser?.profilePictureURL ?? null
      }
    }
  ];
  const mostRecentNames = nameOptions.reduce(
    (acc, el) => !acc.timestamp || el.timestamp && el.timestamp > acc.timestamp ? el : acc
  );
  const mostRecentProfilePictureURL = profilePictureOptions.reduce(
    (acc, el) => !acc.timestamp || el.timestamp && el.timestamp > acc.timestamp ? el : acc
  );
  return { ...mostRecentNames.fields, ...mostRecentProfilePictureURL.fields };
}
var userDisplayName = (user) => user.screenName || user.name || "unknown";
var userFullName = (user) => user.name || user.screenName || "Unknown";

// common/uploads/index.ts
import { Buffer as Buffer2 } from "buffer";
import isValidDataURL from "valid-data-url";
var MAX_UPLOAD_SIZE = 100 * 1024 * 1024;
var MAX_PROFILE_PICTURE_UPLOAD_SIZE = 5 * 1024 * 1024;
var RESIZE_PROFILE_PICTURE_THRESHOLD = 0.1 * 1024 * 1024;
var MAX_APPLICATION_ASSET_UPLOAD_SIZE = 5 * 1024 * 1024;
var MIN_RESIZED_PROFILE_PICTURE_DIMENSION = 512;
var ALLOWED_APPLICATION_ASSET_MIME_TYPES = [
  "image/jpeg",
  "image/jpg",
  "image/png",
  "image/gif"
];
var ALLOWED_PROFILE_PICTURE_MIME_TYPES = [
  "image/jpeg",
  "image/jpg",
  "image/png"
];
var BANNED_FILE_EXTENSIONS = [
  ".7z",
  // 7-ZIP
  ".ade",
  // Microsoft Access project extension
  ".adp",
  // Microsoft Access project
  ".apk",
  // Android application
  ".app",
  // Windows application
  ".application",
  // ClickOnce deployment manifest file
  ".appref-ms",
  // ClickOnce application reference file
  ".appx",
  // Windows application
  ".appxbundle",
  // Windows application
  ".asp",
  // ASP file
  ".aspx",
  // ASP file
  ".asx",
  // ASF redirector file
  ".bas",
  // BASIC source code
  ".bat",
  // Windows batch file
  ".bgi",
  // Borland graphics interface
  ".cab",
  // Windows cabinet file
  ".cer",
  // Certificate file
  ".chm",
  // Windows help module
  ".cmd",
  // Windows command script
  ".cnt",
  // Microsoft help workshop application
  ".com",
  // Windows command script
  ".cpl",
  // Windows control panel
  ".crt",
  // Certificate file
  ".csh",
  // csh script
  ".der",
  // X509 certificate file
  ".diagcab",
  // Windows troubleshooting cabinet file
  ".diagcfg",
  // Windows troubleshooting config file
  ".dll",
  // Windows dynamically linked library
  ".dmg",
  // MacOS disk image
  ".exe",
  // Windows executable
  ".fxp",
  // Microsoft FoxPro compiled source
  ".gadget",
  // Windows Vista gadget
  ".grp",
  // Microsoft program group
  ".gz",
  // GZip file
  ".hlp",
  // Windows help file
  ".hpj",
  // AppWizard Help project
  ".hta",
  // HTML application file
  ".htc",
  // HTML component file
  ".img",
  // Disk image
  ".inf",
  // Information or setup file
  ".ins",
  // Windows internet settings file
  ".ipa",
  // iOS application
  ".iso",
  // Disk image
  ".isp",
  // IIS internet settings file
  ".its",
  // Internet document set
  ".jar",
  // Java binary code
  ".jnlp",
  // Java Web Start file
  ".js",
  // JavaScript source file
  ".jse",
  // JScript encoded file
  ".jsp",
  // Jakarta server pages source file
  ".ksh",
  // ksh shell script
  ".lib",
  // Generic library file
  ".lnk",
  // Windows shortcut
  ".mad",
  // Microsoft Access module shortcut
  ".maf",
  // Microsoft Access file
  ".mag",
  // Microsoft Access diagram shortcut
  ".mam",
  // Microsoft Access macro shortcut
  ".maq",
  // Microsoft Access query shortcut
  ".mar",
  // Microsoft Access report shortcut
  ".mas",
  // Microsoft Access stored procedures
  ".mat",
  // Microsoft Access table shortcut
  ".mau",
  // Media attachment unit
  ".mav",
  // Microsoft Access view shortcut
  ".maw",
  // Microsoft Access data access page
  ".mcf",
  // Media container format
  ".mda",
  // Microsoft Access add-in
  ".mdb",
  // Microsoft Access application
  ".mde",
  // Microsoft Access add-in
  ".mdt",
  // Microsoft Access add-in data
  ".mdw",
  // Microsoft Access workgroup information
  ".mdz",
  // Microsoft Access wizard template
  ".msc",
  // Microsoft management console snap-in
  ".msh",
  // Microsoft shell
  ".msh1",
  // Microsoft shell
  ".msh1xml",
  // Microsoft shell
  ".msh2",
  // Microsoft shell
  ".msh2xml",
  // Microsoft shell
  ".mshxml",
  // Microsoft shell
  ".msi",
  // Windows installer
  ".msix",
  // Windows installer
  ".msixbundle",
  // Windows installer
  ".msp",
  // Windows OS patch file
  ".mst",
  // Windows installer settings file
  ".msu",
  // Windows update file
  ".nsh",
  // Nullsoft installer file
  ".ops",
  // Office profile settings file
  ".osd",
  // Open software description
  ".pcd",
  // Microsoft visual test
  ".pif",
  // Windows shortcut
  ".pl",
  // Perl script
  ".plg",
  // Developer Studio build log
  ".prf",
  // Windows system file
  ".prg",
  // Windows program file
  ".printerexport",
  // Printer backup File
  ".ps1",
  // Windows PowerShell script
  ".ps1xml",
  // Windows PowerShell script
  ".ps2",
  // Windows PowerShell script
  ".ps2xml",
  // Windows PowerShell script
  ".psc1",
  // Windows PowerShell script
  ".psc2",
  // Windows PowerShell script
  ".psd1",
  // Windows PowerShell script
  ".psdm1",
  // Windows PowerShell script
  ".pst",
  // MS Exchange address book file
  ".py",
  // Python script
  ".pyc",
  // Python script
  ".pyo",
  // Python script
  ".pyw",
  // Python script
  ".pyz",
  // Python script
  ".pyzw",
  // Python script
  ".reg",
  // Windows Registry file
  ".scf",
  // Windows Explorer command
  ".scr",
  // Windows screensaver
  ".sct",
  // Windows scriptlet
  ".shb",
  // Windows shortcut
  ".shs",
  // Shell scrap object
  ".sys",
  // Windows system settings
  ".tar",
  // TAR archive file
  ".theme",
  // Windows desktop theme
  ".tmp",
  // Temporary file
  ".url",
  // URL file
  ".vb",
  // Visual Basic source file
  ".vbe",
  // Visual Basic executable
  ".vbp",
  // Visual Basic project file
  ".vbs",
  // Visual Basic script file
  ".vhd",
  // Windows Virtual PC hard disk image
  ".vhdx",
  // Windows Virtual PC hard disk image
  ".vsmacros",
  // Visual Studio macros
  ".vsw",
  // Microsoft Visio workspace file
  ".vxd",
  // Windows virtual device driver
  ".webpnp",
  // Internet printing file
  ".website",
  // IE pinned site shortcut
  ".ws",
  // Windows script file
  ".wsc",
  // Windows scripting component
  ".wsf",
  // Windows script file
  ".wsh",
  // Windows script settings file
  ".xbap",
  // Browser applications
  ".xll",
  // Excel plugin
  ".xnk"
  // Exchange public folder shortcut
];
var BANNED_MIME_TYPES = [
  "application/x-msdownload",
  // Windows executable
  "application/x-ms-installer"
  // Windows installer
];
var ALLOWED_APPLICATION_ASSET_NAMES = [
  "icon",
  "email-logo",
  "nux-initial-open-image",
  "nux-welcome-image",
  "support-avatar"
];
var UPLOAD_VALIDATORS = {
  application_asset: {
    nameValidator: (name) => ALLOWED_APPLICATION_ASSET_NAMES.includes(
      name
    ),
    mimeTypeValidator: (mimeType) => ALLOWED_APPLICATION_ASSET_MIME_TYPES.includes(mimeType),
    maxSize: MAX_APPLICATION_ASSET_UPLOAD_SIZE
  },
  profile_picture: {
    nameValidator: (name) => {
      const lowerName = name.toLowerCase();
      return BANNED_FILE_EXTENSIONS.every((ext) => !lowerName.endsWith(ext));
    },
    mimeTypeValidator: (mimeType) => ALLOWED_PROFILE_PICTURE_MIME_TYPES.includes(mimeType),
    maxSize: MAX_PROFILE_PICTURE_UPLOAD_SIZE
  },
  attachment: {
    nameValidator: (name) => {
      const lowerName = name.toLowerCase();
      return BANNED_FILE_EXTENSIONS.every((ext) => !lowerName.endsWith(ext));
    },
    mimeTypeValidator: (mimeType) => !BANNED_MIME_TYPES.includes(mimeType),
    maxSize: MAX_UPLOAD_SIZE
  }
};
function validateFileForUpload(kind, input) {
  const { name, mimeType, size } = input;
  const validator = UPLOAD_VALIDATORS[kind];
  if (!validator) {
    throw new Error(`Could not find validator for type ${kind}`);
  }
  return {
    input,
    name: validator.nameValidator(name),
    mimeType: validator.mimeTypeValidator(mimeType),
    size: size < validator.maxSize,
    get valid() {
      return this.name && this.mimeType && this.size;
    }
  };
}
function assertValid(result) {
  if (!result.name) {
    throw new Error(`Cannot upload file named ${result.input.name}`);
  }
  if (!result.size) {
    throw new Error(`Maximum file size exceeded`);
  }
  if (!result.mimeType) {
    throw new Error(`Input ${result.input.mimeType} MIME type is not allowed`);
  }
}

// opensource/sdk-js/packages/react/common/lib/uploads.ts
var ALLOWED_INLINE_IMAGE_MIME_TYPES = [
  "image/jpeg",
  "image/png",
  "image/apng",
  "image/webp",
  "image/bmp",
  "image/tiff",
  "image/gif"
];
function isInlineDisplayableImage(mimeType) {
  return ALLOWED_INLINE_IMAGE_MIME_TYPES.includes(mimeType);
}

// server/src/slack/api.ts
import * as Slack from "@slack/web-api";
import { unique as unique3 } from "radash";

// common/util/oauth.ts
var slackAuthRedirectHost = SLACK_APP_REDIRECT_HOST ?? API_SERVER_HOST;
var slackAuthRedirectStatePrefix = SLACK_APP_REDIRECT_HOST ? `[${API_SERVER_HOST}]` : "";
var slackAuthRedirectURI = (isDevApp) => `https://${slackAuthRedirectHost}/auth/slack/redirect/${isDevApp ? "dev" : ""}`;
var slackLoginURL = (state, team, customClientID) => {
  const logInToSlackDevApp = team === CORD_TEST_SLACK_TEAM_ID;
  const redirectURI = slackAuthRedirectURI(logInToSlackDevApp);
  const clientID = customClientID ?? (logInToSlackDevApp ? SLACK_DEV_APP_CLIENT_ID : SLACK_APP_CLIENT_ID);
  const botOAuthScopes = [
    "channels:history",
    "channels:join",
    "channels:read",
    "chat:write",
    "chat:write.customize",
    "im:history",
    "im:write",
    "team:read",
    "users:read",
    "users:read.email",
    "files:read"
  ];
  return [
    "https://slack.com/oauth/v2/authorize?",
    `scope=${botOAuthScopes.join(",")}`,
    `&client_id=${clientID}`,
    `&redirect_uri=${encodeURIComponent(redirectURI)}`,
    `&state=${slackAuthRedirectStatePrefix}${state}`,
    team ? `&team=${team}` : ""
  ].join("");
};
var JIRA_AUTH_REDIRECT_URL = `https://${API_SERVER_HOST_PRODUCTION}/auth/jira/redirect/`;
var ASANA_AUTH_REDIRECT_URL = `https://${API_SERVER_HOST}/auth/asana/redirect/`;
var LINEAR_AUTH_REDIRECT_URL = `https://${API_SERVER_HOST}/auth/linear/redirect/`;
var TRELLO_AUTH_REDIRECT_URL = `https://${API_SERVER_HOST}/auth/trello/redirect/`;
var TRELLO_AUTH_LOGIN_URL = `https://${API_SERVER_HOST}/auth/trello/login/`;
var MONDAY_AUTH_REDIRECT_URL = `https://${API_SERVER_HOST}/auth/monday/redirect/`;

// server/src/slack/api.ts
async function fetchAuthedSlackUser(code, isDevApp, decodedState) {
  const slackClient2 = new Slack.WebClient();
  const redirectURI = slackAuthRedirectURI(isDevApp);
  const platformApplication = await ApplicationEntity.findByPk(
    decodedState.data.platformApplicationID
  );
  if (!platformApplication) {
    throw new Error("Linking error - unable to find platform app");
  }
  const customAppDetails = platformApplication.getCustomSlackAppDetails();
  const clientId = customAppDetails?.clientID ?? (isDevApp ? SLACK_DEV_APP_CLIENT_ID : SLACK_APP_CLIENT_ID);
  const clientSecret = customAppDetails?.clientSecret ?? (isDevApp ? Env_default.SLACK_DEV_APP_CLIENT_SECRET : Env_default.SLACK_APP_CLIENT_SECRET);
  const response = await slackClient2.oauth.v2.access({
    code,
    client_id: clientId,
    client_secret: clientSecret,
    redirect_uri: redirectURI
  });
  if (!response.ok) {
    let msg = "Slack OAuth Failure";
    if (response.error) {
      msg += ": " + response.error;
    }
    throw new Error(msg);
  }
  return response;
}
async function fetchSlackUserInfo(id, accessToken) {
  const slackClient2 = new Slack.WebClient(accessToken);
  const response = await slackClient2.users.info({ user: id });
  return response;
}
async function fetchSlackUsersList(accessToken) {
  let users = [];
  const slackClient2 = new Slack.WebClient(accessToken);
  let cursor = void 0;
  do {
    const response = await slackClient2.users.list({
      cursor,
      limit: 500
    });
    users = [...users, ...response.members];
    cursor = response.response_metadata?.next_cursor;
  } while (cursor !== void 0 && cursor !== "");
  return users;
}
async function fetchSlackTeamInfo(accessToken) {
  const slackClient2 = new Slack.WebClient(accessToken);
  const response = await slackClient2.team.info();
  return response;
}
async function sendPrivateMessage(accessToken, recipientUserID, notificationText, messageBlocks, username, iconURL) {
  if (process.env.IS_TEST) {
    return null;
  }
  const slackClient2 = new Slack.WebClient(accessToken);
  try {
    const conversationResponse = await slackClient2.conversations.open({
      users: [recipientUserID].join(","),
      return_im: true
      // This tells us if the channel is new, so we can send a NUX message.
    });
    if (!conversationResponse.ok || !conversationResponse.channel?.id) {
      console.log(conversationResponse);
      return null;
    }
    const channelId = conversationResponse.channel.id;
    const response = await slackClient2.chat.postMessage({
      channel: channelId,
      text: notificationText,
      // used for notifications
      blocks: messageBlocks,
      // Actual body of the message
      username,
      icon_url: iconURL
    });
    if (!response.ok) {
      console.log(response);
      return null;
    }
    return {
      channelID: response.channel,
      timestamp: response.ts
    };
  } catch (e) {
    console.log(e);
    return null;
  }
}
async function sendChannelMessage({
  slackBotCredentials,
  channelID,
  text,
  blocks,
  threadTS,
  username,
  iconURL
}) {
  const slackClient2 = new Slack.WebClient(slackBotCredentials.bot_access_token);
  try {
    const response = await slackClient2.chat.postMessage({
      channel: channelID,
      thread_ts: threadTS,
      text,
      ...blocks ? { blocks } : {},
      username,
      icon_url: iconURL
    });
    if (!response.ok) {
      console.log(response);
      return null;
    }
    return {
      channelID: response.channel,
      timestamp: response.ts
    };
  } catch (e) {
    console.log(e);
    return null;
  }
}
async function sendHelpMessage(accessToken, recipientUserID, text, onlyPostIfConversationEmpty = false) {
  const slackClient2 = new Slack.WebClient(accessToken);
  const conversationResponse = await slackClient2.conversations.open({
    users: recipientUserID,
    return_im: true
    // This tells us if the channel is new, so we can send a NUX message.
  });
  if (!conversationResponse.ok || !conversationResponse.channel?.id) {
    throw new Error("conversations.open failed");
  }
  const channelId = conversationResponse.channel.id;
  if (onlyPostIfConversationEmpty && conversationResponse.channel?.latest) {
    return;
  }
  const postMessageResponse = await slackClient2.chat.postMessage({
    channel: channelId,
    text,
    blocks: [{ type: "section", text: { type: "mrkdwn", text } }]
  });
  if (!postMessageResponse.ok) {
    throw new Error("conversations.open failed");
  }
}
async function addCordBotToSlackChannels(_context, botAccessToken, channelIDs) {
  const slackClient2 = new Slack.WebClient(botAccessToken);
  return await Promise.all(
    channelIDs.map(
      (channel) => slackClient2.conversations.join({ channel }).then(
        (_) => ({ success: true, channelID: channel, error: null }),
        (error) => ({ success: false, channelID: channel, error })
      )
    )
  );
}
async function fetchSlackChannelList(slackClient2) {
  let cursor = void 0;
  const channels = [];
  do {
    const response = await slackClient2.conversations.list({
      cursor,
      types: "public_channel"
    });
    if (!isValidSlackChannelsListResponse(response)) {
      throw new Error(
        "Malformed Slack API response (conversations.list.channels)"
      );
    }
    if (!response.ok) {
      throw new Error("conversations.list failed");
    }
    channels.push(...response.channels);
    cursor = response.response_metadata?.next_cursor;
  } while (cursor);
  return unique3(channels, ({ id }) => id).map(
    ({ id, name, num_members, is_archived }) => ({
      id,
      name,
      users: num_members,
      archived: is_archived
    })
  );
}
function isValidSlackChannelsListResponse(resp) {
  return resp && typeof resp === "object" && Array.isArray(resp.channels) && resp.channels.every(
    (x) => typeof x.id === "string" && typeof x.name === "string" && typeof x.num_members === "number" && typeof x.is_archived === "boolean"
  );
}

// server/src/RequestContext.ts
import { v4 as uuid4 } from "uuid";

// server/src/entity/application/ApplicationLoader.ts
import DataLoader5 from "dataloader";
import { QueryTypes as QueryTypes3 } from "sequelize";
var ApplicationLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader5(
      async (keys) => {
        const buckets = await ApplicationEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrder(buckets, keys);
      },
      { cache: false }
    );
  }
  async load(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("Application dataloader error", e);
      return null;
    }
  }
  async loadAll() {
    return await ApplicationEntity.findAll();
  }
  async loadApplicationsForConsoleUser(customerID) {
    return await ApplicationEntity.findAll({
      where: { customerID },
      order: [["name", "ASC"]]
    });
  }
  async countActiveUsersForApplications(applicationIDs) {
    if (!applicationIDs.length) {
      return /* @__PURE__ */ new Map();
    }
    const results = await getSequelize().query(
      `SELECT applications.id AS id, COUNT(users) AS users_count
        FROM cord.applications
        LEFT JOIN cord.users on users."platformApplicationID" = applications.id
        WHERE applications.id IN (:application_ids)
        AND users.state = 'active'
        GROUP BY applications.id;`,
      {
        replacements: { application_ids: applicationIDs },
        type: QueryTypes3.SELECT
      }
    );
    const retval = /* @__PURE__ */ new Map();
    results.forEach((r) => retval.set(r.id, r.users_count));
    return retval;
  }
  async countOrgsForApplications(applicationIDs) {
    if (!applicationIDs.length) {
      return /* @__PURE__ */ new Map();
    }
    const results = await getSequelize().query(
      `SELECT applications.id AS id, COUNT(orgs) AS orgs_count
      FROM cord.applications
      LEFT JOIN cord.orgs on orgs."platformApplicationID" = applications.id
      WHERE applications.id IN (:application_ids)
      GROUP BY applications.id;`,
      {
        replacements: { application_ids: applicationIDs },
        type: QueryTypes3.SELECT
      }
    );
    const retval = /* @__PURE__ */ new Map();
    results.forEach((r) => retval.set(r.id, r.orgs_count));
    return retval;
  }
  async getFirstOrgInApplication(applicationID) {
    const orgs = await OrgEntity.findAll({
      where: {
        platformApplicationID: applicationID
      },
      order: [["createdTimestamp", "ASC"]],
      limit: 1
    });
    return orgs[0];
  }
  async getFirstUserInApplication(applicationID) {
    const users = await UserEntity.findAll({
      where: {
        platformApplicationID: applicationID
      },
      order: [["createdTimestamp", "ASC"]],
      limit: 1
    });
    return users[0];
  }
  async isComponentInitializedForApplication(applicationID) {
    const [{ exists: initializedEventExists }] = await getSequelize().query(
      `SELECT EXISTS (
        SELECT 1 FROM events e
        WHERE e.type = 'sdk-components-used'
        AND e."platformApplicationID" = $1
      )`,
      {
        bind: [applicationID],
        type: QueryTypes3.SELECT
      }
    );
    return initializedEventExists;
  }
};

// server/src/entity/heimdall/HeimdallLoader.ts
var HeimdallLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async load(key) {
    return await HeimdallEntity.findOne({
      where: { key, tier: Env_default.CORD_TIER }
    });
  }
  async loadAll() {
    return await HeimdallEntity.findAll({ where: { tier: Env_default.CORD_TIER } });
  }
};

// server/src/logging/segment.ts
import { Analytics } from "@segment/analytics-node";
var SegmentLogger = class {
  constructor(session, clientVersion, connectionID, deployment, switchedOn, application) {
    this.session = session;
    this.clientVersion = clientVersion;
    this.connectionID = connectionID;
    this.deployment = deployment;
    this.switchedOn = switchedOn;
    if (application?.segmentWriteKey) {
      this.partnerAnalytics = new Analytics({
        writeKey: application.segmentWriteKey
      });
    } else {
      this.partnerAnalytics = null;
    }
  }
  partnerLog(eventName, metadata, payload, customEventMetadata) {
    if (this.switchedOn && this.partnerAnalytics !== null && this.session.viewer.externalUserID && INCLUDED_EVENTS.has(eventName)) {
      this.partnerAnalytics.track({
        userId: this.session.viewer.externalUserID,
        event: "cord-" + eventName,
        properties: {
          organization_id: this.session.viewer.externalOrgID,
          group_id: this.session.viewer.externalOrgID,
          location: metadata.url,
          method: payload.method,
          type: payload.type,
          task_provider: payload.provider,
          mentions: payload.mentions,
          attachments: payload.attachments,
          annotations: payload.annotations,
          new_thread: payload.newThread,
          cord_location: payload.location,
          to: payload.to,
          thread_id: payload.threadID,
          message_id: payload.messageID,
          service: payload.service,
          reason: payload.reason,
          email: payload.email,
          success: payload.success,
          custom_event_metadata: customEventMetadata
        },
        timestamp: /* @__PURE__ */ new Date()
      });
    }
  }
  publishMessageSendEvent(thread, message, newThread, mentionsCount) {
    const metadata = {
      url: thread.url
    };
    const payload = {
      mentions: mentionsCount,
      threadID: thread.externalID,
      newThread,
      messageID: message.externalID
    };
    const customEventMetadata = {};
    this.partnerLog("message-send", metadata, payload, customEventMetadata);
  }
};
var INCLUDED_EVENTS = /* @__PURE__ */ new Set([
  "click-share-thread-to-email-submit-button",
  "click-thread-menu-share-to-email",
  "click-upgrade-plan",
  "connect-service-failed",
  "connect-service-started",
  "connect-service-successful",
  "create-new-profile",
  "create-task",
  "disconnect-service",
  "hover-for-presence",
  "insert-assignee",
  "insert-mention",
  "logout",
  "message-delete-undone",
  "message-deleted",
  "message-send",
  /* Added to support a customer who uses the customEventMetadata field
  that message-send used to send before we moved it server side 
  */
  "message-send-ui",
  "message-updated",
  "navigate-to",
  "remove-task",
  "render-embedded-launcher",
  "render-sidebar-open",
  "select-profile",
  "slack-login-launched",
  "subscribed-to-thread",
  "thread-resolved",
  "thread-shared-to-email",
  "thread-unresolved",
  "toggle-sidebar-visibility",
  "unsubscribed-from-thread",
  "update-profile"
]);

// common/const/HeimdallSwitches.ts
var heimdallSwitches = {
  AUTOMATIC_DEPLOYS_ON: "automaticDeploy",
  // We only do automatic deployments when this is true.
  LOG_TO_SEGMENT: "LogToSegment"
  // We only log to segment when this is true
};
var HeimdallSwitches_default = heimdallSwitches;

// server/src/entity/user/UserLoader.ts
import DataLoader7 from "dataloader";
import { unique as unique5 } from "radash";
import { QueryTypes as QueryTypes4 } from "sequelize";

// server/src/entity/linked_orgs/LinkedOrgsLoader.ts
import { Op as Op4 } from "sequelize";
import DataLoader6 from "dataloader";
import { unique as unique4 } from "radash";
var LinkedOrgsLoader = class {
  constructor(viewer, cache2 = false) {
    this.allConnectedOrgIDsPromise = null;
    this.viewer = viewer;
    this.linkedSlackOrgIDDataloader = new DataLoader6(
      async (sourceOrgIDs) => {
        const uniqOrgIDs = unique4(sourceOrgIDs);
        const linkedOrgs = await LinkedOrgsEntity.findAll({
          where: {
            sourceOrgID: uniqOrgIDs
          }
        });
        const index = new Map(
          linkedOrgs.map((linkedOrg) => [linkedOrg.sourceOrgID, linkedOrg])
        );
        return sourceOrgIDs.map(
          (sourceOrgID) => index.get(sourceOrgID)?.linkedOrgID || null
        );
      },
      { cache: cache2 }
    );
  }
  async getConnectedSlackOrgID(orgID) {
    return await this.linkedSlackOrgIDDataloader.load(orgID);
  }
  async getAllConnectedOrgIDsImpl() {
    const orgIDs = assertViewerHasOrgs(this.viewer);
    const orgLinks = await LinkedOrgsEntity.findAll({
      where: {
        [Op4.or]: [{ sourceOrgID: orgIDs }, { linkedOrgID: orgIDs }]
      }
    });
    const orgIDsSet = new Set(orgIDs);
    return orgLinks.map(
      (orgLink) => orgIDsSet.has(orgLink.sourceOrgID) ? orgLink.linkedOrgID : orgLink.sourceOrgID
    );
  }
  async getAllConnectedOrgIDs() {
    if (this.allConnectedOrgIDsPromise === null) {
      this.allConnectedOrgIDsPromise = this.getAllConnectedOrgIDsImpl();
    }
    return await this.allConnectedOrgIDsPromise;
  }
  async getOrgIDs() {
    const orgIDs = assertViewerHasOrgs(this.viewer);
    const connectedOrgIDs = await this.getAllConnectedOrgIDs();
    return [...orgIDs, ...connectedOrgIDs];
  }
  // Input is an orgID (for the fn to make sense it should be a Slack org id),
  // output is an array containing that orgID plus any platform orgs it is linked to
  async getAllConnectedPlatformOrgs(orgID) {
    const linkedPlatformOrgIDs = (await LinkedOrgsEntity.findAll({
      where: {
        linkedOrgID: orgID
      }
    })).map((o) => o.sourceOrgID);
    return [orgID, ...linkedPlatformOrgIDs];
  }
  clearAll() {
    this.linkedSlackOrgIDDataloader.clearAll();
    this.allConnectedOrgIDsPromise = null;
  }
};

// server/src/util/hash.ts
import { v5 as uuidv5 } from "uuid";
import jsonStableStringify4 from "fast-json-stable-stringify";
var RADICAL_UUID_NAMESPACE = uuidv5("getradical.co", uuidv5.DNS);
var uuidHash = (object) => uuidv5(jsonStableStringify4(object), RADICAL_UUID_NAMESPACE);
function isLocationOnly(data) {
  return "location" in data && Object.keys(data).length === 1;
}
function getPageContextHash(pageContext) {
  let hashInput = null;
  if (isLocationOnly(pageContext.data)) {
    hashInput = {
      location: pageContext.data.location,
      data: null
    };
  } else {
    hashInput = {
      providerID: null,
      data: pageContext.data
    };
  }
  return [uuidHash(hashInput), pageContext.data];
}

// server/src/entity/user/UserLoader.ts
var UserLoader = class {
  constructor(viewer, loaders, cache2 = false) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.dataloader = new DataLoader7(
      async (keys) => {
        const users = await UserEntity.findAll({
          where: {
            id: unique5(keys)
          }
        });
        return inKeyOrder(users, keys);
      },
      { cache: cache2 }
    );
    this.orgCheckedDataloader = new DataLoader7(
      async (userIDs) => {
        const uniqUserIDs = unique5(userIDs);
        const orgIDs = await (this.loaders()?.linkedOrgsLoader ?? new LinkedOrgsLoader(this.viewer)).getOrgIDs();
        const users = await getSequelize().query(
          `SELECT users.* FROM users, org_members
             WHERE users.id = ANY($1)
             AND users.id = org_members."userID"
             AND org_members."orgID" = ANY($2);`,
          {
            bind: [uniqUserIDs, orgIDs],
            type: QueryTypes4.SELECT,
            model: UserEntity
          }
        );
        return inKeyOrder(users, userIDs);
      },
      { cache: cache2 }
    );
    this.loadUsersByEmailDataloader = new DataLoader7(
      async (emailOrgs) => {
        const emails = unique5(emailOrgs.map(({ email }) => email));
        const orgIDs = unique5(emailOrgs.map(({ orgID }) => orgID));
        const users = await getSequelize().query(
          `
          SELECT users.*, org_members."orgID" FROM org_members, users
          WHERE users."email" = ANY($1)
          AND users.id = org_members."userID"
          AND org_members."orgID" = ANY($2)
          AND users."state" !=  'deleted'
          `,
          {
            bind: [emails, orgIDs],
            type: QueryTypes4.SELECT,
            model: UserEntity
          }
        );
        const makeKey3 = (email, orgID) => `${email}/${orgID}`;
        const index = /* @__PURE__ */ new Map();
        for (const user of users) {
          const key = makeKey3(
            user.email,
            user.get({ plain: true }).orgID
            // orgID is not a column on UserEntity but is returned by this query, so it needs to be converted to a basic object to retrieve orgID
          );
          if (index.has(key)) {
            index.get(key).push(user);
          } else {
            index.set(key, [user]);
          }
        }
        return emailOrgs.map(
          ({ email, orgID }) => index.get(makeKey3(email, orgID)) ?? []
        );
      },
      { cache: cache2 }
    );
    this.platformProfileDataloader = new DataLoader7(
      async (keys) => {
        const usersByApplication = /* @__PURE__ */ new Map();
        for (const key of keys) {
          if (!usersByApplication.has(key.platformApplicationID)) {
            usersByApplication.set(key.platformApplicationID, /* @__PURE__ */ new Set());
          }
          usersByApplication.get(key.platformApplicationID).add(key.externalID);
        }
        const promises = [];
        for (const [platformApplicationID, userIDSet] of usersByApplication) {
          const externalUserIDs = [...userIDSet];
          for (let offset = 0; offset < externalUserIDs.length; offset += MAX_IDS_PER_QUERY) {
            promises.push(
              getSequelize().query(
                `
          SELECT users.* FROM users
            WHERE users."platformApplicationID" = $1
            AND users."externalID" = ANY($2)
            AND users.state != 'deleted'
          `,
                {
                  bind: [
                    platformApplicationID,
                    externalUserIDs.slice(offset, offset + MAX_IDS_PER_QUERY)
                  ],
                  type: QueryTypes4.SELECT,
                  model: UserEntity
                }
              )
            );
          }
        }
        const users = (await Promise.all(promises)).flat();
        const index = /* @__PURE__ */ new Map();
        for (const user of users) {
          index.set(
            keyForPlatformID({
              platformApplicationID: user.platformApplicationID,
              externalID: user.externalID
            }),
            user
          );
        }
        return keys.map(
          (platformId) => index.get(keyForPlatformID(platformId)) ?? null
        );
      },
      { cache: cache2 }
    );
  }
  async loadUser(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("Failed to loadUser", e);
      return null;
    }
  }
  async loadUsers(ids) {
    const users = await Promise.all(ids.map((uid) => this.loadUser(uid)));
    return users.filter(isDefined);
  }
  async loadUserInAnyViewerOrg(id) {
    try {
      if (id === this.viewer.userID) {
        return await this.loadUser(id);
      }
      return await this.orgCheckedDataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("Failed to loadUserInAnyViewerOrg", e);
      return null;
    }
  }
  async loadUsersInViewerOrgs(userIDs) {
    const orgIDs = await (this.loaders()?.orgMembersLoader ?? new OrgMembersLoader(this.viewer)).loadAllOrgIDsForUser();
    return await getSequelize().query(
      `SELECT users.* FROM users, org_members
         WHERE users.id = ANY($1)
         AND users.id = org_members."userID"
         AND org_members."orgID" = ANY($2);`,
      {
        bind: [userIDs, orgIDs],
        type: QueryTypes4.SELECT,
        model: UserEntity
      }
    );
  }
  async loadUsersInApplication(appID, limit) {
    return await UserEntity.findAll({
      where: { platformApplicationID: appID },
      order: [["createdTimestamp", "DESC"]],
      limit
    });
  }
  async loadUsersInOrg(userIDs, orgID) {
    return await getSequelize().query(
      `
      SELECT users.* FROM users, org_members
      WHERE users.id = ANY($1)
      AND users.id = org_members."userID"
      AND org_members."orgID" = $2;
    `,
      {
        bind: [userIDs, orgID],
        type: QueryTypes4.SELECT,
        model: UserEntity
      }
    );
  }
  async loadUserInOrg(userID, orgID) {
    const results = await this.loadUsersInOrg([userID], orgID);
    return results.length > 0 ? results[0] : null;
  }
  async loadUsersNoOrgCheck(userIDs) {
    const results = await this.dataloader.loadMany(userIDs);
    return results.filter(
      (x) => isDefined(x) && !(x instanceof Error)
    );
  }
  async loadAllUsersInOrgPaginatedByUserID(orgID, after, limit) {
    const bindVariables = [orgID];
    let afterCondition = "";
    if (after) {
      bindVariables.push(after);
      afterCondition = `AND org_members."userID" > $${bindVariables.length}`;
    }
    let limitCondition = "";
    if (limit) {
      bindVariables.push(limit.toString());
      limitCondition = `LIMIT $${bindVariables.length}`;
    }
    const users = await getSequelize().query(
      `SELECT users.* FROM users, org_members
      WHERE users.id = org_members."userID"
      AND org_members."orgID" = $1
      AND users.state != 'deleted'
      ${afterCondition}
      ORDER BY org_members."userID" ASC
      ${limitCondition}
    `,
      {
        bind: bindVariables,
        type: QueryTypes4.SELECT,
        model: UserEntity
      }
    );
    return {
      users,
      hasMore: isDefined(limit) ? users.length === limit : false,
      token: users.at(-1)?.id
    };
  }
  /**
   * We have a valid match if any permutation of the query matches every
   * part of a user's name. E.g.
   * User: "James Bond" -> "James" = Match.
   * User: "James Bond" -> "James B" = Match.
   * User: "James Bond" -> "Bond Jam" = Match.
   * "James Bond" -> "James Wond" = Not a match.
   * "James Bond" -> "ames" = Not a match.
   *
   * Perhaps sub-optimally,
   * "James Bond" -> "James James" = is a match.
   * which it didn't use to be with our old front end
   * approach, but I don't think is particularly bad.
   */
  async loadNameFilteredUsersInOrg(orgID, nameQuery, platformApplicationID, limit, location = void 0, sortDirection = "descending") {
    const userID = assertViewerHasUser(this.viewer);
    const bindVariables = [orgID, userID, limit.toString()];
    let appIDCondition = "";
    let joinedConditionsArray = [];
    if (platformApplicationID) {
      bindVariables.push(platformApplicationID);
      appIDCondition = `AND users."platformApplicationID" = $${bindVariables.length}`;
    } else {
      appIDCondition = 'AND users."platformApplicationID" IS NULL';
    }
    if (nameQuery) {
      const nameFieldNames = ["name", "screenName"];
      const nameMatchConditions = Array.from(
        { length: nameFieldNames.length },
        () => []
      );
      for (const token of nameQuery.split(" ")) {
        bindVariables.push(token.toLowerCase());
        nameFieldNames.forEach(
          (field, index) => (
            // There is an index on LOWER(user.name) and LOWER(user.screenName), which
            // is faster than using ILIKE.
            // We want to accept words which match our query words from the START only
            // e.g. 'da' should match 'dave' but not 'adam'
            // This means the search word could either be the very start of the db field,
            // so 'searchWord%', or it could be the start of a subsequent word, which we
            // find by '% searchWord%'
            nameMatchConditions[index].push(
              `(LOWER(users."${field}") LIKE $${bindVariables.length} || '%' OR LOWER(users."${field}") LIKE '% ' || $${bindVariables.length} || '%')`
            )
          )
        );
      }
      joinedConditionsArray = nameMatchConditions.map(
        (fieldConditions) => fieldConditions.join(" AND ")
      );
    }
    let leftJoin = "";
    let orderBy = "";
    if (location) {
      const [pageContextHash] = getPageContextHash({
        providerID: null,
        data: location
      });
      bindVariables.push(pageContextHash);
      leftJoin = `
        LEFT JOIN page_visitors 
          ON org_members."orgID" = page_visitors."orgID" 
          AND org_members."userID" = page_visitors."userID" 
          AND page_visitors."pageContextHash" = $${bindVariables.length}`;
      const sortOrderCase = sortDirection === "descending" ? "THEN 1 ELSE 0" : "THEN 0 ELSE 1";
      orderBy = `
        ORDER BY
          CASE WHEN page_visitors."lastPresentTimestamp" IS NULL ${sortOrderCase} END,
          CASE WHEN users.id = $2 THEN 1 ELSE 0 END,
          page_visitors."lastPresentTimestamp" ${sortDirection === "descending" ? "DESC" : "ASC"}`;
    } else {
      orderBy = `
      ORDER BY 
        CASE WHEN users.id = $2 THEN 1 ELSE 0 END`;
    }
    const joinedConditions = joinedConditionsArray.length > 0 ? `AND (
      ${joinedConditionsArray.join(" OR ")}
    )` : "";
    return await getSequelize().query(
      `
    SELECT users.* FROM users, org_members
    ${leftJoin}
      WHERE users.id = org_members."userID"
      ${appIDCondition}
      AND org_members."orgID" = $1
      AND users.state != 'deleted'
      ${joinedConditions}
      ${orderBy}
      LIMIT $3;
    `,
      {
        bind: bindVariables,
        type: QueryTypes4.SELECT,
        model: UserEntity
      }
    );
  }
  async loadUsersByExternalIDsInOrg(externalIDs, orgIDs) {
    const results = await getSequelize().query(
      `
      SELECT DISTINCT ON (users.id) users.* FROM users, org_members
      WHERE users."externalID" = ANY($1)
      AND users.id = org_members."userID"
      AND org_members."orgID" = ANY($2);
    `,
      {
        bind: [externalIDs, orgIDs],
        type: QueryTypes4.SELECT,
        model: UserEntity
      }
    );
    return results;
  }
  async loadUserForEmailInOrg(email, orgID) {
    return await this.loadUsersByEmailDataloader.load({ email, orgID });
  }
  async loadUserForSlackUserWithinViewerOrg(slackUserID) {
    const orgID = assertViewerHasOrg(this.viewer);
    const results = await getSequelize().query(
      `
        SELECT users.* FROM users, org_members
        WHERE users.id = org_members."userID"
        AND org_members."orgID" = $1
        AND users."externalProvider" = $2
        AND users."externalID" = $3
        LIMIT 1;
    `,
      {
        bind: [orgID, "slack" /* SLACK */, slackUserID],
        type: QueryTypes4.SELECT,
        model: UserEntity
      }
    );
    return results.length > 0 ? results[0] : null;
  }
  async loadSlackUserForUserOrgScoped(context, userID) {
    const user = await UserEntity.findByPk(userID);
    const orgID = assertViewerHasOrg(this.viewer);
    if (!user) {
      return void 0;
    }
    return await loadLinkedSlackUserOrgScoped(user, context, orgID);
  }
  // This function does not work if the application uses sock puppets,
  // use loadUndeletedSockPuppets instead.
  async loadUserByExternalID(platformApplicationID, externalID) {
    return await this.platformProfileDataloader.load({
      platformApplicationID,
      externalID
    });
  }
  async loadUndeletedUser(externalUserID, platformApplicationID) {
    const users = await getSequelize().query(
      `SELECT * FROM users
         WHERE "externalID" = $1
         AND "platformApplicationID" = $2
         AND state != 'deleted';`,
      {
        bind: [externalUserID, platformApplicationID],
        type: QueryTypes4.SELECT,
        model: UserEntity
      }
    );
    return users.length > 0 ? users[0] : null;
  }
  async loadReferencedUserData(context, userIDs) {
    const users = await this.dataloader.loadMany(userIDs);
    return await Promise.all(
      users.filter((p) => p instanceof UserEntity).map(async (u) => {
        const displayProfile = await detailsForDisplay(u, context);
        return {
          id: u.id,
          name: displayProfile.displayName
        };
      })
    );
  }
  clearAll() {
    this.dataloader.clearAll();
    this.orgCheckedDataloader.clearAll();
    this.loadUsersByEmailDataloader.clearAll();
    this.platformProfileDataloader.clearAll();
  }
};

// server/src/entity/message/MessageLoader.ts
import { QueryTypes as QueryTypes5, Op as Op5 } from "sequelize";
import DataLoader8 from "dataloader";

// common/const/Api.ts
var INITIAL_MESSAGES_COUNT = 20;
var NOTIFICATION_LOGGING_REDIRECT_ID_LENGTH = 21;
var MAX_NAME_FILTERED_AUTOCOMPLETE_ORG_USERS = 20;
var DEFAULT_THREAD_INITIAL_PAGE_SIZE = 10;
var THREAD_INITIAL_PAGE_SIZE_LIMIT = 1e3;
var DEFAULT_NOTIFICATION_INITIAL_PAGE_SIZE = 10;
var DEFAULT_GROUP_MEMBERS_INITIAL_PAGE_SIZE = 10;

// common/util/asyncFilter.ts
async function asyncFilter(arr, pred) {
  const preds = await Promise.all(arr.map((elem) => pred(elem)));
  return arr.filter((_, idx) => preds[idx]);
}

// server/src/entity/message/MessageLoader.ts
var MAX_LIMIT = 100;
var MessageLoader = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.dataloader = new DataLoader8(
      async (keys) => {
        const where = {
          id: keys
        };
        if (this.viewer.platformApplicationID) {
          where.platformApplicationID = this.viewer.platformApplicationID;
        } else {
          const orgIDs = await this.loaders().orgMembersLoader.loadAllImmediateOrgIDsForUser();
          const viewerLinkedOrgID = await this.loaders().linkedOrgsLoader.getAllConnectedOrgIDs();
          const allOrgIDs = [
            .../* @__PURE__ */ new Set([viewer.orgID, ...orgIDs, ...viewerLinkedOrgID])
          ].filter(isDefined);
          where.orgID = allOrgIDs;
        }
        const messages = await MessageEntity.findAll({
          where
        });
        const filteredMessages = this.viewer.platformApplicationID ? await asyncFilter(
          messages,
          (m) => this.loaders().privacyLoader.viewerHasMessage(m)
        ) : messages;
        return inKeyOrder(filteredMessages, keys);
      },
      { cache: false }
    );
  }
  // Making sure we get both platform and slack orgID, so we load all messages
  async getAllOrgIDs() {
    const orgIDs = await this.loaders().orgMembersLoader.loadAllImmediateOrgIDsForUser();
    const linkedOrgID = await this.loaders().linkedOrgsLoader.getAllConnectedOrgIDs();
    return [.../* @__PURE__ */ new Set([...orgIDs, ...linkedOrgID])];
  }
  async loadMessage(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("Message dataloader error", e);
      return null;
    }
  }
  async loadMessageByExternalID(externalID, platformApplicationID) {
    try {
      const message = await MessageEntity.findOne({
        where: { externalID, platformApplicationID }
      });
      const canSee = await this.loaders().privacyLoader.viewerHasMessage(message);
      return canSee ? message : null;
    } catch (e) {
      anonymousLogger().logException("Message load error", e);
      return null;
    }
  }
  // This method will return args.range number of messages which are not deleted.
  // It will then add all deleted messages with timestamps within the range of
  // timestamps of the returned messages.
  async loadOlderMessages(args) {
    const allOrgIDs = await this.getAllOrgIDs();
    return await getSequelize().query(
      `WITH
      upper_cursor_message AS (
        SELECT m.timestamp FROM messages m WHERE id=$1
      ),
      lower_cursor_message AS (
        SELECT m.timestamp FROM messages m
        LEFT OUTER JOIN upper_cursor_message ucm ON TRUE
        WHERE "threadID"=$2
        AND "orgID"=ANY($3)
        AND "deletedTimestamp" IS NULL
        AND m.timestamp < COALESCE(ucm.timestamp, 'infinity')
        ORDER BY m.timestamp DESC OFFSET $4-1 LIMIT 1
      )
      SELECT m.*
        FROM messages m
        LEFT OUTER JOIN upper_cursor_message ucm ON TRUE
        LEFT OUTER JOIN lower_cursor_message lcm ON TRUE
        WHERE "threadID"=$2
        AND "orgID"=ANY($3)
        AND m.timestamp <= COALESCE(ucm.timestamp, 'infinity')
        AND m.timestamp >= COALESCE(lcm.timestamp, '-infinity')
        ORDER BY m.timestamp ASC;`,
      {
        type: QueryTypes5.SELECT,
        model: MessageEntity,
        bind: [
          args.cursor ?? null,
          args.threadID,
          allOrgIDs,
          typeof args.range === "number" ? Math.min(MAX_LIMIT, Math.abs(args.range)) : INITIAL_MESSAGES_COUNT
        ]
      }
    );
  }
  // Note this will only genuinely return all messages if args.range is 'unlimited'
  // In general this should be avoided, to prevent excessive requests being made
  async loadAll(args) {
    const allOrgIDs = await this.getAllOrgIDs();
    args.where = { ...args.where, orgID: allOrgIDs };
    let range;
    if (typeof args.range === "undefined") {
      range = -INITIAL_MESSAGES_COUNT;
    }
    if (typeof args.range === "number") {
      range = Math.sign(args.range) * Math.min(MAX_LIMIT, Math.abs(args.range));
    }
    if (args.range === "unlimited") {
      range = void 0;
    }
    if (args.cursor) {
      args.where = {
        ...args.where,
        timestamp: {
          [range && range > 0 ? Op5.gt : Op5.lt]: timestampSubquery(args.cursor)
        }
      };
    }
    if (args.ignoreDeleted) {
      args.where = {
        ...args.where,
        deletedTimestamp: { [Op5.is]: null }
      };
    }
    const messages = await MessageEntity.findAll({
      where: args.where,
      // Intentional array of arrays here
      order: [["timestamp", range && range < 0 ? "DESC" : "ASC"]],
      limit: range ? Math.abs(range) : void 0
    });
    return messages.sort(
      (a, b) => a.timestamp.getTime() - b.timestamp.getTime()
    );
  }
  async loadMessagesFromMultipleThreads(args) {
    const where = {
      threadID: args.threadIDs
    };
    return await this.loadAll({ ...args, where });
  }
  async loadMessages(args) {
    const where = {
      threadID: args.threadID
    };
    if (args.ignoreDeleted === true && args.range !== "unlimited") {
      return await this.loadAll({ ...args, where });
    }
    return await this.loadOlderMessages({ ...args, threadID: args.threadID });
  }
  // loads the newest messages back until (and including) a specified message
  async loadNewestUntilTarget({
    threadID,
    targetMessage
  }) {
    const orgIDs = await this.loaders().orgMembersLoader.loadAllImmediateOrgIDsForUser();
    const messages = await MessageEntity.findAll({
      where: {
        threadID,
        orgID: orgIDs,
        timestamp: {
          [Op5.gte]: timestampSubquery(targetMessage)
        },
        deletedTimestamp: { [Op5.is]: null }
      }
    });
    return messages.sort(
      (a, b) => a.timestamp.getTime() - b.timestamp.getTime()
    );
  }
};

// server/src/entity/message_attachment/MessageAttachmentLoader.ts
import { Op as Op6, QueryTypes as QueryTypes6 } from "sequelize";
import DataLoader9 from "dataloader";
var MessageAttachmentLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader9(
      async (keys) => {
        assertViewerHasIdentity(this.viewer);
        const attachments = await MessageAttachmentEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrder(attachments, keys);
      },
      { cache: false }
    );
    this.dataloaderForMessage = new DataLoader9(
      async (keys) => {
        const [messageAttachments, messageLinkPreviews] = await Promise.all([
          MessageAttachmentEntity.findAll({
            where: { messageID: keys }
          }),
          MessageLinkPreviewEntity.findAll({
            where: { messageID: keys, hidden: { [Op6.ne]: true } }
          })
        ]);
        return inKeyOrderGroupedCustom(
          [...messageAttachments, ...messageLinkPreviews],
          keys,
          (a) => a.messageID
        );
      },
      { cache: false }
    );
  }
  async loadAttachmentsForMessage(messageID) {
    return await this.dataloaderForMessage.load(messageID);
  }
  async loadThreadHasAnnotations(threadID) {
    const orgID = assertViewerHasOrg(this.viewer);
    const [{ count }] = await getSequelize().query(
      `SELECT COUNT(*) as count
      FROM message_attachments ma
      INNER JOIN messages m ON ma."messageID" = m."id"
      WHERE
        m."threadID" = $1
        AND m."orgID" = $2
        AND ma.type = $3
      `,
      {
        bind: [threadID, orgID, "annotation" /* ANNOTATION */],
        type: QueryTypes6.SELECT
      }
    );
    return count > 0;
  }
  // Pass includeDeleted=true if you want to include annotations that belong to
  // messages that have been deleted. This is useful for FloatingThreads in
  // which user might delete the first message of a thread but we still want to
  // return the annotation to show the floating pin. Annotations from threads
  // with all messages deleted are not returned.
  async loadAnnotationAttachmentsOnPage(pageContextHash, includeDeleted) {
    const orgID = assertViewerHasOrg(this.viewer);
    const threadIsNonEmpty = `AND EXISTS (
          SELECT 1 FROM messages WHERE "deletedTimestamp" IS NULL
          AND type = 'user_message'
          AND "orgID" = $2
          AND "threadID" = t.id
        )`;
    const messageIsNotDeleted = `AND m."deletedTimestamp" IS NULL`;
    return await getSequelize().query(
      `SELECT ma.*
       FROM message_attachments ma
       INNER JOIN messages m ON ma."messageID" = m."id"
       INNER JOIN threads t ON m."threadID" = t."id"
       WHERE
          t."pageContextHash" = $1
          AND t."orgID"= $2
          AND t."resolvedTimestamp" IS NULL
          AND ma.type = $3
          ${includeDeleted ? threadIsNonEmpty : messageIsNotDeleted}
      `,
      {
        bind: [pageContextHash, orgID, "annotation" /* ANNOTATION */],
        type: QueryTypes6.SELECT,
        model: MessageAttachmentEntity
      }
    );
  }
  async loadAttachment(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("Msg attachment dataloader error", e);
      return null;
    }
  }
  async getAttachmentFromFileID(fileID) {
    return await MessageAttachmentEntity.findOne({
      where: {
        [Op6.or]: [{ data: { fileID } }, { data: { screenshotFileID: fileID } }]
      }
    });
  }
};
function getFileAttachmentEntities(attachments) {
  return attachments.map((a) => "type" in a ? a : null).filter(isDefined);
}

// server/src/entity/file/FileLoader.ts
import DataLoader10 from "dataloader";
var FileLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader10(
      async (keys) => {
        const files = await FileEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrder(files, keys);
      },
      { cache: false }
    );
  }
  async loadFile(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("File dataloader error", e);
      return null;
    }
  }
  async loadFiles(fileIDs) {
    const results = await this.dataloader.loadMany(fileIDs);
    return results.filter((x) => !(x instanceof Error));
  }
};

// server/src/entity/message_reaction/MessageReactionLoader.ts
import DataLoader11 from "dataloader";
var MessageReactionLoader = class {
  constructor(viewer, cache2 = false) {
    this.viewer = viewer;
    this.dataloader = new DataLoader11(
      async (keys) => {
        const messageReactions = await MessageReactionEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrder(messageReactions, keys);
      },
      { cache: cache2 }
    );
    this.dataloaderForMessage = new DataLoader11(
      async (keys) => {
        const messageReactions = await MessageReactionEntity.findAll({
          where: { messageID: keys },
          // Intentional array of arrays here
          order: [["timestamp", "ASC"]]
        });
        return inKeyOrderGroupedCustom(
          messageReactions,
          keys,
          (r) => r.messageID
        );
      },
      { cache: cache2 }
    );
  }
  async loadReactionNoOrgCheck(id) {
    return await this.dataloader.load(id);
  }
  async loadReactionsForMessageNoOrgCheck(messageID) {
    return await this.dataloaderForMessage.load(messageID);
  }
  async loadReactionForMessageByUser(messageID, unicodeReaction) {
    const userID = assertViewerHasUser(this.viewer);
    const reactionEntity = await MessageReactionEntity.findOne({
      where: {
        messageID,
        userID,
        unicodeReaction
      }
    });
    return reactionEntity;
  }
  clearAll() {
    this.dataloader.clearAll();
    this.dataloaderForMessage.clearAll();
  }
};

// server/src/entity/slack_channel/SlackChannelLoader.ts
import DataLoader12 from "dataloader";
var SlackChannelLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader12(
      async (keys) => {
        const orgIDs = await new LinkedOrgsLoader(this.viewer).getOrgIDs();
        const slackChannels = await SlackChannelEntity.findAll({
          where: { slackID: [...keys], orgID: orgIDs }
        });
        const slackChannelById = Object.fromEntries(
          slackChannels.map((entity) => [entity.slackID, entity])
        );
        const result = keys.map(
          (key) => slackChannelById[key] || null
        );
        return result;
      },
      { cache: false }
    );
  }
  async loadSlackChannel(slackChannelID) {
    try {
      return await this.dataloader.load(slackChannelID);
    } catch (e) {
      anonymousLogger().logException("SlackChannel dataloader error", e);
      return null;
    }
  }
  async loadJoinableSlackChannels(orgIDs) {
    return await SlackChannelEntity.findAll({
      where: { orgID: orgIDs, added: false, archived: false },
      order: [["users", "DESC"]]
    });
  }
  async loadJoinedSlackChannels(orgIDs) {
    return await SlackChannelEntity.findAll({
      where: { orgID: orgIDs, added: true, archived: false },
      order: [["users", "DESC"]]
    });
  }
};

// server/src/entity/user_preference/UserPreferenceLoader.ts
var UserPreferenceLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadPreferences() {
    const userID = assertViewerHasUser(this.viewer);
    const entities = await UserPreferenceEntity.findAll({
      where: {
        userID
      }
    });
    return Object.fromEntries(entities.map(({ key, value }) => [key, value]));
  }
  async loadPreferenceValueForViewer(key) {
    const userID = assertViewerHasUser(this.viewer);
    return await this.loadPreferenceValueForUser(key, userID);
  }
  async loadPreferenceValueForUser(key, userID) {
    const entity = await UserPreferenceEntity.findOne({
      where: { userID, key }
    });
    if (!entity) {
      return void 0;
    }
    return entity.value;
  }
};

// server/src/entity/task/TaskLoader.ts
import DataLoader13 from "dataloader";
var TaskLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloaderForMessage = new DataLoader13(
      async (keys) => {
        const tasks = await TaskEntity.findAll({
          where: { messageID: keys }
        });
        return inKeyOrderGroupedCustom(tasks, keys, (t) => t.messageID).map(
          // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
          (tasks2) => tasks2[0]
        );
      },
      { cache: false }
    );
  }
  async loadTaskForMessageNoOrgCheck(messageID) {
    return await this.dataloaderForMessage.load(messageID);
  }
  async loadTask(taskID, orgID) {
    return await TaskEntity.findOne({
      where: { id: taskID, orgID }
    });
  }
};

// server/src/entity/task_assignee/TaskAssigneeLoader.ts
var TaskAssigneeLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadTaskAssigneesForTaskNoOrgCheck(taskID) {
    return await TaskAssigneeEntity.findAll({
      where: { taskID }
    });
  }
};

// server/src/entity/task_todo/TaskTodoLoader.ts
var TaskTodoLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadTaskTodosNoOrgCheck(taskID) {
    return await TaskTodoEntity.findAll({
      where: { taskID }
    });
  }
};

// server/src/entity/page/PageLoader.ts
import { QueryTypes as QueryTypes7 } from "sequelize";
import DataLoader14 from "dataloader";
var PageLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.primaryPageForThreadDataloader = new DataLoader14(
      async (keys) => {
        const rows = await getSequelize().query(
          `SELECT t.id as "threadID", p.* FROM pages p, threads t
         WHERE p."orgID" = t."orgID"
          AND p."contextHash" = t."pageContextHash"
          AND t.id = ANY($1);`,
          {
            bind: [keys],
            type: QueryTypes7.SELECT
          }
        );
        return inKeyOrderOrNullCustom(rows, keys, (r) => r.threadID).map(
          (r) => r && PageEntity.build(r)
        );
      },
      { cache: false }
    );
  }
  async getPageFromContextHash(contextHash, orgOverride) {
    const orgID = assertViewerHasOrg(this.viewer);
    return await PageEntity.findOne({
      where: {
        contextHash,
        orgID: orgOverride ?? orgID
      }
    });
  }
  async loadPrimaryPageForThreadNoOrgCheck(threadID) {
    return await this.primaryPageForThreadDataloader.load(threadID);
  }
};

// server/src/entity/thread/ThreadLoader.ts
import { Op as Op7, QueryTypes as QueryTypes8, Sequelize as Sequelize9 } from "sequelize";
import DataLoader15 from "dataloader";
import { unique as unique6, isEmpty } from "radash";

// server/src/util/filteredBatchLoad.ts
async function filteredBatchLoad(loadBatch, filterItem, initialToken, limit) {
  const result = {
    items: [],
    hasMore: true,
    token: initialToken
  };
  while (result.hasMore && (!isDefined(limit) || result.items.length < limit)) {
    const next = await loadBatch(result.token, limit ?? void 0);
    const filteredItems = await asyncFilter(next.items, filterItem);
    result.items.push(...filteredItems);
    result.hasMore = next.hasMore;
    result.token = next.token;
  }
  if (isDefined(limit) && result.items.length > limit) {
    result.items = result.items.slice(0, limit);
    result.hasMore = true;
  }
  return result;
}
async function findFirstEntity(model, options, filterItem) {
  const batch = await filteredBatchLoad(
    async (offset, limit) => {
      const items = await model.findAll({ ...options, offset, limit });
      return {
        items,
        token: offset + (limit ?? 0),
        hasMore: items.length === limit
      };
    },
    filterItem,
    0,
    1
  );
  return batch.items[0];
}

// server/src/util/filteredApproximateCount.ts
var CUTOFF = 50;
var NUM_SAMPLE_ITEMS = CUTOFF;
async function filteredApproximateCount(unfilteredCount, sampleItems, filterItem) {
  if (unfilteredCount >= NUM_SAMPLE_ITEMS && sampleItems.length < NUM_SAMPLE_ITEMS) {
    throw new Error("Not enough items provided");
  }
  if (unfilteredCount < CUTOFF) {
    const rest = await asyncFilter(sampleItems, filterItem);
    return rest.length;
  }
  return unfilteredCount;
}
async function adjustCounts(unfilteredCounts, filterItem) {
  return await Promise.all(
    unfilteredCounts.map(async (item) => {
      const count = await filteredApproximateCount(
        item.count,
        item.items,
        filterItem
      );
      return { ...item, count };
    })
  );
}
function countedItems() {
  return `(array_agg("id"))[1:${NUM_SAMPLE_ITEMS}]`;
}

// server/src/entity/thread/ThreadLoader.ts
function updateMightBeRelevant(logger, filter, payload, userID) {
  if (Object.keys(payload.changes).length === 0) {
    logger.warn("Got a thread-filterable-properties-updated with no changes", {
      threadID: payload.threadID
    });
    return false;
  }
  if (payload.changes.orgID) {
    return true;
  }
  return isDefined(filter.location) && isDefined(payload.changes.location) && matchesLocationFilter(payload.changes.location.old, filter) !== matchesLocationFilter(payload.changes.location.new, filter) || isDefined(filter.metadata) && isDefined(payload.changes.metadata) && metadataMatches(payload.changes.metadata.old, filter.metadata) !== metadataMatches(payload.changes.metadata.new, filter.metadata) || isDefined(filter.resolved) && isDefined(payload.changes.resolved) || isDefined(filter.viewer) && filter.viewer.includes("subscribed") && isDefined(payload.changes.subscribers) && (payload.changes.subscribers.added.includes(userID) || payload.changes.subscribers.removed.includes(userID));
}
function matchesLocationFilter(location, filter) {
  if (!filter.location) {
    return true;
  }
  if (filter.partialMatch) {
    return locationMatches(location, filter.location);
  } else {
    return locationEqual(location, filter.location);
  }
}
var ThreadLoader = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.threadByIDNoOrgCheckDataloader = new DataLoader15(
      async (keys) => {
        const { platformApplicationID } = this.viewer;
        const threads = await ThreadEntity.findAll({
          where: {
            id: keys,
            ...platformApplicationID && { platformApplicationID }
          }
        });
        return inKeyOrder(threads, keys);
      },
      {
        cache: false
      }
    );
    this.messagesCountNoOrgCheckDataloader = new DataLoader15(
      async (keys) => {
        const counts = await MessageEntity.count({
          group: ["threadID"],
          where: { threadID: keys },
          attributes: [[Sequelize9.literal(countedItems()), "items"]]
        });
        const adjustedCounts = await adjustCounts(
          counts,
          async (messageID) => !!await this.loaders().messageLoader.loadMessage(messageID)
        );
        return inKeyOrderOrNullCustom(
          adjustedCounts,
          keys,
          (c) => c.threadID
        ).map((c) => c ? c.count : 0);
      },
      { cache: false }
    );
    this.messagesCountExcludingDeletedNoOrgCheckDataloader = new DataLoader15(
      async (keys) => {
        const counts = await MessageEntity.count({
          group: ["threadID"],
          where: { threadID: keys, deletedTimestamp: { [Op7.is]: null } },
          attributes: [[Sequelize9.literal(countedItems()), "items"]]
        });
        const adjustedCounts = await adjustCounts(
          counts,
          async (messageID) => !!await this.loaders().messageLoader.loadMessage(messageID)
        );
        return inKeyOrderOrNullCustom(
          adjustedCounts,
          keys,
          (c) => c.threadID
        ).map((c) => c ? c.count : 0);
      },
      { cache: false }
    );
    this.newMessageCountDataloader = new DataLoader15(
      async (keys) => {
        const userID = assertViewerHasUser(this.viewer);
        const counts = await getSequelize().query(
          // We are getting a count from messages we find where they have not been
          // deleted, and the viewer isn't the author of the message, and the message
          // timestamp is greater than that of the thread_participant if they exist.
          // If a user is mentioned then they become a thread_participant but the
          // lastSeenTimestamp is set to null.
          // Using COALESCE allows us use the first non-null value we get from the list
          // within the brackets. In this case, if there isn't a thread_participant
          // the first value will be NULL and it will take 'TRUE' as the value instead
          // if FALSE is the value taken, the message count will be 0
          // The nested COALESCE ensures that if thread_participant does exist but if
          // the 'lastSeenTimestamp' is NULL then it will default to
          // '-infinity'::timestamp which is always smaller than 'timestamp'
          // in order to correctly contribute to the new messages count.
          `
          SELECT m."threadID", COUNT(*)::integer
            FROM messages m
            LEFT JOIN thread_participants tp ON (m."threadID" = tp."threadID" AND tp."userID" = $2)
            WHERE m."threadID" = ANY($1)
              AND m."deletedTimestamp" IS NULL
              AND m."sourceID" != $2
              AND m.timestamp > COALESCE(tp."lastSeenTimestamp", '-infinity'::timestamp)
            GROUP BY m."threadID"
        `,
          { bind: [keys, userID], type: QueryTypes8.SELECT }
        );
        return inKeyOrderOrNullCustom(counts, keys, (c) => c.threadID).map(
          (c) => c ? c.count : 0
        );
      },
      { cache: false }
    );
    this.newReactionCountDataloader = new DataLoader15(
      async (keys) => {
        const userID = assertViewerHasUser(this.viewer);
        const reactionCounts = await getSequelize().query(
          // We are getting a count from messages reactions added on any of the viewer's messages
          // and the reaction timestamp is greater than that of the thread_participant if they exist.
          `
          SELECT m."threadID", COUNT(*)::integer
            FROM messages m
            INNER JOIN message_reactions mr ON (mr."messageID" = m.id)
            LEFT JOIN thread_participants tp ON (m."threadID" = tp."threadID" AND tp."userID" = $2)
          WHERE m."threadID" = ANY($1)
            AND m."deletedTimestamp" IS NULL
            AND m."sourceID" = $2
            AND mr."userID" != $2
            AND mr.timestamp > COALESCE(tp."lastSeenTimestamp", '-infinity'::timestamp)
          GROUP BY m."threadID"
        `,
          { bind: [keys, userID], type: QueryTypes8.SELECT }
        );
        return inKeyOrderOrNullCustom(
          reactionCounts,
          keys,
          (c) => c.threadID
        ).map((c) => c?.count ?? 0);
      },
      { cache: false }
    );
    this.messagesReplyCountDataloader = new DataLoader15(
      async (keys) => {
        const counts = await getSequelize().query(
          // NB: assign the row_number() *before* filtering deleted messages, so
          // that we count the *replies* (i.e., not the first message) whether
          // or not the first message is deleted.
          `
            SELECT "threadID", COUNT(*), ${countedItems()} as "items" FROM (
              SELECT *, row_number() OVER (PARTITION BY "threadID" ORDER BY timestamp ASC) AS index
              FROM messages
              WHERE "threadID" = ANY($1)
            ) x
            WHERE type = 'user_message'
            AND "deletedTimestamp" IS NULL
            AND index>1
            GROUP BY "threadID";
          `,
          {
            bind: [keys],
            type: QueryTypes8.SELECT
          }
        );
        const adjustedCounts = await adjustCounts(
          counts,
          async (messageID) => !!await this.loaders().messageLoader.loadMessage(messageID)
        );
        return inKeyOrderOrNullCustom(
          adjustedCounts,
          keys,
          (c) => c.threadID
        ).map((c) => c ? c.count : 0);
      },
      { cache: false }
    );
    this.userMessagesCountDataloader = new DataLoader15(
      async (keys) => {
        const counts = await MessageEntity.count({
          group: ["threadID"],
          where: {
            threadID: keys,
            deletedTimestamp: { [Op7.is]: null },
            type: "user_message"
          },
          attributes: [[Sequelize9.literal(countedItems()), "items"]]
        });
        const adjustedCounts = await adjustCounts(
          counts,
          async (messageID) => !!await this.loaders().messageLoader.loadMessage(messageID)
        );
        return inKeyOrderOrNullCustom(
          adjustedCounts,
          keys,
          (c) => c.threadID
        ).map((c) => c ? c.count : 0);
      },
      { cache: false }
    );
    this.actionMessagesCountDataloader = new DataLoader15(
      async (keys) => {
        const counts = await MessageEntity.count({
          group: ["threadID"],
          where: {
            threadID: keys,
            deletedTimestamp: { [Op7.is]: null },
            type: "action_message"
          }
        });
        return inKeyOrderOrNullCustom(
          counts,
          keys,
          (c) => c.threadID
        ).map((c) => c ? c.count : 0);
      },
      { cache: false }
    );
    this.firstUnseenMessageIDDataloader = new DataLoader15(
      async (keys) => {
        const userID = assertViewerHasUser(this.viewer);
        const results = await getSequelize().query(
          `
          SELECT DISTINCT ON (m."threadID") m."threadID", m.id as "messageID"
          FROM messages m
          LEFT JOIN thread_participants tp ON (m."threadID" = tp."threadID" AND tp."userID" = $2)
          WHERE m."threadID" = ANY($1)
            AND m."deletedTimestamp" IS NULL
            AND m."sourceID" != $2
            AND m.timestamp > COALESCE(tp."lastSeenTimestamp", '-infinity'::timestamp)
          ORDER BY m."threadID", m.timestamp`,
          { bind: [keys, userID], type: QueryTypes8.SELECT }
        );
        return inKeyOrderOrNullCustom(results, keys, (c) => c.threadID).map(
          (c) => c?.messageID ?? null
        );
      },
      { cache: false }
    );
    this.replyingUserIDsDataloader = new DataLoader15(
      async (keys) => {
        const rows = await getSequelize().query(
          `SELECT DISTINCT m."threadID", m."sourceID"
          FROM messages m
          INNER JOIN (
            SELECT "threadID", MIN(timestamp) as "firstMessageTimestamp"
            FROM messages
            WHERE "threadID" = ANY($1)
            GROUP BY "threadID"
          ) t ON (t."threadID" = m."threadID")
          WHERE m."deletedTimestamp" IS NULL
            AND m.timestamp != t."firstMessageTimestamp"
            AND m.type = 'user_message'
            `,
          { bind: [keys], type: QueryTypes8.SELECT }
        );
        return inKeyOrderGroupedCustom(rows, keys, (r) => r.threadID).map(
          (group) => group.map((r) => r.sourceID)
        );
      },
      { cache: false }
    );
    this.actionMessageReplyingUserIDsDataloader = new DataLoader15(
      async (keys) => {
        const rows = await getSequelize().query(
          `SELECT DISTINCT m."threadID", m."sourceID"
          FROM messages m
          INNER JOIN (
            SELECT "threadID", MIN(timestamp) as "firstMessageTimestamp"
            FROM messages
            WHERE "threadID" = ANY($1)
            GROUP BY "threadID"
          ) t ON (t."threadID" = m."threadID")
          WHERE m."deletedTimestamp" IS NULL
            AND m.timestamp != t."firstMessageTimestamp"
            AND m.type = 'action_message'`,
          { bind: [keys], type: QueryTypes8.SELECT }
        );
        return inKeyOrderGroupedCustom(rows, keys, (r) => r.threadID).map(
          (group) => group.map((r) => r.sourceID)
        );
      },
      { cache: false }
    );
    this.slackMirroredThreadInfoDataloader = new DataLoader15(
      async (keys) => {
        const rows = await getSequelize().query(
          `SELECT
            smt."threadID",
            smt."slackChannelID",
            smt."slackMessageTimestamp",
            smt."slackOrgID",
            smt."threadOrgID",
            sc."name" AS channel
          FROM slack_mirrored_threads smt
          LEFT OUTER JOIN slack_channels sc
            ON (smt."slackOrgID", smt."slackChannelID") = (sc."orgID", sc."slackID")
          WHERE smt."threadID" = ANY($1);`,
          { bind: [keys], type: QueryTypes8.SELECT }
        );
        const mirroredInfo = inKeyOrderOrNullCustom(
          rows,
          keys,
          (r) => r.threadID
        );
        const orgLoader = loaders().orgLoader;
        return await Promise.all(
          mirroredInfo.map(async (mi) => {
            if (!mi) {
              return null;
            }
            const {
              slackChannelID,
              slackMessageTimestamp,
              channel,
              slackOrgID
            } = mi;
            let slackURL = null;
            const slackOrg = await orgLoader.loadOrg(slackOrgID);
            if (slackOrg?.domain) {
              slackURL = getSlackMessageURL(
                slackOrg.domain,
                slackChannelID,
                slackMessageTimestamp,
                null
              );
            }
            return { channel, slackURL };
          })
        );
      },
      { cache: false }
    );
    this.initialMessagesDataloader = new DataLoader15(
      async (keys) => {
        const userID = assertViewerHasUser(this.viewer);
        const [threadParticipants, messageCounts] = await Promise.all([
          Promise.all(
            keys.map(
              ([threadID]) => this.loaders().threadParticipantLoader.loadForUserNoOrgCheck({
                threadID,
                userID
              })
            )
          ),
          Promise.all(
            keys.map(
              ([threadID]) => this.loadMessagesCountNoOrgCheck(threadID)
            )
          )
        ]);
        const hasMessage = async (m) => await this.loaders().privacyLoader.viewerHasMessage(m);
        return await Promise.all(
          keys.map(async ([threadID, initialFetchCount], i) => {
            const messageWhereOptions = {
              threadID
            };
            if (messageCounts[i] < 4 && !isDefined(initialFetchCount)) {
              const unfiltered = await MessageEntity.findAll({
                where: messageWhereOptions,
                order: [["timestamp", "ASC"]]
              });
              return await asyncFilter(unfiltered, hasMessage);
            }
            const [
              firstMessageOfThread,
              lastMessageOfThread,
              lastMessagesOfThreadUnfiltered
            ] = await Promise.all([
              findFirstEntity(
                MessageEntity,
                {
                  where: messageWhereOptions,
                  order: [["timestamp", "ASC"]]
                },
                hasMessage
              ),
              findFirstEntity(
                MessageEntity,
                {
                  where: messageWhereOptions,
                  order: [["timestamp", "DESC"]]
                },
                hasMessage
              ),
              isDefined(initialFetchCount) ? filteredBatchLoad(
                async (token, limit) => {
                  const result = await getSequelize().query(
                    `
                        WITH
                        cursor_message AS (
                          SELECT m.timestamp FROM messages m WHERE id=$1
                        )
                        SELECT m.*
                          FROM messages m
                          LEFT OUTER JOIN cursor_message ucm ON TRUE
                          WHERE "threadID"=$2
                          AND m.timestamp < COALESCE(ucm.timestamp, 'infinity')
                          ORDER BY m.timestamp DESC
                          LIMIT $3
                `,
                    {
                      bind: [token, threadID, limit],
                      type: QueryTypes8.SELECT,
                      model: MessageEntity
                    }
                  );
                  return {
                    items: result,
                    token: result.length > 0 ? result[result.length - 1].id : null,
                    hasMore: result.length === limit
                  };
                },
                hasMessage,
                null,
                initialFetchCount
              ).then((result) => result.items) : threadParticipants[i] ? (
                // This will fetch all messages that are 'new' for the user,
                // plus the message immediately before that (the last 'read'
                // message), with a cap of 50 messages
                //
                // TODO(flooey): Rewrite this to use filteredBatchLoad rather
                // than filtering below.
                getSequelize().query(
                  `
                      SELECT * FROM messages
                      WHERE "threadID" = $1
                      AND "timestamp" >= (
                        SELECT COALESCE(MAX(timestamp), '-infinity'::timestamp) FROM messages
                        WHERE "threadID" = $1
                          AND timestamp <= (
                            SELECT "lastSeenTimestamp"
                            FROM thread_participants
                            WHERE "threadID" = $1 AND "userID" = $2
                            LIMIT 1
                          )
                      )
                      ORDER BY "timestamp" DESC LIMIT 50;
                    `,
                  {
                    bind: [threadID, userID],
                    type: QueryTypes8.SELECT,
                    // have state model otherwise it can't use the entity's properties
                    model: MessageEntity
                  }
                )
              ) : (
                // If viewer is not a thread participant, and there are more than 3
                // messages this will render collapsed similar to if all messages
                // were read.
                []
              )
            ]);
            if (!firstMessageOfThread || !lastMessageOfThread) {
              return [];
            } else if (firstMessageOfThread.id === lastMessageOfThread.id) {
              return [firstMessageOfThread];
            } else {
              const lastMessagesOfThread = await asyncFilter(
                lastMessagesOfThreadUnfiltered,
                hasMessage
              );
              return [
                firstMessageOfThread,
                ...lastMessagesOfThread.filter(
                  ({ id }) => id !== firstMessageOfThread.id && id !== lastMessageOfThread.id
                ).reverse(),
                lastMessageOfThread
              ];
            }
          })
        );
      },
      { cache: false }
    );
  }
  /**
   * Loads a thread by its ID. Will return null either if the thread doesn't
   * exist, or if the viewer doesn't have permission to see the thread.
   *
   * Does *not* do a strict "org check", i.e., this will return any thread the
   * viewer is allowed to see, even if it doesn't match the org(s) in the Viewer
   * object.
   */
  async loadThread(threadID) {
    const thread = await this.threadByIDNoOrgCheckDataloader.load(threadID);
    const canSee = await this.loaders().privacyLoader.viewerHasThread(
      thread,
      false
    );
    return canSee ? thread : null;
  }
  /**
   * Loads a list of threads.
   * @see loadThread
   */
  async loadThreads(ids) {
    return (await Promise.all(ids.map((id) => this.loadThread(id)))).filter(
      isDefined
    );
  }
  /**
   * Loads a thread by its external ID. Will return null either if the thread
   * doesn't exist, or if the viewer doesn't have permission to see the thread.
   *
   * Note that this does *not* do a strict "org check", i.e., this will return
   * any thread the viewer is allowed to see, even if it doesn't match the org(s)
   * in the Viewer object.
   */
  async loadByExternalID(externalThreadID, transaction) {
    const platformApplicationID = assertViewerHasPlatformApplicationID(
      this.viewer
    );
    const thread = await ThreadEntity.findOne({
      where: {
        externalID: externalThreadID,
        platformApplicationID
      },
      transaction
    });
    const canSee = await this.loaders().privacyLoader.viewerHasThread(
      thread,
      false,
      transaction
    );
    return canSee ? thread : null;
  }
  /**
   * Loads a thread by its external ID. Will return null either if the thread
   * doesn't exist, or if the viewer doesn't have permission to see the thread.
   *
   * Note that this *does* do a strict "org check", i.e., the thread's org is
   * checked against the org(s) in the Viewer object. This means this function
   * can return null even if the viewer can nominally see the thread, because it
   * doesn't match their *current* Viewer object.
   */
  async loadByExternalIDStrictOrgCheck(externalThreadID, transaction) {
    const platformApplicationID = assertViewerHasPlatformApplicationID(
      this.viewer
    );
    const thread = await ThreadEntity.findOne({
      where: {
        externalID: externalThreadID,
        platformApplicationID
      },
      transaction
    });
    const canSee = await this.loaders().privacyLoader.viewerHasThread(
      thread,
      true,
      transaction
    );
    return canSee ? thread : null;
  }
  /**
   * You generally shouldn't need to call this function:
   *
   * - If you want to check if the viewer can see a particular thread ID, just
   *   load it with loadThread (since you typically actually want the thread,
   *   not *just* to check if you can see it).
   * - If you want to check if the viewer can see a particular ThreadEntity,
   *   ideally fix the loading code to come through viewerHasThread and check
   *   privacy on load, or use loadThread on the ID if you must.
   */
  async assertViewerHasThread(id) {
    const thread = await this.loadThread(id);
    if (!thread) {
      throw new Error("Viewer does not have permission to access thread");
    }
  }
  async loadThreadsForPageImpl({
    filter,
    sort,
    limit,
    after,
    skipOrgCheck
  }) {
    const userID = assertViewerHasUser(this.viewer);
    const orgIDs = assertViewerHasOrgs(this.viewer);
    const platformApplicationID = assertViewerHasPlatformApplicationID(
      this.viewer
    );
    const limitPlusOne = limit ? limit + 1 : void 0;
    const whereConditions = [];
    const extraJoins = [];
    const ascending = sort?.sortDirection === "ascending";
    const orderByDirection = ascending ? "ASC" : "DESC";
    const makeTimeOrderByCondition = (threadID) => `
      SELECT ${sort?.sortBy === "first_message_timestamp" ? "MIN" : "MAX"}("timestamp") FROM messages
      WHERE "threadID"=${threadID} AND "deletedTimestamp" IS NULL
  `;
    const orderByCondition = makeTimeOrderByCondition("t.id");
    const bindVariables = [];
    if (skipOrgCheck) {
      bindVariables.push(platformApplicationID);
      whereConditions.push('t."platformApplicationID" = $1');
    } else {
      bindVariables.push(orgIDs);
      whereConditions.push('t."orgID" = ANY($1)');
    }
    if (filter?.resolved === true) {
      whereConditions.push(`t."resolvedTimestamp" IS NOT NULL`);
    } else if (filter?.resolved === false) {
      whereConditions.push(`t."resolvedTimestamp" IS NULL`);
    }
    if (filter?.metadata) {
      bindVariables.push(JSON.stringify(filter.metadata));
      whereConditions.push(`t."metadata" @> $${bindVariables.length}`);
    }
    if (filter?.viewer) {
      const viewerConditions = [];
      for (const f of unique6(filter.viewer)) {
        switch (f) {
          case "subscribed":
            bindVariables.push(userID);
            extraJoins.push(`INNER JOIN thread_participants tp
              ON (t.id = tp."threadID" AND tp."userID" = $${bindVariables.length})`);
            viewerConditions.push('tp."subscribed" = TRUE');
            break;
          case "mentioned":
            bindVariables.push(userID);
            viewerConditions.push(
              `t.id IN (
                SELECT "threadID" from messages m
                  INNER JOIN message_mentions mm ON (m.id = mm."messageID")
                WHERE mm."userID" = $${bindVariables.length}
                  AND m.type = 'user_message'
                  AND m."deletedTimestamp" IS NULL
              )`
            );
            break;
          default: {
            const _f = f;
            throw new Error(`Unknown filter: ${f}`);
          }
        }
      }
      if (viewerConditions.length) {
        whereConditions.push(`(${viewerConditions.join(" OR ")})`);
      }
    }
    if (filter?.location) {
      bindVariables.push(JSON.stringify(filter.location));
      extraJoins.push(`INNER JOIN pages p
         ON (p."orgID" = t."orgID" AND p."contextHash" = t."pageContextHash")`);
      whereConditions.push(`p."contextData" ${filter.partialMatch ? "@>" : "="} $${bindVariables.length}::jsonb
      `);
      if (!skipOrgCheck) {
        whereConditions.push(`p."orgID" = ANY($1)`);
      }
    }
    const limitCondition = isDefined(limitPlusOne) ? `LIMIT ${limitPlusOne}` : "";
    let paginationCondition = "";
    if (after) {
      bindVariables.push(after);
      paginationCondition = `WHERE orderTime ${ascending ? ">" : "<"} (${makeTimeOrderByCondition(`$${bindVariables.length}`)})`;
    }
    const threads = await getSequelize().query(
      `WITH unsortedThreads AS (
         SELECT t.*, (${orderByCondition}) AS orderTime
         FROM threads t
         ${extraJoins.join(" ")}
         WHERE ${whereConditions.join(" AND ")}
       )
       SELECT * FROM unsortedThreads
       ${paginationCondition}
       ORDER BY orderTime ${orderByDirection} NULLS LAST
       ${limitCondition};`,
      {
        bind: bindVariables,
        type: QueryTypes8.SELECT,
        model: ThreadEntity
      }
    );
    const hasMore = typeof limitPlusOne === "number" ? threads.length === limitPlusOne : false;
    const threadsToReturn = isDefined(limit) ? threads.slice(0, limit) : threads;
    return {
      threads: threadsToReturn,
      hasMore,
      token: threadsToReturn.at(-1)?.id
    };
  }
  async loadThreadsForPage(args) {
    const enablePerms = await getTypedFeatureFlagValue(
      FeatureFlags2.GRANULAR_PERMISSIONS,
      flagsUserFromViewer(this.viewer)
    );
    if (!enablePerms || viewerIsUsingOrgsAsFilter(this.viewer)) {
      return await this.loadThreadsForPageImpl(args);
    }
    const loaded = await filteredBatchLoad(
      async (token, limit) => {
        const batch = await this.loadThreadsForPageImpl({
          ...args,
          limit,
          after: token,
          skipOrgCheck: true
        });
        return {
          items: batch.threads,
          token: batch.token,
          hasMore: batch.hasMore
        };
      },
      async (t) => await this.loaders().privacyLoader.viewerHasThread(t, false),
      args.after,
      args.limit
    );
    return {
      threads: loaded.items,
      hasMore: loaded.hasMore,
      // The token might point at a thread that got filtered out, and since they
      // are just thread IDs we don't want to leak its existence, so force-reset
      // to the last thread we are returning.
      token: loaded.items.at(-1)?.id
    };
  }
  async threadMatchesFilter(threadID, filter) {
    const { userID, platformApplicationID } = assertViewerHasPlatformUser(
      this.viewer
    );
    const orgIDs = assertViewerHasOrgs(this.viewer);
    const bindVariables = [threadID, platformApplicationID, orgIDs];
    const whereConditions = [
      "t.id = $1",
      't."platformApplicationID" = $2',
      't."orgID" = ANY($3)'
    ];
    const extraJoins = [];
    if (filter.location) {
      bindVariables.push(JSON.stringify(filter.location));
      extraJoins.push(`INNER JOIN pages p
        ON(p."orgID" = t."orgID" AND p."contextHash" = t."pageContextHash")`);
      whereConditions.push(
        `p."contextData" ${filter.partialMatch ? "@>" : "="} $${bindVariables.length}::jsonb`
      );
    }
    if (filter.resolved === true) {
      whereConditions.push('t."resolvedTimestamp" IS NOT NULL');
    } else if (filter.resolved === false) {
      whereConditions.push('t."resolvedTimestamp" IS NULL');
    }
    if (filter?.metadata) {
      bindVariables.push(JSON.stringify(filter.metadata));
      whereConditions.push(`t."metadata" @> $${bindVariables.length}`);
    }
    if (filter?.viewer) {
      const viewerConditions = [];
      for (const f of unique6(filter.viewer)) {
        switch (f) {
          case "subscribed":
            bindVariables.push(userID);
            extraJoins.push(`INNER JOIN thread_participants tp
              ON (t.id = tp."threadID" AND tp."userID" = $${bindVariables.length})`);
            viewerConditions.push('tp."subscribed" = TRUE');
            break;
          case "mentioned":
            bindVariables.push(userID);
            viewerConditions.push(
              `t.id IN (
                  SELECT "threadID" from messages m
                    INNER JOIN message_mentions mm ON (m.id = mm."messageID")
                  WHERE mm."userID" = $${bindVariables.length}
                    AND m.type = 'user_message'
                    AND m."deletedTimestamp" IS NULL
                )`
            );
            break;
          default: {
            const _f = f;
            throw new Error(`Unknown filter: ${f}`);
          }
        }
      }
      if (viewerConditions.length) {
        whereConditions.push(`(${viewerConditions.join(" OR ")})`);
      }
    }
    const threads = await getSequelize().query(
      ` SELECT t.id
          FROM threads t
          ${extraJoins.join(" ")}
          WHERE ${whereConditions.join(" AND ")}
        `,
      {
        bind: bindVariables,
        type: QueryTypes8.SELECT
      }
    );
    return threads.length > 0;
  }
  async loadThreadActivitySummary({
    location,
    partialMatch,
    metadata,
    viewer,
    resolved
  }) {
    const userID = assertViewerHasUser(this.viewer);
    const orgIDs = assertViewerHasOrgs(this.viewer);
    const platformApplicationID = assertViewerHasPlatformApplicationID(
      this.viewer
    );
    const extraConditions = [];
    let extraJoin = "";
    const bindVariables = [
      orgIDs,
      userID,
      platformApplicationID
    ];
    if (location) {
      bindVariables.push(JSON.stringify(location));
      extraJoin = `INNER JOIN pages p
      ON(p."orgID" = t."orgID" AND p."contextHash" = t."pageContextHash")`;
      extraConditions.push(
        `p."contextData" ${partialMatch ? "@>" : "="} $${bindVariables.length}::jsonb`
      );
      extraConditions.push(`p."orgID" = ANY($1)`);
    }
    if (!isEmpty(metadata)) {
      bindVariables.push(JSON.stringify(metadata));
      extraConditions.push(`t."metadata" @> $${bindVariables.length}::jsonb`);
    }
    if (viewer) {
      const viewerConditions = [];
      for (const f of unique6(viewer)) {
        switch (f) {
          case "subscribed":
            viewerConditions.push('tp."subscribed" = TRUE');
            break;
          case "mentioned":
            viewerConditions.push(
              `t.id IN (
                  SELECT "threadID" from messages m
                    INNER JOIN message_mentions mm ON (m.id = mm."messageID")
                  WHERE mm."userID" = $2
                    AND m.type = 'user_message'
                    AND m."deletedTimestamp" IS NULL
                )`
            );
            break;
          default: {
            const _f = f;
            throw new Error(`Unknown filter: ${f}`);
          }
        }
      }
      if (viewerConditions.length) {
        extraConditions.push(`(${viewerConditions.join(" OR ")})`);
      }
    }
    if (resolved === true) {
      extraConditions.push(`t."resolvedTimestamp" IS NOT NULL`);
    } else if (resolved === false) {
      extraConditions.push(`t."resolvedTimestamp" IS NULL`);
    }
    const extraCondition = extraConditions.length > 0 ? `AND ${extraConditions.join(" AND ")}` : "";
    const result = await getSequelize().query(
      `
      WITH thread_props AS (
        SELECT EXISTS (
            SELECT 1 FROM messages
            WHERE "deletedTimestamp" IS NULL
              AND type = 'user_message'
              AND "threadID" = t.id
              AND "platformApplicationID" = $3
          ) AS has_message,
          EXISTS (
            SELECT 1 FROM messages
            WHERE "deletedTimestamp" IS NULL
              AND type = 'user_message'
              AND "threadID" = t.id
              AND "platformApplicationID" = $3
              AND timestamp > COALESCE(tp."lastSeenTimestamp", '-infinity'::timestamp)
          ) AS has_unread,
          EXISTS (
            SELECT 1 FROM messages
            WHERE "deletedTimestamp" IS NULL
              AND type = 'user_message'
              AND "threadID" = t.id
              AND "platformApplicationID" = $3
          ) AND tp."lastSeenTimestamp" IS NULL AS all_unread,
          COALESCE(tp.subscribed, FALSE) AS subscribed,
          t."resolvedTimestamp" IS NOT NULL AS resolved
        FROM threads t
        LEFT JOIN thread_participants tp ON (tp."threadID", tp."userID", tp."orgID") = (t.id, $2, t."orgID")
        ${extraJoin}
        WHERE t."orgID" = ANY($1)
        ${extraCondition}
      )
      SELECT
        (COUNT(*) FILTER (WHERE has_message))::integer AS "totalThreadCount",
        (COUNT(*) FILTER (WHERE has_unread AND NOT resolved))::integer AS "unreadThreadCount",
        (COUNT(*) FILTER (WHERE has_unread AND subscribed AND NOT resolved))::integer AS "unreadSubscribedThreadCount",
        (COUNT(*) FILTER (WHERE resolved))::integer AS "resolvedThreadCount",
        (COUNT(*) FILTER (WHERE all_unread AND NOT resolved))::integer AS "newThreadCount",
        (COUNT(*) FILTER (WHERE NOT has_message))::integer AS "emptyThreadCount"
      FROM thread_props
      `,
      {
        type: QueryTypes8.SELECT,
        bind: bindVariables
      }
    );
    return result[0];
  }
  async loadNewMessageCountNoOrgCheck(threadID) {
    return await this.newMessageCountDataloader.load(threadID);
  }
  async loadNewReactionsCountNoOrgCheck(threadID) {
    return await this.newReactionCountDataloader.load(threadID);
  }
  async getFirstUnseenMessageIDNoOrgCheck(threadID) {
    return await this.firstUnseenMessageIDDataloader.load(threadID);
  }
  async loadMessagesCountExcludingDeletedNoOrgCheck(threadID, cursor) {
    if (cursor) {
      return await MessageEntity.count({
        where: {
          threadID,
          deletedTimestamp: { [Op7.is]: null },
          timestamp: { [Op7.lt]: timestampSubquery(cursor) }
        }
      });
    } else {
      return await this.messagesCountExcludingDeletedNoOrgCheckDataloader.load(
        threadID
      );
    }
  }
  /**
   * Returns the number of messages in a thread including any deleted messages
   * and any action messages (resolved/unresolved).
   */
  async loadMessagesCountNoOrgCheck(threadID) {
    return await this.messagesCountNoOrgCheckDataloader.load(threadID);
  }
  async loadUserMessagesCountNoOrgCheck(threadID) {
    return await this.userMessagesCountDataloader.load(threadID);
  }
  async loadActionMessagesCountNoOrgCheck(threadID) {
    return await this.actionMessagesCountDataloader.load(threadID);
  }
  /**
   * Returns the number of replies in a thread excluding any deleted messages
   * and any action messages (resolved/unresolved).
   * The first message in the thread is ignored in this count as it is not a reply.
   */
  async loadReplyCount(threadID) {
    return await this.messagesReplyCountDataloader.load(threadID);
  }
  // This is called once to load the initial messages for a thread
  // loads the first message of thread
  // loads the 10 previous messages either before any unread
  // loads unread messages based on thread participant lastSeenTimestamp
  async loadInitialMessagesNoOrgCheck(threadID, initialFetchCount) {
    return await this.initialMessagesDataloader.load([
      threadID,
      initialFetchCount
    ]);
  }
  async loadRecentlyActiveThreads(orgID) {
    const rows = await getSequelize().query(
      `SELECT "threadID" FROM
         (SELECT DISTINCT ON ("threadID") "threadID", timestamp
          FROM messages
          WHERE
            "orgID" = $1
            AND "deletedTimestamp" IS NULL
          ORDER BY "threadID", timestamp DESC) as subquery
       ORDER BY timestamp DESC
       LIMIT 20;`,
      { bind: [orgID], type: QueryTypes8.SELECT }
    );
    return rows.map((row) => row.threadID);
  }
  async loadMessagesCountBeforeNoOrgCheck(threadID, messageID) {
    const rows = await getSequelize().query(
      `SELECT COUNT(m) AS count FROM messages m
       WHERE "threadID"=$1
       AND "deletedTimestamp" IS NULL
       AND timestamp < (
           SELECT timestamp FROM messages
           WHERE "threadID"=$1 AND "id"=$2
       );`,
      {
        bind: [threadID, messageID],
        type: QueryTypes8.SELECT
      }
    );
    return rows[0]?.count ?? 0;
  }
  async loadSlackMirroredThreadInfoNoOrgCheck(threadID) {
    return await this.slackMirroredThreadInfoDataloader.load(threadID);
  }
  async hasUserMessagesNoOrgCheck(threadID) {
    return await this.userMessagesCountDataloader.load(threadID).then((c) => c > 0);
  }
  async loadReplyingUserIDsNoOrgCheck(threadID) {
    return await this.replyingUserIDsDataloader.load(threadID);
  }
  /**
   * Returns all the authors of action messages in the thread's replies.
   */
  async loadActionMessageReplyingUserIDsNoOrgCheck(threadID) {
    return await this.actionMessageReplyingUserIDsDataloader.load(threadID);
  }
};

// server/src/entity/page_visitor/PageVisitorLoader.ts
import { QueryTypes as QueryTypes9 } from "sequelize";
var PageVisitorLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  loadForContextHash(pageContextHash, orgOverride) {
    const orgIDs = assertViewerHasOrgs(this.viewer);
    return getSequelize().query(
      `SELECT pv.*
       FROM page_visitors pv
       INNER JOIN users u ON u.id=pv."userID"
       WHERE u.state != 'deleted'
       AND pv."pageContextHash"=$1
       AND pv."orgID"=ANY($2);`,
      {
        type: QueryTypes9.SELECT,
        bind: [pageContextHash, orgOverride ? [orgOverride] : orgIDs],
        model: PageVisitorEntity
      }
    );
  }
  async latestForContext(matcher, exactMatch) {
    const orgIDs = assertViewerHasOrgs(this.viewer);
    const latest = /* @__PURE__ */ new Map();
    const results = await getSequelize().query(
      `SELECT DISTINCT ON (pv."userID")
       p."contextData" as "contextData", u."externalID" as "externalUserID", pv."lastPresentTimestamp" as "lastPresentTimestamp"
       FROM pages p INNER JOIN page_visitors pv 
                    ON (p."orgID" = pv."orgID" AND p."contextHash" = pv."pageContextHash")
                    INNER JOIN users u
                    ON (u.id = pv."userID")
       WHERE "contextData" ${exactMatch ? "=" : "@>"} $1::jsonb
         AND p."orgID" = ANY($2)
         AND u.state != 'deleted'
       ORDER BY pv."userID", "lastPresentTimestamp" DESC`,
      {
        bind: [(0, import_types.locationJson)(matcher), orgIDs],
        type: QueryTypes9.SELECT
      }
    );
    for (const row of results) {
      latest.set(row.externalUserID, {
        context: row.contextData,
        timestamp: row.lastPresentTimestamp.getTime()
      });
    }
    return latest;
  }
};

// server/src/entity/thread_participant/ThreadParticipantLoader.ts
import { Op as Op8 } from "sequelize";
import DataLoader16 from "dataloader";
import { unique as unique7 } from "radash";
var ThreadParticipantLoader = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.loadForUserNoOrgCheckDataloader = new DataLoader16(
      async (userThreadPairs) => {
        function getKey(x) {
          return `${x.threadID}/${x.userID}`;
        }
        const uniqPairs = unique7(userThreadPairs, getKey);
        const all = await ThreadParticipantEntity.findAll({
          where: { [Op8.or]: [...uniqPairs] }
        });
        return inKeyOrderOrNullCustom(all, userThreadPairs.map(getKey), getKey);
      },
      { cache: false }
    );
    this.loadForThreadIDNoOrgCheckDataloader = new DataLoader16(
      async (keys) => {
        const participants = await ThreadParticipantEntity.findAll({
          where: { threadID: unique7(keys) }
        });
        return inKeyOrderGroupedCustom(participants, keys, (p) => p.threadID);
      },
      { cache: false }
    );
  }
  async loadForThreadIDNoOrgCheck(threadID) {
    const participants = await this.loadForThreadIDNoOrgCheckDataloader.load(threadID);
    return await asyncFilter(
      participants,
      async (p) => await this.loaders().privacyLoader.viewerHasParticipant(p)
    );
  }
  async loadForUser(args) {
    const { orgID } = assertViewerHasIdentity(this.viewer);
    const participant = await ThreadParticipantEntity.findOne({
      where: { threadID: args.threadID, orgID, userID: args.userID }
    });
    const canSee = await this.loaders().privacyLoader.viewerHasParticipant(participant);
    return canSee ? participant : null;
  }
  async loadForUserNoOrgCheck(args) {
    return await this.loadForUserNoOrgCheckDataloader.load(args);
  }
  async loadNewlyActiveThreads() {
    const userID = assertViewerHasUser(this.viewer);
    const orgMembersLoader = new OrgMembersLoader(this.viewer);
    const orgIDFilter = await orgMembersLoader.loadAllImmediateOrgIDsForUser();
    const lastUnseenCondition = {
      [Op8.or]: [
        { lastUnseenMessageTimestamp: { [Op8.ne]: null } },
        { lastUnseenReactionTimestamp: { [Op8.ne]: null } }
      ]
    };
    const threadParticipantEntities = await ThreadParticipantEntity.findAll({
      where: {
        userID,
        orgID: orgIDFilter,
        subscribed: true,
        ...lastUnseenCondition
      },
      order: [["lastUnseenMessageTimestamp", "DESC"]]
    });
    return (await asyncFilter(
      threadParticipantEntities,
      async (p) => await this.loaders().privacyLoader.viewerHasParticipant(p)
    )).map(({ threadID }) => threadID);
  }
  async loadSubscriberIDsForThreadNoOrgCheck(threadID) {
    return (await ThreadParticipantEntity.findAll({
      where: {
        threadID,
        subscribed: true
      }
    })).map((p) => p.userID);
  }
  async loadSubscribedNoOrgCheck(threadID) {
    const userID = assertViewerHasUser(this.viewer);
    const data = await this.loadForUserNoOrgCheck({
      userID,
      threadID
    });
    return data?.subscribed === true;
  }
  async isViewerThreadParticipantNoOrgCheck(threadID) {
    const userID = assertViewerHasUser(this.viewer);
    const threadParticipant = await this.loadForUserNoOrgCheck({
      userID,
      threadID
    });
    return threadParticipant ? true : false;
  }
  async loadInboxCount() {
    const userID = assertViewerHasUser(this.viewer);
    const orgMembersLoader = new OrgMembersLoader(this.viewer);
    const orgIDFilter = await orgMembersLoader.loadAllImmediateOrgIDsForUser();
    const lastUnseenCondition = {
      [Op8.or]: [
        { lastUnseenMessageTimestamp: { [Op8.not]: null } },
        { lastUnseenReactionTimestamp: { [Op8.not]: null } }
      ]
    };
    const where = {
      userID,
      orgID: orgIDFilter,
      subscribed: true,
      ...lastUnseenCondition
    };
    return await ThreadParticipantEntity.count({ where });
  }
  async loadThreadsInArchive() {
    const userID = assertViewerHasUser(this.viewer);
    const orgMembersLoader = new OrgMembersLoader(this.viewer);
    const orgIDFilter = await orgMembersLoader.loadAllImmediateOrgIDsForUser();
    const [rows] = await getSequelize().query(
      `
      SELECT
        subquery."threadID" as id
      FROM (
        SELECT
          DISTINCT ON (tp."threadID")
          tp."threadID",
          m."timestamp"
        FROM
          thread_participants as tp,
          messages as m
        WHERE
          tp."userID" = $1
          AND tp."orgID" = ANY($2)
          AND tp."subscribed" = TRUE
          AND tp."lastUnseenMessageTimestamp" IS NULL
          AND tp."threadID" = m."threadID"
          AND m."deletedTimestamp" IS NULL
        ORDER BY
          tp."threadID",
          m."timestamp" DESC
      ) as subquery
      ORDER BY
        subquery."timestamp" DESC
      LIMIT 20;`,
      {
        bind: [userID, orgIDFilter]
      }
    );
    return rows.map((row) => row.id);
  }
  async loadSeenByUsers(message) {
    const timestamp = message.lastUpdatedTimestamp ?? message.timestamp;
    const seenByUsers = await ThreadParticipantEntity.findAll({
      where: {
        threadID: message.threadID,
        [Op8.or]: {
          lastSeenTimestamp: { [Op8.not]: null, [Op8.gt]: timestamp },
          // A user has always seen their own messages
          userID: message.sourceID
        }
      }
    });
    const userIDs = (await asyncFilter(
      seenByUsers,
      async (p) => await this.loaders().privacyLoader.viewerHasParticipant(p)
    )).map((user) => user.userID);
    const userLoader = new UserLoader(this.viewer, this.loaders, false);
    const users = await userLoader.loadUsersInOrg(userIDs, message.orgID);
    return users;
  }
};

// server/src/entity/email_subscription/EmailSubscriptionLoader.ts
var EmailSubscriptionLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async isUserSubscribedToThread(userID, threadID) {
    const result = await EmailSubscriptionEntity.findOne({
      where: { userID, threadID }
    });
    return result?.subscribed ?? true;
  }
};

// server/src/entity/slack_mirrored_thread/SlackMirroredThreadLoader.ts
import { Op as Op9 } from "sequelize";
var SlackMirroredThreadLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadFromThreadID(threadID) {
    const orgIDs = assertViewerHasOrgs(this.viewer);
    return await SlackMirroredThreadEntity.findOne({
      where: {
        threadID,
        [Op9.or]: { slackOrgID: orgIDs, threadOrgID: orgIDs }
      }
    });
  }
  async loadFromSlackID(slackChannelID, slackMessageTimestamp) {
    const orgID = assertViewerHasOrg(this.viewer);
    return await SlackMirroredThreadEntity.findOne({
      where: {
        slackChannelID,
        slackMessageTimestamp,
        [Op9.or]: { slackOrgID: orgID, threadOrgID: orgID }
      }
    });
  }
  async threadIsMirrored(threadID) {
    const [rows] = await getSequelize().query(
      `SELECT 1 FROM slack_mirrored_threads WHERE "threadID"=$1 LIMIT 1;`,
      {
        bind: [threadID]
      }
    );
    return rows.length > 0;
  }
};

// server/src/entity/user/ConsoleUserLoader.ts
import { Op as Op10 } from "sequelize";
var ConsoleUserLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadUser(email, transaction) {
    return await ConsoleUserEntity.findOne({
      where: { email },
      transaction
    });
  }
  async loadConsoleUsersForCustomer(customerID, includingPendingUsers) {
    let whereOptions = {
      customerID
    };
    if (includingPendingUsers) {
      whereOptions = {
        [Op10.or]: {
          customerID,
          pendingCustomerID: customerID
        }
      };
    }
    return await ConsoleUserEntity.findAll({
      where: whereOptions,
      order: ["pendingCustomerID"]
    });
  }
  async loadPendingUserInCustomer(email, pendingCustomerID, transaction) {
    return await ConsoleUserEntity.findOne({
      where: { email, pendingCustomerID },
      transaction
    });
  }
};

// server/src/entity/deploys/DeploysLoader.ts
import { Op as Op11 } from "sequelize";
var mostRecentDeployCache = /* @__PURE__ */ new Map();
var DeploysLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadMostRecentSuccessfulDeploymentCached(version2, tier3) {
    try {
      const key = `${tier3}/${version2}`;
      if (mostRecentDeployCache.has(key)) {
        return mostRecentDeployCache.get(key);
      }
      const deploy = await DeploysEntity.findOne({
        where: {
          packageVersion: version2,
          tier: tier3,
          success: true,
          deployFinishTime: {
            [Op11.ne]: null
          }
        },
        order: [["deployFinishTime", "DESC"]]
      });
      if (deploy?.deployFinishTime) {
        mostRecentDeployCache.set(key, deploy.deployFinishTime);
      }
      return deploy?.deployFinishTime ?? null;
    } catch (e) {
      return null;
    }
  }
};

// server/src/entity/customer/CustomerLoader.ts
import DataLoader17 from "dataloader";
var CustomerLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader17(
      async (keys) => {
        const buckets = await CustomerEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrder(buckets, keys);
      },
      { cache: false }
    );
  }
  async load(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("Customer dataloader error", e);
      return null;
    }
  }
  async loadAll() {
    return await CustomerEntity.findAll();
  }
};

// server/src/entity/application_usage_metric/ApplicationUsageMetricLoader.ts
import { QueryTypes as QueryTypes10 } from "sequelize";
var ApplicationUsageMetricLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  /**
   * Load stored application usage metrics from the database and return them in
   * the format in which we deliver them in GraphQL: an array of JSON objects,
   * one per day, in chronological order. Each object contains the field `date`,
   * with a date string, and fields for the requested metrics.
   */
  async loadUsageMetrics(applicationID, metrics, days) {
    const rows = await getSequelize().query(
      `SELECT
        jsonb_build_object('date', d.day) ||
        jsonb_object_agg(mt.metric, m.value)
        AS data
      FROM (SELECT CURRENT_DATE-generate_series(1,$1) AS day) d
      CROSS JOIN application_usage_metric_types mt
      LEFT OUTER JOIN application_usage_metrics m
        ON m."applicationID"=$2
        AND m.date=d.day
        AND m."metricID"=mt.id
      WHERE mt.metric=ANY($3)
      GROUP BY d.day ORDER BY d.day;`,
      {
        type: QueryTypes10.SELECT,
        bind: [days, applicationID, metrics]
      }
    );
    return rows.map((row) => row.data);
  }
  async loadLatestUsage(metric, applicationIDs) {
    const rows = await getSequelize().query(
      `SELECT
      m.date,
      m."applicationID",
      jsonb_object_agg(mt.metric, m.value) AS data
    FROM application_usage_metrics m
    JOIN application_usage_metric_types mt ON m."metricID" = mt.id
    WHERE
      m.date = (
        SELECT
          MAX(date)
        FROM
          application_usage_metrics
      )
      AND mt.metric=$1
      and m."applicationID"=ANY($2)
    GROUP BY
      m.date,
      m."applicationID";`,
      {
        type: QueryTypes10.SELECT,
        bind: [metric, applicationIDs]
      }
    );
    return rows.map((row) => row.data);
  }
};

// server/src/entity/notification/NotificationLoader.ts
import { QueryTypes as QueryTypes12 } from "sequelize";

// server/src/notifications/fetch.ts
import { QueryTypes as QueryTypes11 } from "sequelize";

// server/src/notifications/types/thread_action.ts
async function buildThreadActionNotification(context, notif) {
  assert(
    notif.recipientID === context.session.viewer.userID,
    "Viewer must be notif recipient"
  );
  if (notif.senderID === null) {
    throw new Error("Thread action notif must have a sender");
  }
  if (notif.threadID === null) {
    throw new Error("Thread action notif must have a threadID");
  }
  const [sender, thread] = await Promise.all([
    context.loaders.userLoader.loadUser(notif.senderID),
    context.loaders.threadLoader.loadThread(notif.threadID)
  ]);
  if (sender === null) {
    throw new Error("Unable to load sender");
  }
  if (thread === null) {
    throw new Error("Unable to load thread");
  }
  if (!notif.threadActionType) {
    throw new Error(
      "threadActionType must be present for thread action notifs"
    );
  }
  const [header, translationKey] = headerText(notif.threadActionType);
  return {
    id: notif.id,
    externalID: notif.externalID,
    senders: [sender],
    iconUrl: null,
    header: [
      {
        user: sender
      },
      {
        text: ` ${header} `,
        bold: false
      },
      {
        text: thread.name,
        bold: true
      }
    ],
    headerTranslationKey: translationKey,
    headerSimpleTranslationParams: { threadName: thread.name },
    readStatus: notif.readStatus,
    timestamp: notif.createdTimestamp,
    extraClassnames: notif.extraClassnames,
    metadata: notif.metadata,
    attachment: { thread }
  };
}
function headerText(action) {
  switch (action) {
    case "resolve":
      return [`resolved the thread`, "cord.thread_resolve"];
    case "unresolve":
      return [`reopened the thread`, "cord.thread_unresolve"];
    default: {
      const _ = action;
      throw new Error("Unknown thread action type: " + action);
    }
  }
}

// server/src/notifications/types/external.ts
async function buildExternalNotification(context, notif) {
  assert(
    notif.recipientID === context.session.viewer.userID,
    "Viewer must be notif recipient"
  );
  if (notif.externalTemplate === null || notif.externalURL === null) {
    throw new Error("External notif must have template and URL");
  }
  const [sender, recipient] = await Promise.all([
    notif.senderID ? context.loaders.userLoader.loadUser(notif.senderID) : null,
    context.loaders.userLoader.loadUser(notif.recipientID)
  ]);
  if (recipient === null) {
    throw new Error("Unable to load recipient");
  }
  return {
    id: notif.id,
    externalID: notif.externalID,
    senders: sender ? [sender] : [],
    iconUrl: notif.iconUrl,
    header: externalHeader(notif.externalTemplate, sender, recipient),
    headerTranslationKey: null,
    headerSimpleTranslationParams: null,
    attachment: { url: notif.externalURL },
    readStatus: notif.readStatus,
    timestamp: notif.createdTimestamp,
    extraClassnames: notif.extraClassnames,
    metadata: notif.metadata
  };
}
function externalHeader(template, sender, recipient) {
  const re = /({{ *(?:actor|recipient) *}})/;
  const result = [];
  for (const segment of template.split(re)) {
    if (segment === "") {
      continue;
    } else if (segment.match(re) === null) {
      result.push({ text: segment, bold: false });
    } else if (sender && segment.includes("actor")) {
      result.push({ user: sender });
    } else if (segment.includes("recipient")) {
      result.push({ user: recipient });
    } else {
      throw new Error(`What did we match?! ${segment}`);
    }
  }
  return result;
}

// server/src/notifications/types/reaction.ts
import { unique as unique8 } from "radash";
async function buildReactionNotification(context, notifs) {
  const firstNotif = notifs[0];
  const firstNotifReaction = firstNotif.reactionID;
  if (firstNotifReaction === null) {
    throw new Error("Reaction notif must have reactionID");
  }
  notifs.forEach((notification) => {
    if (!notification.senderID) {
      throw new Error(`Reaction notif must have a sender`);
    }
  });
  const [maybeSenders, message, reactionUnicode] = await Promise.all([
    Promise.all(
      notifs.map((n) => context.loaders.userLoader.loadUser(n.senderID))
    ),
    (async () => {
      const reaction = await context.loaders.messageReactionLoader.loadReactionNoOrgCheck(
        firstNotifReaction
      );
      if (!reaction) {
        return null;
      }
      return await context.loaders.messageLoader.loadMessage(
        reaction.messageID
      );
    })(),
    (async () => {
      const reaction = await context.loaders.messageReactionLoader.loadReactionNoOrgCheck(
        firstNotifReaction
      );
      return reaction?.unicodeReaction ?? null;
    })()
  ]);
  if (message === null) {
    throw new Error("Unable to load message");
  }
  if (reactionUnicode === null) {
    throw new Error("Unable to load message reaction");
  }
  if (message.deletedTimestamp) {
    return null;
  }
  const senders = unique8(maybeSenders.filter(isNotNull), (u) => u.id);
  if (senders.length === 0) {
    throw new Error("Unable to load any senders");
  }
  await context.loaders.threadLoader.assertViewerHasThread(message.threadID);
  const [header, headerTranslationKey, headerSimpleTranslationParams] = getHeader2(senders, reactionUnicode);
  return {
    id: firstNotif.id,
    externalID: firstNotif.externalID,
    senders,
    iconUrl: null,
    header,
    headerTranslationKey,
    headerSimpleTranslationParams,
    attachment: {
      message
    },
    readStatus: firstNotif.readStatus,
    timestamp: firstNotif.createdTimestamp,
    extraClassnames: firstNotif.extraClassnames,
    metadata: firstNotif.metadata
  };
}
function getHeader2(senders, reactionUnicode) {
  if (senders.length === 0) {
    throw new Error("Notification must have at least one sender!");
  } else if (senders.length === 1) {
    return [
      [
        {
          user: senders[0]
        },
        {
          text: ` reacted ${reactionUnicode} to your message`,
          bold: false
        }
      ],
      "cord.reaction_single",
      { reaction: reactionUnicode }
    ];
  } else if (senders.length === 2) {
    return [
      [
        {
          user: senders[0]
        },
        {
          text: " and ",
          bold: true
        },
        {
          user: senders[1]
        },
        {
          text: ` reacted ${reactionUnicode} to your message`,
          bold: false
        }
      ],
      "cord.reaction_double",
      { reaction: reactionUnicode }
    ];
  } else {
    return [
      [
        {
          user: senders[0]
        },
        {
          text: ` and ${senders.length - 1} others`,
          bold: true
        },
        {
          text: ` reacted ${reactionUnicode} to your message`,
          bold: false
        }
      ],
      "cord.reaction_overflow",
      { reaction: reactionUnicode, count: senders.length - 1 }
    ];
  }
}

// server/src/notifications/types/reply.ts
async function buildReplyNotification(context, notif) {
  assert(
    notif.recipientID === context.session.viewer.userID,
    "Viewer must be notif recipient"
  );
  if (notif.messageID === null) {
    throw new Error("Reply notif must have messageID");
  }
  if (notif.replyActions === null) {
    throw new Error("No reply actions");
  }
  if (notif.senderID === null) {
    throw new Error("Reply notif must have a sender");
  }
  const [sender, message] = await Promise.all([
    context.loaders.userLoader.loadUser(notif.senderID),
    context.loaders.messageLoader.loadMessage(notif.messageID)
  ]);
  if (sender === null) {
    throw new Error("Unable to load sender");
  }
  if (message === null) {
    throw new Error("Unable to load message");
  }
  if (message.deletedTimestamp) {
    return null;
  }
  const thread = await context.loaders.threadLoader.loadThread(
    message.threadID
  );
  if (thread === null) {
    throw new Error("Unable to load thread");
  }
  const [header, connective, translationKey] = headerText2(notif.replyActions);
  return {
    id: notif.id,
    externalID: notif.externalID,
    senders: [sender],
    iconUrl: null,
    header: [
      {
        user: sender
      },
      {
        text: ` ${header} ${connective} `,
        bold: false
      },
      {
        text: thread.name,
        bold: true
      }
    ],
    headerTranslationKey: translationKey,
    headerSimpleTranslationParams: { threadName: thread.name },
    attachment: {
      message
    },
    readStatus: notif.readStatus,
    timestamp: notif.createdTimestamp,
    extraClassnames: notif.extraClassnames,
    metadata: notif.metadata
  };
}
function headerText2(actions) {
  if (actions.includes("unassign-task")) {
    let text = "unassigned you from a task";
    let key = "cord.reply_unassign";
    if (actions.includes("mention")) {
      text = "mentioned you and " + text;
      key = "cord.reply_mention_unassign";
    }
    return [text, "in", key];
  } else if (actions.includes("assign-task")) {
    let text = "assigned you to a task";
    let key = "cord.reply_assign";
    if (actions.includes("mention")) {
      text = "mentioned you and " + text;
      key = "cord.reply_mention_assign";
    }
    return [text, "in", key];
  } else if (actions.includes("mention")) {
    let text = "mentioned you";
    let key = "cord.reply_mention";
    if (actions.includes("attach-file")) {
      text += " and sent you a file";
      key = "cord.reply_mention_attachment";
    }
    return [text, "in", key];
  } else if (actions.includes("create-thread")) {
    return ["created a new thread", "named", "cord.thread_create"];
  } else {
    return ["replied", "on", "cord.reply"];
  }
}

// server/src/public/routes/platform/util.ts
import isJWT from "validator/lib/isJWT.js";
import { Op as Op13 } from "sequelize";
import { v4 as uuid3 } from "uuid";
import { verify as verify2 } from "jsonwebtoken";

// server/src/entity/user/UserMutator.ts
import { Op as Op12, Sequelize as Sequelize10 } from "sequelize";
var nowOrNull = (before, after) => {
  if (!isDefined(before) && !isDefined(after)) {
    return null;
  } else if (before === after) {
    return null;
  } else {
    return Sequelize10.fn("NOW");
  }
};
var UserMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
  }
  async findOrCreateExternalUser(userData, transaction) {
    if (this.viewer.userID !== SERVICE_USER_ID) {
      throw new Error("Only a service user can create users.");
    }
    if (userData.externalProvider === "platform" /* PLATFORM */ && !userData.platformApplicationID) {
      throw new Error(
        "platformApplicationID must be defined to create a platform user"
      );
    }
    const { externalProvider, externalID, platformApplicationID } = userData;
    const result = await UserEntity.findOrCreate({
      where: {
        externalProvider,
        externalID,
        ...platformApplicationID && { platformApplicationID }
      },
      defaults: {
        ...userData,
        userType: "person",
        nameUpdatedTimestamp: nowOrNull(void 0, userData.name),
        profilePictureURLUpdatedTimestamp: nowOrNull(
          void 0,
          userData.profilePictureURL
        )
      },
      // "as any" to work around deficiency in sequelize types, not combined with "where" items.
      transaction
    });
    this.loaders?.userLoader.clearAll();
    return result;
  }
  async updateOrCreateExternalUserInSlackOrg(userData, orgID, userDeletedInSlack, transaction) {
    const [user, isNewUser] = await this.findOrCreateExternalUser(
      userData,
      transaction
    );
    if (user.state === "deleted") {
      return [null, false];
    }
    if (userDeletedInSlack) {
      await OrgMembersEntity.destroy({
        where: { orgID, userID: user.id },
        transaction
      });
    } else {
      await OrgMembersEntity.findOrCreate({
        where: { orgID, userID: user.id },
        defaults: {},
        // "as any" to work around deficiency in sequelize types, not combined with "where" items.
        transaction
      });
    }
    if (isNewUser) {
      return [user, true];
    } else {
      const { externalProvider, externalID, ...updateFields } = userData;
      const filteredUpdateFields = Object.fromEntries(
        Object.entries(updateFields).filter(
          ([_, value]) => value !== void 0
        )
      );
      const userChanged = Object.entries(filteredUpdateFields).some(
        ([key, value]) => !isEqual(user[key], value)
      );
      if (!userChanged) {
        return [user, false];
      }
      const nameUpdatedTimestamp = nowOrNull(
        user.name,
        filteredUpdateFields.name
      );
      const profilePictureURLUpdatedTimestamp = nowOrNull(
        user.profilePictureURL,
        filteredUpdateFields.profilePictureURL
      );
      const [_numberOfRows, users] = await UserEntity.update(
        {
          ...filteredUpdateFields,
          ...nameUpdatedTimestamp && { nameUpdatedTimestamp },
          ...profilePictureURLUpdatedTimestamp && {
            profilePictureURLUpdatedTimestamp
          }
        },
        {
          where: { externalProvider, externalID },
          returning: true,
          transaction
        }
      );
      this.loaders?.userLoader.clearAll();
      if (users.length > 0) {
        return [users[0], true];
      } else {
        throw new Error("User got deleted between SELECT and UPDATE");
      }
    }
  }
  async updateProfilePictureURL(url6) {
    const fields = { profilePictureURL: url6 };
    await UserEntity.update(fields, { where: { id: this.viewer.userID } });
    this.loaders?.userLoader.clearAll();
  }
  async updateUser(user, data, transaction) {
    const { name, email, screenName, profilePictureURL, state, metadata } = data;
    if (name !== void 0 && user.name !== name || email !== void 0 && user.email !== email || screenName !== void 0 && user.screenName !== screenName || profilePictureURL !== void 0 && user.profilePictureURL !== profilePictureURL || state !== void 0 && user.state !== state || metadata !== void 0 && !isEqual(user.metadata, metadata)) {
      const nameUpdatedTimestamp = nowOrNull(user.name, name);
      const profilePictureURLUpdatedTimestamp = nowOrNull(
        user.profilePictureURL,
        profilePictureURL
      );
      await user.update(
        {
          ...data,
          ...nameUpdatedTimestamp && { nameUpdatedTimestamp },
          ...profilePictureURLUpdatedTimestamp && {
            profilePictureURLUpdatedTimestamp
          }
        },
        { transaction }
      );
      this.loaders?.userLoader.clearAll();
      return true;
    }
    return false;
  }
  async findOrCreateAndUpdateApplicationSupportBot(application, name, profilePictureURL, transaction) {
    const bot = application.supportBotID ? await UserEntity.findByPk(application.supportBotID, { transaction }) : await UserEntity.create(
      { userType: "bot", platformApplicationID: application.id },
      { transaction }
    );
    if (!bot) {
      throw new Error("No support bot found");
    }
    const result = await bot.update(
      {
        name,
        // technically this might not have changed but it doesn't matter
        // since this is the only way to set the support bot's profile (not
        // through Settings or slack linking)
        nameUpdatedTimestamp: Sequelize10.fn("NOW"),
        profilePictureURL,
        // same as for nameUpdatedTimestamp
        profilePictureURLUpdatedTimestamp: Sequelize10.fn("NOW")
      },
      { transaction }
    );
    this.loaders?.userLoader.clearAll();
    return result;
  }
  async rawBulkCreate(records, transaction) {
    const result = await UserEntity.bulkCreate(records, {
      transaction,
      updateOnDuplicate: [
        "name",
        "screenName",
        "nameUpdatedTimestamp",
        "email",
        "profilePictureURL",
        "profilePictureURLUpdatedTimestamp",
        "externalProvider",
        "state",
        "metadata"
      ],
      conflictWhere: { platformApplicationID: { [Op12.ne]: null } }
    });
    this.loaders?.userLoader.clearAll();
    return result;
  }
};

// server/src/public/routes/platform/util.ts
var ApiErrors = {
  // Database queries
  project_not_found: {
    statusCode: 401,
    message: "Platform project not found."
  },
  group_not_found: {
    statusCode: 401,
    message: "Platform group not found."
  },
  organization_not_found: {
    statusCode: 401,
    message: "Platform organization not found."
  },
  group_already_exists: {
    statusCode: 409,
    message: "Platform group already exists."
  },
  organization_already_exists: {
    statusCode: 409,
    message: "Platform organization already exists."
  },
  user_not_found: {
    statusCode: 401,
    message: "Platform user not found."
  },
  user_already_exists: {
    statusCode: 409,
    message: "Platform user already exists."
  },
  user_not_in_group: {
    statusCode: 401,
    message: "The user is not a member of the group."
  },
  user_not_in_organization: {
    statusCode: 401,
    message: "The user is not a member of the oranization."
  },
  invalid_user_id: {
    statusCode: 401,
    message: "Invalid user id"
  },
  group_members_missing: {
    statusCode: 401,
    message: "Could not find some group members"
  },
  // Request input
  invalid_request: {
    statusCode: 400,
    message: "Invalid request."
  },
  unexpected_field: {
    statusCode: 400,
    message: "Unexpected field."
  },
  invalid_field: {
    statusCode: 400,
    message: "Invalid field type."
  },
  missing_field: {
    statusCode: 400,
    message: "Missing field in request."
  },
  // Authorization
  invalid_project_token: {
    statusCode: 401,
    message: "Invalid project token."
  },
  invalid_customer_token: {
    statusCode: 401,
    message: "Invalid customer token."
  },
  expired_access_token: {
    statusCode: 401,
    message: "Access token has expired."
  },
  invalid_access_token: {
    statusCode: 401,
    message: "Invalid access token."
  },
  invalid_authorization_header: {
    statusCode: 401,
    message: "Invalid authorization header."
  },
  invalid_session_token: {
    statusCode: 401,
    message: "Invalid session token."
  },
  missing_authorization_header: {
    statusCode: 401,
    message: "Missing authorization header."
  },
  // Only used when a console user has logged in with auth0 using a different
  // type of connection. We match this in AuthErrorPage.tsx
  invalid_console_user: {
    statusCode: 401,
    message: "User has logged in with different connection type."
  },
  // Thread
  thread_already_exists: {
    statusCode: 409,
    message: "Thread already exists."
  },
  thread_not_found: {
    statusCode: 404,
    message: "Thread not found."
  },
  // Sharing Threads
  invalid_email: {
    statusCode: 400,
    message: "Invalid email address."
  },
  group_not_connected_to_slack: {
    statusCode: 400,
    message: "Group not connected to a Slack Workspace."
  },
  slack_credentials_not_found: {
    statusCode: 404,
    message: "Could not retrieve slack bot credentials"
  },
  slack_channel_not_found: {
    statusCode: 404,
    message: "Cannot load slack channel"
  },
  thread_already_shared: {
    statusCode: 400,
    message: "Thread already shared to slack channel."
  },
  // Message
  message_already_exists: {
    statusCode: 409,
    message: "Message already exists."
  },
  message_not_found: {
    statusCode: 404,
    message: "Message not found."
  },
  message_edit_forbidden: {
    statusCode: 403,
    message: "This user cannot edit this message."
  },
  message_not_appendable: {
    statusCode: 400,
    message: "The request references a message that can not support appending. It must contain a markdown node only."
  },
  // Notification
  notification_not_found: {
    statusCode: 404,
    message: "Notification not found."
  },
  // Files
  file_not_found: {
    statusCode: 404,
    message: "File not found."
  },
  file_belongs_to_different_user: {
    statusCode: 403,
    message: "Cannot attach files owned by another user"
  },
  file_too_large: {
    statusCode: 413,
    message: "Maximum file size exceeded"
  },
  file_name_not_allowed: {
    statusCode: 400,
    message: "File name is not allowed"
  },
  file_type_not_allowed: {
    statusCode: 400,
    message: "File MIME type is not allowed"
  },
  //Webhook
  webhook_url_not_verified: {
    statusCode: 400,
    message: "Cannot verify event webhook URL."
  }
};
var ApiCallerError = class extends CordError {
  constructor(errorName, { message, code } = {}, loggingMetadata, loggingTags) {
    const app_id = loggingMetadata?.app_id ?? "unknown";
    super(message, loggingMetadata, {
      ...loggingTags,
      api_caller_error: true,
      app_id
    });
    this.name = errorName;
    this.message = this.message || ApiErrors[errorName].message;
    this.statusCode = code || ApiErrors[errorName].statusCode;
  }
};
function createMissingFieldsMessage(missingFields) {
  return `Missing ${generateFieldsListString(missingFields, "required")}`;
}
function createUnexpectedFieldMessage(invalidFieldName, requiredFields, optionalFields) {
  const expectedMessage = requiredFields && requiredFields.length > 0 ? `${requiredFields.length} ${generateFieldsListString(
    requiredFields,
    "required"
  )}` : "";
  const optionalFieldsMessage = optionalFields && optionalFields.length > 0 ? `${optionalFields.length} ${generateFieldsListString(
    optionalFields,
    "optional"
  )}` : "";
  return `${invalidFieldName} is not a valid field name for this request. Expected ${[
    expectedMessage,
    optionalFieldsMessage
  ].filter((s) => s.length > 0).join(" ")}`;
}
function createInvalidInputTypeMessage(fieldName, expectedInputType) {
  return `Input type for ${fieldName} is not valid, expected ${expectedInputType}.`;
}
function generateFieldsListString(fields, fieldsType) {
  let fieldsString = "";
  if (fields.length === 0) {
    return " fields.";
  }
  if (fields.length === 1) {
    fieldsString = `${fieldsType ?? ""} field: ${fields[0]}.`;
  }
  if (fields.length > 1) {
    fieldsString = `${fieldsType ?? ""} fields: ${fields.slice(0, -1).join(", ")} and ${fields.slice(-1).join("")}.`;
  }
  return fieldsString;
}
function validateInput(input, {
  required: required2 = {},
  optional: optional2 = {}
}) {
  if (typeof input !== "object") {
    throw new ApiCallerError("invalid_request");
  }
  const receivedFields = Object.keys(input);
  const requiredFields = Object.keys(required2);
  const optionalFields = Object.keys(optional2);
  const missingRequiredFields = requiredFields.filter(
    (field) => input[field] === void 0
  );
  if (missingRequiredFields.length > 0) {
    throw new ApiCallerError("missing_field", {
      message: createMissingFieldsMessage(missingRequiredFields)
    });
  }
  for (const key of receivedFields) {
    if (!requiredFields.includes(key) && !optionalFields.includes(key)) {
      throw new ApiCallerError("unexpected_field", {
        message: createUnexpectedFieldMessage(
          key,
          requiredFields,
          optionalFields
        )
      });
    }
    const validationFunction = required2[key] || optional2[key];
    const validationResult = validationFunction(input[key]);
    if (validationResult !== true) {
      throw new ApiCallerError("invalid_field", {
        message: createInvalidInputTypeMessage(key, validationResult)
      });
    }
  }
  return input;
}
function forwardHandlerExceptionsToNext(handler) {
  return (req, res, next) => {
    void (async () => {
      try {
        await handler(req, res, next);
      } catch (e) {
        next(e);
      }
    })();
  };
}
function isCordSignedToken(accessToken) {
  try {
    verify2(accessToken, Env_default.JWT_SIGNING_SECRET, {
      algorithms: ["HS512"]
    });
  } catch (err) {
    return false;
  }
  return true;
}
function verifyBearerTokenInAuthorizationHeaders(header) {
  if (!header) {
    throw new ApiCallerError("missing_authorization_header", {
      message: "Authorization header bearer token must be present."
    });
  }
  if (header.indexOf("Bearer") !== 0) {
    throw new ApiCallerError("invalid_authorization_header", {
      message: "Expecting a token with a Bearer prefix."
    });
  }
  const token = header.replace("Bearer ", "").trim();
  if (!isJWT.default(token)) {
    throw new ApiCallerError("invalid_authorization_header", {
      message: createInvalidInputTypeMessage(
        "authorization header bearer token",
        "JWT"
      )
    });
  }
  return token;
}
async function createPlatformOrganization(platformApplicationID, externalID, name, status, metadata, transaction) {
  return await OrgEntity.create(
    {
      name,
      externalProvider: "platform" /* PLATFORM */,
      externalID,
      state: status === "deleted" ? "inactive" : "active",
      metadata,
      platformApplicationID
    },
    { transaction }
  );
}
async function findOrCreatePlatformOrganization(platformApplicationID, externalID, name, status) {
  return await OrgEntity.findOrCreate({
    where: { platformApplicationID, externalID, name, state: status },
    defaults: {
      name,
      externalProvider: "platform" /* PLATFORM */,
      externalID,
      state: status === "deleted" ? "inactive" : "active",
      platformApplicationID
    }
  });
}
async function findOrCreatePlatformApplication(id, name, environment, customerID, eventWebhookURL, eventWebhookSubscriptions, sharedSecret) {
  return await ApplicationEntity.findOrCreate({
    where: { id },
    defaults: {
      name,
      environment,
      customerID,
      eventWebhookURL,
      eventWebhookSubscriptions,
      sharedSecret
    }
  });
}
async function createPlatformUser(context, platformApplicationID, externalID, email, name, short_name, profile_picture_url, status, metadata, tx) {
  if (tx) {
    return await doCreatePlatformUser(
      context,
      platformApplicationID,
      externalID,
      email,
      name,
      short_name,
      profile_picture_url,
      status,
      metadata,
      tx
    );
  } else {
    return await getSequelize().transaction(
      // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
      async (tx2) => await doCreatePlatformUser(
        context,
        platformApplicationID,
        externalID,
        email,
        name,
        short_name,
        profile_picture_url,
        status,
        metadata,
        tx2
      )
    );
  }
}
async function doCreatePlatformUser(context, platformApplicationID, externalID, email, name, screen_name, profile_picture_url, status, metadata, tx) {
  const [user, isNewUser] = await new UserMutator(
    Viewer.createServiceViewer(),
    context?.loaders ?? null
  ).findOrCreateExternalUser(
    {
      name: name ?? null,
      screenName: screen_name ?? null,
      email: email ?? null,
      profilePictureURL: profile_picture_url ?? null,
      externalID,
      platformApplicationID,
      state: status,
      metadata: metadata ?? {},
      externalProvider: "platform" /* PLATFORM */
    },
    tx
  );
  if (!isNewUser) {
    throw new ApiCallerError("user_already_exists", {
      message: `The platform user with id ${user.externalID} already exists, to update user please make a PUT request to users/<USER_ID>.`
    });
  }
  return user;
}
async function updatePlatformOrganizationMembers(org, members, transaction) {
  const newMembers = members.map((member) => member.toString());
  const userMap = new Map(
    (await UserEntity.findAll({
      where: {
        externalID: newMembers,
        platformApplicationID: org.platformApplicationID,
        externalProvider: "platform" /* PLATFORM */
      },
      transaction
    })).map((user) => [user.externalID, user])
  );
  if (newMembers.length !== userMap.size) {
    const missingMembers = /* @__PURE__ */ new Set();
    newMembers.map((member) => {
      if (!userMap.has(member)) {
        missingMembers.add(member);
      }
    });
    throw new ApiCallerError("user_not_found", {
      message: `Platform ${missingMembers.size > 1 ? "users" : "user"} ${combine("and", [...missingMembers])} not found.`
    });
  }
  const orgMemberships = new Set(
    (await OrgMembersEntity.findAll({
      where: {
        orgID: org.id
      },
      transaction
    })).map((om) => om.userID)
  );
  const addedMembers = /* @__PURE__ */ new Set();
  await OrgMembersEntity.bulkCreate(
    newMembers.filter((member) => {
      const user = userMap.get(member);
      return !orgMemberships.has(user.id);
    }).map((member) => {
      const user = userMap.get(member);
      addedMembers.add(user.id);
      return {
        userID: user.id,
        orgID: org.id
      };
    }),
    { ignoreDuplicates: true, transaction }
  );
  const userToDeleteWhere = {
    orgID: org.id,
    userID: { [Op13.notIn]: [...userMap.values()].map((user) => user.id) }
  };
  const deleted = await OrgMembersEntity.findAll({
    where: userToDeleteWhere,
    transaction
  });
  await OrgMembersEntity.destroy({
    where: userToDeleteWhere,
    transaction
  });
  const deletedMembersIds = deleted.map((om) => om.userID);
  return { added: [...addedMembers], deleted: deletedMembersIds };
}
async function createDummyPlatformUser({
  applicationID,
  orgID,
  firstName,
  profilePicture,
  transaction,
  externalID,
  email,
  dummy
}) {
  const newUser = await createPlatformUser(
    null,
    applicationID,
    externalID ?? uuid3(),
    // ExternalID
    email,
    firstName,
    // Name
    void 0,
    // Screen name
    profilePicture,
    "active",
    { dummy: dummy ?? true },
    transaction
  );
  if (orgID) {
    await OrgMembersEntity.upsert(
      {
        userID: newUser.id,
        orgID
      },
      { transaction }
    );
  }
  return newUser;
}

// server/src/notifications/fetch.ts
var fetchedCounter = Counter2({
  name: "NotificationEntityFetched",
  help: "Count of NotificationEntity fetched by notificationsResolver",
  labelNames: ["appID", "type"]
});
var sentCounter = Counter2({
  name: "NotificationSentToClient",
  help: "Count of GraphQL Notification objects returned to client from notificationsResolver",
  labelNames: ["appID"]
});
async function fetchAndBuildNotifications(context, {
  ltCreatedTimestamp,
  limit,
  filter
}) {
  const userID = assertViewerHasUser(context.session.viewer);
  const {
    bindVariables: partialBind,
    extraJoins,
    extraCondition,
    limitCondition
  } = await createNotificationsQueryExpressionsFromFilters({
    ltCreatedTimestamp,
    limit,
    filter,
    platformApplicationID: context.session.viewer.platformApplicationID,
    viewer: context.session.viewer
  });
  const bindVariables = [...partialBind, userID];
  const recipientFilter = `WHERE n."recipientID" = $${bindVariables.length}`;
  const entities = await getSequelize().query(
    `
    SELECT n.*
    FROM notifications n
    ${extraJoins}
    ${recipientFilter}
    ${extraCondition}
    ORDER BY n."createdTimestamp" DESC
    ${limitCondition};`,
    {
      bind: bindVariables,
      type: QueryTypes11.SELECT,
      model: NotificationEntity
    }
  );
  entities.forEach(
    (e) => incCounterWithAppID(context.session.viewer, fetchedCounter, {
      type: e.type
    })
  );
  const aggregatedEntities = aggregateNotificationEntities(entities);
  const maybeNodes = await Promise.all(
    Array.from(aggregatedEntities.values()).map(
      (notifEntities) => buildNotification(context, notifEntities)
    )
  );
  const nodes = maybeNodes.filter(isNotNull);
  incCounterWithAppID(context.session.viewer, sentCounter, {}, nodes.length);
  return { entities, nodes };
}
async function buildNotification(context, notifs) {
  try {
    const ty = notifs[0].type;
    switch (ty) {
      case "reply":
        assertCorrectAggregation(notifs, ty);
        return await buildReplyNotification(context, notifs[0]);
      case "reaction":
        assertCorrectAggregation(notifs, ty);
        return await buildReactionNotification(context, notifs);
      case "external":
        assertCorrectAggregation(notifs, ty);
        return await buildExternalNotification(context, notifs[0]);
      case "thread_action":
        assertCorrectAggregation(notifs, ty);
        return await buildThreadActionNotification(context, notifs[0]);
      default: {
        const _ = ty;
        throw new Error("Invalid notification type: " + ty);
      }
    }
  } catch (e) {
    context.logger.logException("Failed to create notification", e, {
      notifID: notifs[0].id,
      notifType: notifs[0].type,
      userID: context.session.viewer.userID
    });
    return null;
  }
}
function aggregateNotificationEntities(notifs) {
  const m = /* @__PURE__ */ new Map();
  notifs.forEach((n) => {
    const key = n.aggregationKey ?? n.id;
    if (!m.has(key)) {
      m.set(key, []);
    }
    m.get(key).push(n);
  });
  return m;
}
var aggregates = {
  reaction: true
};
function assertCorrectAggregation(notifs, ty) {
  if (notifs.length > 1 && !aggregates[ty]) {
    throw new Error(
      `Notification type ${ty} should not be aggregated (has ${notifs.length})`
    );
  }
  notifs.forEach((n) => {
    if (n.type !== ty) {
      throw new Error(
        `Invalid aggregation of ${ty}, found unexpected ${n.type}`
      );
    }
  });
}
async function createNotificationsQueryExpressionsFromFilters({
  ltCreatedTimestamp,
  limit,
  filter,
  platformApplicationID,
  viewer
}) {
  const bindVariables = [];
  const extraConditions = ['m."deletedTimestamp" IS NULL'];
  let extraJoins = "";
  if (ltCreatedTimestamp) {
    bindVariables.push(JSON.stringify(ltCreatedTimestamp));
    extraConditions.push(
      `n."createdTimestamp" < $${bindVariables.length}::timestamp`
    );
  }
  if (filter?.metadata) {
    bindVariables.push(JSON.stringify(filter?.metadata));
    extraConditions.push(`n."metadata" @> $${bindVariables.length}::jsonb`);
  }
  extraJoins = `
      LEFT JOIN message_reactions mr ON n."reactionID" = mr.id
      LEFT JOIN messages m ON CASE 
        WHEN n."messageID" IS NULL THEN mr."messageID"
        ELSE n."messageID" END = m.id`;
  const orgMembersLoader = new OrgMembersLoader(viewer);
  const orgIDs = await orgMembersLoader.loadAllImmediateOrgIDsForUser();
  if (orgIDs.length === 0) {
    throw new ApiCallerError("group_not_found");
  }
  if (filter?.groupID || filter?.organizationID) {
    const org = await OrgEntity.findOne({
      where: {
        externalID: filter.groupID ?? filter.organizationID,
        platformApplicationID
      }
    });
    if (!org) {
      throw new ApiCallerError("group_not_found");
    }
    if (!orgIDs.includes(org.id)) {
      throw new ApiCallerError("group_not_found");
    }
    bindVariables.push(org.id);
    extraConditions.push(
      `((m."orgID" = $${bindVariables.length} AND n."type" != 'external') OR n."type" = 'external')`
    );
  } else {
    bindVariables.push(orgIDs);
    extraConditions.push(
      `((m."orgID" = ANY($${bindVariables.length}) AND n."type" != 'external') OR n."type" = 'external')`
    );
  }
  const locationFilter = getLocationFilter(filter?.location);
  if (locationFilter) {
    extraJoins = `
    LEFT JOIN message_reactions mr ON n."reactionID" = mr.id
    LEFT JOIN messages m ON CASE
      WHEN n."messageID" IS NULL THEN mr."messageID"
      ELSE n."messageID" END = m.id
    LEFT JOIN threads t ON m."threadID" = t.id
    INNER JOIN pages p ON (p."orgID" = t."orgID" AND p."contextHash" = t."pageContextHash")`;
    bindVariables.push(JSON.stringify(locationFilter.value));
    extraConditions.push(
      `p."contextData" ${locationFilter.partialMatch ? "@>" : "="} $${bindVariables.length}::jsonb`
    );
  }
  let limitCondition = "";
  if (limit) {
    bindVariables.push(limit);
    limitCondition = `LIMIT $${bindVariables.length}`;
  }
  const extraCondition = `AND ${extraConditions.join(" AND ")}`;
  return { bindVariables, extraJoins, extraCondition, limitCondition };
}

// server/src/entity/notification/NotificationLoader.ts
var NotificationLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadUnreadNotificationCount(userID, filter) {
    const {
      bindVariables: partialBind,
      extraJoins,
      extraCondition
    } = await createNotificationsQueryExpressionsFromFilters({
      filter,
      platformApplicationID: this.viewer.platformApplicationID,
      ltCreatedTimestamp: void 0,
      limit: void 0,
      viewer: this.viewer
    });
    const bindVariables = [...partialBind, userID];
    const recipientFilter = `WHERE n."recipientID" = $${bindVariables.length}`;
    const result = await getSequelize().query(
      `SELECT COALESCE(
           COUNT(DISTINCT n."aggregationKey") +
             SUM(n."aggregationKey" IS NULL::int),
           0
         )::int AS count
         FROM "cord".notifications as n
         ${extraJoins}
         ${recipientFilter} AND n."readStatus" = 'unread'
         ${extraCondition}
        `,
      { bind: bindVariables, type: QueryTypes12.SELECT }
    );
    return result[0].count;
  }
  async notificationMatchesFilter(notificationID, filter) {
    const {
      bindVariables: partialBind,
      extraJoins,
      extraCondition
    } = await createNotificationsQueryExpressionsFromFilters({
      filter,
      platformApplicationID: this.viewer.platformApplicationID,
      ltCreatedTimestamp: void 0,
      limit: void 0,
      viewer: this.viewer
    });
    const bindVariables = [...partialBind, notificationID];
    const idFilter = `WHERE n."id" = $${bindVariables.length}`;
    const notification = await getSequelize().query(
      `
      SELECT n.id
      FROM notifications n
      ${extraJoins}
      ${idFilter}
      ${extraCondition}
      `,
      {
        bind: bindVariables,
        type: QueryTypes12.SELECT,
        model: NotificationEntity
      }
    );
    return notification.length > 0;
  }
};

// server/src/entity/message_link_preview/MessageLinkPreviewLoader.ts
import DataLoader18 from "dataloader";
import { Op as Op14 } from "sequelize";
var MessageLinkPreviewLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.dataloader = new DataLoader18(
      async (keys) => {
        const linkPreviews = await MessageLinkPreviewEntity.findAll({
          where: {
            id: keys
          }
        });
        return inKeyOrder(linkPreviews, keys);
      },
      { cache: false }
    );
    this.dataloaderForMessage = new DataLoader18(
      async (keys) => {
        const linkPreviews = await MessageLinkPreviewEntity.findAll({
          where: { messageID: keys, hidden: { [Op14.ne]: true } }
        });
        return inKeyOrderGroupedCustom(linkPreviews, keys, (a) => a.messageID);
      },
      { cache: false }
    );
  }
  async loadLinkPreviewsForMessage(messageID) {
    return await this.dataloaderForMessage.load(messageID);
  }
  async loadLinkPreview(id) {
    try {
      return await this.dataloader.load(id);
    } catch (e) {
      anonymousLogger().logException("Msg link preview dataloader error", e);
      return null;
    }
  }
};

// server/src/entity/privacy/PrivacyLoader.ts
import { QueryTypes as QueryTypes13 } from "sequelize";
var PrivacyLoader = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
  }
  async granularPermissionsEnabled() {
    return await getTypedFeatureFlagValue(
      FeatureFlags2.GRANULAR_PERMISSIONS,
      flagsUserFromViewer(this.viewer)
    );
  }
  async viewerPermissionJson(transaction) {
    const user = await UserEntity.findByPk(assertViewerHasUser(this.viewer), {
      transaction
    });
    if (!user) {
      throw new Error("Could not load our own user?");
    }
    return await this.userPermissionJson(user, transaction);
  }
  async userPermissionJson(user, _transaction) {
    return { id: user.externalID, metadata: user.metadata };
  }
  async threadPermissionJson(thread, _transaction) {
    return {
      id: thread.externalID,
      metadata: thread.metadata
    };
  }
  async messagePermissionJson(message) {
    return {
      id: message.externalID,
      metadata: message.metadata
    };
  }
  async hasMatchingPermissionRule(userJson, resourceJson, permission, transaction) {
    const rules = await getSequelize().query(
      `SELECT id FROM permission_rules
          WHERE "platformApplicationID" = $1
          AND $2 @@ "userSelector"
          AND $3 @@ "resourceSelector"
          AND $4 = ANY("permissions")
          LIMIT 1`,
      {
        bind: [
          assertViewerHasPlatformApplicationID(this.viewer),
          userJson,
          resourceJson,
          permission
        ],
        type: QueryTypes13.SELECT,
        transaction
      }
    );
    return rules.length > 0;
  }
  async viewerHasThread(thread, strictOrgCheck, transaction) {
    if (!thread) {
      return false;
    }
    if (strictOrgCheck) {
      const orgIDs = assertViewerHasOrgs(this.viewer);
      if (orgIDs.includes(thread.orgID)) {
        return true;
      }
      if (viewerIsUsingOrgsAsFilter(this.viewer)) {
        return false;
      }
    } else {
      const canAccess = await this.loaders().orgMembersLoader.viewerCanAccessOrg(
        thread.orgID,
        transaction
      );
      if (canAccess) {
        return true;
      }
    }
    const enablePerms = await this.granularPermissionsEnabled();
    const { platformApplicationID } = this.viewer;
    if (enablePerms && platformApplicationID) {
      const [userJson, threadJson] = await Promise.all([
        this.viewerPermissionJson(transaction),
        this.threadPermissionJson(thread, transaction)
      ]);
      const hasRule = await this.hasMatchingPermissionRule(
        userJson,
        threadJson,
        "thread:read",
        transaction
      );
      if (hasRule) {
        return true;
      }
    }
    return false;
  }
  async viewerHasMessage(message) {
    if (!message) {
      return false;
    }
    const thread = await this.loaders().threadLoader.loadThread(
      message.threadID
    );
    if (!thread) {
      return false;
    }
    const enablePerms = await this.granularPermissionsEnabled();
    if (!enablePerms) {
      return true;
    }
    if (await this.loaders().orgMembersLoader.viewerCanAccessOrg(message.orgID)) {
      return true;
    }
    const [userJson, threadJson, messageJson] = await Promise.all([
      this.viewerPermissionJson(),
      this.threadPermissionJson(thread),
      this.messagePermissionJson(message)
    ]);
    const [hasThreadRule, hasMessageRule] = await Promise.all([
      this.hasMatchingPermissionRule(userJson, threadJson, "message:read"),
      this.hasMatchingPermissionRule(userJson, messageJson, "message:read")
    ]);
    if (hasThreadRule || hasMessageRule) {
      return true;
    }
    return false;
  }
  async viewerHasParticipant(participant) {
    if (!participant) {
      return false;
    }
    if (participant.userID === this.viewer.userID) {
      return true;
    }
    const thread = await this.loaders().threadLoader.loadThread(
      participant.threadID
    );
    if (!thread) {
      return false;
    }
    const enablePerms = await this.granularPermissionsEnabled();
    if (!enablePerms) {
      return true;
    }
    const participantMembershipInThreadOrg = await this.loaders().orgMembersLoader.loadUserOrgMembership(
      participant.userID,
      thread.orgID
    );
    if (participantMembershipInThreadOrg) {
      return true;
    }
    const participantUser = await this.loaders().userLoader.loadUser(
      participant.userID
    );
    if (!participantUser) {
      return false;
    }
    const [userJson, threadJson, participantUserJson] = await Promise.all([
      this.viewerPermissionJson(),
      this.threadPermissionJson(thread),
      this.userPermissionJson(participantUser)
    ]);
    const [hasThreadRule, hasParticipantUserRule] = await Promise.all([
      this.hasMatchingPermissionRule(
        userJson,
        threadJson,
        "thread-participant:read"
      ),
      this.hasMatchingPermissionRule(
        userJson,
        participantUserJson,
        "thread-participant:read"
      )
    ]);
    if (hasThreadRule || hasParticipantUserRule) {
      return true;
    }
    return false;
  }
  async viewerCanSendMessageToThread(thread, transaction) {
    const [canSeeThread, enablePerms] = await Promise.all([
      this.viewerHasThread(thread, false, transaction),
      this.granularPermissionsEnabled()
    ]);
    if (!enablePerms) {
      if (!canSeeThread) {
        new Logger(this.viewer).warn(
          `Privacy logic error: sending to thread viewer cannot see: ${thread.id}`
        );
      }
      return true;
    }
    if (!canSeeThread) {
      return false;
    }
    const canAccessOrg = await this.loaders().orgMembersLoader.viewerCanAccessOrg(
      thread.orgID,
      transaction
    );
    if (canAccessOrg) {
      return true;
    }
    const [userJson, threadJson] = await Promise.all([
      this.viewerPermissionJson(transaction),
      this.threadPermissionJson(thread, transaction)
    ]);
    return await this.hasMatchingPermissionRule(
      userJson,
      threadJson,
      "thread:send-message",
      transaction
    );
  }
};

// server/src/entity/message_mention/MessageMentionLoader.ts
import { QueryTypes as QueryTypes14 } from "sequelize";
var MessageMentionLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadMentionedUsersForThread(threadID) {
    return await getSequelize().query(
      `
        SELECT DISTINCT u.* FROM users u
        INNER JOIN message_mentions mm ON (u.id = mm."userID")
        INNER JOIN messages m ON (mm."messageID" = m.id)
        WHERE m."threadID" = $1
      `,
      {
        bind: [threadID],
        type: QueryTypes14.SELECT,
        model: UserEntity
      }
    );
  }
};

// server/src/RequestContextLoaders.ts
async function getNewLoaders(viewer) {
  const flagsUser = flagsUserFromViewer(viewer);
  const cache2 = await getTypedFeatureFlagValue(
    FeatureFlags2.LOADER_CACHES,
    flagsUser
  );
  const loaders = {
    fileLoader: new FileLoader(viewer),
    messageAttachmentLoader: new MessageAttachmentLoader(viewer),
    messageLoader: new MessageLoader(viewer, () => loaders),
    messageMentionLoader: new MessageMentionLoader(viewer),
    orgLoader: new OrgLoader(viewer, cache2),
    userLoader: new UserLoader(viewer, () => loaders, cache2),
    pageLoader: new PageLoader(viewer),
    threadLoader: new ThreadLoader(viewer, () => loaders),
    pageVisitorLoader: new PageVisitorLoader(viewer),
    threadParticipantLoader: new ThreadParticipantLoader(viewer, () => loaders),
    messageReactionLoader: new MessageReactionLoader(viewer, cache2),
    slackChannelLoader: new SlackChannelLoader(viewer),
    userPreferenceLoader: new UserPreferenceLoader(viewer),
    deploysLoader: new DeploysLoader(viewer),
    taskLoader: new TaskLoader(viewer),
    taskAssigneeLoader: new TaskAssigneeLoader(viewer),
    taskTodoLoader: new TaskTodoLoader(viewer),
    orgMembersLoader: new OrgMembersLoader(viewer),
    s3BucketLoader: new S3BucketLoader(viewer),
    applicationLoader: new ApplicationLoader(viewer),
    customerLoader: new CustomerLoader(viewer),
    heimdallLoader: new HeimdallLoader(viewer),
    emailSubscriptionLoader: new EmailSubscriptionLoader(viewer),
    linkedOrgsLoader: new LinkedOrgsLoader(viewer, cache2),
    linkedUsersLoader: new LinkedUsersLoader(viewer),
    slackMirroredThreadLoader: new SlackMirroredThreadLoader(viewer),
    consoleUserLoader: new ConsoleUserLoader(viewer),
    applicationUsageMetricLoader: new ApplicationUsageMetricLoader(viewer),
    notificationLoader: new NotificationLoader(viewer),
    messageLinkPreviewLoader: new MessageLinkPreviewLoader(viewer),
    privacyLoader: new PrivacyLoader(viewer, () => loaders)
  };
  return loaders;
}

// server/src/RequestContext.ts
function assertRequestHasContext(req) {
  if (!("context" in req) || typeof req.context !== "object" || !req.context || !("connectionID" in req.context) || !("session" in req.context)) {
    throw new ApiCallerError("invalid_access_token");
  }
  return req.context;
}
async function contextWithSession(session, sequelize2, clientVersion, deployment) {
  const connectionID = uuid4();
  const heimdallLoader = new HeimdallLoader(session.viewer);
  const applicationLoader = new ApplicationLoader(session.viewer);
  const loggingToSegment = await heimdallLoader.load(
    HeimdallSwitches_default.LOG_TO_SEGMENT
  );
  const application = session.viewer.platformApplicationID ? await applicationLoader.load(session.viewer.platformApplicationID) : null;
  return await buildContext(
    session,
    sequelize2,
    clientVersion,
    deployment,
    connectionID,
    application,
    loggingToSegment?.isOn() ?? false
  );
}
async function buildContext(session, sequelize2, clientVersion, deployment, connectionID, application, logToSegment) {
  return {
    connectionID,
    session,
    sequelize: sequelize2,
    clientVersion,
    application,
    logger: new Logger(session.viewer, { connectionID, deployment }),
    deployment,
    segmentLogger: new SegmentLogger(
      session,
      clientVersion,
      connectionID,
      deployment,
      logToSegment,
      application
    ),
    loaders: await getNewLoaders(session.viewer)
  };
}
async function contextWithOtherOrg(context, orgID) {
  const userID = assertViewerHasUser(context.session.viewer);
  const [org, orgMembership] = await Promise.all([
    context.loaders.orgLoader.loadOrg(orgID),
    context.loaders.orgMembersLoader.loadUserOrgMembership(userID, orgID)
  ]);
  if (!org || !orgMembership) {
    throw new CordError(
      "Cannot create context for org user is not a member of",
      { orgID }
    );
  }
  return await buildContext(
    {
      ...context.session,
      viewer: context.session.viewer.viewerInOtherOrg(
        orgID,
        org.externalProvider === "platform" ? org.externalID : void 0
      )
    },
    context.sequelize,
    context.clientVersion,
    context.deployment,
    context.connectionID,
    context.application,
    context.segmentLogger.switchedOn
  );
}
async function getRelevantContext(originalContext, threadOrgID) {
  return !threadOrgID || originalContext.session.viewer.orgID === threadOrgID ? originalContext : await contextWithOtherOrg(originalContext, threadOrgID);
}

// server/src/slack/mrkdwnImpl.ts
var import_types14 = __toESM(require_cjs(), 1);

// server/src/util/splitStringToWsAndText.ts
function splitStringToWsAndText(string) {
  const [_, wsStart, middleText, wsEnd] = string.match(/^(\s*)(.*?)(\s*)$/s);
  return [wsStart, middleText, wsEnd];
}

// server/src/slack/mrkdwnImpl.ts
var MAX_SLACK_TEXT_LENGTH = 2970;
async function slackMrkdwnFromMessageContentImpl(content, helpers) {
  const segments = await nodesToMrkdwnSegments(
    content,
    helpers
  );
  const formattingState = {
    bold: false,
    italic: false,
    code: false
  };
  let output = "";
  const formattingStack = [];
  let remainingWhitespace = "";
  for (const segment of segments) {
    let { text } = segment;
    text = text.replace(/([*~_`]+)/, (...m) => `<!date^00000000^{_}|${m[1]}>`);
    let [wsStart, middle, wsEnd] = splitStringToWsAndText(text);
    if (!middle) {
      remainingWhitespace += wsStart + wsEnd;
      continue;
    }
    let whiteSpace = remainingWhitespace + wsStart;
    remainingWhitespace = wsEnd;
    const whiteSpaceContainsLineBreak = whiteSpace.indexOf("\n") >= 0;
    let formattingOff = "";
    while (formattingStack.length && (whiteSpaceContainsLineBreak || formattingTypes.some((key) => formattingState[key] && !segment[key]))) {
      const key = formattingStack.pop();
      formattingOff += formattingCharacters[key];
      formattingState[key] = false;
    }
    let formattingOn = "";
    for (const key of formattingTypes) {
      if (segment[key] && !formattingState[key]) {
        formattingOn += formattingCharacters[key];
        formattingStack.push(key);
        formattingState[key] = true;
      }
    }
    if (output && !whiteSpace && (formattingOff || formattingOn)) {
      whiteSpace = "\u200B";
    }
    if (formattingStack.length && middle.indexOf("\n") >= 0) {
      const on = formattingStack.map((key) => formattingCharacters[key]);
      const off = [...on].reverse();
      middle = middle.replace(
        /\s*\n\s*/g,
        ([m]) => `${off.join()}${m}${on.join("")}`
      );
    }
    output += formattingOff + whiteSpace + formattingOn + middle;
  }
  output += formattingStack.reverse().map((key) => formattingCharacters[key]).join("");
  output += remainingWhitespace;
  output = output.replace(/\s+\n/g, "\n").trim();
  if (output.length > MAX_SLACK_TEXT_LENGTH) {
    output = output.slice(0, MAX_SLACK_TEXT_LENGTH) + "...(message too long)";
  }
  return output;
}
var formattingCharacters = {
  bold: "*",
  italic: "_",
  code: "`"
};
var formattingTypes = [
  "italic",
  "bold",
  "code"
];
async function nodesToMrkdwnSegments(nodes, helpers) {
  const segments = [];
  let numberBulletCount = 0;
  for (const node of nodes) {
    if (node.type === void 0) {
      segments.push([{ ...node, text: mrkdwnEscapeText(node.text) }]);
      continue;
    }
    switch (node.type) {
      case import_types14.MessageNodeType.PARAGRAPH:
        segments.push(nodesToMrkdwnSegments(node.children, helpers));
        segments.push([{ text: "\n" }]);
        break;
      case import_types14.MessageNodeType.LINK: {
        const nodeText = node.children[0].text;
        segments.push([
          {
            text: `<${node.url}|${nodeText}>`
          }
        ]);
        break;
      }
      case import_types14.MessageNodeType.BULLET:
        segments.push(newLinePrefixAndIndent("\u2022 ", "  ", node, helpers));
        break;
      case import_types14.MessageNodeType.NUMBER_BULLET:
        segments.push(
          newLinePrefixAndIndent(
            `${++numberBulletCount}. `,
            "  ",
            node,
            helpers
          )
        );
        break;
      case import_types14.MessageNodeType.QUOTE:
        segments.push(newLinePrefixAndIndent("> ", "  ", node, helpers));
        break;
      case import_types14.MessageNodeType.TODO:
        segments.push(newLinePrefixAndIndent("[] ", "  ", node, helpers));
        break;
      case import_types14.MessageNodeType.MENTION:
      case import_types14.MessageNodeType.ASSIGNEE: {
        const userID = node.user.id;
        segments.push(
          helpers.lookUpSlackUserID(userID).then((slackUserID) => {
            if (slackUserID) {
              return [{ text: `<@${slackUserID}>` }];
            } else {
              return nodesToMrkdwnSegments(node.children, helpers);
            }
          })
        );
        break;
      }
      case import_types14.MessageNodeType.CODE:
        segments.push(
          // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
          nodesToMrkdwnSegments(node.children, helpers).then(
            (segments2) => segments2.map((segment) => ({
              ...segment,
              code: true
            }))
          )
        );
        break;
    }
  }
  return await Promise.all(segments).then(
    (arrayOfArrays) => arrayOfArrays.flat()
  );
}
async function newLinePrefixAndIndent(prefix, indent, node, helpers) {
  return [
    { text: `
${prefix}` },
    ...(await nodesToMrkdwnSegments(node.children, helpers)).map((segment) => ({
      ...segment,
      text: segment.text.replace(/\n/g, `
${indent}`)
    }))
  ];
}
function mrkdwnEscapeText(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "\u200B&gt;");
}

// server/src/slack/mrkdwn.ts
async function slackMrkdwnFromMessageContent(content, lookUpSlackUserID) {
  return await slackMrkdwnFromMessageContentImpl(content, {
    lookUpSlackUserID
  });
}

// server/src/entity/slack_message/SlackMessageLoader.ts
var SlackMessageLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async loadSlackMessage(slackChannelID, slackMessageTimestamp) {
    const orgIDs = await new LinkedOrgsLoader(this.viewer).getOrgIDs();
    return await SlackMessageEntity.findOne({
      where: { slackChannelID, slackMessageTimestamp, sharerOrgID: orgIDs }
    });
  }
};

// server/src/entity/message/MessageMutator.ts
import { Sequelize as Sequelize11 } from "sequelize";
var import_types15 = __toESM(require_cjs(), 1);

// server/src/util/locks.ts
var LOCK_TTL_MS = 5e3;
function withLock(lockName) {
  const locks = typeof lockName === "string" ? [lockName] : lockName;
  return (func) => getRedlock().using(
    locks,
    LOCK_TTL_MS,
    (signal) => func(() => {
      if (signal.aborted) {
        throw signal.error;
      }
    })
  );
}
var withSlackMirroredThreadLock = (threadID, mirrorType) => withLock(`SlackMirroredThread:${threadID}:${mirrorType}`);

// server/src/entity/message/MessageMutator.ts
var counter2 = Counter2({
  name: "MessageCreated",
  help: "Count of created messages",
  labelNames: ["appID"]
});
function undefinedNull(x) {
  return x === void 0 ? null : x;
}
var MessageMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.logger = new Logger(viewer);
    this.loaders = loaders;
  }
  async mirrorMessageToSlack(args, message) {
    incCounterWithAppID(this.viewer, counter2);
    const { threadID } = message;
    const context = await contextWithSession(
      { viewer: this.viewer },
      getSequelize(),
      null,
      null
    );
    const promises = await Promise.allSettled([
      context.loaders.slackMirroredThreadLoader.loadFromThreadID(threadID),
      SlackMirroredSupportThreadEntity.findByPk(threadID)
    ]);
    const [slackMirroredThread, slackMirroredSupportThread] = promises.map(
      (promise) => {
        if (promise.status === "fulfilled") {
          return promise.value;
        }
        return null;
      }
    );
    if (slackMirroredThread && (args.importedSlackChannelID !== slackMirroredThread.slackChannelID || args.importedSlackMessageThreadTS !== slackMirroredThread.slackMessageTimestamp)) {
      addMessageToMirroredSlackThread(
        message,
        this.viewer,
        context,
        threadID,
        slackMirroredThread,
        "internal"
      ).catch(
        this.logger.exceptionLogger(
          "Importing Slack reply from mirrored support thread or reply from Cord thread to mirrored internal thread failed."
        )
      );
    }
    if (slackMirroredSupportThread && (args.importedSlackChannelID !== slackMirroredSupportThread.slackChannelID || args.importedSlackMessageThreadTS !== slackMirroredSupportThread.slackMessageTimestamp)) {
      addMessageToMirroredSlackThread(
        message,
        this.viewer,
        context,
        threadID,
        slackMirroredSupportThread,
        "support"
      ).catch(
        this.logger.exceptionLogger(
          "Importing Slack reply from mirrored internal thread or reply from Cord thread to mirrored support thread failed."
        )
      );
    }
  }
  async createMessage(args, transaction) {
    return await this.createMessageImpl(
      {
        ...args,
        sourceID: assertViewerHasUser(this.viewer)
      },
      transaction
    );
  }
  async createMessageExternal(args, transaction) {
    return await this.createMessageImpl(args, transaction);
  }
  async createMessageImpl(args, transaction) {
    const canSend = await this.loaders.privacyLoader.viewerCanSendMessageToThread(
      args.thread,
      transaction
    );
    if (!canSend) {
      throw new Error(
        `User ${this.viewer.userID} is not allowed to send message to thread ${args.thread.id}`
      );
    }
    const message = await MessageEntity.create(
      {
        id: args.id,
        externalID: args.externalID,
        sourceID: args.sourceID,
        orgID: args.thread.orgID,
        threadID: args.thread.id,
        platformApplicationID: args.thread.platformApplicationID,
        content: args.content,
        url: args.url,
        ...args.timestamp ? { timestamp: args.timestamp } : null,
        ...args.lastUpdatedTimestamp ? { lastUpdatedTimestamp: args.lastUpdatedTimestamp } : null,
        ...args.deletedTimestamp ? { deletedTimestamp: args.deletedTimestamp } : null,
        importedSlackChannelID: undefinedNull(args.importedSlackChannelID),
        importedSlackMessageTS: undefinedNull(args.importedSlackMessageTS),
        importedSlackMessageType: undefinedNull(args.importedSlackMessageType),
        importedSlackMessageThreadTS: undefinedNull(
          args.importedSlackMessageThreadTS
        ),
        replyToEmailNotificationID: undefinedNull(
          args.replyToEmailNotificationID
        ),
        type: args.type ?? void 0,
        iconURL: args.iconURL,
        translationKey: args.translationKey,
        metadata: args.metadata,
        extraClassnames: args.extraClassnames ?? "",
        skipLinkPreviews: args.skipLinkPreviews ?? false
      },
      { transaction }
    );
    const mirror = () => this.mirrorMessageToSlack(args, message);
    if (transaction) {
      transaction.afterCommit(mirror);
    } else {
      await mirror();
    }
    return message;
  }
  async updateContent(logger, message, content) {
    assertViewerIsMessageOwner(this.logger, this.viewer, message);
    return await this.updateContentWithoutCheckingOwnership(message, content);
  }
  async updateContentWithoutCheckingOwnership(message, content) {
    const userID = assertViewerHasUser(this.viewer);
    const id = message.id;
    const [updateCount] = await MessageEntity.update(
      {
        content,
        lastUpdatedTimestamp: Sequelize11.fn("NOW")
      },
      { where: { id, sourceID: userID, orgID: message.orgID } }
    );
    return updateCount === 1;
  }
  async setDeleted(message, deleted) {
    const userID = assertViewerHasUser(this.viewer);
    assertViewerIsMessageOwner(this.logger, this.viewer, message);
    const [updateCount] = await MessageEntity.update(
      {
        deletedTimestamp: deleted ? Sequelize11.fn("NOW") : null
      },
      { where: { id: message.id, sourceID: userID, orgID: message.orgID } }
    );
    return updateCount === 1;
  }
  async deleteMessage(message) {
    const { orgID } = assertViewerHasIdentity(this.viewer);
    assertViewerIsMessageOwner(this.logger, this.viewer, message);
    const { id } = message;
    const messageDeleted = await MessageEntity.destroy({
      where: {
        id,
        orgID
      }
    });
    return messageDeleted === 1;
  }
  async removeAssignees(messageID, removedAssignees) {
    const message = await this.loaders.messageLoader.loadMessage(messageID);
    const content = message?.content ?? [];
    const newContent = convertAssignees(content, removedAssignees);
    const [updateCount] = await MessageEntity.update(
      {
        content: newContent,
        lastUpdatedTimestamp: Sequelize11.fn("NOW")
      },
      { where: { id: messageID } }
    );
    return updateCount === 1;
  }
  async resetSlackImportForThread(threadID) {
    const orgID = assertViewerHasOrg(this.viewer);
    await MessageEntity.update(
      {
        importedSlackChannelID: null,
        importedSlackMessageTS: null,
        importedSlackMessageType: null,
        importedSlackMessageThreadTS: null
      },
      {
        where: { threadID, orgID }
      }
    );
  }
};
function convertAssignees(content, removedAssignees) {
  return content.map((node) => {
    if (isMessageNodeType(node, import_types15.MessageNodeType.ASSIGNEE)) {
      const removed = removedAssignees.find(
        (assignee) => assignee.userID === node.user.id
      );
      if (removed !== void 0) {
        return {
          type: void 0,
          text: node.children[0].text
        };
      } else {
        return node;
      }
    }
    let children = null;
    try {
      children = getMessageNodeChildren(node);
    } catch (_) {
      children = null;
    }
    if (children !== null && children !== void 0) {
      return {
        ...node,
        children: convertAssignees(children, removedAssignees)
      };
    }
    return node;
  });
}
function assertViewerIsMessageOwner(logger, viewer, message) {
  if (viewer.userID !== message.sourceID) {
    logger.error("User does not have write permissions to message.", {
      actingUser: viewer.userID,
      messageOwner: message.sourceID
    });
    throw new Error(
      "User does not have write permissions to message created by another user"
    );
  }
}
async function addMessageToMirroredSlackThread(message, viewer, originalContext, threadID, mirroredThread, mirrorType) {
  return await withSlackMirroredThreadLock(
    threadID,
    mirrorType
  )(async () => {
    if (await SlackMessageEntity.count({
      where: {
        slackOrgID: mirroredThread.slackOrgID,
        slackChannelID: mirroredThread.slackChannelID,
        messageID: message.id
      }
    }) > 0) {
      return;
    }
    let slackBotCredentials = null;
    const context = await getRelevantContext(originalContext, message.orgID);
    if (mirrorType === "internal") {
      slackBotCredentials = await findSlackBotCredentials(context);
      if (!slackBotCredentials) {
        context.logger.warn(
          "addMessageToMirroredSlackThread: no Slack bot credentials available for viewer",
          { viewerOrgID: viewer.orgID, viewerUserID: viewer.userID }
        );
        return;
      }
      if (slackBotCredentials.org.id !== mirroredThread.slackOrgID) {
        context.logger.warn(
          "addMessageToMirroredSlackThread: Slack workspace mismatch",
          {
            viewerOrgID: viewer.orgID,
            linkedSlackOrgID: slackBotCredentials.org.id,
            mirroredTheadSlackOrgID: mirroredThread.slackOrgID
          }
        );
        return;
      }
    } else if (mirrorType === "support") {
      const supportOrg = await context.loaders.orgLoader.loadOrg(
        mirroredThread.slackOrgID
      );
      if (!supportOrg) {
        throw new Error(
          "Could not find org with ID " + mirroredThread.slackOrgID
        );
      }
      slackBotCredentials = await supportOrg.getSlackBotCredentials();
    }
    if (!slackBotCredentials) {
      throw new Error("No valid slackBotCredentials found.");
    }
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (!thread) {
      throw new Error("Thread does not exist");
    }
    const user = await context.loaders.userLoader.loadUserInAnyViewerOrg(
      message.sourceID
    );
    if (!user) {
      throw new Error("User does not exist");
    }
    await addMessageToSelectedSlackChannel(
      context,
      slackBotCredentials,
      mirroredThread.slackChannelID,
      user,
      message,
      thread,
      mirrorType,
      mirroredThread.slackMessageTimestamp
    );
  });
}

// server/src/third_party_tasks/jira/api.ts
import FormData from "form-data";
async function completeOAuthFlow(code) {
  const response = await fetch("https://auth.atlassian.com/oauth/token", {
    method: "post",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      grant_type: "authorization_code",
      client_id: Env_default.JIRA_APP_CLIENT_ID,
      client_secret: Env_default.JIRA_APP_CLIENT_SECRET,
      code,
      redirect_uri: JIRA_AUTH_REDIRECT_URL
    })
  });
  const { access_token, refresh_token } = await response.json();
  if (!access_token) {
    throw new Error("Access token not received");
  }
  if (!refresh_token) {
    throw new Error("Refresh token not received");
  }
  const [identity, accessible_resources] = await Promise.all([
    me(access_token),
    accessibleResources(access_token)
  ]);
  const cloudID = accessible_resources[0].id;
  const projects = await fetchProjects(access_token, cloudID);
  return {
    refreshToken: refresh_token,
    identity,
    cloudID,
    projects: projects.values
  };
}
async function me(accessToken) {
  const response = await fetch("https://api.atlassian.com/me", {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: "application/json",
      "Content-Type": "application/json"
    }
  });
  return await response.json();
}
async function accessibleResources(accessToken) {
  const response = await fetch(
    "https://api.atlassian.com/oauth/token/accessible-resources",
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json"
      }
    }
  );
  return await response.json();
}
async function fetchAccessToken(viewer, refreshToken, cloudID) {
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  const response = await fetch("https://auth.atlassian.com/oauth/token", {
    method: "post",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json"
    },
    body: JSON.stringify({
      grant_type: "refresh_token",
      client_id: Env_default.JIRA_APP_CLIENT_ID,
      client_secret: Env_default.JIRA_APP_CLIENT_SECRET,
      refresh_token: refreshToken
    })
  });
  const responseJSON = await handleResponseJSON(response);
  if (responseJSON.refresh_token) {
    const newExternalAuthData = {
      cloudID,
      refreshToken: responseJSON.refresh_token
    };
    await ThirdPartyConnectionEntity.update(
      { externalAuthData: newExternalAuthData },
      {
        where: {
          userID,
          orgID,
          type: "jira"
        }
      }
    );
  }
  return responseJSON;
}
async function fetchProjects(accessToken, cloudID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/project/search?expand=issueTypes`,
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json"
      }
    }
  );
  return await handleResponseJSON(response);
}
async function createIssue(accessToken, cloudID, summary, description, projectID, issueType, assigneeID, parentIssueID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue`,
    {
      method: "post",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        update: {},
        fields: {
          // Summary must be fewer than 255 chars
          // https://community.atlassian.com/t5/Jira-questions/Summary-must-be-less-than-255-characters/qaq-p/989632
          summary: summary.slice(0, 254),
          description,
          issuetype: { id: issueType },
          project: { id: projectID },
          assignee: { id: assigneeID },
          parent: { id: parentIssueID }
          // components: [{ id: '10000' }],
          // reporter: {
          //   id: '5b10a2844c20165700ede21g',
          // },
          // fixVersions: [{ id: '10001' }],
          // priority: {
          //   id: '20000',
          // },
          // timetracking: {
          //   remainingEstimate: '5',
          //   originalEstimate: '10',
          // },
          // security: {
          //   id: '10000',
          // },
          // environment: {
          //   type: 'doc',
          //   version: 1,
          //   content: [
          //     {
          //       type: 'paragraph',
          //       content: [
          //         {
          //           text: 'UAT',
          //           type: 'text',
          //         },
          //       ],
          //     },
          //   ],
          // },
          // versions: [{ id: '10000' }],
          // duedate: '2019-05-11',
        }
      })
    }
  );
  return await handleResponseJSON(response);
}
async function assignIssue(accessToken, cloudID, issueID, assigneeID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue/${issueID}/assignee`,
    {
      method: "put",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ accountId: assigneeID })
    }
  );
  await handleResponse(response);
}
async function addIssueWatcher(accessToken, cloudID, issueID, watcherID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue/${issueID}/watchers`,
    {
      method: "post",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify(watcherID)
    }
  );
  await handleResponse(response);
}
async function addIssueAttachment(accessToken, cloudID, issueID, filename, contentType, stream, filesize) {
  const form = new FormData();
  form.append("file", stream, {
    filename,
    contentType,
    knownLength: filesize
  });
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue/${issueID}/attachments`,
    {
      method: "post",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        "X-Atlassian-Token": "no-check",
        Accept: "application/json"
      },
      body: form.getBuffer()
    }
  );
  return await handleResponseJSON(response);
}
async function getIssueTransitions(accessToken, cloudID, issueID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue/${issueID}/transitions`,
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      }
    }
  );
  return await handleResponseJSON(response);
}
async function transitionIssue(accessToken, cloudID, issueID, transitionID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue/${issueID}/transitions`,
    {
      method: "post",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        transition: { id: transitionID }
      })
    }
  );
  return await handleResponse(response);
}
async function addIssueComment(accessToken, cloudID, issueID, comment) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue/${issueID}/comment`,
    {
      method: "post",
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        body: comment
      })
    }
  );
  return await handleResponseJSON(response);
}
async function getIssue(accessToken, cloudID, issueID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/issue/${issueID}?fields=*all&properties=*all`,
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
        Accept: "application/json"
      }
    }
  );
  return await handleResponseJSON(response);
}
async function getServerInfo(cloudID) {
  const response = await fetch(
    `https://api.atlassian.com/ex/jira/${cloudID}/rest/api/3/serverInfo`,
    {
      headers: {
        Accept: "application/json"
      }
    }
  );
  return await handleResponseJSON(response);
}
async function handleResponseJSON(response) {
  const textResponse = await handleResponse(response);
  try {
    return JSON.parse(textResponse);
  } catch (e) {
    throw new Error("Could not deserialize response JSON: " + textResponse);
  }
}
async function handleResponse(response) {
  const textResponse = await response.text();
  if (response.status >= 400) {
    if (response.status === 403) {
      throw new Error("external_api_forbidden_response" /* EXTERNAL_API_FORBIDDEN_RESPONSE */);
    } else {
      throw new Error(textResponse);
    }
  }
  return textResponse;
}

// server/src/util/cache.ts
import NodeCache from "node-cache";
import jsonStableStringify5 from "fast-json-stable-stringify";
var cache = new NodeCache();
function cacheKey(data) {
  return jsonStableStringify5(data);
}

// server/src/entity/user_preference/UserPreferenceMutator.ts
var UserPreferenceMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async setViewerPreference(key, value) {
    const userID = assertViewerHasUser(this.viewer);
    return await this.setPreferenceForUser(userID, key, value);
  }
  async setPreferenceForUser(userID, key, value) {
    const entity = await UserPreferenceEntity.findOne({
      where: { userID, key }
    });
    const changed = !entity || !isEqual(entity.value, value);
    if (!changed) {
      return;
    }
    await UserPreferenceEntity.upsert({
      userID,
      key,
      value
    });
    await publishPubSubEvent("user-preference-updated", { userID }, { key });
  }
};

// common/const/UserPreferenceKeys.ts
var LINEAR_CONNECTION_PREFERENCES = "linear_connection_preferences";
var JIRA_CONNECTION_PREFERENCES = "jira_connection_preferences";
var TRELLO_CONNECTED_LIST = "trello_list";
var ASANA_CONNECTION_PREFERENCES = "asana_connection_preferences";
var MONDAY_CONNECTION_PREFERENCES = "monday_connection_preferences";
var DEFAULT_TASK_TYPE = "default_task_type";
var NOTIFICATION_CHANNELS = "notification_channels";
var ACTIVATION_FIRST_MESSAGE_SENT = "activation_first_message_sent";

// server/src/third_party_tasks/util.ts
async function getExternalAuthData(viewer, type) {
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  const connection = await ThirdPartyConnectionEntity.findOne({
    where: { userID, orgID, type }
  });
  if (!connection?.externalAuthData) {
    return null;
  }
  return connection.externalAuthData;
}
var credentialsCacheKey = (userID, orgID, type) => cacheKey({ type: `${type}_credentials`, userID, orgID });
async function removeExternalConnection(viewer, type) {
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  cache.del(credentialsCacheKey(userID, orgID, type));
  const defaultTaskType = await new UserPreferenceLoader(
    viewer
  ).loadPreferenceValueForViewer(DEFAULT_TASK_TYPE);
  if (defaultTaskType === type) {
    await new UserPreferenceMutator(viewer).setViewerPreference(
      DEFAULT_TASK_TYPE,
      "cord"
    );
  }
  const count = await ThirdPartyConnectionEntity.destroy({
    where: { userID, orgID, type }
  });
  return count > 0;
}
function handleThirdPartyException(message, exception, type, viewer) {
  backgroundPromise(
    (async () => {
      const logger = new Logger(viewer ?? Viewer.createAnonymousViewer());
      if (viewer && exception.message === "external_api_forbidden_response" /* EXTERNAL_API_FORBIDDEN_RESPONSE */) {
        try {
          logger.logException(message, exception, void 0, void 0, "warn");
          await removeExternalConnection(viewer, type);
        } catch (e) {
        }
      } else {
        logger.logException(message, exception);
      }
    })()
  );
}
var publishMessageUpdateForTask = async (reference) => {
  const task = await TaskEntity.findByPk(reference.taskID);
  if (!task) {
    return;
  }
  const message = await MessageEntity.findByPk(task.messageID);
  if (!message) {
    return;
  }
  backgroundPromise(
    publishPubSubEvent(
      "thread-message-updated",
      { threadID: message.threadID },
      { messageID: message.id }
    )
  );
};
var generateLinearTaskFooterText = (url6, pageTitle, showCordCopy, orgDomain, platformApplicationName) => {
  if (platformApplicationName) {
    return `Continue the Conversation on [${pageTitle || "this page"}](${url6}) in ${platformApplicationName}
    ${showCordCopy ? "Powered by [Cord](https://cord.com)" : ""}`;
  } else {
    return `Created from [${pageTitle || "this page"}](${url6})
    Continue the conversation with [Cord](https://app.cord.com/${orgDomain ?? ""})`;
  }
};
var generateAsanaOrMondayTaskFooterText = (url6, pageTitle, showCordCopy, orgDomain, platformApplicationName) => {
  const pageLink = `<a href="${encodeURI(url6)}">${pageTitle || "this page"}</a>`;
  if (platformApplicationName) {
    const cordLink = `<a href="${encodeURI("https://cord.com")}">Cord</a>`;
    return `Continue the Conversation on ${pageLink} in ${platformApplicationName}
${showCordCopy ? `Powered by ${cordLink}` : ""}`;
  } else {
    const cordLink = `<a href="${encodeURI(
      `https://app.cord.com/${orgDomain ?? ""}`
    )}">Cord</a>`;
    return `Created from ${pageLink}
Continue the conversation with ${cordLink}`;
  }
};
var generateJiraTaskFooterText = (url6, pageTitle, showCordCopy, orgDomain, platformApplicationName) => {
  if (platformApplicationName) {
    const copy = [
      {
        type: "text",
        text: "Continue the Conversation on "
      },
      {
        type: "text",
        text: pageTitle || "this page",
        marks: [
          {
            type: "link",
            attrs: { href: url6 }
          }
        ]
      },
      {
        type: "text",
        text: ` in ${platformApplicationName}`
      }
    ];
    if (showCordCopy) {
      copy.concat([
        {
          type: "text",
          text: `
Powered by `
        },
        {
          type: "text",
          text: "Cord",
          marks: [
            {
              type: "link",
              attrs: { href: "https://cord.com" }
            }
          ]
        }
      ]);
    }
    return copy;
  } else {
    return [
      {
        type: "text",
        text: "Created from "
      },
      {
        type: "text",
        text: pageTitle || "this page",
        marks: [
          {
            type: "link",
            attrs: { href: url6 }
          }
        ]
      },
      {
        type: "text",
        text: `
Continue the conversation with `
      },
      {
        type: "text",
        text: "Cord",
        marks: [
          {
            type: "link",
            attrs: { href: `https://app.cord.com/${orgDomain ?? ""}` }
          }
        ]
      }
    ];
  }
};
async function getTaskFooterText(viewer, message, connectionType) {
  const { orgID, userID } = assertViewerHasIdentity(viewer);
  let application;
  if (viewer.platformApplicationID) {
    application = await ApplicationEntity.findByPk(
      viewer.platformApplicationID
    );
  }
  const showCordCopy = await getTypedFeatureFlagValue(
    FeatureFlags2.SHOW_CORD_COPY_IN_TASKS,
    {
      userID,
      orgID,
      platformApplicationID: viewer.platformApplicationID ?? "extension",
      version: null,
      customerID: application?.customerID
    }
  );
  const org = await OrgEntity.findByPk(orgID);
  if (!org) {
    return "";
  }
  const thread = await ThreadEntity.findByPk(message.threadID);
  if (!thread) {
    return "";
  }
  let applicationName;
  if (org.platformApplicationID) {
    const application2 = await ApplicationEntity.findByPk(
      org.platformApplicationID
    );
    if (!application2) {
      return "";
    }
    applicationName = application2.name;
  }
  if (message.url === null) {
    return "";
  }
  switch (connectionType) {
    case "linear": {
      return generateLinearTaskFooterText(
        message.url,
        thread.name,
        showCordCopy,
        org.domain ?? void 0,
        applicationName
      );
    }
    case "asana":
    case "monday": {
      return generateAsanaOrMondayTaskFooterText(
        message.url,
        thread.name,
        showCordCopy,
        org.domain ?? void 0,
        applicationName
      );
    }
    case "jira": {
      return generateJiraTaskFooterText(
        message.url,
        thread.name,
        showCordCopy,
        org.domain ?? void 0,
        applicationName
      );
    }
    default:
      return "";
  }
}
var GRAPHQL_ENDPOINTS = {
  linear: {
    endpoint: "https://api.linear.app/graphql",
    authHeader: (token) => `Bearer ${token}`
  },
  monday: {
    endpoint: "https://api.monday.com/v2",
    authHeader: (token) => token
  }
};
async function thirdPartyGraphQLRequest(service, query, accessToken, variables = null) {
  const response = await fetch(GRAPHQL_ENDPOINTS[service].endpoint, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: GRAPHQL_ENDPOINTS[service].authHeader(accessToken)
    },
    body: JSON.stringify({ query, variables })
  });
  const responseText = await response.text();
  let responseJson;
  try {
    responseJson = JSON.parse(responseText);
  } catch (e) {
    throw new Error("Failed to obtain JSON response from: " + responseText);
  }
  if (responseJson.errors || responseJson.error_message) {
    if (responseJson.errors && responseJson.errors[0].message === "authentication failed") {
      throw new Error("external_api_forbidden_response" /* EXTERNAL_API_FORBIDDEN_RESPONSE */);
    } else {
      throw new Error(
        responseJson.errors ? JSON.stringify(responseJson.errors) : responseJson.error_message
      );
    }
  }
  return responseJson.data;
}
async function getThirdPartyExternalIDs(viewer, users, thirdPartyType) {
  try {
    const orgID = assertViewerHasOrg(viewer);
    const connections = await ThirdPartyConnectionEntity.findAll({
      where: {
        userID: users.map(({ id }) => id),
        orgID,
        type: thirdPartyType
      }
    });
    const userIDtoAccountID = new Map(
      connections.map((connection) => [
        connection.userID,
        connection.externalID
      ])
    );
    return users.map((user) => userIDtoAccountID.get(user.id));
  } catch (e) {
    handleThirdPartyException(
      "getThirdPartyExternalIDs",
      e,
      thirdPartyType,
      viewer
    );
    return [];
  }
}
async function getThirdPartyMatchedAccounts(viewer, taskAssigneeUserIDs, thirdPartyType) {
  if (taskAssigneeUserIDs.length === 0) {
    return [[], []];
  }
  try {
    const { orgID } = assertViewerHasIdentity(viewer);
    const userLoader = new UserLoader(viewer, () => null);
    const users = await userLoader.loadUsersInOrg(taskAssigneeUserIDs, orgID);
    const mondayProfileAccountIDs = await getThirdPartyExternalIDs(
      viewer,
      users,
      thirdPartyType
    );
    const matchedAccountIDs = mondayProfileAccountIDs.filter(isDefined);
    const unmatchedUsers = users.filter(
      (_user, i) => !mondayProfileAccountIDs[i]
    );
    return [matchedAccountIDs, unmatchedUsers];
  } catch (e) {
    handleThirdPartyException(
      "getThirdPartyMatchedAccounts",
      e,
      thirdPartyType,
      viewer
    );
    return [[], []];
  }
}
async function findTaskAndMessageEntitiesFromExternalTaskID(externalTaskID, thirdPartyType) {
  const thirdPartyTaskEntity = await TaskThirdPartyReference.findTaskWithExternalID(
    externalTaskID,
    thirdPartyType
  );
  if (!thirdPartyTaskEntity) {
    return null;
  }
  const taskID = thirdPartyTaskEntity.taskID;
  const taskEntity = await TaskEntity.findByPk(taskID);
  if (!taskEntity) {
    throw new Error(`Could not find task entity`);
  }
  const messageEntity = await MessageEntity.findByPk(taskEntity.messageID);
  if (!messageEntity) {
    throw new Error(`Could not find task message`);
  }
  return {
    thirdPartyTaskEntity,
    taskEntity,
    messageEntity
  };
}

// server/src/third_party_tasks/jira/util.ts
var import_types16 = __toESM(require_cjs(), 1);
var textNodeStyleToMarks = (node) => {
  const marks = [];
  if (node.bold) {
    marks.push({ type: "strong" });
  }
  if (node.italic) {
    marks.push({ type: "em" });
  }
  if (node.underline) {
    marks.push({ type: "underline" });
  }
  return marks;
};
var emptyFooter = [
  {
    type: "text",
    text: ""
  }
];
var convertNodeListToAtlassianDocumentNodes = (nodes) => {
  const convertedNodes = nodes.map(convertNodeToAtlassianDocumentNode).filter((node) => node !== void 0);
  const resultNodes = [];
  for (const node of convertedNodes) {
    if (node.type === "bulletList" && resultNodes.length > 0 && resultNodes[resultNodes.length - 1].type === "bulletList") {
      resultNodes[resultNodes.length - 1].content = [
        ...resultNodes[resultNodes.length - 1].content,
        ...node.content
      ];
    } else if (node.type === "orderedList" && resultNodes.length > 0 && resultNodes[resultNodes.length - 1].type === "orderedList") {
      resultNodes[resultNodes.length - 1].content = [
        ...resultNodes[resultNodes.length - 1].content,
        ...node.content
      ];
    } else {
      resultNodes.push(node);
    }
  }
  return resultNodes;
};
var wrapTextInParagraphIfNecessary = (node) => {
  if (node.type === "text") {
    return {
      type: "paragraph",
      content: [node]
    };
  } else {
    return node;
  }
};
var convertNodeToAtlassianDocumentNode = (node) => {
  if (node.type === void 0) {
    if (!node.text) {
      return void 0;
    }
    return {
      type: "text",
      text: node.text,
      marks: textNodeStyleToMarks(node)
    };
  } else {
    switch (node.type) {
      case import_types16.MessageNodeType.LINK: {
        const nodeText = node.children[0].text;
        if (nodeText.length === 0) {
          return void 0;
        }
        return {
          type: "text",
          text: nodeText,
          marks: [
            {
              type: "link",
              attrs: { href: node.url }
            }
          ]
        };
      }
      case import_types16.MessageNodeType.PARAGRAPH:
      case import_types16.MessageNodeType.MARKDOWN: {
        const content = convertNodeListToAtlassianDocumentNodes(node.children);
        if (content.length === 0) {
          return void 0;
        }
        return {
          type: "paragraph",
          content
        };
      }
      case import_types16.MessageNodeType.TODO:
      case import_types16.MessageNodeType.BULLET: {
        const content = convertNodeListToAtlassianDocumentNodes(node.children);
        if (content.length === 0) {
          return void 0;
        }
        return {
          type: "bulletList",
          content: [
            {
              type: "listItem",
              content: content.map(wrapTextInParagraphIfNecessary)
            }
          ]
        };
      }
      case import_types16.MessageNodeType.NUMBER_BULLET: {
        const content = convertNodeListToAtlassianDocumentNodes(node.children);
        if (content.length === 0) {
          return void 0;
        }
        return {
          type: "orderedList",
          content: [
            {
              type: "listItem",
              content: content.map(wrapTextInParagraphIfNecessary)
            }
          ]
        };
      }
      case import_types16.MessageNodeType.ASSIGNEE:
        return {
          type: "text",
          text: node.children[0].text
          // TODO: strip +
        };
      case import_types16.MessageNodeType.MENTION:
        return {
          type: "text",
          text: node.children[0].text
          // TODO: strip @
        };
      case import_types16.MessageNodeType.QUOTE: {
        const content = convertNodeListToAtlassianDocumentNodes(node.children);
        if (content.length === 0) {
          return void 0;
        }
        return {
          type: "blockquote",
          content: content.map(wrapTextInParagraphIfNecessary)
        };
      }
      case import_types16.MessageNodeType.CODE: {
        const content = convertNodeListToAtlassianDocumentNodes(node.children);
        if (content.length === 0) {
          return void 0;
        }
        return {
          type: "codeBlock",
          content: content.map(wrapTextInParagraphIfNecessary)
        };
      }
    }
  }
};
function messageContentToAtlassianDocument(content, footer) {
  return {
    type: "doc",
    version: 1,
    content: convertNodeListToAtlassianDocumentNodes(content).map(wrapTextInParagraphIfNecessary).concat({
      type: "paragraph",
      content: footer
    })
  };
}
function unmatchedUsersToAtlassianDocument(users) {
  return {
    type: "doc",
    version: 1,
    content: [
      {
        type: "paragraph",
        content: [
          {
            type: "text",
            text: "This task was assigned to the following Cord users who did not have Jira connected:"
          }
        ]
      },
      {
        type: "bulletList",
        content: users.map((user) => ({
          type: "listItem",
          content: [
            {
              type: "paragraph",
              content: [
                {
                  type: "text",
                  text: [userDisplayName(user), user.email || ""].join(" ").trim()
                }
              ]
            }
          ]
        }))
      }
    ]
  };
}

// server/src/third_party_tasks/jira/actions.ts
var CACHE_TTL_EXPIRATION_DELTA_SECONDS = 30;
async function getJiraCredentials(viewer) {
  try {
    const { userID, orgID } = assertViewerHasIdentity(viewer);
    const key = cacheKey({ type: "jira_credentials", userID, orgID });
    let credentials2 = cache.get(key);
    if (credentials2 !== void 0) {
      return credentials2;
    }
    const externalAuthData = await getExternalAuthData(viewer, "jira");
    if (!externalAuthData) {
      return null;
    }
    const { refreshToken, cloudID } = externalAuthData;
    const response = await fetchAccessToken(viewer, refreshToken, cloudID);
    credentials2 = {
      accessToken: response.access_token,
      cloudID
    };
    cache.set(
      key,
      credentials2,
      // subtract a small amount of time to avoid the risk of the action happening
      // between when the token expires as determined by the remote server versus
      // when we receive and store it here (probably a couple of seconds).
      response.expires_in - CACHE_TTL_EXPIRATION_DELTA_SECONDS
    );
    return credentials2;
  } catch (e) {
    handleThirdPartyException("getJiraCredentials", e, "jira", viewer);
    return null;
  }
}
async function fetchJiraProjects(viewer) {
  try {
    const credentials2 = await getJiraCredentials(viewer);
    if (!credentials2) {
      return [];
    }
    const { accessToken, cloudID } = credentials2;
    const projectsResponse = await fetchProjects(accessToken, cloudID);
    return projectsResponse.values;
  } catch (e) {
    handleThirdPartyException(`fetchJiraProjects`, e, "jira", viewer);
    return [];
  }
}
async function getProjectAndIssueTypes(viewer) {
  try {
    const userID = assertViewerHasUser(viewer);
    const response = await UserPreferenceEntity.findOne({
      where: {
        userID,
        key: JIRA_CONNECTION_PREFERENCES
      }
    });
    if (!response) {
      throw new Error("user preferences missing");
    }
    return response.value;
  } catch (e) {
    handleThirdPartyException(`getProjectAndIssueTypes`, e, "jira", viewer);
    return void 0;
  }
}
async function createSimpleJiraTask(viewer, task) {
  try {
    const credentials2 = await getJiraCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken, cloudID } = credentials2;
    const preferences = await getProjectAndIssueTypes(viewer);
    if (!preferences) {
      return;
    }
    const { projectID, issueType } = preferences;
    if (!issueType || !projectID) {
      return;
    }
    const message = await MessageEntity.findByPk(task.messageID);
    if (!message) {
      return;
    }
    const title = taskTitleFromMessageContent(message.content);
    let footerText = await getTaskFooterText(viewer, message, "jira");
    if (typeof footerText === "string") {
      footerText = emptyFooter;
    }
    const description = messageContentToAtlassianDocument(
      message.content,
      footerText
    );
    const { id } = await createIssue(
      accessToken,
      cloudID,
      title,
      description,
      projectID,
      issueType,
      null
    );
    const previewData = await getJiraIssuePreviewData(viewer, id);
    const reference = await TaskThirdPartyReference.create({
      taskID: task.id,
      externalID: id,
      externalConnectionType: "jira",
      previewData,
      externalLocationID: cloudID
    });
    await publishMessageUpdateForTask(reference);
    if (task.done) {
      await updateJiraTask(viewer, reference, true);
    }
  } catch (e) {
    handleThirdPartyException(`createSimpleJiraTask`, e, "jira", viewer);
  }
}
async function updateJiraTaskAssigneeAndWatchers(viewer, taskID, taskAssigneeUserIDs) {
  try {
    const credentials2 = await getJiraCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken, cloudID } = credentials2;
    const thirdPartyReference = await TaskThirdPartyReference.findForTask(
      taskID,
      "jira"
    );
    if (!thirdPartyReference) {
      return;
    }
    const issueID = thirdPartyReference.externalID;
    const [matchedJiraAccountIDs, unmatchedUsers] = await getThirdPartyMatchedAccounts(viewer, taskAssigneeUserIDs, "jira");
    const [assigneeAccountID, ...watcherAccountIDs] = matchedJiraAccountIDs;
    await Promise.all([
      assignIssue(accessToken, cloudID, issueID, assigneeAccountID),
      ...watcherAccountIDs.map(
        (watcherID) => addIssueWatcher(accessToken, cloudID, issueID, watcherID)
      )
    ]);
    await updateTaskPreviewData(viewer, thirdPartyReference);
    if (unmatchedUsers.length > 0) {
      await addIssueComment(
        accessToken,
        cloudID,
        issueID,
        unmatchedUsersToAtlassianDocument(unmatchedUsers)
      );
    }
  } catch (e) {
    handleThirdPartyException(
      `updateJiraTaskAssigneeAndWatchers`,
      e,
      "jira",
      viewer
    );
  }
}
async function createJiraSubtasks(viewer, taskID, todos) {
  try {
    const credentials2 = await getJiraCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken, cloudID } = credentials2;
    const [preferences, thirdPartyReference, task] = await Promise.all([
      getProjectAndIssueTypes(viewer),
      TaskThirdPartyReference.findForTask(taskID, "jira"),
      TaskEntity.findByPk(taskID)
    ]);
    if (!preferences || !thirdPartyReference || !task) {
      return;
    }
    const { projectID, subissueType } = preferences;
    if (!projectID || !subissueType) {
      return;
    }
    const { messageID } = task;
    const message = await MessageEntity.findByPk(messageID);
    if (!message) {
      return;
    }
    const issueID = thirdPartyReference.externalID;
    const createdTodoIDs = new Set(todos.map((todo) => todo.id));
    const todoNodes = todoNodesFromMessage(message.content).filter(
      (node) => createdTodoIDs.has(node.todoID)
    );
    let footerText = await getTaskFooterText(viewer, message, "jira");
    if (typeof footerText === "string") {
      footerText = emptyFooter;
    }
    const description = messageContentToAtlassianDocument(
      [{ text: "" }],
      footerText
    );
    const subIssues = await Promise.all(
      todoNodes.map(
        (todoNode) => createIssue(
          accessToken,
          cloudID,
          textFromNodeRecursive(todoNode),
          description,
          projectID,
          subissueType,
          null,
          issueID
        )
      )
    );
    const references = await Promise.all(
      subIssues.map(
        (subIssue, index) => TaskThirdPartyReference.create({
          taskID,
          taskTodoID: todoNodes[index].todoID,
          externalID: subIssue.id,
          externalConnectionType: "jira",
          previewData: null,
          externalLocationID: cloudID
        })
      )
    );
    await Promise.all(
      todoNodes.map((todoNode, index) => {
        if (!todos.find(({ id }) => todoNode.todoID === id)?.done) {
          return null;
        }
        const reference = references.find(
          (ref) => ref.externalID === subIssues[index].id
        );
        if (!reference) {
          return null;
        }
        return updateJiraTask(viewer, reference, true);
      })
    );
    await publishMessageUpdateForTask(thirdPartyReference);
  } catch (e) {
    handleThirdPartyException(`createJiraSubtasks`, e, "jira", viewer);
  }
}
async function addJiraTaskAttachments(viewer, externalIssueID, files) {
  if (files.length === 0) {
    return;
  }
  try {
    const credentials2 = await getJiraCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const s3BucketLoader = new S3BucketLoader(viewer);
    const { accessToken, cloudID } = credentials2;
    await Promise.all(
      files.filter((file) => file.uploadStatus === "uploaded").map(async (file) => {
        const url6 = await file.getSignedDownloadURL(s3BucketLoader);
        const response = await fetch(url6);
        if (response.status === 200) {
          await addIssueAttachment(
            accessToken,
            cloudID,
            externalIssueID,
            file.name,
            file.mimeType,
            response.body,
            file.size
          );
        }
      })
    );
  } catch (e) {
    handleThirdPartyException(`addJiraTaskAttachments`, e, "jira", viewer);
  }
}
async function updateJiraTask(viewer, reference, done) {
  try {
    const credentials2 = await getJiraCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken, cloudID } = credentials2;
    const issueID = reference.externalID;
    const { transitions } = await getIssueTransitions(
      accessToken,
      cloudID,
      issueID
    );
    const transitionToStatusKey = done ? "done" : "new";
    const transition = transitions.find(
      // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
      (transition2) => transition2.isAvailable && transition2.to.statusCategory.key === transitionToStatusKey
    );
    if (!transition) {
      throw new Error(
        `Couldn't transition Jira issue ${issueID} to ${transitionToStatusKey} due to missing transition`
      );
    }
    await transitionIssue(accessToken, cloudID, issueID, transition.id);
    await updateTaskPreviewData(viewer, reference);
  } catch (e) {
    handleThirdPartyException(`updateJiraTask`, e, "jira", viewer);
  }
}
async function getBaseURLForCloudInstance(cloudID) {
  try {
    const key = cacheKey({
      type: "jira_cloud_base_url",
      cloudID
    });
    let value = cache.get(key);
    if (value === void 0) {
      const { baseUrl } = await getServerInfo(cloudID);
      value = baseUrl;
      cache.set(key, value);
    }
    return value;
  } catch (e) {
    handleThirdPartyException(`getBaseURLForCloudInstance`, e, "jira");
    return null;
  }
}
async function updateTaskPreviewData(viewer, externalReference) {
  if (!externalReference.taskTodoID) {
    const issueID = externalReference.externalID;
    const previewData = await getJiraIssuePreviewData(viewer, issueID);
    await externalReference.update({ previewData });
    await publishMessageUpdateForTask(externalReference);
  }
}
async function getJiraIssuePreviewData(viewer, issueID) {
  try {
    const credentials2 = await getJiraCredentials(viewer);
    if (!credentials2) {
      return null;
    }
    const { accessToken, cloudID } = credentials2;
    const [issue, baseURL2] = await Promise.all([
      getIssue(accessToken, cloudID, issueID),
      getBaseURLForCloudInstance(cloudID)
    ]);
    if (!baseURL2) {
      return null;
    }
    return {
      key: issue.key,
      title: issue.fields.summary,
      url: `${baseURL2}/browse/${issue.key}`,
      assignee: issue.fields.assignee?.displayName,
      status: issue.fields.status.statusCategory.name,
      done: issue.fields.status.statusCategory.key === "done",
      priority: issue.fields.priority.name,
      subtasks: issue.fields.subtasks.map((subtask) => ({
        id: subtask.id,
        title: subtask.fields.summary,
        done: subtask.fields.status.statusCategory.key === "done"
      }))
    };
  } catch (e) {
    handleThirdPartyException(`getJiraIssuePreviewData`, e, "jira", viewer);
    return null;
  }
}

// server/src/third_party_tasks/asana/actions.ts
import { QueryTypes as QueryTypes27 } from "sequelize";

// server/src/third_party_tasks/asana/api.ts
import FormData3 from "form-data";

// server/src/public/routes/MainRouter.ts
import { Router } from "express";
import cors from "cors";
import multer from "multer";
import basicAuth from "express-basic-auth";
import responseTime from "response-time";
import { v4 as uuid23 } from "uuid";

// server/src/public/routes/platform/threads/CreateThreadHandler.ts
import { v4 as uuid5 } from "uuid";

// common/util/externalIDs.ts
import isUUID2 from "validator/lib/isUUID.js";
var MAX_EXTERNAL_ID_LENGTH = 320;
var ID_TO_EXTERNAL_ID_PREFIX = "cord:";
function isValidExternalID(id) {
  const stringifiedID = id.toString();
  const charLength = [...stringifiedID].length;
  if (charLength <= 0 || MAX_EXTERNAL_ID_LENGTH < charLength) {
    return false;
  }
  if (stringifiedID.startsWith(ID_TO_EXTERNAL_ID_PREFIX)) {
    return false;
  }
  if (stringifiedID.match(new RegExp("\\p{C}", "u"))) {
    return false;
  }
  return true;
}
function externalizeID(id) {
  return `${ID_TO_EXTERNAL_ID_PREFIX}${id}`;
}
function isExternalizedID(externalID) {
  return externalID.startsWith(ID_TO_EXTERNAL_ID_PREFIX) && isUUID2.default(externalID.substring(ID_TO_EXTERNAL_ID_PREFIX.length));
}
function extractInternalID(externalizedID) {
  if (!isExternalizedID(externalizedID)) {
    return null;
  }
  return externalizedID.substring(ID_TO_EXTERNAL_ID_PREFIX.length);
}

// server/src/public/routes/platform/types.ts
function validateExternalID(id, fieldName) {
  if (!isValidExternalID(id)) {
    throw new ApiCallerError("invalid_field", {
      message: createInvalidInputTypeMessage(fieldName, "identifier")
    });
  }
}

// server/src/public/routes/platform/validatorFunction.ts
var import_api_types = __toESM(require_cjs2(), 1);
import Ajv from "ajv";
import { fullFormats } from "ajv-formats/dist/formats.js";
import addFormat from "ajv-formats";
var ajv = new Ajv.default({
  allErrors: true,
  coerceTypes: false,
  useDefaults: false,
  allowUnionTypes: true,
  keywords: ["propertyOrder"],
  // as propertyOrder is not a default key in json schemas and so crashes as we're running on strict mode
  verbose: true
  // Include the reference to the part of the schema (schema and parentSchema) and validated data in errors
});
addFormat.default(ajv, ["date-time", "uri", "uuid"]);
ajv.addFormat("email", {
  validate: (data) => {
    if (data === "") {
      return true;
    }
    return data.match(fullFormats["email"]);
  }
});
function getErrorMessage(typeName, errors) {
  const errorMessages = [];
  const requiredFieldErrors = {};
  const additionalFieldErrors = {};
  for (const error of errors) {
    const field = error.instancePath.slice(1);
    const schemaPath = error.schemaPath;
    if (schemaPath.includes("anyOf") && error.keyword !== "anyOf") {
      continue;
    }
    const errorData = JSON.stringify(error.data);
    switch (error.keyword) {
      case "required": {
        const instancePath = error.instancePath;
        if (!requiredFieldErrors[instancePath]) {
          requiredFieldErrors[instancePath] = { input: null, fields: [] };
          requiredFieldErrors[instancePath]["input"] = errorData;
        }
        requiredFieldErrors[instancePath]["fields"].push(
          error.params.missingProperty
        );
        break;
      }
      case "type": {
        let params;
        if (Array.isArray(error.params.type)) {
          params = error.params.type.join(" or ");
        } else {
          params = error.params.type;
        }
        errorMessages.push(
          `Input ${errorData} for ${field} must be type ${params}`
        );
        break;
      }
      case "format":
      case "minLength":
      case "maxLength":
        errorMessages.push(`Input ${errorData} for ${field} ${error.message}`);
        break;
      case "additionalProperties": {
        const instancePath = error.instancePath;
        if (!additionalFieldErrors[instancePath]) {
          additionalFieldErrors[instancePath] = { input: null, fields: [] };
          additionalFieldErrors[instancePath]["input"] = errorData;
        }
        additionalFieldErrors[instancePath]["fields"].push(
          error.params.additionalProperty
        );
        break;
      }
      case "enum":
        errorMessages.push(
          `Input ${errorData} for ${field} ${error.message}: ${error.params.allowedValues.join(" or ")}`
        );
        break;
      case "anyOf":
        errorMessages.push(
          `Input ${errorData} for ${field} must match one of: ${decodeSchema(
            error.schema
          )}`
        );
        break;
      case "maxItems": {
        if (Array.isArray(error.data)) {
          errorMessages.push(
            `Input has ${error.data.length} items and ${error.message}`
          );
        } else {
          errorMessages.push(`${field} ${error.message}`);
        }
        break;
      }
      default:
        errorMessages.push(`Input ${errorData} for ${field} ${error.message}`);
        break;
    }
  }
  Object.values(requiredFieldErrors).forEach((requiredFieldError) => {
    const errorMessage = generateFieldsMessageWithInput(
      requiredFieldError,
      "required"
    );
    if (errorMessage) {
      errorMessages.push(errorMessage);
    }
  });
  Object.values(additionalFieldErrors).map((additionalFieldError) => {
    const errorMessage = generateFieldsMessageWithInput(
      additionalFieldError,
      "unexpected"
    );
    if (errorMessage) {
      errorMessages.push(errorMessage);
    }
  });
  const schemaDescription = getSchemaDescription(typeName);
  return `Invalid ${typeName}:
${errorMessages.join(",\n")}.${schemaDescription ?? ""}`;
}
var validate = Object.fromEntries(
  Object.keys(import_api_types.schema).map((typeName) => {
    const typeSchema = import_api_types.schema[typeName];
    const validator = ajv.compile(typeSchema);
    const isClientAuthTokenData = typeName === "ClientAuthTokenData";
    const errorName = isClientAuthTokenData ? "invalid_session_token" : "invalid_request";
    const code = isClientAuthTokenData ? 401 : 400;
    function validate2(value) {
      const schemaDescription = getSchemaDescription(typeName);
      const isObject = value && typeof value === "object" && !Array.isArray(value);
      if (!isObject) {
        throw new ApiCallerError(errorName, {
          message: `Invalid ${typeName}:
Expected JSON object.${schemaDescription ?? ""}`,
          code
        });
      }
      if (validator(value)) {
        return value;
      }
      if (validator.errors && validator.errors.length) {
        const message = getErrorMessage(typeName, validator.errors);
        throw new ApiCallerError(errorName, {
          message,
          code
        });
      } else {
        throw new ApiCallerError("invalid_request", {
          message: "Invalid request"
        });
      }
    }
    return [typeName, validate2];
  })
);
function getSchemaDescription(typeName) {
  const schemaByType = import_api_types.schema[typeName];
  if (!("description" in schemaByType)) {
    return null;
  }
  if (typeof schemaByType.description !== "string") {
    return null;
  }
  return `
Refer to ${schemaByType.description}`;
}
function generateFieldsMessageWithInput(data, type) {
  if (!data.input) {
    return null;
  }
  if (data.fields.length === 0) {
    return null;
  }
  if (type === "unexpected") {
    return `Input ${data.input} has unexpected ${generateFieldsListToString(
      data.fields
    )}`;
  }
  return `Input ${data.input} requires ${generateFieldsListToString(
    data.fields
  )}`;
}
function generateFieldsListToString(fields) {
  let fieldsString = "";
  if (fields.length === 0) {
    return "";
  }
  if (fields.length === 1) {
    fieldsString = `field: ${fields[0]}`;
  }
  if (fields.length > 1) {
    fieldsString = `fields: ${fields.slice(0, -1).join(", ")} and ${fields.slice(-1).join("")}`;
  }
  return fieldsString;
}
function decodeSchema(schema2) {
  const message = [];
  if (!schema2) {
    return "";
  }
  schema2?.map((schemaItem) => {
    if (typeof schemaItem !== "boolean") {
      const item = schemaItem.format ?? schemaItem.type ?? "";
      message.push(item.toString());
    }
  });
  return message.join(", ");
}
function removeEmptyStringEmailIfExists(data) {
  const dataCopy = { ...data };
  if ("email" in dataCopy && dataCopy.email === "") {
    delete dataCopy.email;
    return dataCopy;
  }
  if ("user_details" in dataCopy && dataCopy["user_details"] && "email" in dataCopy.user_details && dataCopy.user_details.email === "") {
    delete dataCopy.user_details.email;
    return dataCopy;
  }
  return data;
}

// server/src/entity/thread/ThreadMutator.ts
import { Sequelize as Sequelize12 } from "sequelize";

// server/src/entity/thread_participant/ThreadParticipantMutator.ts
import { Op as Op15, QueryTypes as QueryTypes15 } from "sequelize";
import { unique as unique9 } from "radash";
var ThreadParticipantMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
  }
  async threadLoader() {
    if (!this.loaders) {
      this.loaders = await getNewLoaders(this.viewer);
    }
    return this.loaders.threadLoader;
  }
  async getLocation(threadID) {
    const pageLoader = this.loaders?.pageLoader ?? new PageLoader(this.viewer);
    const page = await pageLoader.loadPrimaryPageForThreadNoOrgCheck(threadID);
    if (!page) {
      throw new Error("Unable to find thread location");
    }
    return page.contextData;
  }
  async markThreadSeen({
    threadID,
    setSubscribed = false,
    transaction
  }) {
    const userID = assertViewerHasUser(this.viewer);
    const thread = await ThreadEntity.findByPk(threadID, { transaction });
    if (!thread) {
      throw new Error("No such thread");
    }
    await getSequelize().query(
      `INSERT INTO thread_participants ("orgID", "userID", "threadID", "subscribed", "lastUnseenMessageTimestamp","lastUnseenReactionTimestamp","lastSeenTimestamp")
       VALUES ($1, $2, $3, $4, $5, $6, (
        SELECT GREATEST(MAX(m."timestamp"), MAX(mr."timestamp")) FROM messages m LEFT OUTER JOIN message_reactions mr ON mr."messageID"=m.id
        WHERE m."threadID"=$3
       ))
       ON CONFLICT ("orgID", "userID", "threadID") DO UPDATE
       SET "lastSeenTimestamp" = EXCLUDED."lastSeenTimestamp", "lastUnseenMessageTimestamp" = NULL, "lastUnseenReactionTimestamp" = NULL`,
      {
        bind: [thread.orgID, userID, threadID, setSubscribed, null, null],
        transaction
      }
    );
    const notify = async () => {
      if (thread.platformApplicationID !== "9e7d98ae-5da5-42ca-b857-2f15dc9a63db") {
        const location = await this.getLocation(threadID);
        await Promise.all([
          publishPubSubEvent(
            "inbox-updated",
            { userID },
            { threadID, location }
          ),
          publishPubSubEvent(
            "thread-participants-updated-incremental",
            { threadID },
            { userID }
          )
        ]);
      } else {
        anonymousLogger().debug(
          "Skipped thread seen subscriptions for 9e7d98ae-5da5-42ca-b857-2f15dc9a63db"
        );
      }
    };
    if (transaction) {
      transaction.afterCommit(notify);
    } else {
      await notify();
    }
  }
  async markThreadUnseenFromMessage({
    threadID,
    messageID,
    transaction
  }) {
    const { userID, orgID } = assertViewerHasIdentity(this.viewer);
    const lastSeenMessage = await getSequelize().query(
      `SELECT * from messages m
      WHERE m.timestamp < (SELECT timestamp from messages m WHERE m.id = $1)
      AND m."threadID" = $2 
      ORDER BY timestamp DESC
      LIMIT 1`,
      {
        bind: [messageID, threadID],
        type: QueryTypes15.SELECT,
        model: MessageEntity,
        transaction
      }
    );
    const lastSeenMessageTimestamp = lastSeenMessage[0]?.timestamp ?? null;
    const mostRecentMessage = await MessageEntity.findOne({
      where: {
        threadID
      },
      order: [["timestamp", "DESC"]],
      transaction
    });
    if (!mostRecentMessage) {
      throw new Error("No messages found in thread");
    }
    await getSequelize().query(
      `INSERT INTO thread_participants ("orgID", "userID", "threadID", "subscribed", "lastUnseenMessageTimestamp", "lastUnseenReactionTimestamp", "lastSeenTimestamp")
        VALUES ($1, $2, $3, $4, $5, $5, $6)
        ON CONFLICT ("orgID", "userID", "threadID") DO UPDATE
        SET "lastSeenTimestamp" = $6, "lastUnseenMessageTimestamp" = $5, "lastUnseenReactionTimestamp" = $5`,
      {
        bind: [
          orgID,
          userID,
          threadID,
          false,
          mostRecentMessage.timestamp,
          lastSeenMessageTimestamp
        ],
        transaction
      }
    );
    const notify = async () => {
      const location = await this.getLocation(threadID);
      await Promise.all([
        publishPubSubEvent("inbox-updated", { userID }, { threadID, location }),
        publishPubSubEvent(
          "thread-participants-updated-incremental",
          {
            threadID
          },
          { userID }
        )
      ]);
    };
    if (transaction) {
      transaction.afterCommit(notify);
    } else {
      await notify();
    }
  }
  async markAllThreadsSeen({
    seen,
    externalThreadID,
    location,
    resolved,
    metadata,
    viewer,
    ...rest
  }) {
    const _ = rest;
    const userID = assertViewerHasUser(this.viewer);
    const orgIDs = assertViewerHasOrgs(this.viewer);
    const whereConditions = [];
    const extraJoins = [];
    const bindVariables = [orgIDs, userID];
    whereConditions.push('t."orgID" = ANY($1)');
    if (externalThreadID) {
      bindVariables.push(externalThreadID);
      whereConditions.push(`t."externalID" = $${bindVariables.length}`);
    }
    if (resolved === true) {
      whereConditions.push(`t."resolvedTimestamp" IS NOT NULL`);
    } else if (resolved === false) {
      whereConditions.push(`t."resolvedTimestamp" IS NULL`);
    }
    if (metadata) {
      bindVariables.push(JSON.stringify(metadata));
      whereConditions.push(`t."metadata" @> $${bindVariables.length}`);
    }
    if (viewer) {
      const viewerConditions = [];
      for (const f of unique9(viewer)) {
        switch (f) {
          case "subscribed":
            extraJoins.push(`LEFT JOIN thread_participants tp
              ON (t.id = tp."threadID" AND tp."userID" = $2)`);
            viewerConditions.push('tp."subscribed" = TRUE');
            break;
          case "mentioned":
            viewerConditions.push(
              `t.id IN (
                SELECT "threadID" from messages m
                  INNER JOIN message_mentions mm ON (m.id = mm."messageID")
                WHERE mm."userID" = $2
                  AND m.type = 'user_message'
                  AND m."deletedTimestamp" IS NULL
              )`
            );
            break;
          default: {
            const _f = f;
            throw new Error(`Unknown filter: ${f}`);
          }
        }
      }
      if (viewerConditions.length) {
        whereConditions.push(`(${viewerConditions.join(" OR ")})`);
      }
    }
    if (location) {
      bindVariables.push(JSON.stringify(location.value));
      extraJoins.push(`INNER JOIN pages p
         ON (p."orgID" = t."orgID" AND p."contextHash" = t."pageContextHash")`);
      whereConditions.push(`p."contextData" ${location.partialMatch ? "@>" : "="} $${bindVariables.length}::jsonb
      `);
      whereConditions.push(`p."orgID" = ANY($1)`);
    }
    const seenVal = seen ? "NOW()" : "NULL";
    const [threadIDs, _affected] = await getSequelize().query(
      `INSERT INTO thread_participants
          ("orgID", "userID", "threadID", "subscribed", "lastUnseenMessageTimestamp", "lastUnseenReactionTimestamp", "lastSeenTimestamp")
        SELECT t."orgID", $2, t."id", false, NULL, NULL, ${seenVal}
          FROM threads t
          ${extraJoins.join(" ")}
          WHERE ${whereConditions.join(" AND ")}
      ON CONFLICT ("orgID", "userID", "threadID") DO UPDATE
        SET "lastUnseenMessageTimestamp" = NULL, "lastUnseenReactionTimestamp" = NULL, "lastSeenTimestamp" = ${seenVal}
      RETURNING "threadID"`,
      { bind: bindVariables }
    );
    await Promise.all([
      publishPubSubEvent("inbox-updated", { userID }, null),
      Promise.all(
        threadIDs.map(
          ({ threadID }) => publishPubSubEvent(
            "thread-participants-updated-incremental",
            { threadID },
            { userID }
          )
        )
      )
    ]);
  }
  async subscribeUsersToThread(threadID, userIDs, orgIDOverride, transaction) {
    const viewerOrgID = assertViewerHasOrg(this.viewer);
    const orgMembers = await OrgMembersEntity.findAll({
      where: {
        orgID: orgIDOverride ?? viewerOrgID,
        userID: userIDs
      },
      transaction
    });
    await ThreadParticipantEntity.bulkCreate(
      orgMembers.map((om) => ({
        threadID,
        userID: om.userID,
        orgID: orgIDOverride ?? viewerOrgID,
        subscribed: true
      })),
      {
        transaction,
        updateOnDuplicate: ["subscribed"]
      }
    );
  }
  async unsubscribeUsersFromThread(threadID, userIDs, transaction) {
    await ThreadParticipantEntity.update(
      { subscribed: false },
      { where: { threadID, userID: userIDs }, transaction }
    );
  }
  async markThreadNewlyActiveForOtherUsers(threadID, messageID, transaction) {
    const userID = assertViewerHasUser(this.viewer);
    const [rows] = await getSequelize().query(
      `UPDATE thread_participants
       SET "lastUnseenMessageTimestamp" = (
         SELECT timestamp FROM messages WHERE id=$1
       )
       WHERE "threadID"=$2 AND "userID"!=$3
       RETURNING "userID";`,
      { bind: [messageID, threadID, userID], transaction }
    );
    const notify = async () => {
      const location = await this.getLocation(threadID);
      await Promise.all(
        // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
        rows.map(({ userID: userID2 }) => {
          return publishPubSubEvent(
            "inbox-updated",
            { userID: userID2 },
            { threadID, location }
          );
        })
      );
    };
    if (transaction) {
      transaction.afterCommit(notify);
    } else {
      await notify();
    }
  }
  /**
   * This function marks the thread active for the participant who has received
   * the reaction, by setting the lastUnseenReactionTimestamp to that of the given reaction.
   * This is called when a logged in user reacts to someone's message.
   */
  async markThreadNewlyActiveForUser(threadID, reactionID, userID, transaction) {
    assertViewerHasUser(this.viewer);
    if (userID === this.viewer.userID) {
      return;
    }
    await getSequelize().query(
      `UPDATE thread_participants
       SET "lastUnseenReactionTimestamp" = (
         SELECT timestamp FROM message_reactions WHERE id=$1
       )
       WHERE "threadID"=$2 AND "userID"=$3
       RETURNING "userID";`,
      { bind: [reactionID, threadID, userID], transaction }
    );
    const notify = async () => {
      const location = await this.getLocation(threadID);
      return await publishPubSubEvent(
        "inbox-updated",
        { userID },
        { threadID, location }
      );
    };
    if (transaction) {
      transaction.afterCommit(notify);
    } else {
      await notify();
    }
  }
  async updateLastUnseenMessageTimestamp(threadID, orgID) {
    const threadLoader = await this.threadLoader();
    const [participants, threadHasUserMessages] = await Promise.all([
      ThreadParticipantEntity.findAll({
        where: { threadID, orgID }
      }),
      threadLoader.hasUserMessagesNoOrgCheck(threadID)
    ]);
    if (threadHasUserMessages) {
      const lastUnseenMessages = await Promise.all(
        participants.map(({ userID, lastSeenTimestamp }) => {
          let whereOptions = {
            threadID,
            sourceID: { [Op15.ne]: userID },
            orgID,
            deletedTimestamp: { [Op15.is]: null }
          };
          if (lastSeenTimestamp !== null) {
            whereOptions = {
              ...whereOptions,
              // if lastSeenTimestamp is null, Postgres does not consider
              // message.timestamp to be GT than lastSeenTimestamp so the row
              // is not returned.  This means the lastUnseenMessageTimestamp on the
              // Thread Participant Entities can get overwritten by null in step 3 below
              // if a user had seen none of the messages in the thread,
              // and the message incorrectly appears in the 'read' section of the inbox
              // because it seems like the user has seen all the messages
              timestamp: { [Op15.gt]: lastSeenTimestamp }
            };
          }
          return MessageEntity.findOne({
            where: {
              ...whereOptions
            },
            order: [["timestamp", "DESC"]]
          });
        })
      );
      await Promise.all(
        participants.map(
          ({ userID }, index) => ThreadParticipantEntity.update(
            {
              lastUnseenMessageTimestamp: lastUnseenMessages[index] ? lastUnseenMessages[index]?.timestamp : null
            },
            { where: { threadID, userID, orgID } }
          )
        )
      );
    } else {
      await ThreadParticipantEntity.update(
        {
          lastUnseenMessageTimestamp: null
        },
        { where: { threadID, orgID } }
      );
    }
    const location = await this.getLocation(threadID);
    await Promise.all(
      participants.map(
        ({ userID }) => publishPubSubEvent("inbox-updated", { userID }, { threadID, location })
      )
    );
  }
  async setViewerSubscribed(thread, subscribed, transaction) {
    const userID = assertViewerHasUser(this.viewer);
    await ThreadParticipantEntity.upsert(
      { threadID: thread.id, userID, orgID: thread.orgID, subscribed },
      {
        transaction
      }
    );
    const notify = async () => {
      const location = await this.getLocation(thread.id);
      await Promise.all([
        publishPubSubEvent(
          "inbox-updated",
          { userID },
          { threadID: thread.id, location }
        ),
        publishPubSubEvent(
          "thread-subscriber-updated",
          { threadID: thread.id },
          { userID }
        )
      ]);
    };
    if (transaction) {
      transaction.afterCommit(notify);
    } else {
      await notify();
    }
    return true;
  }
};

// server/src/message/new_message_tasks/maybeAddEveryOrgMemberAsThreadParticipants.ts
async function maybeAddEveryOrgMemberAsThreadParticipants(viewer, flagsUser, threadID) {
  if (await getFeatureFlagValue("subscribe_all_org_members", flagsUser)) {
    await addEveryOrgMemberToThreadParticipants(viewer, threadID);
  }
}
async function addEveryOrgMemberToThreadParticipants(viewer, threadID) {
  const orgMembersLoader = new OrgMembersLoader(viewer);
  const orgMembers = await orgMembersLoader.loadNotifiableOrgMembers(void 0);
  const userIDs = orgMembers.map((u) => u.userID);
  return await new ThreadParticipantMutator(
    viewer,
    null
  ).subscribeUsersToThread(threadID, userIDs);
}

// server/src/message/new_message_tasks/addAdditionalSubscribersOnThreadCreation.ts
async function addAdditionalSubscribersOnThreadCreation(context, additionalSubscribers, threadID) {
  const orgIDs = assertViewerHasOrgs(context.session.viewer);
  const users = await context.loaders.userLoader.loadUsersByExternalIDsInOrg(
    additionalSubscribers,
    orgIDs
  );
  const userIDs = users.map((u) => u.id);
  if (userIDs.length === 0) {
    return;
  }
  return await new ThreadParticipantMutator(
    context.session.viewer,
    context.loaders
  ).subscribeUsersToThread(threadID, userIDs);
}

// server/src/entity/thread/ThreadMutator.ts
var ThreadMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.logger = new Logger(viewer);
  }
  // remember to trigger the page events PAGE_THREAD_ADDED when using
  // createThreadOnPage function
  async createThreadOnPage(threadID, threadURL, page, threadName, transaction, platformApplicationID, externalID, metadata = {}, extraClassnames = null, subscribers = void 0) {
    const orgID = assertViewerHasSingleOrgForWrite(
      this.viewer,
      "Must specify a groupID when creating a new thread"
    );
    const thread = await ThreadEntity.create(
      {
        id: threadID,
        orgID,
        name: threadName,
        url: threadURL,
        metadata,
        pageContextHash: page.contextHash,
        platformApplicationID,
        extraClassnames,
        ...externalID && { externalID }
      },
      { transaction }
    );
    transaction.afterCommit(async () => {
      const context = await contextWithSession(
        { viewer: this.viewer },
        getSequelize(),
        null,
        null
      );
      const flagsUser = flagsUserFromContext(context);
      await maybeAddEveryOrgMemberAsThreadParticipants(
        this.viewer,
        flagsUser,
        thread.id
      );
      if (context.session.viewer.userID) {
        await new ThreadParticipantMutator(
          context.session.viewer,
          context.loaders
        ).setViewerSubscribed(thread, true);
      }
      if (subscribers && subscribers.length > 0) {
        await addAdditionalSubscribersOnThreadCreation(
          context,
          subscribers,
          thread.id
        );
      }
    });
    return thread;
  }
  async setThreadResolved(threadID, resolved, transaction) {
    const { userID, orgID } = assertViewerHasIdentity(this.viewer);
    const [updateCount] = await ThreadEntity.update(
      {
        resolvedTimestamp: resolved ? Sequelize12.fn("NOW") : null,
        resolverUserID: userID
      },
      { where: { id: threadID, orgID }, transaction }
    );
    return updateCount === 1;
  }
  async setThreadSupportStatus(threadID, supportStatus, transaction) {
    const [updated] = await ThreadEntity.update(
      { supportStatus },
      { where: { id: threadID }, transaction }
    );
    return updated === 1;
  }
  async setThreadName(threadID, name) {
    const [updated] = await ThreadEntity.update(
      { name },
      { where: { id: threadID } }
    );
    return updated === 1;
  }
  async setThreadMetadata(threadID, metadata) {
    const [updated] = await ThreadEntity.update(
      { metadata },
      { where: { id: threadID } }
    );
    return updated === 1;
  }
};

// server/src/entity/page/PageMutator.ts
var PageMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async createPageIfNotExists(pageContext) {
    const orgID = assertViewerHasOrg(this.viewer);
    const [contextHash, contextData] = getPageContextHash(pageContext);
    await PageEntity.bulkCreate(
      [
        {
          orgID,
          contextHash,
          contextData
        }
      ],
      {
        ignoreDuplicates: true
      }
    );
    return contextHash;
  }
  async getPageCreateIfNotExists(pageContext, transaction) {
    const orgID = assertViewerHasSingleOrgForWrite(
      this.viewer,
      "Must specify a groupID when creating a new location"
    );
    const [contextHash, contextData] = getPageContextHash(pageContext);
    const [pageEntity] = await PageEntity.findOrCreate({
      where: {
        orgID,
        contextHash
      },
      defaults: {
        orgID,
        contextHash,
        contextData
      },
      transaction
    });
    return { page: pageEntity, pageContextHash: contextHash };
  }
};

// server/src/entity/thread/new_thread_tasks/publishNewThreadEvents.ts
async function publishNewThreadEvents(location, thread, transaction) {
  const notify = async () => {
    await publishPubSubEvent(
      "page-thread-added-with-location",
      { orgID: thread.orgID },
      { threadID: thread.id, location }
    );
    await publishPubSubEvent(
      "thread-created",
      { threadID: thread.id },
      { threadID: thread.id }
    );
  };
  if (transaction) {
    transaction.afterCommit(notify);
  } else {
    await notify();
  }
}

// server/src/public/routes/platform/threads/CreateThreadHandler.ts
async function CreateThreadHandler(req, res) {
  const {
    id: externalID,
    groupID,
    url: url6,
    name,
    location,
    metadata,
    extraClassnames,
    addSubscribers,
    ...rest
  } = validate.CreateThreadVariables(req.body);
  const _ = rest;
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const app = await ApplicationEntity.findByPk(platformApplicationID);
  if (!app) {
    throw new ApiCallerError("invalid_request");
  }
  const org = await OrgEntity.findOne({
    where: {
      externalID: groupID,
      platformApplicationID
    }
  });
  if (!org) {
    throw new ApiCallerError("group_not_found");
  }
  const viewer = Viewer.createOrgViewer(org.id, platformApplicationID);
  const thread = (
    // We use SERIALIZABLE here because it's needed to ensure the threads and
    // preallocated_thread_ids tables remain consistent, see thread_by_external_id.ts
    await serializableTransactionWithRetries(async (transaction) => {
      const { thread: newThread } = await createThread({
        id: externalID,
        url: url6,
        location,
        name,
        metadata,
        extraClassnames,
        addSubscribers,
        transaction,
        viewer,
        platformApplicationID
      });
      await publishNewThreadEvents(location, newThread, transaction);
      return newThread;
    })
  );
  res.status(200).json({
    success: true,
    message: "Thread created.",
    threadID: thread.externalID
  });
}
var CreateThreadHandler_default = forwardHandlerExceptionsToNext(CreateThreadHandler);
async function createThread({
  platformApplicationID,
  id: externalID,
  url: url6,
  location,
  name,
  metadata,
  extraClassnames,
  addSubscribers,
  transaction,
  viewer,
  ...rest
}) {
  await assertTransactionIsSerializable(transaction);
  const _ = rest;
  if (externalID) {
    validateExternalID(externalID, "id");
    const existingThread = await ThreadEntity.findOne({
      where: {
        externalID,
        platformApplicationID
      },
      transaction
    });
    if (existingThread) {
      throw new ApiCallerError("thread_already_exists");
    }
  }
  const { page } = await new PageMutator(viewer).getPageCreateIfNotExists(
    { data: location, providerID: null },
    transaction
  );
  const threadIDEntity = externalID ? await PreallocatedThreadIDEntity.findOne({
    where: {
      platformApplicationID,
      externalID
    },
    transaction
  }) : void 0;
  const thread = await new ThreadMutator(viewer, null).createThreadOnPage(
    threadIDEntity?.id ?? uuid5(),
    url6,
    page,
    name,
    transaction,
    platformApplicationID,
    externalID ?? null,
    metadata,
    extraClassnames ?? void 0,
    addSubscribers
  );
  return { thread, page };
}

// server/src/public/routes/platform/applications/GetApplicationHandler.ts
import isUUID3 from "validator/lib/isUUID.js";

// server/src/public/routes/platform/applications/util.ts
function emailSettingsToDbData(input, applicationName, existingData) {
  if (!input) {
    return void 0;
  }
  const { name, sender, logoConfig, imageURL } = input;
  const partnerName = name ?? existingData?.partnerName ?? "";
  const emailTemplate = {
    ...existingData,
    partnerName,
    imageURL: imageURL ?? existingData?.imageURL ?? ""
  };
  if (sender) {
    emailTemplate["sender"] = `${partnerName} <${sender}>`;
  } else if (!existingData?.sender) {
    const defaultSenderEmail = createDefaultSenderEmailName(applicationName);
    emailTemplate["sender"] = `${partnerName} <${defaultSenderEmail}@cord.fyi>`;
  }
  if (logoConfig) {
    if ("height" in logoConfig) {
      emailTemplate["logoConfig"] = {
        height: Math.round(logoConfig.height).toString(),
        width: "auto"
      };
    } else if ("width" in logoConfig) {
      emailTemplate["logoConfig"] = {
        width: Math.round(logoConfig.width).toString(),
        height: "auto"
      };
    }
  } else if (!existingData?.logoConfig) {
    emailTemplate["logoConfig"] = {
      width: "140",
      height: "auto"
    };
  }
  return emailTemplate;
}
function customEmailTemplateToAPIData(data, enableEmailNotifications) {
  const emailTemplate = {
    name: data?.partnerName || null,
    imageURL: data?.imageURL || null,
    sender: getEmailInfoFromSenderData(data?.sender)?.emailAddress || null,
    logoConfig: null,
    enableEmailNotifications
  };
  if (data?.logoConfig) {
    emailTemplate["logoConfig"] = data.logoConfig.height === "auto" ? { width: Number(data.logoConfig.width) } : { height: Number(data.logoConfig.height) };
  }
  return emailTemplate;
}

// server/src/public/routes/platform/applications/GetApplicationHandler.ts
async function GetApplicationHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const appID = req.params.appID;
  if (!isUUID3.default(appID)) {
    throw new ApiCallerError("invalid_request", {
      message: "Project ID is invalid"
    });
  }
  const app = await ApplicationEntity.findOne({
    where: { id: appID, customerID }
  });
  if (!app) {
    throw new ApiCallerError("project_not_found", {
      message: `Project ${appID} not found.`
    });
  }
  const result = {
    id: app.id,
    secret: app.sharedSecret,
    name: app.name,
    iconURL: app.iconURL,
    eventWebhookURL: app.eventWebhookURL,
    redirectURI: app.redirectURI,
    emailSettings: customEmailTemplateToAPIData(
      app.customEmailTemplate,
      app.enableEmailNotifications
    ),
    createdTimestamp: app.createdTimestamp
  };
  return res.status(200).json(result);
}
var GetApplicationHandler_default = forwardHandlerExceptionsToNext(GetApplicationHandler);

// server/src/public/routes/platform/orgs/DeletePlatformOrganizationsHandler.ts
async function deleteOrganizationHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.orgID;
  validateExternalID(externalID, "orgID");
  await getSequelize().transaction(async (transaction) => {
    const org = await OrgEntity.findOne({
      where: {
        externalID,
        externalProvider: "platform" /* PLATFORM */,
        platformApplicationID
      },
      transaction
    });
    if (!org) {
      throw new ApiCallerError("group_not_found");
    }
    await org.destroy();
  });
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully deleted group ${externalID}`
  });
}
var DeletePlatformOrganizationsHandler_default = forwardHandlerExceptionsToNext(deleteOrganizationHandler);

// server/src/public/routes/platform/applications/DeleteApplicationHandler.ts
import isUUID4 from "validator/lib/isUUID.js";
async function DeleteApplicationHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const { secret, ...rest } = validate.DeleteApplicationVariables(req.body);
  const _ = rest;
  const appID = req.params.appID;
  if (!isUUID4.default(appID)) {
    throw new ApiCallerError("invalid_request", {
      message: "Project ID is invalid"
    });
  }
  const app = await ApplicationEntity.findOne({
    where: { id: appID, customerID, sharedSecret: secret }
  });
  if (!app) {
    throw new ApiCallerError("project_not_found", {
      message: `Project ${appID} not found.`
    });
  }
  await app.destroy();
  return res.status(200).json({
    success: true,
    message: `\u{1F480} You successfully deleted project ${req.params.appID}`
  });
}
var DeleteApplicationHandler_default = forwardHandlerExceptionsToNext(DeleteApplicationHandler);

// server/src/public/routes/platform/applications/UpdateApplicationHandler.ts
import isUUID5 from "validator/lib/isUUID.js";

// server/src/util/safeFetch.ts
import nodeFetch from "node-fetch";

// server/src/util/third_party/ssrf-req-filter.mjs
import http from "http";
import https from "https";
import ipaddr from "ipaddr.js";
var checkIp = (ip) => {
  if (!ipaddr.isValid(ip)) {
    return true;
  }
  try {
    const addr = ipaddr.parse(ip);
    const range = addr.range();
    if (range !== "unicast") {
      return false;
    }
  } catch (err) {
    return false;
  }
  return true;
};
var ACTIVE = Symbol("active");
var requestFilterHandler = (agent) => {
  if (agent[ACTIVE]) {
    return agent;
  }
  agent[ACTIVE] = true;
  const { createConnection } = agent;
  agent.createConnection = function(options, func) {
    const { host: address } = options;
    if (!checkIp(address)) {
      throw new Error(`Call to ${address} is blocked.`);
    }
    const socket = createConnection.call(this, options, func);
    socket.on("lookup", (error, address2) => {
      if (error || checkIp(address2)) {
        return false;
      }
      return socket.destroy(new Error(`Call to ${address2} is blocked.`));
    });
    return socket;
  };
  return agent;
};
var manageConnection = (url6) => {
  const httpAgent = new http.Agent();
  const httpsAgent = new https.Agent();
  const agent = url6.startsWith("https") ? httpsAgent : httpAgent;
  return requestFilterHandler(agent);
};

// server/src/util/safeFetch.ts
async function safeFetch(url6, init3) {
  return await nodeFetch(url6, { ...init3, agent: manageConnection(url6) });
}

// server/src/webhook/webhook.ts
import { createHmac as createHmac2 } from "crypto";
import jsonStableStringify6 from "fast-json-stable-stringify";

// server/src/public/routes/platform/threads/GetThreadHandler.ts
import { Op as Op16, QueryTypes as QueryTypes16 } from "sequelize";

// server/src/presence/typing.ts
async function publishUpdate(threadID) {
  const users = await getUsersTyping(threadID);
  return await publishPubSubEvent(
    "thread-typing-users-updated",
    { threadID },
    { users }
  );
}
function makeSetKey(threadID) {
  return `typing-${threadID}`;
}
var timeouts = /* @__PURE__ */ new Map();
function makeUserThreadKey(threadID, userID) {
  return `typing-user-${userID}-${threadID}`;
}
function setUserTyping(logger, threadID, userID, typing) {
  if (typing) {
    return add(logger, threadID, userID);
  } else {
    return remove(threadID, userID);
  }
}
async function add(logger, threadID, userID) {
  clearPreviousTimeout(threadID, userID);
  const newTimestamp = Date.now();
  const setKey = makeSetKey(threadID);
  const errsAndVals = await getRedis().multi().zscore(setKey, userID).zadd(setKey, newTimestamp, userID).expire(setKey, TYPING_TIMEOUT_TTL_SECONDS).exec();
  if (!multiOperationSucceeded(errsAndVals, "Failed to mark user as typing")) {
    return;
  }
  timeouts.set(
    makeUserThreadKey(threadID, userID),
    setTimeoutAsync(
      () => notifyIfNotTyping(threadID, userID).catch(
        logger.exceptionLogger(
          "Failed to notify about expired typing status"
        )
      ),
      TYPING_TIMEOUT_TTL_SECONDS * 1e3 + 100
    )
  );
  const previousUserTimestamp = errsAndVals[0]?.[1];
  if (!previousUserTimestamp || Number(previousUserTimestamp) < newTimestamp - TYPING_TIMEOUT_TTL_SECONDS * 1e3) {
    return await publishUpdate(threadID);
  }
}
async function getUsersTyping(threadID) {
  const setKey = makeSetKey(threadID);
  const cutoffTime = Date.now() - TYPING_TIMEOUT_TTL_SECONDS * 1e3;
  return await getRedis().zrangebyscore(setKey, cutoffTime, "+inf");
}
async function remove(threadID, userID) {
  const now = Date.now();
  const setKey = makeSetKey(threadID);
  const errsAndVals = await getRedis().multi().zscore(setKey, userID).zrem(setKey, userID).exec();
  if (!multiOperationSucceeded(
    errsAndVals,
    "Failed to remove user from typing set"
  )) {
    return;
  }
  const previousUserTimestamp = errsAndVals[0]?.[1];
  if (!!previousUserTimestamp && Number(previousUserTimestamp) > now - TYPING_TIMEOUT_TTL_SECONDS * 1e3) {
    clearPreviousTimeout(threadID, userID);
    return await publishUpdate(threadID);
  }
  return;
}
function clearPreviousTimeout(threadID, userID) {
  const userKey = makeUserThreadKey(threadID, userID);
  const prevTimeoutID = timeouts.get(userKey);
  if (prevTimeoutID !== void 0) {
    clearTimeout(prevTimeoutID);
    timeouts.delete(userKey);
  }
}
async function notifyIfNotTyping(threadID, userID) {
  const setKey = makeSetKey(threadID);
  const now = Date.now();
  const latestUserTimestamp = await getRedis().zscore(setKey, userID);
  if (latestUserTimestamp === null || Number(latestUserTimestamp) < now - TYPING_TIMEOUT_TTL_SECONDS * 1e3) {
    return await publishUpdate(threadID);
  }
}
async function removeAllTypingUsers(threadID) {
  const setKey = makeSetKey(threadID);
  await getRedis().del(setKey);
  return await publishUpdate(threadID);
}

// server/src/public/routes/platform/threads/util/getCoreThreadData.ts
async function getCoreThreadData(loaders, thread) {
  const [
    org,
    total,
    userMessages,
    actionMessages,
    deletedMessages,
    repliers,
    actionMessageRepliers,
    participants,
    subscribers,
    mentioned,
    typing,
    location
  ] = await Promise.all([
    OrgEntity.findByPk(thread.orgID),
    MessageEntity.count({ where: { threadID: thread.id } }),
    loadUserMessagesCount(thread.id),
    loadActionMessagesCount(thread.id),
    loadDeletedMessagesCount(thread.id),
    loadRepliers(loaders.threadLoader, thread.id),
    loadActionMessageRepliers(loaders.threadLoader, thread.id),
    loadParticipants(thread.id),
    loadSubscribers(thread.id),
    loadMentioned(thread.id),
    loadTypingUsers(thread.id),
    getThreadLocation(thread)
  ]);
  if (!org) {
    throw new Error("Unable to find thread org");
  }
  return {
    id: thread.externalID,
    organizationID: org.externalID,
    groupID: org.externalID,
    total,
    userMessages,
    actionMessages,
    deletedMessages,
    resolved: !!thread.resolvedTimestamp,
    resolvedTimestamp: thread.resolvedTimestamp,
    participants,
    repliers,
    actionMessageRepliers,
    subscribers,
    mentioned,
    typing,
    name: thread.name,
    url: thread.url,
    location,
    metadata: thread.metadata,
    extraClassnames: thread.extraClassnames
  };
}

// server/src/public/routes/platform/threads/GetThreadHandler.ts
async function loadTypingUsers(threadID) {
  const typingUserIDs = await getUsersTyping(threadID);
  const users = await UserEntity.findAll({
    where: { id: typingUserIDs }
  });
  return users.map((u) => u.externalID);
}
async function loadUserMessagesCount(threadID) {
  return await MessageEntity.count({
    where: { threadID, type: "user_message", deletedTimestamp: null }
  });
}
async function loadActionMessagesCount(threadID) {
  return await MessageEntity.count({
    where: { threadID, type: "action_message", deletedTimestamp: null }
  });
}
async function loadDeletedMessagesCount(threadID) {
  return await MessageEntity.count({
    where: { threadID, deletedTimestamp: { [Op16.not]: null } }
  });
}
async function loadParticipants(threadID) {
  const participants = await ThreadParticipantEntity.findAll({
    where: { threadID }
  });
  const users = await UserEntity.findAll({
    where: { id: participants.map((p) => p.userID) }
  });
  const userMap = /* @__PURE__ */ new Map();
  users.forEach((u) => userMap.set(u.id, u));
  return participants.map((p) => {
    const u = userMap.get(p.userID);
    return {
      lastSeenTimestamp: p.lastSeenTimestamp,
      userID: u ? u.externalID ?? externalizeID(u.id) : null,
      displayName: u?.name ? userDisplayName({ name: u.name, screenName: u.screenName }) : null
    };
  });
}
async function loadSubscribers(threadID) {
  const subscribers = await getSequelize().query(
    `
    SELECT "externalID" FROM cord.users u
    LEFT JOIN cord.thread_participants as tp on tp."userID"=u.id
    WHERE tp."threadID"=$1
    AND tp.subscribed IS TRUE;
  `,
    { bind: [threadID], type: QueryTypes16.SELECT, model: UserEntity }
  );
  return subscribers.map((u) => u.externalID);
}
async function loadMentioned(threadID) {
  const mentioned = await getSequelize().query(
    `
      SELECT DISTINCT u."externalID" FROM users u
      INNER JOIN message_mentions mm ON (u.id = mm."userID")
      INNER JOIN messages m ON (mm."messageID" = m.id)
      WHERE m."threadID" = $1
    `,
    {
      bind: [threadID],
      type: QueryTypes16.SELECT
    }
  );
  return mentioned.map((u) => u.externalID);
}
async function loadRepliers(threadLoader, threadID) {
  const replyingUsers = await threadLoader.loadReplyingUserIDsNoOrgCheck(threadID);
  const users = await UserEntity.findAll({
    where: { id: replyingUsers }
  });
  return users.map((user) => user.externalID);
}
async function loadActionMessageRepliers(threadLoader, threadID) {
  const replyingUsers = await threadLoader.loadActionMessageReplyingUserIDsNoOrgCheck(threadID);
  const users = await UserEntity.findAll({
    where: { id: replyingUsers }
  });
  return users.map((user) => user.externalID);
}
async function loadThread(platformApplicationID, externalID) {
  if (!externalID) {
    throw new ApiCallerError("thread_not_found");
  }
  const where = { platformApplicationID };
  if (isExternalizedID(externalID)) {
    const internalID = extractInternalID(externalID);
    if (!internalID) {
      throw new ApiCallerError("invalid_request", {
        message: `${externalID} is not a valid thread ID`
      });
    }
    where.id = internalID;
  } else {
    where.externalID = externalID;
  }
  return await ThreadEntity.findOne({ where });
}
async function getThreadLocation(thread) {
  const page = await PageEntity.findOne({
    where: { orgID: thread.orgID, contextHash: thread.pageContextHash }
  });
  if (!page) {
    throw new Error("Unable to find thread location");
  }
  return page.contextData;
}
async function getThreadHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const thread = await loadThread(platformApplicationID, req.params.threadID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  const loaders = await getNewLoaders(
    Viewer.createOrgViewer(thread.orgID, thread.platformApplicationID)
  );
  const result = await getCoreThreadData(loaders, thread);
  return res.status(200).json(result);
}
var GetThreadHandler_default = forwardHandlerExceptionsToNext(getThreadHandler);

// server/src/public/mutations/notifications/utils.ts
var deletedCounter = Counter2({
  name: "NotificationEntityDeleted",
  help: "Count of NotificationEntity deleted",
  labelNames: ["appID"]
});
function whereAggregatedNotificationEntity(notif) {
  return notif.aggregationKey === null ? { id: notif.id } : {
    aggregationKey: notif.aggregationKey,
    recipientID: notif.recipientID
  };
}

// server/src/public/routes/platform/messages/getMessageAttachments.ts
import * as base64 from "js-base64";
async function getMessageAttachments(loaders, message) {
  const attachments = await loaders.messageAttachmentLoader.loadAttachmentsForMessage(message.id);
  const fileIDs = attachments.map((a) => {
    if (a instanceof MessageAttachmentEntity) {
      if ("fileID" in a.data) {
        return a.data.fileID;
      } else if ("screenshotFileID" in a.data) {
        return a.data.screenshotFileID;
      }
    }
    return void 0;
  }).filter(isDefined);
  const files = await loaders.fileLoader.loadFiles(fileIDs);
  const filesByID = /* @__PURE__ */ new Map();
  for (const file of files) {
    filesByID.set(file.id, file);
  }
  return (await Promise.all(
    attachments.map(async (a) => {
      if (a instanceof MessageAttachmentEntity) {
        switch (a.type) {
          case "file" /* FILE */:
            return await makeFile(
              filesByID.get(a.data.fileID)
            );
          case "annotation" /* ANNOTATION */: {
            const data = a.data;
            if (!data.screenshotFileID) {
              return void 0;
            }
            return await makeAnnotation(
              filesByID.get(data.screenshotFileID),
              data
            );
          }
          case "screenshot" /* SCREENSHOT */: {
            const data = a.data;
            if (!data.screenshotFileID) {
              return void 0;
            }
            return await makeScreenshot(filesByID.get(data.screenshotFileID));
          }
        }
      } else {
        return makeLinkPreview(a);
      }
    })
  )).filter(isDefined);
}
async function makeFile(f) {
  if (!f) {
    return void 0;
  }
  return {
    id: externalizeID(f.id),
    type: "file",
    name: f.name,
    url: await f.getSignedDownloadURL(),
    mimeType: f.mimeType,
    size: f.size,
    uploadStatus: f.uploadStatus
  };
}
async function makeScreenshot(screenshot) {
  if (!screenshot) {
    return void 0;
  }
  return {
    type: "screenshot",
    screenshot: {
      id: externalizeID(screenshot.id),
      name: "annotation",
      url: await screenshot.getSignedDownloadURL(),
      mimeType: screenshot.mimeType,
      size: screenshot.size,
      uploadStatus: screenshot.uploadStatus
    }
  };
}
async function makeAnnotation(screenshot, a) {
  if (!screenshot) {
    return void 0;
  }
  return {
    type: "annotation",
    screenshot: {
      id: externalizeID(screenshot.id),
      name: "annotation",
      url: await screenshot.getSignedDownloadURL(),
      mimeType: screenshot.mimeType,
      size: screenshot.size,
      uploadStatus: screenshot.uploadStatus
    },
    locationData: a.location ? base64.encode(JSON.stringify(a.location)) : null,
    customData: a.customLocation ? {
      location: a.customLocation,
      coordsRelativeToTarget: a.coordsRelativeToTarget,
      // always set when custom locations used
      label: a.customLabel ?? null
    } : null,
    textContent: a.location?.highlightedTextConfig?.textToDisplay ?? a.customHighlightedTextConfig?.textToDisplay ?? null
  };
}
function makeLinkPreview(a) {
  return {
    id: a.id,
    type: "link_preview",
    url: a.url,
    imageURL: a.img,
    title: a.title,
    description: a.description
  };
}

// server/src/public/routes/platform/messages/util.ts
import { unique as unique10 } from "radash";
var import_types20 = __toESM(require_cjs(), 1);
async function loadThreadMessage(threadID, externalMessageID) {
  if (!externalMessageID) {
    throw new ApiCallerError("message_not_found");
  }
  const where = { threadID };
  if (isExternalizedID(externalMessageID)) {
    const internalMessageID = extractInternalID(externalMessageID);
    if (!internalMessageID) {
      throw new ApiCallerError("invalid_request", {
        message: "message ID is not valid"
      });
    }
    where.id = internalMessageID;
  } else {
    where.externalID = externalMessageID;
  }
  return await MessageEntity.findOne({ where });
}
async function externalizeContent(content, platformApplicationID) {
  return await Promise.all(
    content.map(async (node) => {
      if (node.type === import_types20.MessageNodeType.MENTION) {
        const user = await UserEntity.findByPk(node.user.id);
        const id = user?.platformApplicationID === platformApplicationID && user?.externalID ? user.externalID : externalizeID(node.user.id);
        return {
          ...node,
          user: { id }
        };
      } else if ("children" in node) {
        return {
          ...node,
          children: await externalizeContent(
            node.children,
            platformApplicationID
          )
        };
      }
      return node;
    })
  );
}
function forceExternalizeContent(content) {
  return content.map((node) => {
    if (node.type === import_types20.MessageNodeType.MENTION) {
      return {
        ...node,
        user: { id: externalizeID(node.user.id) }
      };
    } else if ("children" in node) {
      return {
        ...node,
        children: forceExternalizeContent(node.children)
      };
    }
    return node;
  });
}
async function internalizeContent(content, platformApplicationID, orgID) {
  return await Promise.all(
    content.map(async (node) => {
      if (node.type === import_types20.MessageNodeType.MENTION) {
        let user = await UserEntity.findOne({
          where: { platformApplicationID, externalID: node.user.id }
        });
        if (!user && isExternalizedID(node.user.id)) {
          user = await UserEntity.findOne({
            where: { id: extractInternalID(node.user.id) }
          });
        }
        if (!user) {
          const slackLinking = await LinkedOrgsEntity.findOne({
            where: {
              sourceOrgID: orgID
            }
          });
          if (slackLinking) {
            const [slackUsers, slackOrgMembers] = await Promise.all([
              UserEntity.findAll({
                where: { externalID: node.user.id, externalProvider: "slack" }
              }),
              OrgMembersEntity.findAll({
                where: { orgID: slackLinking.linkedOrgID }
              })
            ]);
            const slackOrgMemberUserIDs = slackOrgMembers.map(
              (om) => om.userID
            );
            for (const slackUser of slackUsers) {
              if (slackOrgMemberUserIDs.includes(slackUser.id)) {
                user = slackUser;
              }
            }
          }
        }
        if (!user) {
          throw new ApiCallerError("user_not_found", {
            message: "Could not find mentioned user with ID " + node.user.id
          });
        }
        return {
          ...node,
          user: { id: user.id }
        };
      } else if ("children" in node) {
        return {
          ...node,
          children: await internalizeContent(
            node.children,
            platformApplicationID,
            orgID
          )
        };
      }
      return node;
    })
  );
}
async function buildMessageVariablesReactions(loaders, internalMessageID) {
  const messageReactions = await loaders.messageReactionLoader.loadReactionsForMessageNoOrgCheck(
    internalMessageID
  );
  const usersWithReactions = unique10(
    messageReactions.map((reaction) => reaction.userID)
  );
  const reactionUsers = await loaders.userLoader.loadUsers(usersWithReactions);
  const internalIDtoExternalID = /* @__PURE__ */ new Map();
  for (const reactionUser of reactionUsers) {
    if (!internalIDtoExternalID.has(reactionUser.id)) {
      internalIDtoExternalID.set(reactionUser.id, reactionUser.externalID);
    }
  }
  return messageReactions.map((messageReaction) => {
    return {
      reaction: messageReaction.unicodeReaction,
      userID: internalIDtoExternalID.get(messageReaction.userID),
      timestamp: new Date(messageReaction.timestamp)
    };
  });
}
async function getValidExternalToInternalReactionUsers(context, externalReactionUserIDs, org) {
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  const internalReactionUsers = await Promise.all(
    externalReactionUserIDs.map(async (externalReactionUserID) => {
      const user = await context.loaders.userLoader.loadUserByExternalID(
        platformApplicationID,
        externalReactionUserID
      );
      if (user) {
        return user;
      } else {
        throw new ApiCallerError("user_not_found", {
          message: `User with ID ${externalReactionUserID} does not exist.`
        });
      }
    })
  );
  const externalIDtoInternalID = /* @__PURE__ */ new Map();
  for (const reactionUser of internalReactionUsers) {
    if (!externalIDtoInternalID.has(reactionUser.externalID)) {
      externalIDtoInternalID.set(reactionUser.externalID, reactionUser);
    }
  }
  await Promise.all(
    internalReactionUsers.map(async (internalReactionUser) => {
      const orgMembership = await context.loaders.orgMembersLoader.loadUserOrgMembership(
        internalReactionUser.id,
        org.id
      );
      if (!orgMembership) {
        throw new ApiCallerError("user_not_in_organization", {
          message: `User with ID '${internalReactionUser.externalID}' does not belong in organization ${org.externalID}.`
        });
      }
    })
  );
  return externalIDtoInternalID;
}

// server/src/public/routes/platform/messages/getCoreMessageData.ts
async function getCoreMessageData(loaders, message, thread) {
  const [author, org, content, attachments, reactions, threadParticipants] = await Promise.all([
    loaders.userLoader.loadUser(message.sourceID),
    loaders.orgLoader.loadOrg(message.orgID),
    externalizeContent(message.content, thread.platformApplicationID),
    getMessageAttachments(loaders, message),
    buildMessageVariablesReactions(loaders, message.id),
    loaders.threadParticipantLoader.loadForThreadIDNoOrgCheck(
      message.threadID
    )
  ]);
  const seenByUserIDs = threadParticipants.filter((participant) => {
    if (participant.lastSeenTimestamp === null) {
      return false;
    }
    const timestamp = message.lastUpdatedTimestamp ?? message.timestamp;
    return timestamp <= participant.lastSeenTimestamp;
  }).map((participant) => participant.userID);
  const seenByUsers = await loaders.userLoader.loadUsers(seenByUserIDs);
  return {
    id: message.externalID,
    // If we didn't find the org, something is broken, so at least give
    // ourselves a breadcrumb
    organizationID: org?.externalID ?? externalizeID(message.orgID),
    groupID: org?.externalID ?? externalizeID(message.orgID),
    threadID: thread.externalID,
    // If we didn't find the user, something is broken, so at least give
    // ourselves a breadcrumb to debug with
    // We're making the strategic choice here to give the end users a more
    // coherent name that what we've used internally. We may regret this
    // if we find ourselves confused because the same thing has multiple
    // names.
    authorID: author?.externalID ?? externalizeID(message.sourceID),
    url: message.url,
    content,
    plaintext: convertStructuredMessageToText(message.content),
    // Strategically renamed to be more intuitive to devs
    createdTimestamp: message.timestamp,
    // Strategically renamed to be more intuitive to devs
    updatedTimestamp: message.lastUpdatedTimestamp,
    deletedTimestamp: message.deletedTimestamp,
    type: message.type,
    iconURL: message.iconURL,
    translationKey: message.translationKey,
    metadata: message.metadata,
    seenBy: seenByUsers.map((user) => user.externalID),
    extraClassnames: message.extraClassnames,
    skipLinkPreviews: message.skipLinkPreviews,
    attachments,
    reactions
  };
}

// server/src/notifications/convert.ts
function gqlNotificationHeaderToNotificationVariables(gqlHeader) {
  if ("user" in gqlHeader) {
    return {
      type: "user",
      userID: gqlHeader.user.externalID,
      user: {
        id: gqlHeader.user.externalID,
        name: gqlHeader.user.name,
        shortName: gqlHeader.user.screenName,
        displayName: userDisplayName(gqlHeader.user),
        secondaryDisplayName: userFullName(gqlHeader.user),
        profilePictureURL: gqlHeader.user.profilePictureURL,
        metadata: gqlHeader.user.metadata
      }
    };
  } else if ("text" in gqlHeader) {
    return { type: "text", text: gqlHeader.text, bold: gqlHeader.bold };
  } else {
    const _ = gqlHeader;
    return { type: "text", text: "", bold: false };
  }
}
async function gqlNotificationAttachmentToNotificationVariables(loaders, gqlAttachment) {
  if (!gqlAttachment) {
    return null;
  } else if ("message" in gqlAttachment) {
    const message = gqlAttachment.message;
    const thread = await ThreadEntity.findByPk(message.threadID);
    if (!thread) {
      throw new Error(
        `Could not find thread ${message.threadID} for message ${message.id}`
      );
    }
    const coreMessageData = await getCoreMessageData(loaders, message, thread);
    return {
      type: "message",
      messageID: message.externalID,
      threadID: thread.externalID,
      message: coreMessageData
    };
  } else if ("url" in gqlAttachment) {
    return {
      type: "url",
      url: gqlAttachment.url
    };
  } else if ("thread" in gqlAttachment) {
    const thread = gqlAttachment.thread;
    const threadEntity = await ThreadEntity.findByPk(thread.id);
    if (!threadEntity) {
      throw new Error(`Could not find thread ${thread.id}`);
    }
    const coreThreadData = await getCoreThreadData(loaders, thread);
    return {
      type: "thread",
      thread: coreThreadData
    };
  } else {
    const _ = gqlAttachment;
    return null;
  }
}
function convertGqlNotificationHeaderTranslation(gqlNotif) {
  if (!gqlNotif.headerTranslationKey) {
    return null;
  }
  if (!gqlNotif.headerSimpleTranslationParams) {
    throw new Error("Got notification with translation key but no parameters");
  }
  const parameters = {
    ...gqlNotif.headerSimpleTranslationParams,
    senders: gqlNotif.senders.map((sender) => ({
      id: sender.externalID,
      name: sender.name,
      shortName: sender.screenName,
      displayName: userDisplayName(sender),
      secondaryDisplayName: userFullName(sender),
      profilePictureURL: sender.profilePictureURL,
      metadata: sender.metadata
    }))
  };
  return {
    key: gqlNotif.headerTranslationKey,
    parameters
  };
}
async function gqlNotificationToNotificationVariables(loaders, gqlNotif) {
  return {
    id: gqlNotif.externalID,
    senderUserIDs: gqlNotif.senders.map((u) => u.externalID),
    iconUrl: gqlNotif.iconUrl ?? null,
    header: gqlNotif.header.map(gqlNotificationHeaderToNotificationVariables),
    headerTranslation: convertGqlNotificationHeaderTranslation(gqlNotif),
    attachment: await gqlNotificationAttachmentToNotificationVariables(
      loaders,
      gqlNotif.attachment
    ),
    readStatus: gqlNotif.readStatus,
    timestamp: typeof gqlNotif.timestamp === "string" ? new Date(gqlNotif.timestamp) : gqlNotif.timestamp,
    extraClassnames: gqlNotif.extraClassnames ?? null,
    metadata: gqlNotif.metadata
  };
}

// server/src/util/createViewerAndContext.ts
async function createViewerAndContext(platformApplicationID, user, platformType) {
  const arbitraryOrgMembership = await OrgMembersEntity.findOne({
    where: { userID: user.id }
  });
  if (!arbitraryOrgMembership) {
    switch (platformType) {
      case "api":
        throw new ApiCallerError("user_not_in_organization", {
          message: "Could not find any active org for user"
        });
      case "webhook":
        throw new Error("Could not find any active org for recipient user");
      default: {
        const _ = platformType;
        throw new Error("Invalid platform type: " + platformType);
      }
    }
  }
  const arbitraryOrg = await OrgEntity.findByPk(
    arbitraryOrgMembership.orgID
  );
  const viewer = await Viewer.createLoggedInPlatformViewer({
    user,
    org: arbitraryOrg
  });
  const context = await contextWithSession(
    { viewer },
    getSequelize(),
    null,
    null
  );
  return context;
}

// server/src/asyncTier/submitAsync.ts
function submitAsync(name, data, options) {
  return getBoss().send(name, data, options ?? {});
}

// server/src/webhook/webhook.ts
function assemblePayload(type, appID, timestamp, eventBody) {
  return {
    type,
    applicationID: appID,
    projectID: appID,
    timestamp,
    event: eventBody,
    ...eventBody
    // TODO: remove when we're sure consuming code has been updated
  };
}
async function publishEventToWebhook(app, event) {
  const webhooks = [];
  if (app.eventWebhookURL && app.eventWebhookSubscriptions?.includes(event.type)) {
    webhooks.push(app.eventWebhookURL);
  }
  const applicationWebhooks = await ApplicationWebhookEntity.findAll({
    where: { platformApplicationID: app.id }
  });
  webhooks.push(
    ...applicationWebhooks.filter(
      (entity) => entity.eventWebhookURL && entity.eventWebhookSubscriptions?.includes(event.type)
    ).map((entity) => entity.eventWebhookURL)
  );
  if (webhooks.length === 0) {
    return;
  }
  const handler = handlers[event.type];
  const payload = await handler(event);
  await postEvent(app, webhooks, event.type, payload);
}
function authenticationHeader(eventType, app, event) {
  const timestamp = Date.now().toString();
  const payloadString = jsonStableStringify6(
    assemblePayload(eventType, app.id, timestamp, event)
  );
  const hmac = createHmac2("sha256", app.sharedSecret);
  hmac.update(timestamp + ":" + payloadString);
  const signature = hmac.digest("base64");
  return [payloadString, timestamp, signature];
}
async function postEvent(app, webhookURLs, eventType, event) {
  if (webhookURLs.length === 0) {
    return;
  }
  const [payloadString, timestamp, signature] = authenticationHeader(
    eventType,
    app,
    event
  );
  await Promise.all(
    webhookURLs.map(async (url6) => {
      void submitAsync("notifyWebhook", {
        retryCount: 0,
        eventType,
        appID: app.id,
        url: url6,
        timestamp,
        signature,
        payload: payloadString,
        event
      });
    })
  );
}
var handlers = {
  "thread-message-added": handleThreadMessageAddedEvent,
  "notification-created": handleNotificationCreatedEvent,
  "url-verification": handleVerifyWebhookURL
};
async function handleVerifyWebhookURL(_event) {
  return {
    message: "Please respond with a HTTP 200 status code."
  };
}
async function handleThreadMessageAddedEvent(event) {
  const [message, thread, notifications] = await Promise.all([
    MessageEntity.findByPk(event.messageID),
    ThreadEntity.findByPk(event.threadID),
    NotificationEntity.findAll({ where: { messageID: event.messageID } })
  ]);
  if (!message || !thread) {
    throw new Error(
      "Unable to find message and/or thread when creating webhook payload"
    );
  }
  const notifiedUserIntIDs = notifications.map((n) => n.recipientID);
  const loaders = await getNewLoaders(
    Viewer.createOrgViewer(thread.orgID, thread.platformApplicationID)
  );
  const [
    users,
    org,
    repliers,
    actionMessageRepliers,
    participants,
    subscribers,
    mentioned,
    typing,
    totalThreadMessages,
    userThreadMessages,
    actionThreadMessages,
    deletedThreadMessages,
    location,
    coreMessageData
  ] = await Promise.all([
    UserEntity.findAll({
      where: { id: [message.sourceID, ...notifiedUserIntIDs] }
    }),
    OrgEntity.findByPk(thread.orgID),
    loadRepliers(loaders.threadLoader, thread.id),
    loadActionMessageRepliers(loaders.threadLoader, thread.id),
    loadParticipants(thread.id),
    loadSubscribers(thread.id),
    loadMentioned(thread.id),
    loadTypingUsers(thread.id),
    MessageEntity.count({ where: { threadID: thread.id } }),
    loadUserMessagesCount(thread.id),
    loadActionMessagesCount(thread.id),
    loadDeletedMessagesCount(thread.id),
    getThreadLocation(thread),
    getCoreMessageData(loaders, message, thread)
  ]);
  if (!org) {
    throw new Error("Unable to find org when creating webhook payload");
  }
  const externalUserInfo = users.reduce(
    (obj, u) => {
      obj[u.id] = {
        id: u.externalID,
        metadata: u.metadata,
        name: u.name,
        shortName: u.screenName,
        displayName: userDisplayName(u),
        secondaryDisplayName: userFullName(u),
        profilePictureURL: u.profilePictureURL
      };
      return obj;
    },
    {}
  );
  const usersToNotifyInfo = notifications.map((n) => ({
    replyActions: n.replyActions,
    ...externalUserInfo[n.recipientID]
  }));
  return {
    // TODO: deprecate this first chunk (see comment on WebhookPayloads interface)
    messageID: message.externalID,
    threadID: thread.externalID,
    orgID: org.externalID,
    organizationID: org.externalID,
    groupID: org.externalID,
    applicationID: message.platformApplicationID,
    projectID: message.platformApplicationID,
    author: externalUserInfo[message.sourceID],
    content: message.content,
    plaintext: convertStructuredMessageToText(message.content),
    url: message.url ?? thread.url,
    messageType: message.type,
    metadata: message.metadata,
    // New format:
    usersToNotify: usersToNotifyInfo,
    message: {
      author: externalUserInfo[message.sourceID],
      ...coreMessageData
    },
    thread: {
      id: thread.externalID,
      organizationID: org.externalID,
      groupID: org.externalID,
      name: thread.name,
      metadata: thread.metadata,
      location,
      total: totalThreadMessages,
      userMessages: userThreadMessages,
      actionMessages: actionThreadMessages,
      deletedMessages: deletedThreadMessages,
      resolved: !!thread.resolvedTimestamp,
      resolvedTimestamp: thread.resolvedTimestamp,
      participants,
      subscribers,
      mentioned,
      repliers,
      actionMessageRepliers,
      typing,
      url: thread.url,
      extraClassnames: thread.extraClassnames
    }
  };
}
async function handleNotificationCreatedEvent(event) {
  const notif = await NotificationEntity.findByPk(event.notificationID);
  if (!notif) {
    throw new Error(
      `Unable to find notification when creating webhook payload. notificationID: ${event.notificationID}, userID: ${event.userID}`
    );
  }
  const platformApplicationID = notif.platformApplicationID;
  const user = await UserEntity.findOne({
    where: { platformApplicationID, id: event.userID }
  });
  if (!user) {
    throw new Error(
      "Unable to find recipient user when creating webhook payload"
    );
  }
  const context = await createViewerAndContext(
    platformApplicationID,
    user,
    "webhook"
  );
  const aggregateEntities = await NotificationEntity.findAll({
    where: whereAggregatedNotificationEntity(notif)
  });
  const gqlNotif = await buildNotification(context, aggregateEntities);
  if (!gqlNotif) {
    throw new Error("No notification found when creating webhook payload");
  }
  const notifVariables = await gqlNotificationToNotificationVariables(
    context.loaders,
    gqlNotif
  );
  return {
    recipientUserID: user.externalID,
    ...notifVariables
  };
}

// server/src/webhook/verifyWebhookURL.ts
async function verifyWebhookURL(app, url6) {
  const [payloadString, timestamp, signature] = authenticationHeader(
    "url-verification",
    app,
    await handleVerifyWebhookURL({ type: "url-verification" })
  );
  const timeLimit = 3e3;
  return await new Promise((resolve2, reject) => {
    void (async () => {
      const controller = new AbortController();
      const timeout = setTimeout(() => {
        controller.abort();
      }, timeLimit);
      try {
        const response = await safeFetch(url6, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "X-Cord-Timestamp": timestamp,
            "X-Cord-Signature": signature
          },
          body: payloadString,
          signal: controller.signal
        });
        if (response.status === 200) {
          clearTimeout(timeout);
          resolve2({ verified: true, message: null });
        } else {
          clearTimeout(timeout);
          reject({
            verified: false,
            code: response.status,
            message: `Request to '${url6}' failed with status ${response.status} but status 200 expected.`
          });
        }
      } catch (error) {
        clearTimeout(timeout);
        if (error.name === "AbortError") {
          reject({
            verified: false,
            code: 408,
            message: `URL verification aborted: no response from '${url6}' within 3 seconds.`
          });
        } else {
          reject({
            verified: false,
            code: 404,
            message: `Cannot verify webhook URL '${url6}'.`
          });
        }
      }
    })();
  });
}

// server/src/public/routes/platform/applications/UpdateApplicationHandler.ts
async function UpdateApplicationHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const appID = req.params.appID;
  if (!isUUID5.default(appID)) {
    throw new ApiCallerError("invalid_request", {
      message: "Project ID is invalid"
    });
  }
  const app = await ApplicationEntity.findOne({
    where: { id: appID, customerID }
  });
  if (!app) {
    throw new ApiCallerError("project_not_found", {
      message: `Project ${appID} not found.`
    });
  }
  const {
    name,
    iconURL,
    eventWebhookURL,
    redirectURI,
    emailSettings,
    ...rest
  } = validate.UpdateApplicationVariables(req.body);
  const _ = rest;
  if (eventWebhookURL && eventWebhookURL !== app.eventWebhookURL) {
    try {
      await verifyWebhookURL(app, eventWebhookURL);
    } catch (e) {
      throw new ApiCallerError("webhook_url_not_verified", {
        message: `${e.message} For more information see: https://docs.cord.com/reference/events-webhook/events/url-verification`
      });
    }
  }
  let updatedCustomEmailTemplate;
  if (emailSettings) {
    updatedCustomEmailTemplate = emailSettingsToDbData(
      emailSettings,
      app.name,
      app.customEmailTemplate
    );
  }
  await app.update({
    name,
    iconURL,
    eventWebhookURL,
    redirectURI,
    customEmailTemplate: updatedCustomEmailTemplate,
    enableEmailNotifications: emailSettings?.enableEmailNotifications ?? app.enableEmailNotifications
  });
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully updated project ${appID}`
  });
}
var UpdateApplicationHandler_default = forwardHandlerExceptionsToNext(UpdateApplicationHandler);

// server/src/public/routes/platform/applications/ListApplicationsHandler.ts
async function ListApplicationsHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const apps = await ApplicationEntity.findAll({
    where: {
      customerID
    }
  });
  const result = apps.map((app) => {
    return {
      id: app.id,
      secret: app.sharedSecret,
      name: app.name,
      iconURL: app.iconURL,
      eventWebhookURL: app.eventWebhookURL,
      redirectURI: app.redirectURI,
      emailSettings: customEmailTemplateToAPIData(
        app.customEmailTemplate,
        app.enableEmailNotifications
      ),
      createdTimestamp: app.createdTimestamp
    };
  });
  return res.status(200).json(result);
}
var ListApplicationsHandler_default = forwardHandlerExceptionsToNext(ListApplicationsHandler);

// server/src/public/routes/middleware/VerifyAPIAccessToken.ts
import { decode, TokenExpiredError, verify as verify3 } from "jsonwebtoken";
import isUUID6 from "validator/lib/isUUID.js";
function validateCordTokenData(data) {
  if (!(data instanceof Object)) {
    throw createInvalidInputTypeMessage("access token payload", "object");
  }
  const { session_id } = data;
  if (!session_id) {
    throw "Access token payload is missing session_id.";
  }
  if (!isUUID6.default(session_id)) {
    throw createInvalidInputTypeMessage("session_id", "UUID");
  }
  return { session_id };
}
async function verifyCordBearerTokenAuthorization(token, req, _res, next) {
  try {
    let decodedAPIAccessToken;
    try {
      decodedAPIAccessToken = validateCordTokenData(
        verify3(token, Env_default.JWT_SIGNING_SECRET, {
          algorithms: ["HS512"]
        })
      );
    } catch (e) {
      if (e instanceof TokenExpiredError) {
        throw new ApiCallerError("expired_access_token");
      } else {
        throw new ApiCallerError("invalid_access_token", { message: e });
      }
    }
    const { session_id } = decodedAPIAccessToken;
    const session = await SessionEntity.findByPk(session_id);
    if (!session) {
      throw new ApiCallerError("invalid_access_token", {
        message: "No valid session found."
      });
    }
    if (!session.expiresAt) {
      throw new ApiCallerError("expired_access_token", {
        message: "Access token has been revoked."
      });
    }
    const currentDate = /* @__PURE__ */ new Date();
    if (currentDate > session.expiresAt) {
      throw new ApiCallerError("expired_access_token");
    }
    const application = await ApplicationEntity.findByPk(session.applicationID);
    if (!application) {
      throw new ApiCallerError("project_not_found");
    }
    req.appID = session.applicationID;
    next();
  } catch (err) {
    next(err);
  }
}
function validateAppTokenData(data) {
  if (!(data instanceof Object)) {
    throw createInvalidInputTypeMessage("Authorization token", "object");
  }
  const { app_id, project_id, iat: _iat, exp: _exp, ...rest } = data;
  const appID = app_id || project_id;
  if (!appID) {
    throw new ApiCallerError("invalid_project_token", {
      message: "Please include the project_id if you are authorizing directly with a non-Cord signed token."
    });
  }
  if (typeof appID !== "string" || !isUUID6.default(appID)) {
    throw new ApiCallerError("invalid_project_token", {
      message: createInvalidInputTypeMessage("project_id", "UUID")
    });
  }
  if (Object.keys(rest).length > 0) {
    throw new ApiCallerError("invalid_project_token", {
      message: "Authorization token payload invalid, must contain only project_id."
    });
  }
  return { app_id: appID };
}
function validateCustomerTokenData(data) {
  if (!(data instanceof Object)) {
    throw createInvalidInputTypeMessage("Authorization token", "object");
  }
  const { customer_id } = data;
  if (!customer_id) {
    throw new ApiCallerError("invalid_customer_token", {
      message: "Project management auth tokens must include a customer_id field.  Refer to https://docs.cord.com/reference/authentication#Project-management-auth-token for more details."
    });
  }
  if (typeof customer_id !== "string" || !isUUID6.default(customer_id)) {
    throw new ApiCallerError("invalid_customer_token", {
      message: createInvalidInputTypeMessage("customer_id", "UUID")
    });
  }
  if ("user_id" in data || "org_id" in data || "app_id" in data || "project_id" in data) {
    throw new ApiCallerError("invalid_customer_token", {
      message: "Authorization token payload invalid, must contain only customer_id."
    });
  }
  return { customer_id };
}
async function verifyAppToken(token, req, _res, next) {
  try {
    let decodedCustomerAppToken;
    try {
      const data = decode(token);
      decodedCustomerAppToken = validateAppTokenData(data);
      const application = await ApplicationEntity.findByPk(
        decodedCustomerAppToken.app_id
      );
      if (!application) {
        throw new ApiCallerError("project_not_found");
      }
      verify3(token, application.sharedSecret, {
        clockTolerance: ACCESS_TOKEN_CLOCK_TOLERANCE_SECONDS,
        maxAge: `${ACCESS_TOKEN_MAX_AGE_SECONDS}s`,
        algorithms: ["HS512"]
      });
    } catch (e) {
      if (e instanceof ApiCallerError) {
        throw e;
      } else {
        throw new ApiCallerError("invalid_project_token", { message: e });
      }
    }
    const { app_id } = decodedCustomerAppToken;
    req.appID = app_id;
    const storage = asyncLocalStorage?.getStore();
    if (storage) {
      storage.platformApplicationID = app_id;
    }
    next();
  } catch (err) {
    next(err);
  }
}
async function verifyCustomerToken(token, req, _res, next) {
  try {
    let decodedCustomerAppToken;
    try {
      const data = decode(token);
      decodedCustomerAppToken = validateCustomerTokenData(data);
      const customer = await CustomerEntity.findByPk(
        decodedCustomerAppToken.customer_id
      );
      if (!customer) {
        throw new ApiCallerError("invalid_customer_token");
      }
      verify3(token, customer.sharedSecret, {
        clockTolerance: ACCESS_TOKEN_CLOCK_TOLERANCE_SECONDS,
        maxAge: `${ACCESS_TOKEN_MAX_AGE_SECONDS}s`,
        algorithms: ["HS512"]
      });
    } catch (e) {
      if (e instanceof ApiCallerError) {
        throw e;
      } else {
        throw new ApiCallerError("invalid_customer_token", { message: e });
      }
    }
    const { customer_id } = decodedCustomerAppToken;
    req.customerID = customer_id;
    next();
  } catch (err) {
    next(err);
  }
}
async function VerifyAppServerAuthTokenImpl(req, res, next) {
  const authorizationHeader = req.headers.authorization;
  const accessToken = verifyBearerTokenInAuthorizationHeaders(authorizationHeader);
  if (isCordSignedToken(accessToken)) {
    await verifyCordBearerTokenAuthorization(accessToken, req, res, next);
  } else {
    await verifyAppToken(accessToken, req, res, next);
  }
}
var VerifyAppServerAuthToken = forwardHandlerExceptionsToNext(
  VerifyAppServerAuthTokenImpl
);
async function VerifyCustomerServerAuthTokenImpl(req, res, next) {
  const authorizationHeader = req.headers.authorization;
  const accessToken = verifyBearerTokenInAuthorizationHeaders(authorizationHeader);
  await verifyCustomerToken(accessToken, req, res, next);
}
var VerifyCustomerServerAuthToken = forwardHandlerExceptionsToNext(
  VerifyCustomerServerAuthTokenImpl
);

// server/src/public/routes/handlers/IndexHandler.ts
function IndexHandler(req, res, _next) {
  res.send(
    `<pre>
                                             *&&&&&&&&&&&&&&&&&&
                   .*,                       *&&&&&&&&&&&&&&&&&&
                &&&&&&&&&&&&.                *&&&&&&&&&%
               &&&&&&&&&&&&&&&&&             *&&&&&&&&&&&%
               &&&&&&     /&&&&&&&&          *&&&&&  &&&&&&
                &&&&&&        &&&&&&&&       *&&&&&    &&&&&&
                 &&&&&&          &&&&&&&     *&&&&&     &&&&&&
                  .&&&&&&          &&&&&&%               &&&&&&
                    %&&&&&&          &&&&&&               &&&&&
                      (&&&&&&&        (&&&&&              &&&&&.
                         &&&&&&&&      .&&&&&             &&&&&
                           .&&&&&&&&&   &&&&&&          &&&&&&.
                   *           &&&&&&&&&&&&&&&       &&&&&&&&
                (&&&&&,            &&&&&&&&&&&&&&&&&&&&&&&&
                 &&&&&&&&&,            &&&&&&&&&&&&&&&&
                    %&&&&&&&&&&&&&&&&&&&&&&&
                        ,&&&&&&&&&&&&&&&&,

${(/* @__PURE__ */ new Date()).toLocaleString()}
${process.env.COMMIT_HASH}
</pre>`
  );
}

// server/src/public/routes/handlers/SlackAuthRedirectHandler.ts
import * as url2 from "url";
import * as cookie2 from "cookie";
import * as Slack2 from "@slack/web-api";
import { Op as Op17, QueryTypes as QueryTypes17 } from "sequelize";

// server/src/entity/org/OrgMutator.ts
var OrgMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async findOrCreateSlackOrg({
    name,
    domain,
    externalID,
    externalAuthData,
    state,
    slackAppID
  }) {
    if (this.viewer.userID !== SERVICE_USER_ID) {
      throw new Error("Only a service user can create orgs.");
    }
    const customSlackAppID = CORD_SLACK_APP_IDS.includes(slackAppID) ? null : slackAppID;
    return await OrgEntity.findOrCreate({
      where: {
        externalProvider: "slack" /* SLACK */,
        externalID,
        // Technically redundant, but allows postgres to use an index.
        platformApplicationID: null,
        customSlackAppID
      },
      defaults: {
        name,
        domain,
        externalProvider: "slack" /* SLACK */,
        externalID,
        externalAuthData,
        state,
        customSlackAppID
      }
    });
  }
  async toggleInternalFlag(orgID) {
    const org = await OrgEntity.findByPk(orgID);
    if (!org) {
      throw new Error(`org ${orgID} not found`);
    }
    org.internal = !org.internal;
    return await org.save();
  }
};

// server/src/entity/slack_channel/SlackChannelMutator.ts
var SlackChannelMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async createOne(slackChannelID, name, added, archived, users) {
    const orgID = assertViewerHasOrg(this.viewer);
    return await SlackChannelEntity.upsert({
      orgID,
      slackID: slackChannelID,
      name,
      added,
      archived,
      users
    });
  }
  async setAdded(slackChannelID, added) {
    const orgID = assertViewerHasOrg(this.viewer);
    const [numberUpdated] = await SlackChannelEntity.update(
      {
        added
      },
      {
        where: { orgID, slackID: slackChannelID }
      }
    );
    return !!numberUpdated;
  }
  async setArchived(slackChannelID, archived) {
    const orgID = assertViewerHasOrg(this.viewer);
    const [numberUpdated] = await SlackChannelEntity.update(
      {
        // Nothing (including bots) can be in an archived channel, so set added
        // to false if we update a channel to archived
        added: archived ? false : void 0,
        archived
      },
      {
        where: { orgID, slackID: slackChannelID }
      }
    );
    return !!numberUpdated;
  }
  createMany(channels) {
    const orgID = assertViewerHasOrg(this.viewer);
    return SlackChannelEntity.bulkCreate(
      channels.map(({ id, name, users, archived }) => ({
        slackID: id,
        name,
        orgID,
        added: false,
        archived,
        users
      })),
      { updateOnDuplicate: ["name", "users", "archived"] }
    );
  }
  async setName(slackChannelID, name) {
    const orgID = assertViewerHasOrg(this.viewer);
    const [numberUpdated] = await SlackChannelEntity.update(
      {
        name
      },
      {
        where: { orgID, slackID: slackChannelID }
      }
    );
    return !!numberUpdated;
  }
};

// server/src/util/cookies.ts
import { parse } from "querystring";
import * as cookie from "cookie";

// common/const/Cookies.ts
var UTM_COOKIE_KEY = "utm";

// server/src/util/google-analytics.ts
var GA_USER_COOKIE_KEY = "_ga";
var GA_MEASUREMENT_COOKIE_KEY = `_ga_${Env_default.GA_MEASUREMENT_ID.split("-")[1]}`;
var GA_MEASUREMENT_API_URL = `https://www.google-analytics.com/mp/collect?api_secret=${Env_default.GA_MEASUREMENT_PROTOCOL_API_SECRET}&measurement_id=${Env_default.GA_MEASUREMENT_ID}`;

// server/src/util/cookies.ts
function parseUtmParameters(utm) {
  if (typeof utm !== "string") {
    return;
  }
  const query = parse(utm.replace(/^\?/, ""));
  let nonEmpty = false;
  const utmParameters = {};
  for (const [key, value] of Object.entries(query)) {
    if (key.startsWith("utm_")) {
      utmParameters[key.substr(4)] = value;
      nonEmpty = true;
    }
  }
  if (nonEmpty) {
    return utmParameters;
  }
  return void 0;
}
function parametersFromCookie(value) {
  const parsedCookies = cookie.parse(value);
  return {
    utmParameters: parseUtmParameters(parsedCookies[UTM_COOKIE_KEY]),
    gaCookie: parsedCookies[GA_USER_COOKIE_KEY],
    gaMeasurementCookie: parsedCookies[GA_MEASUREMENT_COOKIE_KEY]
  };
}
function parametersFromRequest(req) {
  return parametersFromCookie(req.headers.cookie || "");
}

// server/src/auth/oauth.ts
import * as crypto6 from "crypto";
import { sign as sign2, verify as verify4 } from "jsonwebtoken";
function encodeViewerForOAuthState(viewer, type) {
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  const state = {
    userID,
    orgID,
    type
  };
  if (API_SERVER_HOST !== API_SERVER_HOST_PRODUCTION) {
    state["development"] = API_SERVER_HOST;
  }
  return sign2(state, Env_default.OAUTH_STATE_SIGNING_SECRET);
}
function decodeViewerFromOAuthState(token) {
  return verify4(
    token,
    Env_default.OAUTH_STATE_SIGNING_SECRET
  );
}
function getOAuthCodeAndState(req) {
  const { code, state } = req.query;
  if (!code || !state) {
    throw new Error(`missing code or state`);
  }
  let stateData = null;
  try {
    stateData = decodeViewerFromOAuthState(state);
  } catch (e) {
    throw new Error(`decodeViewerFromOAuthState failed`);
  }
  if (!stateData) {
    throw new Error(`missing state data`);
  }
  return [code, stateData];
}
function encryptSlackOAuthState(state) {
  const iv = crypto6.randomBytes(12);
  const cipher = crypto6.createCipheriv(
    "aes-256-gcm",
    Env_default.SLACK_OAUTH_STATE_SIGNING_SECRET,
    iv
  );
  const encrypted = Buffer.concat([
    cipher.update(state, "utf8"),
    cipher.final()
  ]);
  const authTag = cipher.getAuthTag();
  return [
    encrypted.toString("hex"),
    authTag.toString("hex"),
    iv.toString("hex")
  ].join(":");
}
function decryptSlackOAuthState(token) {
  const [encrypted, authTag, iv] = token.split(":");
  const decipher = crypto6.createDecipheriv(
    "aes-256-gcm",
    Env_default.SLACK_OAUTH_STATE_SIGNING_SECRET,
    Buffer.from(iv, "hex")
  );
  decipher.setAuthTag(Buffer.from(authTag, "hex"));
  let decrypted = decipher.update(encrypted, "hex", "utf8");
  decrypted += decipher.final();
  return decrypted;
}
function encodeSlackOAuthState(state) {
  return encryptSlackOAuthState(JSON.stringify(state));
}
function decodeSlackOAuthState(state) {
  const decodedState = JSON.parse(decryptSlackOAuthState(state));
  if (typeof decodedState !== "object") {
    throw new Error(`Unexpected Slack OAuth State format: ${state}`);
  }
  if (!decodedState?.type || !decodedState?.nonce || !decodedState?.data) {
    throw new Error(`Unexpected Slack OAuth State format: ${state}`);
  }
  if (decodedState.type === "link_org") {
    return decodeSlackOAuthLinkOrgDataState(decodedState);
  }
  if (decodedState.type === "console_user") {
    return decodeSlackOAuthConsoleUserDataState(decodedState);
  }
  throw new Error(`unknown type: ${decodedState.type}`);
}
function decodeSlackOAuthLinkOrgDataState(decodedState) {
  if (decodedState.type !== "link_org") {
    throw new Error(
      `Decoded slack state type is not link_org: ${decodedState}`
    );
  }
  if (typeof decodedState.nonce !== "string") {
    throw new Error(
      `Decoded slack state nonce is not a string: ${decodedState}`
    );
  }
  if (typeof decodedState.data !== "object") {
    throw new Error(
      `Decoded slack state data is not an object: ${decodedState}`
    );
  }
  const dataState = decodedState.data;
  if (typeof dataState.userID !== "string") {
    throw new Error(
      `Decoded slack state data userID is not a string: ${decodedState}`
    );
  }
  if (typeof dataState.orgID !== "string") {
    throw new Error(
      `Decoded slack state data orgID is not a string: ${decodedState}`
    );
  }
  if (typeof dataState.platformApplicationID !== "string") {
    throw new Error(
      `Decoded slack state data platformApplicationID is not a string: ${decodedState}`
    );
  }
  return {
    type: decodedState.type,
    nonce: decodedState.nonce,
    data: {
      userID: dataState.userID,
      orgID: dataState.orgID,
      platformApplicationID: dataState.platformApplicationID
    }
  };
}
function decodeSlackOAuthConsoleUserDataState(decodedState) {
  if (decodedState.type !== "console_user") {
    throw new Error(
      `Decoded slack state type is not console_user: ${decodedState}`
    );
  }
  if (typeof decodedState.nonce !== "string") {
    throw new Error(
      `Decoded slack state nonce is not a string: ${decodedState}`
    );
  }
  if (typeof decodedState.data !== "object") {
    throw new Error(
      `Decoded slack state data is not an object: ${decodedState}`
    );
  }
  const dataState = decodedState.data;
  if (typeof dataState.platformApplicationID !== "string") {
    throw new Error(
      `Decoded slack state data platformApplicationID is not a string: ${decodedState}`
    );
  }
  return {
    type: decodedState.type,
    nonce: decodedState.nonce,
    data: {
      platformApplicationID: dataState.platformApplicationID
    }
  };
}

// server/src/entity/linked_orgs/LinkedOrgsMutator.ts
var LinkedOrgsMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.logger = new Logger(viewer);
  }
  async linkOrgs(linkedOrgID, transaction) {
    const { userID: mergerUserID, orgID: sourceOrgID } = assertViewerHasPlatformIdentity(this.viewer);
    const application = await ApplicationEntity.findByPk(
      this.viewer.platformApplicationID,
      { transaction }
    );
    if (!application) {
      throw new Error("No app id found for viewer");
    }
    if (application.slackConnectAllOrgs) {
      const allUsersPlatformOrgIDs = (await OrgMembersEntity.findAll({
        where: {
          userID: this.viewer.userID
        },
        transaction
      })).map((o) => o.orgID);
      const alreadyLinkedOrgIDs = (await LinkedOrgsEntity.findAll({
        where: { sourceOrgID: allUsersPlatformOrgIDs },
        transaction
      })).map((o) => o.sourceOrgID);
      if (alreadyLinkedOrgIDs.length > 1) {
        this.logger.warn(
          "Linking all of platform users orgs, but some are already linked",
          {
            alreadyLinkedOrgIDs,
            allUsersPlatformOrgIDs
          }
        );
      }
      const orgIDsToLink = allUsersPlatformOrgIDs.filter(
        (id) => !alreadyLinkedOrgIDs.includes(id)
      );
      const linkings = orgIDsToLink.map((orgID) => ({
        sourceOrgID: orgID,
        sourceExternalProvider: "platform" /* PLATFORM */,
        linkedOrgID,
        linkedExternalProvider: "slack" /* SLACK */,
        mergerUserID
      }));
      const result = await LinkedOrgsEntity.bulkCreate(linkings, {
        ignoreDuplicates: true,
        transaction
      });
      this.loaders?.linkedOrgsLoader.clearAll();
      return result;
    } else {
      const result = await LinkedOrgsEntity.bulkCreate(
        [
          {
            sourceOrgID,
            sourceExternalProvider: "platform" /* PLATFORM */,
            linkedOrgID,
            linkedExternalProvider: "slack" /* SLACK */,
            mergerUserID
          }
        ],
        {
          ignoreDuplicates: true,
          transaction
        }
      );
      this.loaders?.linkedOrgsLoader.clearAll();
      return result;
    }
  }
  async unlinkOrgs() {
    const { orgID: sourceOrgID } = assertViewerHasPlatformIdentity(this.viewer);
    const application = await ApplicationEntity.findByPk(
      this.viewer.platformApplicationID
    );
    if (!application) {
      throw new Error("No app id found for viewer");
    }
    if (application.slackConnectAllOrgs) {
      const allUsersPlatformOrgIDs = (await OrgMembersEntity.findAll({
        where: {
          userID: this.viewer.userID
        }
      })).map((o) => o.orgID);
      const result = await LinkedOrgsEntity.destroy({
        where: { sourceOrgID: allUsersPlatformOrgIDs }
      });
      this.loaders?.linkedOrgsLoader.clearAll();
      return result;
    } else {
      const result = await LinkedOrgsEntity.destroy({ where: { sourceOrgID } });
      this.loaders?.linkedOrgsLoader.clearAll();
      return result;
    }
  }
};

// server/src/entity/linked_users/LinkedUsersMutator.ts
var LinkedUsersMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async linkUsers({
    sourceUserID,
    sourceOrgID,
    linkedUserID,
    linkedOrgID
  }, transaction) {
    if (!this.viewer.platformApplicationID) {
      throw new Error("Trying to link Slack org to a non-platform org");
    }
    const application = await ApplicationEntity.findByPk(
      this.viewer.platformApplicationID
    );
    if (!application) {
      throw new Error("No app id found for viewer");
    }
    if (application.slackConnectAllOrgs) {
      const allUsersPlatformOrgIDs = (await OrgMembersEntity.findAll({
        where: {
          userID: sourceUserID
        }
      })).map((o) => o.orgID);
      const alreadyLinkedOrgIDs = (await LinkedOrgsEntity.findAll({
        where: { sourceOrgID: allUsersPlatformOrgIDs }
      })).map((o) => o.sourceOrgID);
      const orgIDsToLink = allUsersPlatformOrgIDs.filter(
        (id) => !alreadyLinkedOrgIDs.includes(id)
      );
      const userLinkings = orgIDsToLink.map((platformOrgID) => ({
        sourceUserID,
        sourceOrgID: platformOrgID,
        linkedUserID,
        linkedOrgID
      }));
      return await LinkedUsersEntity.bulkCreate(userLinkings, {
        ignoreDuplicates: true,
        transaction
      });
    } else {
      return await LinkedUsersEntity.upsert(
        {
          sourceUserID,
          sourceOrgID,
          linkedUserID,
          linkedOrgID
        },
        { transaction }
      );
    }
  }
  async unlinkUsers({
    sourceUserID,
    sourceOrgID,
    linkedUserID,
    linkedOrgID
  }, transaction) {
    return await LinkedUsersEntity.destroy({
      where: {
        sourceUserID,
        sourceOrgID,
        linkedUserID,
        linkedOrgID
      },
      transaction
    });
  }
};

// server/src/public/routes/handlers/SlackAuthRedirectHandler.ts
async function findOrCreateSlackOrg(bot_access_token, bot_user_id, team, app_id) {
  const orgMutator = new OrgMutator(Viewer.createServiceViewer());
  const newAuthData = { bot_access_token, bot_user_id };
  const [orgEntity] = await orgMutator.findOrCreateSlackOrg({
    name: team.name,
    domain: team.domain,
    externalID: team.id,
    externalAuthData: newAuthData,
    state: "active",
    slackAppID: app_id
  });
  if (!isEqual(orgEntity.externalAuthData, newAuthData)) {
    orgEntity.externalAuthData = newAuthData;
    await orgEntity.save();
  }
  if (orgEntity.name !== team.name || orgEntity.domain !== team.domain) {
    orgEntity.name = team.name;
    orgEntity.domain = team.domain;
    await orgEntity.save();
  }
  return orgEntity;
}
function getNonceFromRequest(req) {
  const cookies = req.headers.cookie;
  if (!cookies) {
    anonymousLogger().warn("No cookies found");
    return "";
  }
  const parsedCookies = cookie2.parse(cookies);
  const nonce = parsedCookies["nonce"];
  if (!nonce) {
    return "";
  }
  return nonce;
}
function doCSRFCheck(nonceCookie, nonceState) {
  if (!nonceCookie) {
    anonymousLogger().warn("Nonce cookie not found");
    return false;
  }
  if (!nonceState) {
    anonymousLogger().warn("Nonce state not found");
    return false;
  }
  if (nonceState !== nonceCookie) {
    anonymousLogger().warn(
      "Login CSRF attempt detected. Nonce does not equal state value. Preventing Login"
    );
    return false;
  }
  return true;
}
function SlackAuthRedirectHandler(req, res, _next) {
  let logger = anonymousLogger();
  let { state } = req.query;
  if (typeof state === "string" && state[0] === "[") {
    const match = /^\[([\w.:-]+)\](.*)$/.exec(state);
    if (match) {
      const [_, redirectHost, trueState] = match;
      if (/^([\w-]+\.)*cord\.com(:\d+)?$/.test(redirectHost)) {
        res.redirect(
          url2.format({
            protocol: "https",
            host: redirectHost,
            pathname: req.path,
            query: {
              ...req.query,
              state: trueState
            }
          })
        );
        return;
      }
    }
  }
  const isDevApp = req.path.slice(-3) === "dev";
  const { code, error } = req.query;
  if (typeof state !== "string") {
    logger.error(
      "state was not a string as expected - continuing with empty state",
      { state }
    );
    state = "";
  }
  const decodedState = decodeSlackOAuthState(state);
  const nonceCookie = getNonceFromRequest(req);
  const csrfCheckPassed = doCSRFCheck(nonceCookie, decodedState.nonce);
  let utmParameters;
  try {
    utmParameters = parametersFromRequest(req).utmParameters;
  } catch (error2) {
    logger.warn("Error parsing utm parameters from cookie");
    utmParameters = void 0;
  }
  (async () => {
    function redirectURLWithError(errorMessage) {
      return `${APP_ORIGIN}/auth-slack-linking-error.html#message=${errorMessage}&service=slack`;
    }
    if (!code || !csrfCheckPassed) {
      let errorMessage;
      if (error === "access_denied") {
        errorMessage = "slack-login-access-denied";
      } else if (!csrfCheckPassed) {
        errorMessage = "slack-csrf-check-failed";
      } else {
        errorMessage = "slack-login-failed";
      }
      const anonymousEventMutator = new EventMutator({
        viewer: Viewer.createAnonymousViewer(),
        utmParameters
      });
      await anonymousEventMutator.createEvent({
        pageLoadID: null,
        installationID: null,
        eventNumber: null,
        clientTimestamp: null,
        logLevel: "debug" /* DEBUG */,
        type: errorMessage,
        payload: { payload: errorMessage },
        metadata: {}
      });
      return redirectURLWithError(errorMessage);
    }
    const slackAuthedUserResponse = await fetchAuthedSlackUser(
      code.toString(),
      isDevApp,
      decodedState
    );
    if (!slackAuthedUserResponse.authed_user || !slackAuthedUserResponse.team) {
      throw new Error("Slack authed user response malformed");
    }
    const {
      authed_user: { id: user_id },
      team: { id: team_id },
      access_token: bot_access_token,
      bot_user_id,
      app_id
    } = slackAuthedUserResponse;
    if (!app_id || !user_id || !team_id || !bot_user_id || !bot_access_token) {
      throw new Error("Slack authed user response malformed");
    }
    if (team_id === CORD_TEST_SLACK_TEAM_ID && app_id !== SLACK_DEV_APP_ID || team_id !== CORD_TEST_SLACK_TEAM_ID && app_id === SLACK_DEV_APP_ID) {
      const slackClient2 = new Slack2.WebClient(bot_access_token);
      if (app_id === SLACK_APP_ID) {
        await slackClient2.apps.uninstall({
          client_id: SLACK_APP_CLIENT_ID,
          client_secret: Env_default.SLACK_APP_CLIENT_SECRET
        });
      } else {
        await slackClient2.apps.uninstall({
          client_id: SLACK_DEV_APP_CLIENT_ID,
          client_secret: Env_default.SLACK_DEV_APP_CLIENT_SECRET
        });
      }
      return slackLoginURL(state, team_id);
    }
    const [userInfoResponse, teamInfoResponse, channelList] = await Promise.all(
      [
        // TODO(flooey): We should use a single WebClient for all of these calls
        // instead of passing the token to each function
        fetchSlackUserInfo(user_id, bot_access_token),
        fetchSlackTeamInfo(bot_access_token),
        fetchSlackChannelList(new Slack2.WebClient(bot_access_token))
      ]
    );
    const org = await findOrCreateSlackOrg(
      bot_access_token,
      bot_user_id,
      teamInfoResponse.team,
      app_id
    );
    if (decodedState.type === "console_user") {
      await ApplicationEntity.update(
        { supportOrgID: org.id },
        { where: { id: decodedState.data.platformApplicationID } }
      );
    }
    const user = await updateOrCreateSlackUserProfile(
      org,
      userInfoResponse.user
    );
    if (!user) {
      return redirectURLWithError("DeletedUser");
    }
    let viewerOfSourceUser = Viewer.createAnonymousViewer();
    logger = new Logger(viewerOfSourceUser);
    if (decodedState.type === "link_org") {
      try {
        await getSequelize().transaction(async (transaction) => {
          if (decodedState.type === "link_org") {
            const [user2, org2] = await Promise.all([
              UserEntity.findByPk(decodedState.data.userID),
              OrgEntity.findByPk(decodedState.data.orgID)
            ]);
            if (!user2?.externalID || !org2?.externalID) {
              throw new Error("Cannot find external ids when linking org");
            }
            viewerOfSourceUser = await Viewer.createLoggedInPlatformViewer({
              user: user2,
              org: org2
            });
          }
          const { userID: sourceUserID, orgID: sourceOrgID } = assertViewerHasIdentity(viewerOfSourceUser);
          const [
            isPlatformOrgAlreadyLinkedToAnotherOrg,
            isSlackOrgAlreadyLinkedToAnotherOrg
          ] = await Promise.all([
            Boolean(
              await LinkedOrgsEntity.findOne({
                where: {
                  sourceOrgID,
                  linkedOrgID: { [Op17.ne]: org.id }
                },
                transaction
              })
            ),
            Boolean(
              await LinkedOrgsEntity.findOne({
                where: {
                  sourceOrgID: { [Op17.ne]: sourceOrgID },
                  linkedOrgID: org.id
                },
                transaction
              })
            )
          ]);
          if (isPlatformOrgAlreadyLinkedToAnotherOrg) {
            throw new Error("platform_org_already_linked" /* PLATFORM_ORG_ALREADY_LINKED */);
          }
          const linkedOrgsMutator = new LinkedOrgsMutator(
            viewerOfSourceUser,
            null
          );
          const linkedUsersMutator = new LinkedUsersMutator(viewerOfSourceUser);
          await linkedOrgsMutator.linkOrgs(org.id, transaction);
          await linkedUsersMutator.linkUsers(
            {
              sourceUserID,
              sourceOrgID,
              linkedUserID: user.id,
              linkedOrgID: org.id
            },
            transaction
          );
          if (isSlackOrgAlreadyLinkedToAnotherOrg) {
            const membersInPlatformOrgQuery = `SELECT "userID" FROM cord.org_members WHERE "orgID"= $sourceOrgID AND "userID" != $sourceUserID`;
            const matchedLinkedUsersToLink = await getSequelize().query(
              // if more than one other embed org is currently connected to the
              // same slack org we make sure that we only get one row for each
              // sourceUserID
              `SELECT DISTINCT ON ("sourceUserID") * FROM cord.linked_users
              WHERE "sourceUserID" IN (${membersInPlatformOrgQuery})
              AND "sourceOrgID" != $sourceOrgID
              AND "linkedUserID" != $linkedUserID
              AND "linkedOrgID" = $linkedOrgID
              `,
              {
                bind: {
                  sourceUserID,
                  sourceOrgID,
                  linkedUserID: user.id,
                  linkedOrgID: org.id
                },
                type: QueryTypes17.SELECT,
                model: LinkedUsersEntity,
                transaction
              }
            );
            await Promise.all(
              matchedLinkedUsersToLink.map(
                (linkedUser) => linkedUsersMutator.linkUsers(
                  {
                    sourceUserID: linkedUser.sourceUserID,
                    sourceOrgID,
                    linkedUserID: linkedUser.linkedUserID,
                    linkedOrgID: org.id
                  },
                  transaction
                )
              )
            );
          }
          logger.debug("Linked two users", {
            sourceUserID,
            sourceOrgID,
            linkedUserID: user.id,
            linkedOrgID: org.id
          });
          transaction.afterCommit(async () => {
            await publishUserIdentityUpdate({
              userID: sourceUserID,
              platformApplicationID: viewerOfSourceUser.platformApplicationID
            });
          });
        });
      } catch (e) {
        let errorMessage = "error-connecting-platform-and-slack";
        let logLevel2 = "error";
        if (e.message === "platform_org_already_linked" /* PLATFORM_ORG_ALREADY_LINKED */) {
          errorMessage = "platform_org_already_linked" /* PLATFORM_ORG_ALREADY_LINKED */;
          logLevel2 = "warn";
        }
        logger.logException(
          "Error connecting platform org with Slack org",
          e,
          {
            sourceUserID: viewerOfSourceUser.userID,
            sourceOrgID: viewerOfSourceUser.orgID,
            linkedUserID: user.id,
            linkedOrgID: org.id,
            decodedState,
            isDevApp
          },
          void 0,
          logLevel2
        );
        return `${APP_ORIGIN}/auth-slack-linking-error.html#message=${errorMessage}&service=slack`;
      }
    }
    const viewer = Viewer.createLoggedInViewer(user.id, org.id);
    const promises = [];
    await submitAsync("syncSlackGreyUsers", {
      orgID: org.id
    });
    promises.push(new SlackChannelMutator(viewer).createMany(channelList));
    const eventMutator = new EventMutator({
      viewer,
      utmParameters
    });
    promises.push(
      eventMutator.createEvent({
        pageLoadID: null,
        installationID: null,
        eventNumber: null,
        clientTimestamp: null,
        logLevel: "debug" /* DEBUG */,
        type: "slack-login-success",
        payload: {},
        metadata: {}
      })
    );
    await Promise.all(promises);
    if (decodedState.type === "link_org") {
      return `${APP_ORIGIN}/auth-puppet-complete.html`;
    }
    if (decodedState.type === "console_user") {
      return `${APP_ORIGIN}/auth-complete.html#service=slack&origin=console`;
    }
    return redirectURLWithError("UnexpectedOutcome");
  })().then(
    // this is to make sure we do exactly one of the following:
    // * redirect, if the above async function succeeded at constructing the
    // redirect destination
    // * in case of an error, emit a 500 Server Error and log the error
    (redirect) => res.redirect(redirect),
    // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
    (error2) => {
      res.sendStatus(500);
      logger.logException("Error in SlackAuthRedirectHandler", error2, {
        isDevApp
      });
    }
  );
}

// server/src/public/routes/handlers/JiraAuthRedirectHandler.ts
async function JiraAuthRedirectHandler(req, res) {
  let logger = anonymousLogger();
  if (req.query["error"] === "access_denied") {
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=jira&message=cancelled`
    );
  }
  try {
    const codeAndState = getOAuthCodeAndState(req);
    const [code, { userID, orgID, type, development }] = codeAndState;
    logger = new Logger(Viewer.createLoggedInViewer(userID, orgID));
    if (development && process.env.NODE_ENV !== "development") {
      const { code: code2, state } = req.query;
      return res.redirect(
        `https://${development}/auth/jira/redirect/?code=${encodeURIComponent(
          code2
        )}&state=${encodeURIComponent(state)}`
      );
    }
    if (type !== "jira") {
      throw new Error(`incorrect redirect type, received ${type}`);
    }
    const { refreshToken, identity, cloudID, projects } = await completeOAuthFlow(code);
    const externalID = identity.account_id;
    const externalEmail = identity.email;
    if (projects.length === 0) {
      throw new Error("Jira user has no projects");
    }
    const projectID = projects[0].id;
    const issueType = projects[0].issueTypes.find((type2) => !type2.subtask)?.id;
    const subissueType = projects[0].issueTypes.find(
      // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
      (type2) => type2.subtask
    )?.id;
    if (!issueType || !subissueType) {
      throw new Error("Jira user has no issue or subissue type");
    }
    const preferences = {
      projectID,
      issueType,
      subissueType
    };
    await Promise.all([
      UserPreferenceEntity.upsert({
        userID,
        key: JIRA_CONNECTION_PREFERENCES,
        value: preferences
      }),
      ThirdPartyConnectionEntity.upsert({
        userID,
        orgID,
        type,
        externalID,
        externalEmail,
        externalAuthData: {
          cloudID,
          refreshToken
        }
      })
    ]);
  } catch (e) {
    logger.logException(`JiraAuthRedirectHandler`, e);
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=jira&message=error`
    );
  }
  return res.redirect(`${APP_ORIGIN}/auth-complete.html#service=jira`);
}

// server/src/public/routes/handlers/SlackEventApiHandler.ts
import { WebClient as WebClient3 } from "@slack/web-api";

// server/src/util/isHelpMessage.ts
function isHelpMessage(text) {
  return /^\W*help\W*$/i.test(text);
}

// server/src/serverStatus.ts
import express from "express";

// server/src/util/drainHelper.ts
import * as https2 from "https";
import { EventEmitter } from "events";
var DrainHelper = class _DrainHelper extends EventEmitter {
  constructor() {
    super(...arguments);
    this.draining = false;
    this.terminating = false;
    this.keepAliveCount = 0;
    /** Increment the activity count and return a function to decrement it later
     *
     * The activity count needs to reach zero for graceful shutdown to complete.
     * Any call to this function increments it, and it returns a function object
     * that needs to be called later to decrement it again. The returned function
     * only decrements the count once, even if called multiple times.
     */
    this.keepAlive = () => {
      let complete = false;
      ++this.keepAliveCount;
      return () => {
        if (!complete) {
          complete = true;
          --this.keepAliveCount;
          if (this.keepAliveCount === 0) {
            if (this.draining && !this.terminating) {
              this.terminate();
            }
          }
        }
      };
    };
    this.isDraining = () => this.draining;
    this.isTerminating = () => this.terminating;
  }
  drain() {
    if (!this.draining && !this.terminating) {
      this.draining = true;
      this.emit("draining");
      if (!this.keepAliveCount) {
        this.terminate();
      }
    }
  }
  terminate() {
    if (!this.terminating) {
      this.draining = this.terminating = true;
      this.emit("terminating");
    }
  }
  waitUntilDraining() {
    return this.draining ? Promise.resolve() : new Promise((resolve2) => this.once("draining", resolve2));
  }
  waitUntilTerminating() {
    return this.terminating ? Promise.resolve() : new Promise((resolve2) => this.once("terminating", resolve2));
  }
  /**
   * Make this DrainHelper automatically keep itself alive through http server
   * connections
   *
   * The http(s) server passed to this functions will be equipped with event
   * handlers so that any existing connection keeps this DrainHelper alive (i.e.
   * delays the transition from 'draining' to 'terminating'). For each
   * connection in turn a new DrainHelper is instantiated, which keeps tracks of
   * ongoing requests on that connection. When we drain this whole thing, we
   * immediate start draining the connections, too, which means that they get
   * closed as soon as there is not ongoing request. And as soon as all
   * connections are closed, this http server stops keeping this DrainHelper
   * alive.
   */
  install(server) {
    const { keepAlive } = this;
    const connectionHandler = (socket) => {
      if (this.draining || this.terminating) {
        anonymousLogger().warn(
          `Incoming connection closed immediately because server is ${this.terminating ? "terminating" : "draining"}`
        );
        socket.end();
      } else {
        const expireKeepAlive = keepAlive();
        const connectionDrainHelper = new _DrainHelper();
        socket.cordConnectionDrainHelper = connectionDrainHelper;
        connectionDrainHelper.once("terminating", () => {
          socket.end();
          expireKeepAlive();
        });
        const drainConnection = () => connectionDrainHelper.drain();
        this.addListener("draining", drainConnection);
        socket.once("close", () => {
          expireKeepAlive();
          this.removeListener("draining", drainConnection);
        });
      }
    };
    if (server instanceof https2.Server) {
      server.addListener("secureConnection", connectionHandler);
    } else {
      server.addListener("connection", connectionHandler);
    }
    server.addListener(
      "request",
      (req, res) => {
        const { cordConnectionDrainHelper: connectionDrainHelper } = req.socket;
        if (connectionDrainHelper) {
          res.once("close", connectionDrainHelper.keepAlive());
        }
        if (this.draining && !res.headersSent) {
          res.setHeader("connection", "close");
        }
      }
    );
  }
};

// server/src/serverStatus.ts
var currentStatus = "initializing";
function setStatus(newStatus) {
  if (currentStatus !== newStatus) {
    anonymousLogger().info(
      `Server status changed: ${currentStatus} -> ${newStatus}`,
      {
        oldStatus: currentStatus,
        newStatus
      }
    );
    currentStatus = newStatus;
  }
}
var drainHelper = new DrainHelper();
drainHelper.once("draining", () => {
  setStatus("draining");
});
drainHelper.once("terminating", () => {
  setStatus("terminating");
});

// server/src/public/routes/handlers/SlackEventApiHandler.ts
var counter3 = Counter2({
  name: "SlackEventApiHandler",
  help: "Events received from Slack",
  labelNames: ["type"]
});
var { CORD_TIER: tier } = Env_default;
function SlackEventApiHandler(req, res, _next) {
  const serviceLogger = new Logger(Viewer.createServiceViewer());
  if (req.body?.event?.type !== "message" || isInternalSlackOrg(req.body?.team_id)) {
    serviceLogger.debug("SlackEventApiHandler", { slackEvent: req.body });
  } else {
    const { event: _event, ...redactedSlackEvent } = req.body;
    serviceLogger.debug("SlackEventApiHandler", {
      slackEvent: redactedSlackEvent,
      isRedacted: true
    });
  }
  const slack_message_type = req.body.type;
  if (slack_message_type !== "event_callback") {
    res.sendStatus(400);
    return;
  }
  const release = drainHelper.keepAlive();
  (async () => {
    res.sendStatus(200);
    return await processIncomingSlackEvent(serviceLogger, req.body);
  })().catch(
    serviceLogger.exceptionLogger("SlackEventApiHandler", {
      slackEvent: req.body
    })
  ).finally(release);
}
async function processIncomingSlackEvent(logger, body) {
  if (tier !== "prod") {
    backgroundPromise(
      publishPubSubEvent(
        "incoming-slack-event",
        { tier },
        {
          type: "standard",
          event: body
        }
      ),
      logger
    );
  }
  const { team_id: teamId, event, authorizations, api_app_id } = body;
  if (typeof teamId !== "string" || typeof event !== "object" || typeof api_app_id !== "string") {
    logger.info("Malformed Slack Event object");
    return;
  }
  counter3.inc({ type: event.type });
  if (!(event.type in eventHandlers)) {
    if (IGNORED_SLACK_EVENT_TYPES.has(event.type)) {
      return;
    } else {
      logger.warn("Unhandled Slack Event API event type", {
        event_type: event.type
      });
      return;
    }
  }
  const eventHandler = eventHandlers[event.type];
  const orgLoader = new OrgLoader(Viewer.createServiceViewer());
  const org = await orgLoader.loadSlackOrg(teamId, api_app_id);
  if (org === null) {
    logger.info(`Received user update for unknown Slack team: ${teamId}`);
    return;
  }
  if (!org.externalAuthData) {
    logger.warn("Received slack update for org with no externalAuthData", {
      teamId,
      orgId: org.id,
      eventName: event.type
    });
    return;
  }
  await eventHandler(event, org, authorizations).catch(
    logger.exceptionLogger("SlackEventApiHandler", { event })
  );
}
var IGNORED_SLACK_EVENT_TYPES = /* @__PURE__ */ new Set([
  "channel_deleted",
  "channel_left",
  "team_join"
]);
var eventHandlers = {
  async user_change(event, org) {
    const user = event.user;
    if (allowImportUser(user) && user.team_id === org.externalID) {
      await updateOrCreateSlackUserProfile(org, user);
    }
  },
  async member_joined_channel(event, org) {
    const viewer = Viewer.createOrgViewer(org.id);
    const logger = new Logger(viewer, { event });
    const slackBotCredentials = await org.getSlackBotCredentials();
    if (event.channel_type === "C" /* PUBLIC */ && slackBotCredentials && event.user === slackBotCredentials.bot_user_id) {
      const { channel } = event;
      const slackChannelMutator = new SlackChannelMutator(viewer);
      if (!await slackChannelMutator.setAdded(channel, true)) {
        let name = "[unknown channel]";
        let users = 0;
        try {
          const { bot_access_token } = slackBotCredentials;
          const slackClient2 = new WebClient3(bot_access_token);
          const info = await slackClient2.conversations.info({
            channel,
            include_num_members: true
          });
          if (typeof info.channel?.name === "string") {
            name = info.channel.name;
          }
          if (typeof info.channel?.num_members === "number") {
            users = info.channel.num_members;
          }
        } catch (err) {
          logger.logException("Error looking up Slack channel name", err);
        }
        await slackChannelMutator.createOne(
          channel,
          name,
          /* added */
          true,
          /* archived */
          false,
          users
        );
      }
    }
  },
  async member_left_channel(event, org) {
    const slackBotCredentials = await org.getSlackBotCredentials();
    const viewer = Viewer.createOrgViewer(org.id);
    if (event.channel_type === "C" /* PUBLIC */ && slackBotCredentials && event.user === slackBotCredentials.bot_user_id) {
      const { channel } = event;
      const slackChannelMutator = new SlackChannelMutator(viewer);
      await slackChannelMutator.setAdded(channel, false);
    }
  },
  async message(event, org) {
    await unlinkThreadOnSlackMessageDelete(event, org);
    if (event.subtype && event.subtype !== "file_share") {
      return;
    }
    const userLoader = new UserLoader(
      Viewer.createOrgViewer(org.id),
      () => null
    );
    const messageAuthorUser = await userLoader.loadUserForSlackUserWithinViewerOrg(event.user);
    if (messageAuthorUser === null) {
      return;
    }
    const viewer = Viewer.createLoggedInViewer(
      messageAuthorUser.id,
      org.id
    );
    const logger = new Logger(viewer, { event });
    const { thread_ts } = event;
    const slackBotCredentials = await org.getSlackBotCredentials();
    if (!slackBotCredentials) {
      throw new Error(
        `SlackEventApiHandler message handler: no Slack bot credentials`
      );
    }
    const { bot_access_token, bot_user_id } = slackBotCredentials;
    if (event.channel_type === "channel" /* PUBLIC */) {
      if (thread_ts) {
        await addMessageToCorrectCordThread(
          logger,
          bot_access_token,
          event,
          viewer
        );
      }
    } else if (event.channel_type === "im" /* IM */) {
      if (event.user !== bot_user_id && typeof event.user === "string" && typeof event.text === "string") {
        if (thread_ts) {
          await addMessageToCorrectCordThread(
            logger,
            bot_access_token,
            event,
            viewer
          );
          return;
        }
        if (isHelpMessage(event.text) && org.domain) {
          await sendWelcomeHelpMessage(
            bot_access_token,
            event.user,
            org.domain
          );
          return;
        }
        await sendReplyHelpMessage(bot_access_token, event.user);
      }
    }
  },
  async app_home_opened(event, org, authorizations) {
    const logger = new Logger(Viewer.createServiceViewer(), {
      event,
      org_id: org.id,
      authorizations
    });
    try {
      if (Array.isArray(authorizations) && authorizations.length === 0) {
        logger.warn(
          "No authorization permissions found, the app has been removed from the workspace.",
          {
            orgID: org.id,
            slackUserID: event.user
          }
        );
        return;
      }
      const slackBotCredentials = await org.getSlackBotCredentials();
      if (slackBotCredentials && typeof event.user === "string" && org.domain) {
        await sendWelcomeHelpMessage(
          slackBotCredentials.bot_access_token,
          event.user,
          org.domain,
          /* onlyPostIfConversationEmpty: */
          true
        );
      } else {
        logger.warn("Could not respond to app_home_opened event", {
          orgID: org.id,
          slackUserID: event.user
        });
      }
    } catch (error) {
      if (error.data.error === "account_inactive") {
        logger.warn(
          "User has navigated to app home but the app has been removed from the workspace.",
          {
            orgID: org.id,
            slackUserID: event.user
          }
        );
        return;
      }
      throw error;
    }
  },
  async channel_created(event, org) {
    const viewer = Viewer.createOrgViewer(org.id);
    const { id, name } = event.channel;
    await new SlackChannelMutator(viewer).createOne(
      id,
      name,
      /* added */
      false,
      /* archived */
      false,
      0
    );
  },
  async channel_rename(event, org) {
    const { id, name } = event.channel;
    await new SlackChannelMutator(Viewer.createOrgViewer(org.id)).setName(
      id,
      name
    );
  },
  async channel_archive(event, org) {
    const { channel } = event;
    await new SlackChannelMutator(Viewer.createOrgViewer(org.id)).setArchived(
      channel,
      true
    );
  },
  async channel_unarchive(event, org) {
    const { channel } = event;
    await new SlackChannelMutator(Viewer.createOrgViewer(org.id)).setArchived(
      channel,
      false
    );
  }
};

// server/src/slack/interactionHandlers/blockActions.ts
import { IncomingWebhook } from "@slack/webhook";

// server/src/util/interactiveSupportButton.ts
function supportStatusButton(action, threadID) {
  const buttonText = {
    close: ":tada: Close thread",
    open: ":leftwards_arrow_with_hook: Reopen thread"
  };
  return {
    type: "actions",
    elements: [
      {
        type: "button",
        text: {
          type: "plain_text",
          text: buttonText[action],
          emoji: true
        },
        value: `${action}_${threadID}`,
        action_id: `support_${action}_thread`
      }
    ]
  };
}

// server/src/slack/interactionHandlers/blockActions.ts
async function handleSupportThreadStatusChange(event, org) {
  const logger = new Logger(Viewer.createOrgViewer(org.id), { event });
  const actionId = event.actions[0].action_id;
  const value = event.actions[0].value;
  const threadID = value.split("_")[1];
  const supportStatus = actionId === "support_close_thread" ? "closed" : "open";
  await ThreadEntity.update(
    { supportStatus },
    {
      where: { id: threadID }
    }
  );
  const newStatus = (await ThreadEntity.findByPk(threadID))?.supportStatus;
  if (!newStatus) {
    logger.error("Thread support status not found", {
      threadID,
      slackOrg: event.user.team_id,
      orgID: org.id
    });
  }
  logServerEvent({
    session: { viewer: Viewer.createOrgViewer(org.id) },
    logLevel: "debug" /* DEBUG */,
    type: `support-thread-${supportStatus}`,
    payload: {
      orgID: org.id,
      threadID
    }
  });
  const newActionBlock = newStatus === "closed" ? supportStatusButton("open", threadID) : supportStatusButton("close", threadID);
  const replacementMessage = [
    ...event.message.blocks.filter((block) => block.type !== "actions"),
    newActionBlock
  ];
  const responseUrl = event.response_url;
  const webhook = new IncomingWebhook(responseUrl);
  await webhook.send({
    blocks: replacementMessage
  });
}

// server/src/public/routes/handlers/SlackInteractiveEventApiHandler.ts
var counter4 = Counter2({
  name: "SlackInteractiveEventApiHandler",
  help: "Interactive events received from Slack",
  labelNames: ["type"]
});
var { CORD_TIER: tier2 } = Env_default;
function SlackInteractiveEventApiHandler(req, res, _next) {
  const anonLogger = anonymousLogger();
  anonLogger.debug("SlackInteractiveEventApiHandler", {
    slackEvent: req.body
  });
  const payload = req.body?.payload && JSON.parse(req.body.payload);
  const interactive_message_type = payload.type;
  if (!interactive_message_type || !payload) {
    res.sendStatus(400);
    return;
  }
  const release = drainHelper.keepAlive();
  (async () => {
    res.sendStatus(200);
    if (tier2 !== "prod") {
      backgroundPromise(
        publishPubSubEvent(
          "incoming-slack-event",
          { tier: tier2 },
          {
            type: "interactive",
            event: req.body
          }
        ),
        anonLogger
      );
    }
    return await processIncomingSlackInteractionEvent(payload);
  })().catch(
    anonLogger.exceptionLogger("SlackInteractiveEventApiHandler", {
      slackEvent: req.body
    })
  ).finally(release);
}
async function processIncomingSlackInteractionEvent(event) {
  const {
    type,
    user: { team_id: teamID },
    api_app_id
  } = event;
  const orgLoader = new OrgLoader(Viewer.createServiceViewer());
  const logger = new Logger(Viewer.createServiceViewer());
  const org = await orgLoader.loadSlackOrg(teamID, api_app_id);
  if (org === null) {
    logger.info(
      `Received interactive Slack event from unknown Slack team: ${teamID}`
    );
  }
  if (!org?.externalAuthData) {
    logger.warn(
      "Received interactive Slack event from org with no externalAuthData",
      {
        teamID,
        orgID: org?.id,
        eventName: event.type
      }
    );
    return;
  }
  counter4.inc({ type });
  if (!(type in interactionEventHandlers)) {
    logger.warn("Unhandled Slack Interaction Event API event type", {
      event_type: type
    });
    return;
  }
  const eventHandler = interactionEventHandlers[type];
  await eventHandler(event, org).catch(
    logger.exceptionLogger("SlackInteractiveEventApiHandler", { event })
  );
}
var interactionEventHandlers = {
  async block_actions(event, org) {
    if (event?.actions[0]?.action_id === "support_close_thread" || event?.actions[0]?.action_id === "support_open_thread") {
      return await handleSupportThreadStatusChange(event, org);
    }
  }
};

// server/src/public/routes/handlers/AsanaAuthRedirectHandler.ts
async function AsanaAuthRedirectHandler(req, res) {
  if (req.query["error"] === "access_denied") {
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=asana&message=cancelled`
    );
  }
  try {
    const codeAndState = getOAuthCodeAndState(req);
    const [code, { userID, orgID, type }] = codeAndState;
    if (type !== "asana") {
      throw new Error(`incorrect redirect type, received ${type}`);
    }
    const [refreshToken, asanaUserInfo] = await completeOAuthFlow2(code);
    const externalID = asanaUserInfo.gid;
    const externalEmail = asanaUserInfo.email;
    const workspace = asanaUserInfo.workspaces?.[0]?.gid;
    if (!externalID || !externalEmail || !workspace) {
      throw new Error("Asana user gid/external_email/workspace is missing");
    }
    const preferences = {
      projectID: void 0
      // new tasks don't go to any project
    };
    await Promise.all([
      ThirdPartyConnectionEntity.upsert({
        userID,
        orgID,
        type,
        externalID,
        externalEmail,
        externalAuthData: {
          workspace,
          refreshToken
        }
      }),
      UserPreferenceEntity.upsert({
        userID,
        key: ASANA_CONNECTION_PREFERENCES,
        value: preferences
      })
    ]);
  } catch (e) {
    anonymousLogger().logException(`AsanaAuthRedirectHandler`, e);
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=asana&message=error`
    );
  }
  return res.redirect(`${APP_ORIGIN}/auth-complete.html#service=asana`);
}

// server/src/third_party_tasks/linear/api.ts
async function apiRequest(query, accessToken, variables = null) {
  return await thirdPartyGraphQLRequest(
    "linear",
    query,
    accessToken,
    variables
  );
}
async function completeOAuthFlow3(code) {
  const params = new URLSearchParams();
  params.append("grant_type", "authorization_code");
  params.append("client_id", Env_default.LINEAR_APP_CLIENT_ID);
  params.append("client_secret", Env_default.LINEAR_APP_CLIENT_SECRET);
  params.append("redirect_uri", LINEAR_AUTH_REDIRECT_URL);
  params.append("code", code);
  const response = await fetch("https://api.linear.app/oauth/token", {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: params
  });
  const { access_token } = await response.json();
  const userInfo2 = await getUserInfo(access_token);
  if (!userInfo2) {
    throw new Error("Could not fetch Linear user information.");
  }
  return [access_token, userInfo2];
}
async function getUserInfo(accessToken) {
  const query = `
    query UserInfo {
      viewer {
        id
        email
        teams {
          nodes {
            id
            name
            projects {
              nodes {
                id
                name
              }
            }
          }
        }
      }
    }`;
  const responseJson = await apiRequest(
    query,
    accessToken
  );
  return responseJson ? responseJson.viewer : null;
}
async function createIssue2(accessToken, teamId, title, description = null, assigneeId = null, parentId = null, projectId = null) {
  const input = {
    title,
    teamId,
    description,
    assigneeId,
    parentId,
    projectId
  };
  const mutation = `
    mutation CreateIssue ($input: IssueCreateInput!){
      issueCreate(
        input:$input
      ) {
        success 
        issue {
          id
        }
      }
    }`;
  const responseJson = await apiRequest(
    mutation,
    accessToken,
    { input }
  );
  return responseJson.issueCreate.issue.id;
}
async function getUsersInOrg(accessToken) {
  const query = `
    query UsersInOrg {
      users {
        nodes {
          id
          email
        }
      }
    }`;
  const responseJson = await apiRequest(
    query,
    accessToken
  );
  return responseJson ? responseJson.users.nodes : null;
}
async function getLinearUploadData(accessToken, filename, contentType, filesize) {
  const mutation = `
    mutation FileUpload($size: Int!, $contentType: String!, $filename: String!) {
      fileUpload(size: $size, contentType: $contentType, filename: $filename) {
        success
        uploadFile {
          contentType
          size
          uploadUrl
          assetUrl
          headers {
            key
            value
          }
        }
      } 
    }`;
  const variables = { size: filesize, contentType, filename };
  const responseJson = await apiRequest(
    mutation,
    accessToken,
    variables
  );
  return responseJson ? responseJson.fileUpload.uploadFile : null;
}
async function uploadFileToLinear(accessToken, filename, contentType, stream, filesize) {
  const linearUploadData = await getLinearUploadData(
    accessToken,
    filename,
    contentType,
    filesize
  );
  if (!linearUploadData) {
    return;
  }
  const { uploadUrl, assetUrl, headers } = linearUploadData;
  const authHeaders = new Headers();
  headers.map((header) => {
    authHeaders.append(header.key, header.value);
  });
  authHeaders.append("cache-control", "max-age=31536000");
  authHeaders.append("Content-Type", `${contentType}`);
  const uploadResponse = await fetch(`${uploadUrl}`, {
    method: "PUT",
    headers: authHeaders,
    body: stream
  });
  if (uploadResponse.status === 200) {
    return assetUrl;
  } else {
    return void 0;
  }
}
async function getWorkflowStates(accessToken, teamID) {
  const query = `
    query WorkflowStates {
      workflowStates {
        nodes {
          id
          type
          team {
            id
          }
        }
      }
    }`;
  const responseJson = await apiRequest(
    query,
    accessToken
  );
  const workflowStates = responseJson ? responseJson.workflowStates.nodes : null;
  if (!workflowStates || workflowStates.length === 0) {
    return null;
  }
  return workflowStates.filter((state) => state.team.id === teamID).map((state) => ({ id: state.id, type: state.type }));
}
async function updateIssueState(accessToken, newState, issueID, teamID) {
  const workflowStates = await getWorkflowStates(accessToken, teamID);
  if (!workflowStates) {
    return;
  }
  const [{ id }] = workflowStates.filter((state) => state.type === newState);
  const mutation = `
    mutation UpdateIssueState($id: String!, $stateId: String) {
      issueUpdate(
        id: $id
        input: {
          stateId: $stateId
        }
      ) {
          success
        }
    }`;
  const variables = { id: issueID, stateId: id };
  const responseJson = await apiRequest(
    mutation,
    accessToken,
    variables
  );
  return responseJson.issueUpdate.success;
}
async function updateIssueAssigneeAndSubscribers(accessToken, issueID, assigneeID, subscriberIDs, updatedDescription) {
  const mutation = `
    mutation UpdateIssueAssignee ($id:String!, $assigneeId:String,  $subscriberIds:[String!], $description: String){
      issueUpdate(
        id: $id
        input: {
          assigneeId: $assigneeId
          description: $description
          subscriberIds: $subscriberIds
        }
      ) {
          success
        }
    }`;
  const variables = {
    id: issueID,
    assigneeId: assigneeID,
    description: updatedDescription,
    subscriberIds: subscriberIDs
  };
  const responseJson = await apiRequest(
    mutation,
    accessToken,
    variables
  );
  return responseJson.issueUpdate.success;
}
async function getIssueDescription(issueID, accessToken) {
  const query = `
    query IssueDescription ($id: String!){
      issue(id: $id) {
          description
        }
      }`;
  const variables = { id: issueID };
  const responseJson = await apiRequest(
    query,
    accessToken,
    variables
  );
  return responseJson ? responseJson.issue.description : "";
}
async function updateIssueDescription(issueID, accessToken, updatedDescription) {
  const mutation = `
    mutation UpdateIssueDescription ($id: String!, $description: String) {
      issueUpdate(
        id: $id
        input: {
          description: $description
        }
      ) {
        success
      }
    }`;
  const variables = {
    id: issueID,
    description: updatedDescription
  };
  const responseJson = await apiRequest(
    mutation,
    accessToken,
    variables
  );
  return responseJson.issueUpdate.success;
}
async function getIssue2(accessToken, issueID) {
  const query = `
    query Issue($id: String!) {
      issue(id: $id) {
        title
        identifier
        url
        priorityLabel
        assignee {
          name
        }
        state {
          name
          type
        }
        team {
          organization {
            name
          }
        }
      }
    }`;
  const variables = {
    id: issueID
  };
  const responseJson = await apiRequest(
    query,
    accessToken,
    variables
  );
  return responseJson ? responseJson.issue : null;
}
async function createWebhook(accessToken, teamID, url6, resourceTypes, label = null) {
  try {
    const mutation = `
      mutation CreateWebhook($teamId: String!, $url: String!, $resourceTypes: [String!]!, $label: String) {
        webhookCreate(input:{
          label: $label
          teamId: $teamId
          url: $url
          resourceTypes: $resourceTypes
        }) {
          success
          webhook {
            id
            enabled
          }
        }
      }`;
    const variables = {
      teamId: teamID,
      url: url6,
      resourceTypes,
      label
    };
    const responseJson = await apiRequest(
      mutation,
      accessToken,
      variables
    );
    return responseJson ? responseJson.webhookCreate.success : null;
  } catch (e) {
    return null;
  }
}
async function getAllTeamsInUserOrg(accessToken) {
  const query = `
      query UserInfo {
        viewer {
          organization {
            teams {
              nodes {
                id
                name
              }
            }
          }
        }
      }`;
  const responseJson = await apiRequest(
    query,
    accessToken
  );
  return responseJson ? responseJson.viewer.organization.teams.nodes : null;
}

// server/src/public/routes/handlers/LinearAuthRedirectHandler.ts
async function LinearAuthRedirectHandler(req, res) {
  let logger = anonymousLogger();
  if (req.query["error"] === "access_denied") {
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=linear&message=cancelled`
    );
  }
  try {
    const codeAndState = getOAuthCodeAndState(req);
    const [code, { userID, orgID, type }] = codeAndState;
    logger = new Logger(Viewer.createLoggedInViewer(userID, orgID));
    if (type !== "linear") {
      throw new Error(`incorrect redirect type, received ${type}`);
    }
    const [accessToken, linearUserInfo] = await completeOAuthFlow3(code);
    const externalID = linearUserInfo.id;
    const externalEmail = linearUserInfo.email;
    const teams = linearUserInfo.teams.nodes;
    if (!teams) {
      throw new Error("Failed to find any Linear teams.");
    }
    const teamID = teams[0].id;
    if (!externalID || !externalEmail) {
      throw new Error("Linear user id or email not found.");
    }
    if (!teamID) {
      throw new Error("Linear user is not part of a team.");
    }
    const preferences = {
      teamID
    };
    const teamIDs = teams.map((teamInfo) => teamInfo.id);
    const url6 = `https://${API_SERVER_HOST_PRODUCTION}${LINEAR_EVENTS_PATH}`;
    const resourceTypes = ["Issue"];
    const label = "Created by Cord";
    await Promise.all(
      // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
      teamIDs.map(
        (teamID2) => createWebhook(accessToken, teamID2, url6, resourceTypes, label)
      )
    );
    await Promise.all([
      UserPreferenceEntity.upsert({
        userID,
        key: LINEAR_CONNECTION_PREFERENCES,
        value: preferences
      }),
      ThirdPartyConnectionEntity.upsert({
        userID,
        orgID,
        type,
        externalID,
        externalEmail,
        externalAuthData: {
          accessToken
        }
      })
    ]);
  } catch (e) {
    logger.logException(`LinearAuthRedirectHandler`, e);
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=linear&message=error`
    );
  }
  return res.redirect(`${APP_ORIGIN}/auth-complete.html#service=linear`);
}

// server/src/public/routes/handlers/AsanaEventApiHandler.ts
function AsanaEventApiHandler(req, res) {
  const webhookSecret = req.get("X-Hook-Secret");
  if (webhookSecret) {
    res.setHeader("X-Hook-Secret", webhookSecret);
    res.sendStatus(200);
    return;
  }
  res.sendStatus(200);
  void handleEvents(req.body["events"]);
}
async function handleEvents(events) {
  if (!events) {
    anonymousLogger().error(`asana events was null or undefined: ${events}`);
    return;
  }
  for (const event of events) {
    if (!event.resource) {
      anonymousLogger().warn("asana event without a resource", event);
      continue;
    }
    if (event.resource.resource_type !== "task") {
      continue;
    }
    if (event.change?.action === "changed" && event.change?.field === "completed") {
      const taskGID = event.resource.gid;
      const asanaUserGID = event.user.gid;
      await onAsanaUserChangedTaskStatus(asanaUserGID, taskGID);
    } else if (event.change?.action === "changed" && event.change?.field === "assignee") {
      const taskGID = event.resource.gid;
      const asanaAssignerGID = event.user.gid;
      const newAssigneeGID = event.change?.new_value?.gid;
      await onAsanaAssigneeChanged(asanaAssignerGID, taskGID, newAssigneeGID);
    }
  }
}

// server/src/third_party_tasks/trello/api.ts
import * as querystring from "querystring";
import { OAuth } from "oauth";
var requestURL = "https://trello.com/1/OAuthGetRequestToken";
var authorizeURL = "https://trello.com/1/OAuthAuthorizeToken";
var accessURL = "https://trello.com/1/OAuthGetAccessToken";
var appName = "Cord ";
var oauthTempSecrets = {};
var oauth = new OAuth(
  requestURL,
  accessURL,
  Env_default.TRELLO_APP_CLIENT_ID,
  Env_default.TRELLO_APP_CLIENT_SECRET,
  "1.0A",
  TRELLO_AUTH_REDIRECT_URL,
  "HMAC-SHA1"
);
var baseURL = "https://api.trello.com/1";
function getLoginURLWithRequestToken(req, res) {
  oauth.getOAuthRequestToken(function(error, token, tokenSecret) {
    if (error) {
      res.send(`Error occurred in OAuth request token: ${error}`);
    }
    const { state } = req.query;
    if (state) {
      oauthTempSecrets.state = state;
    } else {
      return res.send(
        // not sure what the error handling here should be
        `Error occurred in OAuth request token: state value not found`
      );
    }
    oauthTempSecrets.token = tokenSecret;
    return res.redirect(
      [
        authorizeURL,
        `?oauth_token=${token}`,
        `&name=${appName}`,
        `&scope=read,write,account`,
        `&expiration=never`
      ].join("")
    );
  });
}
async function completeOAuthFlow4(oauthToken, oauthVerifier) {
  const { accessToken, accessTokenSecret } = await getAccessTokenAndSecret(
    oauthToken,
    oauthVerifier
  );
  const state = oauthTempSecrets.state;
  const userResources = await getUserResources(accessToken);
  return [{ accessToken, accessTokenSecret }, state, userResources];
}
async function getAccessTokenAndSecret(oauthToken, oauthVerifier) {
  const tokenSecret = oauthTempSecrets.token;
  return await new Promise((resolve2, reject) => {
    oauth.getOAuthAccessToken(
      oauthToken,
      tokenSecret,
      oauthVerifier,
      function(error, accessToken, accessTokenSecret) {
        if (error) {
          reject(
            JSON.stringify({
              message: "Error occurred while getting access token",
              error
            })
          );
        } else {
          resolve2({ accessToken, accessTokenSecret });
        }
      }
    );
  });
}
async function getUserResources(accessToken) {
  const queryParams = querystring.stringify({
    fields: "organizations,boards,email",
    organizations: "all",
    organization_fields: "name,id",
    boards: "all",
    board_fields: "name, id",
    board_lists: "all"
  });
  const response = await fetch(`${baseURL}/members/me/?${queryParams}`, {
    method: "get",
    headers: generateRequestHeader(accessToken)
  });
  return await response.json();
}
async function createCard(accessToken, cardContent) {
  const queryParams = querystring.stringify(cardContent);
  const response = await fetch(`${baseURL}/cards/?${queryParams}`, {
    method: "post",
    headers: generateRequestHeader(accessToken)
  });
  const json = await response.json();
  if (json.errors) {
    anonymousLogger().error(`trello createCard`, json);
  }
  return json;
}
async function addMemberToCard(accessToken, cardID, memberID) {
  const memberQuery = querystring.stringify({ id: cardID, value: memberID });
  const response = await fetch(
    `${baseURL}/cards/${cardID}/idMembers/?${memberQuery}`,
    {
      method: "post",
      headers: generateRequestHeader(accessToken)
    }
  );
  return response.status === 200;
}
function generateRequestHeader(accessToken) {
  return {
    Accept: "application/json",
    Authorization: `OAuth oauth_consumer_key="${Env_default.TRELLO_APP_CLIENT_ID}", oauth_token="${accessToken}"`
  };
}

// server/src/public/routes/handlers/TrelloAuthHandlers.ts
async function TrelloAuthRedirectHandler(req, res) {
  let logger = anonymousLogger();
  if (req.query["error"] === "access_denied") {
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=trello&message=cancelled`
    );
  }
  try {
    const { oauth_token, oauth_verifier } = req.query;
    if (!oauth_token || !oauth_verifier) {
      throw new Error(`missing token or verifier`);
    }
    const [authData, state, userResources] = await completeOAuthFlow4(
      oauth_token,
      oauth_verifier
    );
    const { userID, orgID, type } = decodeViewerFromOAuthState(state);
    logger = new Logger(Viewer.createLoggedInViewer(userID, orgID));
    if (type !== "trello") {
      throw new Error(`incorrect redirect type, received ${type}`);
    }
    const { accessToken, accessTokenSecret } = authData;
    const { id, email, boards } = userResources;
    if (!id || !email) {
      throw new Error("Trello user id or email not found.");
    }
    const firstBoardWithList = boards.find((board) => board.lists.length > 1);
    if (!firstBoardWithList) {
      throw new Error("Trello user has no boards.");
    }
    const listID = firstBoardWithList.lists[0].id;
    await Promise.all([
      UserPreferenceEntity.upsert({
        userID,
        key: TRELLO_CONNECTED_LIST,
        value: listID
      }),
      ThirdPartyConnectionEntity.upsert({
        userID,
        orgID,
        type,
        externalID: id,
        externalEmail: email,
        externalAuthData: {
          accessToken,
          accessTokenSecret
        }
      })
    ]);
  } catch (e) {
    logger.logException(`TrelloAuthRedirectHandler`, e);
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=trello&message=error`
    );
  }
  return res.redirect(`${APP_ORIGIN}/auth-complete.html#service=trello`);
}
function TrelloAuthLoginHandler(req, res) {
  getLoginURLWithRequestToken(req, res);
}

// server/src/third_party_tasks/linear/util.ts
var import_types24 = __toESM(require_cjs(), 1);
var textNodeToMarkdown = (node) => {
  let wrapper = "";
  const [wsStart, middleText, wsEnd] = splitStringToWsAndText(node.text);
  if (node.bold) {
    wrapper += "**";
  }
  if (node.italic) {
    wrapper += "*";
  }
  if (node.underline) {
  }
  if (!middleText) {
    return "";
  }
  return wsStart + wrapper + middleText + wrapper + wsEnd;
};
var convertNodeToMarkdown = (node) => {
  if (node.type === void 0) {
    return textNodeToMarkdown(node);
  } else {
    switch (node.type) {
      case import_types24.MessageNodeType.LINK: {
        const nodeText = node.children[0].text;
        return `[${escapeLinkTextAndURL(nodeText)}](${escapeLinkTextAndURL(
          node.url
        )})`;
      }
      case import_types24.MessageNodeType.PARAGRAPH:
        return `${convertNodeListToMarkdown(node.children)}

`;
      case import_types24.MessageNodeType.TODO:
        return `* [ ] ${convertNodeListToMarkdown(node.children)}
`;
      case import_types24.MessageNodeType.BULLET:
        return `* ${convertNodeListToMarkdown(node.children)}
`;
      case import_types24.MessageNodeType.NUMBER_BULLET:
        return `1. ${convertNodeListToMarkdown(node.children)}
`;
      case import_types24.MessageNodeType.ASSIGNEE:
      case import_types24.MessageNodeType.MENTION:
        return node.children[0].text;
      case import_types24.MessageNodeType.QUOTE:
        return `> ${convertNodeListToMarkdown(node.children)}

`;
      case import_types24.MessageNodeType.CODE:
        return `\`${convertNodeListToMarkdown(node.children)}\``;
      case import_types24.MessageNodeType.MARKDOWN:
        return `\`${convertNodeListToMarkdown(node.children)}\``;
    }
  }
};
var convertNodeListToMarkdown = (nodes) => {
  const test = nodes ? nodes.map((node) => convertNodeToMarkdown(node)).join("") : null;
  return test;
};
var convertMessageContentToMarkdown = (messageContent, footer) => {
  return messageContent.map((node) => convertNodeToMarkdown(node)).join("") + "\n\n" + footer;
};
var escapeLinkTextAndURL = (text) => {
  return text.replace(/([()[\]])/g, "\\$1");
};

// server/src/third_party_tasks/linear/actions.ts
async function getLinearCredentials(viewer) {
  try {
    const { userID, orgID } = assertViewerHasIdentity(viewer);
    const key = cacheKey({ type: "linear_credentials", userID, orgID });
    let credentials2 = cache.get(key);
    if (credentials2 !== void 0) {
      return credentials2;
    }
    const externalData = await getExternalAuthData(viewer, "linear");
    if (externalData === null) {
      return null;
    }
    const { accessToken } = externalData;
    credentials2 = {
      accessToken
    };
    cache.set(key, credentials2, 315705599);
    return credentials2;
  } catch (e) {
    handleThirdPartyException("getLinearCredentials", e, "linear", viewer);
    return null;
  }
}
async function createLinearTask(viewer, task) {
  try {
    const credentials2 = await getLinearCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const preferences = await getTeamIDAndProjectID(viewer);
    if (!preferences) {
      return;
    }
    const { teamID, projectID } = preferences;
    if (!teamID) {
      return;
    }
    const message = await MessageEntity.findByPk(task.messageID);
    if (!message) {
      return;
    }
    const title = taskTitleFromMessageContent(message.content);
    let footerText = await getTaskFooterText(viewer, message, "linear");
    if (typeof footerText !== "string") {
      footerText = "";
    }
    const textMessage = convertMessageContentToMarkdown(
      message.content,
      footerText
    );
    const linearIssueID = await createIssue2(
      accessToken,
      teamID,
      title,
      textMessage,
      null,
      null,
      projectID
    );
    if (!linearIssueID) {
      throw new Error(`Failed to create a Linear task for task ${task.id}`);
    }
    const previewData = await getLinearIssuePreviewData(viewer, linearIssueID);
    const externalReference = await TaskThirdPartyReference.create({
      taskID: task.id,
      externalID: linearIssueID,
      externalConnectionType: "linear",
      externalLocationID: teamID,
      previewData
    });
    await publishMessageUpdateForTask(externalReference);
    if (task.done) {
      await updateLinearTask(viewer, externalReference, true);
    }
  } catch (e) {
    handleThirdPartyException("createLinearTask", e, "linear", viewer);
    return;
  }
}
async function addLinearTaskAttachments(viewer, issueID, files) {
  try {
    const credentials2 = await getLinearCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const s3BucketLoader = new S3BucketLoader(viewer);
    const attachmentData = await Promise.all(
      files.filter((file) => file.uploadStatus === "uploaded").map(async (file) => {
        const url6 = await file.getSignedDownloadURL(s3BucketLoader);
        const response = await fetch(url6);
        if (response.status === 200) {
          const assetUrl = await uploadFileToLinear(
            accessToken,
            file.name,
            file.mimeType,
            response.body,
            file.size
          );
          if (!assetUrl) {
            throw new Error(
              `Failed to upload file to Linear, error code ${response.status}`
            );
          }
          return {
            filename: file.name,
            assetUrl,
            contentType: file.mimeType
          };
        } else {
          throw new Error(
            `Failed to fetch upload. Error code:${response.status}`
          );
        }
      })
    );
    const attachmentsDescription = `

Attachments:
` + convertAttachmentDataToMarkdownLinks(
      // Filter out any undefined values in array.
      attachmentData.filter(
        (attachment) => attachment !== void 0
      )
    );
    const currentDescription = await getIssueDescription(issueID, accessToken);
    const updatedDescription = currentDescription + attachmentsDescription;
    await updateIssueDescription(issueID, accessToken, updatedDescription);
  } catch (e) {
    handleThirdPartyException("addLinearTaskAttachments", e, "linear", viewer);
    return;
  }
}
function convertAttachmentDataToMarkdownLinks(urls) {
  return urls.map((data) => {
    if (data.contentType.startsWith("image/")) {
      return `![${data.filename}](${encodeURI(data.assetUrl)})`;
    } else {
      return `[${data.filename}](${encodeURI(data.assetUrl)})`;
    }
  }).join("\n");
}
async function updateLinearTask(viewer, externalReference, done) {
  try {
    if (externalReference.externalConnectionType !== "linear") {
      throw new Error(
        `Expected connection type "linear" but got ${externalReference.externalConnectionType} instead.`
      );
    }
    const credentials2 = await getLinearCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const teamID = externalReference.externalLocationID;
    if (!teamID) {
      return;
    }
    const newState = done ? "completed" /* DONE */ : "unstarted" /* TODO */;
    await updateIssueState(
      accessToken,
      newState,
      externalReference.externalID,
      teamID
    );
    await updateLinearIssuePreviewData(viewer, externalReference);
  } catch (e) {
    handleThirdPartyException("updateLinearTask", e, "linear", viewer);
    return;
  }
}
async function getTeamIDAndProjectID(viewer) {
  const userID = assertViewerHasUser(viewer);
  const response = await UserPreferenceEntity.findOne({
    where: {
      userID,
      key: LINEAR_CONNECTION_PREFERENCES
    }
  });
  return response ? response.value : void 0;
}
async function getLinearUserTeamInfo(viewer) {
  try {
    const credentials2 = await getLinearCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const userInfo2 = await getUserInfo(accessToken);
    if (!userInfo2) {
      return;
    }
    return userInfo2.teams?.nodes;
  } catch (e) {
    handleThirdPartyException("getTeamIDFromPreferences", e, "linear", viewer);
    return;
  }
}
async function getLinearAssigneeAndSubscribers(viewer, accessToken, taskAssigneeUserIDs) {
  try {
    if (taskAssigneeUserIDs.length === 0) {
      return [[], []];
    }
    const { orgID } = assertViewerHasIdentity(viewer);
    const userLoader = new UserLoader(viewer, () => null);
    const users = await userLoader.loadUsersInOrg(taskAssigneeUserIDs, orgID);
    const linearUserIDs = await getLinearUserIDs(viewer, accessToken, users);
    const foundLinearUserIDs = linearUserIDs.filter(
      (linearID) => linearID !== void 0
    );
    const unmatchedUsers = users.filter((_user, i) => !linearUserIDs[i]);
    return [foundLinearUserIDs, unmatchedUsers];
  } catch (e) {
    handleThirdPartyException(
      "getLinearAssigneeAndSubscribers",
      e,
      "linear",
      viewer
    );
    return [[], []];
  }
}
async function getLinearUserIDs(viewer, accessToken, users) {
  try {
    const orgID = assertViewerHasOrg(viewer);
    const connections = await ThirdPartyConnectionEntity.findAll({
      where: {
        userID: users.map(({ id }) => id),
        orgID,
        type: "linear"
      }
    });
    const userIDToLinearID = new Map(
      connections.map((connection) => [
        connection.userID,
        connection.externalID
      ])
    );
    const linearUsers = await getUsersInOrg(accessToken);
    if (!linearUsers) {
      return [];
    }
    const emailToLinearID = new Map(
      linearUsers.map((linearUser) => [linearUser.email, linearUser.id])
    );
    return users.map((user) => {
      return userIDToLinearID.get(user.id) || (user.email ? emailToLinearID.get(user.email) : void 0);
    });
  } catch (e) {
    handleThirdPartyException("getLinearUserIDs", e, "linear", viewer);
    return [];
  }
}
function additionalTextForTask(unmatchedUsers) {
  if (unmatchedUsers.length === 0) {
    return "";
  }
  return [
    "This task was assigned to the following Cord users who do not have Linear connected:",
    ...unmatchedUsers.map((user) => `${userDisplayName(user)} (${user.email})`)
  ].join("\n");
}
async function updateLinearTaskAssigneeAndSubscribers(viewer, taskID, taskAssigneeUserIDs) {
  try {
    const credentials2 = await getLinearCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const thirdPartyReference = await TaskThirdPartyReference.findForTask(
      taskID,
      "linear"
    );
    if (!thirdPartyReference) {
      return;
    }
    const issueID = thirdPartyReference.externalID;
    const [foundLinearUserIDs, unmatchedUsers] = await getLinearAssigneeAndSubscribers(
      viewer,
      accessToken,
      taskAssigneeUserIDs
    );
    const [assigneeID, ...subscriberIDs] = foundLinearUserIDs;
    const currentDescription = await getIssueDescription(issueID, accessToken);
    const extraText = additionalTextForTask(unmatchedUsers);
    const updatedDescription = currentDescription + (extraText ? "\n\n" + extraText : "");
    await updateIssueAssigneeAndSubscribers(
      accessToken,
      issueID,
      assigneeID,
      subscriberIDs,
      updatedDescription
    );
    await updateLinearIssuePreviewData(viewer, thirdPartyReference);
  } catch (e) {
    handleThirdPartyException(
      "updateLinearTaskAssigneeAndSubscribers",
      e,
      "linear",
      viewer
    );
    return;
  }
}
async function createLinearSubtasks(viewer, taskID, todos) {
  try {
    const credentials2 = await getLinearCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const [preferences, task, thirdPartyReference] = await Promise.all([
      getTeamIDAndProjectID(viewer),
      TaskEntity.findByPk(taskID),
      TaskThirdPartyReference.findForTask(taskID, "linear")
    ]);
    if (!preferences || !task || !thirdPartyReference) {
      return;
    }
    const { teamID, projectID } = preferences;
    if (!teamID) {
      return;
    }
    const { messageID } = task;
    const message = await MessageEntity.findByPk(messageID);
    if (!message) {
      return;
    }
    const issueID = thirdPartyReference.externalID;
    const createdTodoIDs = new Set(todos.map((todo) => todo.id));
    const todoNodes = todoNodesFromMessage(message.content).filter(
      (node) => createdTodoIDs.has(node.todoID)
    );
    let footerText = await getTaskFooterText(viewer, message, "linear");
    if (typeof footerText !== "string") {
      footerText = "";
    }
    const description = convertMessageContentToMarkdown([], footerText);
    const linearSubIssueIDs = await Promise.all(
      todoNodes.map(
        (todoNode) => createIssue2(
          accessToken,
          teamID,
          textFromNodeRecursive(todoNode),
          description,
          null,
          issueID,
          projectID
        )
      )
    );
    const externalReferences = await Promise.all(
      linearSubIssueIDs.map((linearSubIssueID, i) => {
        if (!linearSubIssueID) {
          return;
        }
        return TaskThirdPartyReference.create({
          taskID,
          externalID: linearSubIssueID,
          externalConnectionType: "linear",
          taskTodoID: todoNodes[i].todoID,
          externalLocationID: teamID,
          previewData: null
        });
      })
    );
    const filteredExternalReferences = externalReferences.filter(
      (externalReference) => externalReference !== void 0
    );
    await Promise.all(
      todoNodes.map((todoNode, i) => {
        if (!todos.find(({ id }) => todoNode.todoID === id)?.done) {
          return null;
        }
        const externalReference = filteredExternalReferences.find(
          // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
          (externalReference2) => externalReference2.externalID === linearSubIssueIDs[i]
        );
        if (!externalReference) {
          return null;
        }
        return updateLinearTask(viewer, externalReference, true);
      })
    );
  } catch (e) {
    handleThirdPartyException("createLinearSubtasks", e, "linear", viewer);
    return;
  }
}
async function updateLinearIssuePreviewData(viewer, externalReference) {
  if (!externalReference.taskTodoID) {
    const issueID = externalReference.externalID;
    const previewData = await getLinearIssuePreviewData(viewer, issueID);
    await externalReference.update({ previewData });
    await publishMessageUpdateForTask(externalReference);
  }
}
async function getLinearIssuePreviewData(viewer, issueID) {
  const credentials2 = await getLinearCredentials(viewer);
  if (!credentials2) {
    return null;
  }
  const { accessToken } = credentials2;
  const issue = await getIssue2(accessToken, issueID);
  if (!issue) {
    return null;
  }
  return {
    title: issue.title,
    identifier: issue.identifier,
    url: issue.url,
    assignee: issue.assignee?.name,
    priority: issue.priorityLabel,
    status: issue.state.name,
    done: issue.state.type === "completed" /* DONE */,
    orgName: issue.team.organization.name
  };
}
async function handleAssigneeChange(externalTaskID, assigneeID, previousAssigneeID, assignee) {
  try {
    const entities = await findTaskAndMessageEntitiesFromExternalTaskID(
      externalTaskID,
      "linear"
    );
    if (!entities) {
      return;
    }
    const { taskEntity, messageEntity, thirdPartyTaskEntity } = entities;
    const taskID = taskEntity.id;
    const { orgID } = messageEntity;
    if (previousAssigneeID) {
      const thirdPartyConnection = await ThirdPartyConnectionEntity.findOne({
        where: { externalID: previousAssigneeID, orgID }
      });
      if (!thirdPartyConnection) {
        anonymousLogger().info(`Could not find Linear user as a Cord user`);
      } else {
        const { userID } = thirdPartyConnection;
        await TaskAssigneeEntity.destroy({ where: { taskID, userID, orgID } });
      }
    }
    if (assigneeID) {
      const thirdPartyConnection = await ThirdPartyConnectionEntity.findOne({
        where: { externalID: assigneeID, orgID }
      });
      if (!thirdPartyConnection) {
        anonymousLogger().info(`Could not find Linear user as a Cord user`);
      } else {
        const { userID } = thirdPartyConnection;
        const taskAssigneeEntity = await TaskAssigneeEntity.findOne({
          where: { taskID, userID, orgID }
        });
        if (!taskAssigneeEntity) {
          await TaskAssigneeEntity.create({ taskID, userID, orgID });
        }
      }
    }
    const previewData = thirdPartyTaskEntity.previewData;
    if (previewData) {
      await thirdPartyTaskEntity.update({
        previewData: {
          ...previewData,
          assignee: assignee ? assignee.name : null
        }
      });
      await publishMessageUpdateForTask(thirdPartyTaskEntity);
    }
  } catch (e) {
    anonymousLogger().logException("handleAssigneeChange", e);
  }
}
function hasAssigneeChanged(prevAssignee, newAssignee) {
  const isNewAssigneeOnUnassignedTask = newAssignee && prevAssignee === null;
  const isTaskBeingUnassigned = newAssignee === void 0 && prevAssignee;
  const isAssigneeBeingReplaced = newAssignee && prevAssignee;
  return isNewAssigneeOnUnassignedTask || isTaskBeingUnassigned || isAssigneeBeingReplaced;
}
async function handleIssueStatusChange(externalTaskID, newIssueState, stateIssueName) {
  try {
    const entities = await findTaskAndMessageEntitiesFromExternalTaskID(
      externalTaskID,
      "linear"
    );
    if (!entities) {
      return;
    }
    const { taskEntity, thirdPartyTaskEntity } = entities;
    await taskEntity.update({
      done: newIssueState === "completed" /* DONE */
    });
    const previewData = thirdPartyTaskEntity.previewData;
    if (previewData) {
      await thirdPartyTaskEntity.update({
        previewData: {
          ...previewData,
          done: newIssueState === "completed" /* DONE */,
          status: stateIssueName
        }
      });
      await publishMessageUpdateForTask(thirdPartyTaskEntity);
    }
  } catch (e) {
    anonymousLogger().logException("handleIssueStatusChange", e);
  }
}
async function canUserEditTask(accessToken, taskTeamID, viewer) {
  try {
    const teams = await getAllTeamsInUserOrg(accessToken);
    if (!teams) {
      return false;
    }
    const matchedTeam = teams.some((team) => team.id === taskTeamID);
    return matchedTeam;
  } catch (e) {
    handleThirdPartyException("canUserEditTask", e, "linear", viewer);
    return false;
  }
}

// server/src/public/routes/handlers/LinearEventApiHandler.ts
var LINEAR_IP_ADDRESSES = ["35.231.147.226", "35.243.134.228"];
async function LinearEventApiHandler(req, res) {
  const payload = req.body;
  anonymousLogger().debug("LinearEventApiHandler", { linearEvent: payload });
  const requestFromIp = req.get("x-forwarded-for");
  if (process.env.NODE_ENV !== "development" && (!requestFromIp || !LINEAR_IP_ADDRESSES.includes(requestFromIp))) {
    anonymousLogger().error("LinearEventApiHandler", {
      linearEvent: payload,
      message: "ip address does not match linear ones"
    });
    res.sendStatus(403);
    return;
  }
  res.sendStatus(200);
  await handleLinearEvent(payload);
}
async function handleLinearEvent(event) {
  const { action, data, updatedFrom, type } = event;
  if (type !== "Issue") {
    return;
  }
  if (action === "update") {
    if (hasAssigneeChanged(updatedFrom.assigneeId, data.assigneeId)) {
      return await handleAssigneeChange(
        data.id,
        data.assigneeId,
        updatedFrom.assigneeId,
        data.assignee
      );
    }
    if (updatedFrom.stateId) {
      return await handleIssueStatusChange(
        data.id,
        data.state.type,
        data.state.name
      );
    }
  }
  return;
}

// server/src/public/routes/middleware/PlatformErrorHandler.ts
function PlatformErrorHandler(error, req, res, _next) {
  anonymousLogger().logException(
    "Platform",
    error,
    {
      appID: req.appID,
      endpoint: `${req.method} ${req.path}`,
      payload: req.body
    },
    void 0,
    "info"
  );
  if (error instanceof ApiCallerError) {
    return res.status(error.statusCode || 400).send({
      error: error.name,
      message: error.message,
      ...process.env.NODE_ENV === "development" && !process.env.IS_TEST && error.stack && {
        stack: error.stack.split("\n").map((line) => line.trim())
      }
    });
  }
  anonymousLogger().logException(
    "a non platform error was thrown in platform endpoint",
    error,
    {
      appID: req.appID,
      endpoint: `${req.method} ${req.path}`
    }
  );
  return res.status(500).send({
    error: "error",
    message: "internal server error",
    ...process.env.NODE_ENV === "development" && !process.env.IS_TEST && hasStack(error) && {
      stack: error.stack.split("\n").map((line) => line.trim())
    }
  });
}
function hasStack(error) {
  if (typeof error === "object" && error !== null && "stack" in error) {
    return typeof error.stack === "string";
  }
  return false;
}

// server/src/public/routes/platform/APIAuthorizeHandler.ts
import isUUID7 from "validator/lib/isUUID.js";
import isJWT2 from "validator/lib/isJWT.js";
import { sign as sign3, verify as verify5, decode as decode2 } from "jsonwebtoken";
import { Sequelize as Sequelize13 } from "sequelize";

// common/const/IntegrationAPI.ts
var ACCESS_TOKEN_TTL_HOURS = 24;

// server/src/logging/deprecate.ts
var counter5 = Counter2({
  name: "DeprecatedCode",
  help: "Tracks how often deprecated code is executed",
  labelNames: ["label", "appID"]
});
function deprecated(label, appID) {
  counter5.inc({ label, appID: appID ?? "unspecified" });
}
function deprecatedFunction(func, label) {
  return (...args) => {
    deprecated(
      label,
      // If this is a GraphQL resolver (very common), try to extract the appID
      // from the viewer
      args[2]?.session?.viewer?.platformApplicationID ?? void 0
    );
    return func(...args);
  };
}

// server/src/public/routes/platform/APIAuthorizeHandler.ts
function validateTokenData(data) {
  if (!(data instanceof Object)) {
    throw createInvalidInputTypeMessage("signed_app_token payload", "object");
  }
  const { app_id } = data;
  if (!app_id) {
    throw "signed_app_token payload is missing app_id.";
  }
  if (typeof app_id !== "string" || !isUUID7.default(app_id)) {
    throw createInvalidInputTypeMessage("app_id", "UUID");
  }
  if ("user_id" in data || "org_id" in data) {
    throw "signed_app_token payload invalid, must contain only app_id";
  }
  return { app_id };
}
async function authorizeHandler(req, res) {
  deprecated("/v1/authorize");
  const { signed_app_token } = validateInput(req.body, {
    required: {
      signed_app_token: (value) => typeof value === "string" && isJWT2.default(value) || "JWT"
    }
  });
  let decodedSignedAppToken;
  try {
    const data = decode2(signed_app_token);
    decodedSignedAppToken = validateTokenData(data);
    const application = await ApplicationEntity.findByPk(
      decodedSignedAppToken.app_id
    );
    if (!application) {
      throw new ApiCallerError("project_not_found");
    }
    verify5(signed_app_token, application.sharedSecret, {
      clockTolerance: ACCESS_TOKEN_CLOCK_TOLERANCE_SECONDS,
      maxAge: `${ACCESS_TOKEN_MAX_AGE_SECONDS}s`,
      algorithms: ["HS512"]
    });
  } catch (e) {
    if (e instanceof ApiCallerError) {
      throw e;
    } else {
      throw new ApiCallerError("invalid_project_token", { message: e });
    }
  }
  const { app_id } = decodedSignedAppToken;
  const session = await SessionEntity.create({
    applicationID: app_id,
    expiresAt: Sequelize13.literal(
      `NOW() + INTERVAL '${ACCESS_TOKEN_TTL_HOURS} hours'`
    )
  });
  const payload = {
    session_id: session.id
  };
  const accessToken = sign3(payload, Env_default.JWT_SIGNING_SECRET, {
    expiresIn: `${ACCESS_TOKEN_TTL_HOURS}h`,
    algorithm: "HS512"
  });
  return res.json({
    access_token: accessToken,
    expires: session.expiresAt.toISOString()
  });
}
var APIAuthorizeHandler_default = forwardHandlerExceptionsToNext(authorizeHandler);

// server/src/public/routes/platform/orgs/ListPlatformOrganizationsHandler.ts
async function listPlatformOrganizationsHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const orgs = await OrgEntity.findAll({
    where: {
      externalProvider: "platform" /* PLATFORM */,
      platformApplicationID
    }
  });
  const orgsConnectedToSlack = await LinkedOrgsEntity.findAll({
    where: {
      sourceOrgID: orgs.map((org) => org.id)
    }
  });
  const orgsConnectedToSlackSet = new Set(
    orgsConnectedToSlack.map((org) => org.sourceOrgID)
  );
  const orgsData = orgs.map((org) => ({
    id: org.externalID,
    name: org.name,
    status: org.state === "inactive" ? "deleted" : "active",
    connectedToSlack: orgsConnectedToSlackSet.has(org.id),
    metadata: org.metadata
  }));
  return res.status(200).json(orgsData);
}
var ListPlatformOrganizationsHandler_default = forwardHandlerExceptionsToNext(listPlatformOrganizationsHandler);

// server/src/public/routes/platform/orgs/GetPlatformOrganizationHandler.ts
async function getPlatformOrganizationHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.orgID;
  if (!externalID) {
    throw new ApiCallerError("group_not_found");
  }
  if (!isValidExternalID(externalID)) {
    throw new ApiCallerError("invalid_request");
  }
  const org = await OrgEntity.findOne({
    where: {
      externalID,
      externalProvider: "platform" /* PLATFORM */,
      platformApplicationID
    }
  });
  if (!org) {
    throw new ApiCallerError("group_not_found", { code: 404 });
  }
  const linkedOrg = await LinkedOrgsEntity.findOne({
    where: { sourceOrgID: org.id }
  });
  const members = await OrgMembersEntity.findAll({
    where: {
      orgID: org.id
    }
  });
  const users = await UserEntity.findAll({
    where: {
      id: members.map((m) => m.userID),
      externalProvider: "platform" /* PLATFORM */,
      platformApplicationID
    }
  });
  const userExternalIDs = new Set(
    users.map((u) => u.externalID).filter(isNotNull)
  );
  const response = {
    id: org.externalID,
    name: org.name,
    status: org.state === "inactive" ? "deleted" : "active",
    members: [...userExternalIDs],
    connectedToSlack: Boolean(linkedOrg),
    metadata: org.metadata
  };
  return res.status(200).json(response);
}
var GetPlatformOrganizationHandler_default = forwardHandlerExceptionsToNext(getPlatformOrganizationHandler);

// server/src/public/routes/platform/orgs/CreatePlatformOrganizationsHandler.ts
function validateCreateOrganizationInput(data) {
  const validatedInput = validate.CreatePlatformOrganizationVariables(data);
  validateExternalID(validatedInput.id, "id");
  return validatedInput;
}
async function createOrganizationHandler(req, res) {
  const {
    id,
    // This is the externalID but can be type string or number
    name,
    status,
    members,
    metadata,
    ...rest
  } = validateCreateOrganizationInput(req.body);
  const _ = rest;
  const externalID = id.toString();
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  deprecated("api: POST /v1/organizations", platformApplicationID);
  const org = await OrgEntity.findOne({
    where: {
      externalID,
      externalProvider: "platform" /* PLATFORM */,
      platformApplicationID
    }
  });
  if (org) {
    throw new ApiCallerError("organization_already_exists", {
      message: `The platform organization with id ${org.externalID} already exists, to update organization please make a PUT request to organizations/<ORGANIZATION_ID>.`
    });
  }
  const addedMembers = [];
  let newOrg;
  await getSequelize().transaction(async (transaction) => {
    newOrg = await createPlatformOrganization(
      platformApplicationID,
      externalID,
      name,
      status,
      metadata,
      transaction
    );
    if (!newOrg) {
      throw new Error("Could not create organization");
    }
    if (members) {
      const { added } = await updatePlatformOrganizationMembers(
        newOrg,
        members,
        transaction
      );
      addedMembers.push(...added);
    }
    const application = await ApplicationEntity.findByPk(
      platformApplicationID,
      { transaction }
    );
    if (await application?.isSupportChatEnabled()) {
      await OrgMembersEntity.create(
        {
          userID: application.supportBotID,
          orgID: newOrg.id
        },
        { transaction }
      );
    }
  });
  addedMembers.map((userID) => {
    backgroundPromise(publishPubSubEvent("user-identity", { userID }));
    backgroundPromise(
      publishPubSubEvent("org-member-added", { orgID: newOrg.id }, { userID })
    );
  });
  return res.status(201).json({
    success: true,
    message: `\u2705 You successfully created organization ${externalID}`
  });
}
var CreatePlatformOrganizationsHandler_default = forwardHandlerExceptionsToNext(createOrganizationHandler);

// server/src/util/AsyncChannel.ts
var AsyncChannel = class {
  constructor() {
    this.queuedItems = [];
    this.waitingListeners = [];
  }
  push(t) {
    const waitingListener = this.waitingListeners.shift();
    if (waitingListener) {
      waitingListener({ done: false, value: t });
    } else {
      this.queuedItems.push(t);
    }
  }
  next() {
    if (this.queuedItems.length) {
      return Promise.resolve({ done: false, value: this.queuedItems.shift() });
    } else {
      return new Promise((resolve2) => this.waitingListeners.push(resolve2));
    }
  }
  takeAll() {
    const { queuedItems } = this;
    this.queuedItems = [];
    return queuedItems;
  }
  return() {
    const listeners = this.waitingListeners;
    this.waitingListeners = [];
    listeners.forEach((resolve2) => resolve2({ done: true, value: void 0 }));
  }
  iter() {
    const iter = {
      next: async () => await this.next(),
      return: async () => ({ value: void 0, done: true }),
      throw: async () => ({ value: void 0, done: true }),
      [Symbol.asyncIterator]: () => iter
    };
    return iter;
  }
  [Symbol.asyncIterator]() {
    return this.iter();
  }
};

// server/src/public/subscriptions/util/live_query.ts
var NO_VALUE = Symbol("NO_OUTPUT");
async function liveQuery(events, initialData, eventData) {
  const channel = new AsyncChannel();
  const pubSubSubscriptions = [];
  for (const event of events) {
    pubSubSubscriptions.push(
      await subscribeToPubSubEvent(
        event[0],
        event[1],
        (e) => channel.push(e)
      )
    );
  }
  let running = true;
  const shutdown = async () => {
    if (running) {
      running = false;
      channel.return();
      pubSubSubscriptions.map(
        (subscription) => unsubscribeFromPubSub(subscription)
      );
    }
  };
  let firstCall = true;
  const iterator = {
    async next() {
      if (!running) {
        return { done: true, value: void 0 };
      }
      if (firstCall) {
        firstCall = false;
        const result2 = await initialData();
        if (result2 !== NO_VALUE) {
          return { done: false, value: result2 };
        }
      }
      const event = await channel.next();
      if (event.done) {
        await shutdown();
        return event;
      }
      const result = await eventData(event.value);
      if (result !== NO_VALUE) {
        return { done: false, value: result };
      }
      return await this.next();
    },
    async return() {
      await shutdown();
      return { done: true, value: void 0 };
    },
    async throw(error) {
      await shutdown();
      throw error;
    }
  };
  return {
    [Symbol.asyncIterator]() {
      return iterator;
    }
  };
}

// server/src/public/subscriptions/util/with_filter.ts
import { withFilter as originalWithFilter } from "graphql-subscriptions";
function withFilter(asyncIteratorFn, filterFn) {
  return originalWithFilter(asyncIteratorFn, filterFn);
}

// server/src/public/subscriptions/util/restart_subscription.ts
var RESTART_SUBSCRIPTION_ERROR = "restart-subscription";
function maybeRestartSubscription(event, operationName) {
  if (event.name === "restart-subscription") {
    throw new Error(RESTART_SUBSCRIPTION_ERROR, { cause: operationName });
  }
}
function restartSomeUserSubscriptions(userIDs) {
  userIDs.forEach(
    (userID) => backgroundPromise(publishPubSubEvent("restart-subscription", { userID }))
  );
}
function withRestartEvent({
  events,
  userID,
  subscriptionName
}) {
  return withFilter(
    () => {
      const restartEvent = [
        "restart-subscription",
        { userID }
      ];
      const eventsIncRestart = [...events, restartEvent];
      return pubSubAsyncIterator(...eventsIncRestart);
    },
    (event) => {
      maybeRestartSubscription(event, subscriptionName);
      return true;
    }
  );
}
async function liveQueryWithRestartEvent({
  events,
  initialData,
  eventData,
  userID,
  subscriptionName
}) {
  return await liveQuery(
    [...events, ["restart-subscription", { userID }]],
    initialData,
    (event) => {
      maybeRestartSubscription(event, subscriptionName);
      return eventData(event);
    }
  );
}

// server/src/public/routes/platform/orgs/UpdatePlatformOrganizationsHandler.ts
async function updateOrganizationHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.orgID;
  const { isCreated } = await updateOrganization(
    platformApplicationID,
    externalID,
    req.body
  );
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully ${isCreated ? "created" : "updated"} group ${externalID}`
  });
}
async function updateOrganization(platformApplicationID, externalID, data) {
  validateExternalID(externalID, "orgID");
  const application = await ApplicationEntity.findByPk(platformApplicationID);
  const { name, status, members, metadata, ...rest } = validate.UpdatePlatformGroupVariables(data);
  const _ = rest;
  const org = await OrgEntity.findOne({
    where: {
      externalID,
      externalProvider: "platform" /* PLATFORM */,
      platformApplicationID
    }
  });
  let addedMembers = [];
  let deletedMembers = [];
  let newOrg;
  if (org) {
    await getSequelize().transaction(async (transaction) => {
      await OrgEntity.update(
        { name, state: status === "deleted" ? "inactive" : "active", metadata },
        {
          where: {
            externalID,
            externalProvider: "platform" /* PLATFORM */,
            platformApplicationID
          },
          transaction
        }
      );
      if (members) {
        const { added, deleted } = await updatePlatformOrganizationMembers(
          org,
          members,
          transaction
        );
        addedMembers = added;
        deletedMembers = deleted;
      }
      if (await application?.isSupportChatEnabled()) {
        await OrgMembersEntity.upsert(
          {
            userID: application.supportBotID,
            orgID: org.id
          },
          { transaction }
        );
      }
    });
  } else {
    if (!name) {
      throw new ApiCallerError("missing_field", {
        message: 'Invalid UpdatePlatformGroupVariables:\nGroup does not exist, "name" is a required field to create a new group.' + (getSchemaDescription("UpdatePlatformOrganizationVariables") ?? "")
      });
    }
    await getSequelize().transaction(async (transaction) => {
      newOrg = await createPlatformOrganization(
        platformApplicationID,
        externalID,
        name,
        status,
        metadata,
        transaction
      );
      if (members) {
        const { added } = await updatePlatformOrganizationMembers(
          newOrg,
          members,
          transaction
        );
        addedMembers = added;
      }
      if (await application?.isSupportChatEnabled()) {
        await OrgMembersEntity.create(
          {
            userID: application.supportBotID,
            orgID: newOrg.id
          },
          { transaction }
        );
      }
      const orgsCount = await OrgEntity.count({
        where: { platformApplicationID }
      });
      if (orgsCount === 0) {
        transaction.afterCommit(async () => {
          await publishPubSubEvent("console-getting-started-updated", {
            applicationID: platformApplicationID
          });
        });
      }
    });
  }
  if (org?.id !== "ac2ba2c5-f4ad-425b-ab53-2a0970c0b5cc") {
    restartSomeUserSubscriptions([...addedMembers, ...deletedMembers]);
  }
  addedMembers.forEach((userID) => {
    backgroundPromise(publishPubSubEvent("user-identity", { userID }));
    backgroundPromise(
      publishPubSubEvent(
        "org-member-added",
        { orgID: org?.id ?? newOrg.id },
        { userID }
      )
    );
  });
  deletedMembers.forEach((userID) => {
    backgroundPromise(publishPubSubEvent("user-identity", { userID }));
    backgroundPromise(
      publishPubSubEvent(
        "org-member-removed",
        { orgID: org?.id ?? newOrg.id },
        { userID }
      )
    );
  });
  return { isCreated: !org };
}
var UpdatePlatformOrganizationsHandler_default = forwardHandlerExceptionsToNext(updateOrganizationHandler);

// server/src/public/routes/platform/org_members/UpdatePlatformOrganizationMembersHandler.ts
import { QueryTypes as QueryTypes18 } from "sequelize";
function validateAllContained(ids, users) {
  const toFind = new Set(ids);
  for (const p of users) {
    toFind.delete(p.externalID);
  }
  if (toFind.size !== 0) {
    throw new ApiCallerError("user_not_found", {
      // Todo - this doesn't make sense in all the contexts this fn is called
      message: `Platform user ${toFind.values().next().value} not found. If you wanted to create a new user, add user_details to your request. Refer to https://docs.cord.com/reference/authentication#JSON-user-details for details.`
    });
  }
}
async function updateOrganizationMembersHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.orgID;
  await updateOrganizationMembers(platformApplicationID, externalID, req.body);
  return res.status(200).json({
    success: true,
    message: "\u2705 You successfully updated group members"
  });
}
async function updateOrganizationMembers(platformApplicationID, externalID, data) {
  const org = await OrgEntity.findOne({
    where: {
      externalID,
      externalProvider: "platform" /* PLATFORM */,
      platformApplicationID
    }
  });
  if (!org) {
    throw new ApiCallerError("group_not_found", {
      message: `Platform group ${externalID} not found. If you wanted to create a new group, add group_details to your request. Refer to https://docs.cord.com/reference/authentication#JSON-group-details for details.`
    });
  }
  const {
    add: origAdd,
    remove: origRemove,
    ...rest
  } = validate.UpdatePlatformGroupMembersVariables(data);
  const _ = rest;
  const add2 = origAdd?.map((member) => member.toString()) ?? [];
  const remove2 = origRemove?.map((member) => member.toString()) ?? [];
  if (add2.some((x) => remove2.includes(x))) {
    const duplicated = add2.find((x) => remove2.includes(x));
    throw new ApiCallerError("invalid_field", {
      message: `Platform member ${duplicated} both added and removed.`
    });
  }
  const [added, removed] = await getSequelize().transaction(
    async (transaction) => {
      const users = await UserEntity.findAll({
        where: {
          externalID: [...add2, ...remove2],
          platformApplicationID: org.platformApplicationID,
          externalProvider: "platform" /* PLATFORM */
        },
        transaction
      });
      validateAllContained(add2, users);
      validateAllContained(remove2, users);
      const usersToAdd = users.filter((user) => add2.includes(user.externalID));
      const usersToDelete = users.filter(
        (user) => remove2.includes(user.externalID)
      );
      const [insertResult, deleteResult] = await Promise.all([
        usersToAdd.length > 0 ? (
          // NOTE(flooey): We can't really use bind variables here, which would
          // be safer, but these are internal IDs, so they are always UUIDs and
          // can't cause SQL injection problems
          getSequelize().query(
            `
              INSERT INTO org_members VALUES ${usersToAdd.map((user) => `('${user.id}', '${org.id}')`).join(",")}
              ON CONFLICT DO NOTHING
              RETURNING "userID"
            `,
            { transaction, type: QueryTypes18.RAW }
          )
        ) : Promise.resolve([[], 0]),
        usersToDelete.length > 0 ? getSequelize().query(
          `
          DELETE FROM org_members
            WHERE "orgID" = $1
              AND "userID" = ANY($2)
            RETURNING "userID"
        `,
          {
            transaction,
            type: QueryTypes18.RAW,
            bind: [org.id, usersToDelete.map((user) => user.id)]
          }
        ) : Promise.resolve([[], 0])
      ]);
      const actuallyAdded = insertResult[0];
      const actuallyRemoved = deleteResult[0];
      return [
        actuallyAdded.map((u) => u.userID),
        actuallyRemoved.map((u) => u.userID)
      ];
    }
  );
  const operationID = asyncLocalStorage?.getStore()?.operationID;
  anonymousLogger().debug("UpdatePlatformOrganizationMembers stats", {
    appID: platformApplicationID,
    added: added.length,
    removed: removed.length,
    ...operationID && { operationID }
  });
  restartSomeUserSubscriptions([...added, ...removed]);
  const app = await ApplicationEntity.findByPk(platformApplicationID);
  if (app?.customerID !== "43fdeae8-4b68-4e36-a58d-56085f8e2497") {
    added.map((userID) => {
      backgroundPromise(publishPubSubEvent("user-identity", { userID }));
      backgroundPromise(
        publishPubSubEvent("org-member-added", { orgID: org.id }, { userID })
      );
    });
    removed.map((userID) => {
      backgroundPromise(publishPubSubEvent("user-identity", { userID }));
      backgroundPromise(
        publishPubSubEvent("org-member-removed", { orgID: org.id }, { userID })
      );
    });
  }
}
var UpdatePlatformOrganizationMembersHandler_default = forwardHandlerExceptionsToNext(updateOrganizationMembersHandler);

// server/src/public/routes/platform/users/ListPlatformUsersHandler.ts
import { Op as Op18 } from "sequelize";

// server/src/public/routes/platform/validateQuery.ts
function validateFilter(query, accept) {
  const { filter } = query;
  const result = {};
  if (filter) {
    let filterJson = {};
    try {
      filterJson = JSON.parse(filter);
    } catch (e) {
      throw new ApiCallerError("invalid_field", {
        message: "The filter object must be a valid JSON object."
      });
    }
    if (typeof filterJson !== "object") {
      throw new ApiCallerError("invalid_field", {
        message: "The filter object must be a valid JSON object."
      });
    }
    const {
      location,
      metadata,
      authorID,
      firstMessageTimestamp,
      mostRecentMessageTimestamp,
      groupID,
      organizationID,
      resolvedStatus,
      viewer,
      ...otherFilters
    } = filterJson;
    if (Object.keys(otherFilters).length > 0) {
      const someBadField = Object.keys(otherFilters)[0];
      throw new ApiCallerError("invalid_field", {
        message: `The filter object does not support "${someBadField}" as a field.`
      });
    }
    if (location) {
      if (!accept.location) {
        throw new ApiCallerError("invalid_field", {
          message: `The filter object does not support "location" as a field.`
        });
      }
      const parsedLocation = getLocationFilter(location);
      if (!parsedLocation) {
        throw new ApiCallerError("invalid_field", {
          message: `"location" must be valid JSON. See https://docs.cord.com/reference/location for more information.`
        });
      }
      result["location"] = parsedLocation;
    }
    if (metadata) {
      if (!accept.metadata) {
        throw new ApiCallerError("invalid_field", {
          message: `The filter object does not support "metadata" as a field.`
        });
      }
      if (!isValidMetadata(metadata)) {
        throw new ApiCallerError("invalid_field", {
          message: `"metadata" must be valid JSON.`
        });
      }
      result["metadata"] = metadata;
    }
    if (firstMessageTimestamp) {
      if (!accept.firstMessageTimestamp) {
        throw new ApiCallerError("invalid_field", {
          message: `The filter object does not support "firstMessageTimestamp" as a field.`
        });
      }
      const validatedTimestampRange = validateTimestampRange(
        firstMessageTimestamp,
        "firstMessageTimestamp"
      );
      result["firstMessageTimestamp"] = validatedTimestampRange;
    }
    if (mostRecentMessageTimestamp) {
      if (!accept.mostRecentMessageTimestamp) {
        throw new ApiCallerError("invalid_field", {
          message: `The filter object does not support "mostRecentMessageTimestamp" as a field.`
        });
      }
      const validatedTimestampRange = validateTimestampRange(
        mostRecentMessageTimestamp,
        "mostRecentMessageTimestamp"
      );
      result["mostRecentMessageTimestamp"] = validatedTimestampRange;
    }
    if (organizationID) {
      if (typeof organizationID !== "string") {
        throw new ApiCallerError("invalid_field", {
          message: `"groupID" is not valid`
        });
      }
      result["groupID"] = organizationID;
    }
    if (groupID) {
      if (typeof groupID !== "string") {
        throw new ApiCallerError("invalid_field", {
          message: `"groupID" is not valid`
        });
      }
      result["groupID"] = groupID;
    }
    if (authorID) {
      if (!accept.authorID) {
        throw new ApiCallerError("invalid_field", {
          message: `The filter object does not support "authorID" as a field.`
        });
      }
      if (typeof authorID !== "string") {
        throw new ApiCallerError("invalid_field", {
          message: `"authorID" is not valid.`
        });
      }
      result["authorID"] = authorID;
    }
    if (resolvedStatus) {
      if (!accept.resolvedStatus) {
        throw new ApiCallerError("invalid_field", {
          message: `The filter object does not support "resolvedStatus" as a field.`
        });
      }
      if (typeof resolvedStatus !== "string") {
        throw new ApiCallerError("invalid_field", {
          message: `"resolvedStatus" must be set to "any", "resolved", or "unresolved"`
        });
      }
      if (resolvedStatus !== "any" && resolvedStatus !== "resolved" && resolvedStatus !== "unresolved") {
        throw new ApiCallerError("invalid_field", {
          message: `"resolvedStatus" must be set to "any", "resolved", or "unresolved"`
        });
      }
      result["resolvedStatus"] = resolvedStatus;
    }
    if (viewer) {
      if (!accept.viewer) {
        throw new ApiCallerError("invalid_field", {
          message: `The filter object does not support "viewer" as a field.`
        });
      }
      if (typeof viewer !== "string" && !Array.isArray(viewer)) {
        throw new ApiCallerError("invalid_field", {
          message: `"viewer" must be one or more of "subscribed" or "mentioned"`
        });
      }
      const parsedViewer = getViewerThreadFilter(viewer);
      if (parsedViewer.some((v) => v !== "subscribed" && v !== "mentioned")) {
        throw new ApiCallerError("invalid_field", {
          message: `"viewer" must be one or more of "subscribed" or "mentioned"`
        });
      }
      result["viewer"] = parsedViewer;
    }
  }
  return result;
}
function validateTimestampRange(obj, field) {
  if (!obj || typeof obj !== "object" || Array.isArray(obj)) {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" must be valid JSON object.`
    });
  }
  const { from, to, ...otherFields } = obj;
  const timerangeFields = ["from", "to"];
  if (Object.keys(otherFields).length > 0) {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" object must only contain the fields: ${combine(
        "and",
        timerangeFields
      )}}`
    });
  }
  if (from === void 0 && to === void 0) {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" object must contain at least one of the ${timerangeFields.length} optional fields: ${combine("or", timerangeFields)}`
    });
  }
  const validatedObject = {};
  for (const [property, value] of Object.entries(obj)) {
    if (!value || typeof value !== "string" && typeof value !== "number") {
      throw new ApiCallerError("invalid_field", {
        message: `"${property}" value on "${field}" must be a valid date`
      });
    }
    const dateValue = new Date(value);
    if (!isNaN(dateValue.getTime())) {
      validatedObject[property] = dateValue;
    } else {
      throw new ApiCallerError("invalid_field", {
        message: `"${property}" value on "${field}" must be a valid date`
      });
    }
  }
  return validatedObject;
}
function validatePaginationToken({
  token,
  endpoint
}) {
  if (!token) {
    return;
  }
  if (typeof token !== "string") {
    throw new ApiCallerError("invalid_field", {
      message: `Pagination token should be of type string.`
    });
  }
  let decodedToken;
  try {
    decodedToken = token && JSON.parse(atob(token));
  } catch (error) {
    throw new ApiCallerError("invalid_field", {
      message: `Pagination token is not valid`
    });
  }
  if (!decodedToken || !decodedToken.externalID || decodedToken.externalID.length === 0 || endpoint === "messages" && (!decodedToken.createdAtWithMicros || decodedToken.createdAtWithMicros.length === 0) || endpoint === "threads" && (!decodedToken.nextCursorTimestamp || decodedToken.nextCursorTimestamp.length === 0) || endpoint === "org-members" && (!decodedToken.userID || decodedToken.userID.length === 0)) {
    throw new ApiCallerError("invalid_field", {
      message: `Pagination token is not valid`
    });
  }
  return decodedToken;
}
function validateSort(query) {
  const result = {
    sortBy: "first_message_timestamp",
    sortDirection: "descending"
  };
  if (query.sortBy) {
    if (query.sortBy !== "first_message_timestamp" && query.sortBy !== "most_recent_message_timestamp") {
      throw new ApiCallerError("invalid_field", {
        message: `"sortBy" must be set to "first_message_timestamp" or "most_recent_message_timestamp"`
      });
    }
    result.sortBy = query.sortBy;
  }
  if (query.sortDirection) {
    if (query.sortDirection !== "ascending" && query.sortDirection !== "descending") {
      throw new ApiCallerError("invalid_field", {
        message: `"sortDirection" must be set to "ascending" or "descending"`
      });
    }
    result.sortDirection = query.sortDirection;
  }
  return result;
}
function validateInitialFetchCount(query) {
  if (query.initialFetchCount) {
    if (typeof query.initialFetchCount !== "string") {
      throw new ApiCallerError("invalid_field", {
        message: `"initialFetchCount" must be a number`
      });
    }
    const amt = parseInt(query.initialFetchCount, 10);
    if (Number.isNaN(amt)) {
      throw new ApiCallerError("invalid_field", {
        message: `"initialFetchCount" must be a number`
      });
    }
    return Math.min(amt, THREAD_INITIAL_PAGE_SIZE_LIMIT);
  }
  return DEFAULT_THREAD_INITIAL_PAGE_SIZE;
}
function validateBooleanValue(query, field, def) {
  let value = query[field];
  if (!isDefined(value)) {
    return def;
  }
  if (typeof value !== "string") {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" must be a boolean`
    });
  }
  value = value.toLowerCase();
  if (value !== "true" && value !== "false") {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" must be a boolean`
    });
  }
  return value === "true";
}
function validateLocationValue(query, field) {
  const value = query[field];
  if (!isDefined(value)) {
    return void 0;
  }
  if (typeof value !== "string") {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" must be a location`
    });
  }
  let decoded = {};
  try {
    decoded = JSON.parse(value);
  } catch (e) {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" must be a location`
    });
  }
  if (!isLocation(decoded)) {
    throw new ApiCallerError("invalid_field", {
      message: `"${field}" must be a location`
    });
  }
  return decoded;
}
function validateLimit(limit, defaultLimit) {
  if (!limit) {
    return defaultLimit;
  }
  if (typeof limit !== "string") {
    throw new ApiCallerError("invalid_field", {
      message: `Limit must be a number.`
    });
  }
  const parsedLimit = Number.parseInt(limit);
  if (isNaN(parsedLimit)) {
    throw new ApiCallerError("invalid_field", {
      message: `Limit must be a number.`
    });
  }
  return parsedLimit;
}

// server/src/public/routes/platform/users/ListPlatformUsersHandler.ts
var DEFAULT_LIMIT = 1e3;
function encodeToken(token) {
  return btoa(JSON.stringify(token));
}
async function listPlatformUsersHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const { metadata } = validateFilter(req.query, {
    location: false,
    metadata: true,
    firstMessageTimestamp: false,
    mostRecentMessageTimestamp: false,
    groupID: false,
    authorID: false,
    resolvedStatus: false,
    viewer: false
  });
  const where = {
    platformApplicationID,
    externalProvider: "platform" /* PLATFORM */,
    ...metadata && {
      metadata: {
        [Op18.contains]: metadata
      }
    }
  };
  const { token, limit } = req.query;
  const decodedToken = validatePaginationToken({
    token,
    endpoint: "users"
  });
  const parsedLimit = validateLimit(limit, DEFAULT_LIMIT);
  const whereWithPagination = {
    ...where,
    ...decodedToken && { externalID: { [Op18.gt]: decodedToken.externalID } }
  };
  const [users, usersCount, usersRemainingCount] = await Promise.all([
    UserEntity.findAll({
      where: whereWithPagination,
      order: [["externalID", "ASC"]],
      limit: parsedLimit
    }),
    UserEntity.count({
      where
    }),
    UserEntity.count({
      where: whereWithPagination
    })
  ]);
  const lastUser = users.length === 0 ? null : users[users.length - 1];
  const remaining = Math.max(usersRemainingCount - users.length, 0);
  const returnToken = remaining > 0 && lastUser ? encodeToken({
    externalID: lastUser.externalID
  }) : null;
  const result = {
    users: users.map(
      (user) => ({
        id: user.externalID,
        email: user.email,
        status: user.state,
        name: user.name,
        shortName: user.screenName,
        short_name: user.screenName,
        first_name: null,
        last_name: null,
        profilePictureURL: user.profilePictureURL,
        profile_picture_url: user.profilePictureURL,
        metadata: user.metadata,
        createdTimestamp: user.createdTimestamp
      })
    ),
    pagination: {
      token: returnToken,
      total: usersCount
    }
  };
  return res.status(200).json(result);
}
var ListPlatformUsersHandler_default = forwardHandlerExceptionsToNext(listPlatformUsersHandler);

// server/src/public/routes/platform/users/GetPlatformUserHandler.ts
async function findAllOrgMemberships(userID) {
  const orgMemberships = await OrgMembersEntity.findAll({
    where: { userID }
  });
  const orgIds = orgMemberships.map((org) => org.orgID);
  return await OrgEntity.findAll({
    where: { id: orgIds, state: "active" }
  });
}
async function findAllOrgsUserHasLinkedToASlackUser(userID, allUserOrgs) {
  const externalOrgIDByOrgID = {};
  for (const { id, externalID } of allUserOrgs) {
    externalOrgIDByOrgID[id] = externalID;
  }
  const linkedUsers = await LinkedUsersEntity.findAll({
    where: {
      sourceUserID: userID,
      sourceOrgID: Object.keys(externalOrgIDByOrgID)
    }
  });
  return linkedUsers.map((lu) => externalOrgIDByOrgID[lu.sourceOrgID]);
}
async function getPlatformUserHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.userID;
  if (!externalID) {
    throw new ApiCallerError("user_not_found");
  }
  if (!isValidExternalID(externalID)) {
    throw new ApiCallerError("invalid_request");
  }
  const user = await UserEntity.findOne({
    where: {
      externalID,
      platformApplicationID,
      externalProvider: "platform" /* PLATFORM */
    }
  });
  if (!user) {
    throw new ApiCallerError("user_not_found", { code: 404 });
  }
  const allOrgs = await findAllOrgMemberships(user.id);
  const orgExternalIds = allOrgs.map((org) => org.externalID);
  const connectedSlackOrgIDs = await findAllOrgsUserHasLinkedToASlackUser(
    user.id,
    allOrgs
  );
  const result = {
    id: user.externalID,
    email: user.email,
    status: user.state,
    name: user.name,
    shortName: user.screenName,
    short_name: user.screenName,
    first_name: null,
    last_name: null,
    profilePictureURL: user.profilePictureURL,
    profile_picture_url: user.profilePictureURL,
    organizations: orgExternalIds,
    groups: orgExternalIds,
    metadata: user.metadata,
    createdTimestamp: user.createdAt,
    groupIDsWithLinkedSlackProfile: connectedSlackOrgIDs
  };
  return res.status(200).json(result);
}
var GetPlatformUserHandler_default = forwardHandlerExceptionsToNext(getPlatformUserHandler);

// server/src/public/routes/platform/users/CreatePlatformUserHandler.ts
function validateCreateUserInput(data) {
  const validatedInput = validate.CreatePlatformUserVariables(data);
  validateExternalID(validatedInput.id, "id");
  return validatedInput;
}
async function createUserHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  deprecated("api: POST /v1/users", platformApplicationID);
  const {
    id: externalID,
    // Can be type string or number
    name,
    short_name,
    shortName,
    email,
    status,
    profile_picture_url,
    profilePictureURL,
    metadata,
    first_name,
    last_name,
    ...rest
  } = validateCreateUserInput(req.body);
  const _ = rest;
  if (short_name) {
    deprecated(
      "snake:CreatePlatformUserHandler:short_name",
      platformApplicationID
    );
  }
  if (profile_picture_url) {
    deprecated(
      "snake:CreatePlatformUserHandler:profile_picture_url",
      platformApplicationID
    );
  }
  if (first_name) {
    deprecated("CreatePlatformUserHandler:first_name", platformApplicationID);
  }
  if (last_name) {
    deprecated("CreatePlatformUserHandler:last_name", platformApplicationID);
  }
  const newUser = await createPlatformUser(
    null,
    platformApplicationID,
    externalID.toString(),
    // Incase it is a number
    email,
    name,
    shortName ?? short_name,
    profilePictureURL ?? profile_picture_url,
    status,
    metadata
  );
  res.status(201).json({
    success: true,
    message: `\u2705 You successfully created user ${newUser.externalID}`
  });
}
var CreatePlatformUserHandler_default = forwardHandlerExceptionsToNext(createUserHandler);

// server/src/public/routes/platform/users/UpdatePlatformUserHandler.ts
async function updateUserHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.userID;
  const result = await updateUser(platformApplicationID, externalID, req.body);
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully ${result.isCreated ? "created" : "updated"} user ${externalID}`
  });
}
async function updateUser(platformApplicationID, externalID, data) {
  validateExternalID(externalID, "userID");
  const result = await getSequelize().transaction(async (transaction) => {
    const {
      name,
      shortName,
      short_name,
      email,
      profilePictureURL,
      profile_picture_url,
      status,
      metadata,
      first_name,
      last_name,
      addGroups,
      removeGroups,
      ...rest
    } = removeEmptyStringEmailIfExists(
      validate.UpdatePlatformUserVariables(data)
    );
    const _ = rest;
    if (profile_picture_url) {
      deprecated(
        "snake:UpdatePlatformUserHandler:profile_picture_url",
        platformApplicationID
      );
    }
    if (first_name) {
      deprecated("UpdatePlatformUserHandler:first_name", platformApplicationID);
    }
    if (last_name) {
      deprecated("UpdatePlatformUserHandler:last_name", platformApplicationID);
    }
    let user = await UserEntity.findOne({
      where: {
        externalID,
        platformApplicationID,
        externalProvider: "platform" /* PLATFORM */
      },
      transaction
    });
    const isCreated = !user;
    if (user) {
      const didUpdate = await new UserMutator(
        Viewer.createServiceViewer(),
        null
      ).updateUser(
        user,
        {
          name: name ?? void 0,
          email: email ?? void 0,
          screenName: shortName ?? short_name ?? void 0,
          profilePictureURL: profilePictureURL ?? profile_picture_url,
          state: status,
          metadata: metadata ?? void 0
        },
        transaction
      );
      if (didUpdate) {
        transaction.afterCommit(async () => {
          await publishUserIdentityUpdate({
            userID: user.id,
            platformApplicationID
          });
        });
      }
    } else {
      user = await createPlatformUser(
        null,
        platformApplicationID,
        externalID,
        email,
        name,
        shortName ?? short_name,
        profilePictureURL ?? profile_picture_url,
        status,
        metadata,
        transaction
      );
    }
    if (addGroups?.length || removeGroups?.length) {
      const u = user;
      const add2 = addGroups ?? [];
      const remove2 = removeGroups ?? [];
      const addSet = new Set(add2);
      const removeSet = new Set(remove2);
      if (remove2.some((g) => addSet.has(g))) {
        throw new ApiCallerError("invalid_field", {
          message: "Adding and removing the same group is invalid."
        });
      }
      const [addOrgs, removeOrgs] = await Promise.all([
        OrgEntity.findAll({
          where: { platformApplicationID, externalID: add2 },
          transaction
        }),
        OrgEntity.findAll({
          where: { platformApplicationID, externalID: remove2 },
          transaction
        })
      ]);
      if (addSet.size !== addOrgs.length) {
        for (const org of addOrgs) {
          addSet.delete(org.externalID);
        }
        throw new ApiCallerError("group_not_found", {
          message: `Group ${addSet.values().next().value} not found.`
        });
      }
      if (removeSet.size !== removeOrgs.length) {
        for (const org of removeOrgs) {
          removeSet.delete(org.externalID);
        }
        throw new ApiCallerError("group_not_found", {
          message: `Group ${removeSet.values().next().value} not found.`
        });
      }
      await Promise.all([
        OrgMembersEntity.bulkCreate(
          addOrgs.map((org) => ({
            userID: u.id,
            orgID: org.id
          })),
          {
            ignoreDuplicates: true,
            transaction
          }
        ),
        OrgMembersEntity.destroy({
          where: {
            userID: u.id,
            orgID: removeOrgs.map((org) => org.id)
          },
          transaction
        })
      ]);
    }
    if (isCreated) {
      const usersCount = await UserEntity.count({
        where: { platformApplicationID }
      });
      if (usersCount === 0) {
        transaction.afterCommit(async () => {
          await publishPubSubEvent("console-getting-started-updated", {
            applicationID: platformApplicationID
          });
        });
      }
    }
    return { isCreated };
  });
  return result;
}
var UpdatePlatformUserHandler_default = forwardHandlerExceptionsToNext(updateUserHandler);

// server/src/public/routes/platform/PlatformBatchHandler.ts
import { Op as Op19, Sequelize as Sequelize14 } from "sequelize";

// opensource/sdk-js/packages/react/common/util.ts
import dayjs3 from "dayjs";
import Calendar2 from "dayjs/plugin/calendar.js";
dayjs3.extend(Calendar2);
function pluralize(n, what, plural) {
  return `${n} ${pluralizeWord(n, what, plural)}`;
}
function pluralizeWord(n, what, plural = what + "s") {
  return n === 1 ? what : plural;
}

// server/src/public/routes/platform/PlatformBatchHandler.ts
async function batchHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const {
    groups,
    organizations: organizationsInput,
    users,
    ...rest
  } = validate.BatchAPIVariables(req.body);
  const _ = rest;
  const organizations = groups ?? organizationsInput;
  if (users?.some((u) => u.first_name)) {
    deprecated("PlatformBatchHandler:first_name", platformApplicationID);
  }
  if (users?.some((u) => u.last_name)) {
    deprecated("PlatformBatchHandler:last_name", platformApplicationID);
  }
  if (organizationsInput) {
    deprecated("PlatformBatchHandler:organizations", platformApplicationID);
  }
  const externalUserIndex = /* @__PURE__ */ new Map();
  await getSequelize().transaction(async (transaction) => {
    if (users) {
      const usersIndex = /* @__PURE__ */ new Map();
      const userIDs = [];
      for (const u of users) {
        usersIndex.set(u.id.toString(), u);
        userIDs.push(u.id.toString());
      }
      const existingUsers = await UserEntity.findAll({
        where: {
          externalID: userIDs,
          externalProvider: "platform" /* PLATFORM */,
          platformApplicationID
        },
        transaction
      });
      const existingUserIDs = /* @__PURE__ */ new Set();
      for (const userEntity of existingUsers) {
        const data = userEntity.externalID ? usersIndex.get(userEntity.externalID) : void 0;
        if (data) {
          existingUserIDs.add(userEntity.externalID);
          externalUserIndex.set(userEntity.externalID, userEntity.id);
          const { id: _id, ...fields } = data;
          const validatedInput = removeEmptyStringEmailIfExists(
            validate.UpdatePlatformUserVariables(fields)
          );
          const {
            name,
            short_name,
            email,
            profile_picture_url,
            status,
            metadata
          } = validatedInput;
          await userEntity.update(
            {
              name,
              ...isDefined(name) && name !== userEntity.name && {
                nameUpdatedTimestamp: Sequelize14.fn("now")
              },
              screenName: short_name,
              profilePictureURL: profile_picture_url,
              ...isDefined(profile_picture_url) && profile_picture_url !== userEntity.profilePictureURL && {
                profilePictureURLUpdatedTimestamp: Sequelize14.fn("now")
              },
              email,
              state: status,
              metadata: metadata ?? void 0
            },
            { transaction }
          );
        }
      }
      const newUserIDs = userIDs.filter((id) => !existingUserIDs.has(id));
      const newUsersInput = newUserIDs.map(
        (id) => validate.CreatePlatformUserVariables(usersIndex.get(id))
      );
      const userEntities = await new UserMutator(
        Viewer.createServiceViewer(),
        null
      ).rawBulkCreate(
        newUsersInput.map(
          ({ id, name, short_name, email, profile_picture_url, metadata }) => ({
            name,
            screenName: short_name,
            nameUpdatedTimestamp: isDefined(name) ? Sequelize14.fn("now") : null,
            email,
            profilePictureURL: profile_picture_url,
            profilePictureURLUpdatedTimestamp: isDefined(profile_picture_url) ? Sequelize14.fn("now") : null,
            externalID: id.toString(),
            externalProvider: "platform" /* PLATFORM */,
            platformApplicationID,
            state: "active",
            metadata: metadata ?? void 0
          })
        ),
        transaction
      );
      for (const userEntity of userEntities) {
        if (userEntity.externalID !== null) {
          externalUserIndex.set(userEntity.externalID, userEntity.id);
        }
      }
    }
    if (organizations) {
      const organizationsIndex = /* @__PURE__ */ new Map();
      const organizationIDs = [];
      for (const o of organizations) {
        organizationsIndex.set(o.id.toString(), o);
        organizationIDs.push(o.id.toString());
      }
      const existingOrganizations = await OrgEntity.findAll({
        where: {
          externalID: organizationIDs,
          externalProvider: "platform" /* PLATFORM */,
          platformApplicationID
        },
        transaction
      });
      const existingOrganizationIDs = /* @__PURE__ */ new Set();
      await Promise.all(
        existingOrganizations.map((organizationEntity) => {
          const data = organizationEntity.externalID ? organizationsIndex.get(organizationEntity.externalID) : void 0;
          if (data) {
            existingOrganizationIDs.add(organizationEntity.externalID);
            const { id: _id, ...fields } = data;
            const { name, status, metadata } = validate.UpdatePlatformOrganizationVariables(fields);
            return organizationEntity.update(
              {
                name,
                state: status ? status === "deleted" ? "inactive" : "active" : void 0,
                metadata
              },
              { transaction }
            );
          } else {
            return void 0;
          }
        })
      );
      const application = await ApplicationEntity.findByPk(
        platformApplicationID,
        { transaction }
      );
      const newOrganizationsData = organizationIDs.filter((id) => !existingOrganizationIDs.has(id)).map(
        (id) => validate.CreatePlatformOrganizationVariables(
          organizationsIndex.get(id)
        )
      ).map((data) => ({
        name: data.name,
        externalID: data.id.toString(),
        externalProvider: "platform" /* PLATFORM */,
        platformApplicationID,
        state: "active",
        metadata: data.metadata
      }));
      const newlyCreatedOrgs = await OrgEntity.bulkCreate(
        newOrganizationsData,
        {
          transaction,
          updateOnDuplicate: ["name", "state", "externalProvider", "metadata"],
          conflictWhere: { platformApplicationID: { [Op19.ne]: null } }
        }
      );
      if (await application?.isSupportChatEnabled()) {
        await OrgMembersEntity.bulkCreate(
          newlyCreatedOrgs.map((newOrg) => {
            return {
              userID: application.supportBotID,
              orgID: newOrg.id
            };
          }),
          { transaction }
        );
      }
      const allMemberIDs = /* @__PURE__ */ new Set();
      organizations.forEach((org) => {
        if (org.members) {
          org.members.forEach((member) => {
            allMemberIDs.add(member.toString());
          });
        }
      });
      const [allMemberUsers, allOrgs] = await Promise.all([
        UserEntity.findAll({
          where: {
            externalID: [...allMemberIDs],
            externalProvider: "platform" /* PLATFORM */,
            platformApplicationID
          },
          attributes: ["id", "externalID"],
          transaction
        }),
        OrgEntity.findAll({
          where: {
            externalID: organizations.map(({ id }) => id.toString()),
            externalProvider: "platform" /* PLATFORM */,
            platformApplicationID
          },
          attributes: ["id", "externalID"],
          transaction
        })
      ]);
      if (allMemberIDs.size !== allMemberUsers.length) {
        const userIDSet = new Set(
          allMemberUsers.map((user) => user.externalID)
        );
        const missingMembers = /* @__PURE__ */ new Set();
        [...allMemberIDs].forEach((member) => {
          if (!userIDSet.has(member)) {
            missingMembers.add(member);
          }
        });
        if (missingMembers.size > 0) {
          throw new ApiCallerError("user_not_found", {
            message: `Platform ${missingMembers.size > 1 ? "users" : "user"} ${combine("and", [...missingMembers])} not found.`
          });
        }
      }
      const externalIDToUserIDs = new Map(
        allMemberUsers.map((user) => [user.externalID, user.id])
      );
      const orgsIndex = new Map(
        allOrgs.map(({ id, externalID }) => [externalID, id])
      );
      const deleteConditions = {};
      const createData = [];
      for (const organization of organizations) {
        const members = organization.members?.map(
          (member) => member.toString()
        );
        const orgID = orgsIndex.get(organization.id.toString());
        if (!members || !orgID) {
          continue;
        }
        const userIDs = Array.from(
          new Set(
            members.map(
              (externalID) => externalIDToUserIDs.get(externalID) ?? ""
            )
          )
        );
        if (await application?.isSupportChatEnabled()) {
          userIDs.push(application.supportBotID);
        }
        deleteConditions[orgID] = userIDs;
        for (const userID of userIDs) {
          createData.push({
            userID,
            orgID
          });
        }
      }
      await Promise.all([
        OrgMembersEntity.bulkCreate(createData, {
          ignoreDuplicates: true,
          transaction
        }),
        OrgMembersEntity.destroy({
          where: {
            [Op19.or]: Object.entries(deleteConditions).map(
              ([orgID, userIDs]) => ({
                orgID,
                userID: { [Op19.notIn]: userIDs }
              })
            )
          },
          transaction
        })
      ]);
    }
  });
  const usersUpdated = users?.length ?? 0;
  const orgsUpdated = organizations?.length ?? 0;
  return res.json({
    success: true,
    message: `\u2705 You successfully batch updated ${pluralize(
      usersUpdated,
      "user"
    )} and ${pluralize(orgsUpdated, "group")}`
  });
}
var PlatformBatchHandler_default = forwardHandlerExceptionsToNext(batchHandler);

// server/src/public/routes/platform/messages/GetThreadMessageHandler.ts
async function getThreadMessageHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalThreadID = req.params.threadID;
  if (!externalThreadID) {
    throw new ApiCallerError("thread_not_found");
  }
  let internalThreadID = null;
  if (isExternalizedID(externalThreadID)) {
    internalThreadID = extractInternalID(externalThreadID);
    if (!internalThreadID) {
      throw new ApiCallerError("invalid_request", {
        message: "thread ID is not valid"
      });
    }
  }
  let thread = null;
  if (internalThreadID) {
    thread = await ThreadEntity.findOne({
      where: {
        id: internalThreadID,
        platformApplicationID: req.appID
      }
    });
  } else {
    thread = await ThreadEntity.findOne({
      where: {
        externalID: externalThreadID,
        platformApplicationID: req.appID
      }
    });
  }
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  const externalMessageID = req.params.messageID;
  if (!externalMessageID) {
    throw new ApiCallerError("message_not_found");
  }
  let internalMessageID = null;
  if (isExternalizedID(externalMessageID)) {
    internalMessageID = extractInternalID(externalMessageID);
    if (!internalMessageID) {
      throw new ApiCallerError("invalid_request", {
        message: "message ID is not valid"
      });
    }
  }
  let message = null;
  if (internalMessageID) {
    message = await MessageEntity.findOne({
      where: {
        id: internalMessageID,
        threadID: thread.id
      }
    });
  } else {
    message = await MessageEntity.findOne({
      where: {
        externalID: externalMessageID,
        threadID: thread.id
      }
    });
  }
  if (!message) {
    throw new ApiCallerError("message_not_found");
  }
  const loaders = await getNewLoaders(
    Viewer.createOrgViewer(thread.orgID, platformApplicationID)
  );
  const result = await getCoreMessageData(loaders, message, thread);
  return res.status(200).json(result);
}
var GetThreadMessageHandler_default = forwardHandlerExceptionsToNext(getThreadMessageHandler);

// server/src/public/routes/platform/messages/ListThreadMessagesHandler.ts
async function listThreadMessagesHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalThreadID = req.params.threadID;
  if (!externalThreadID) {
    throw new ApiCallerError("thread_not_found", {
      message: "Missing thread ID."
    });
  }
  let internalThreadID = null;
  if (!isValidExternalID(externalThreadID)) {
    internalThreadID = extractInternalID(externalThreadID);
    if (!internalThreadID) {
      throw new ApiCallerError("invalid_request", {
        message: "thread ID is invalid"
      });
    }
  }
  const sortDirection = req.query.sortDirection?.toString().toUpperCase();
  let thread = null;
  if (internalThreadID) {
    thread = await ThreadEntity.findOne({
      where: {
        id: internalThreadID,
        platformApplicationID
      }
    });
  } else {
    thread = await ThreadEntity.findOne({
      where: {
        externalID: externalThreadID,
        platformApplicationID
      }
    });
  }
  if (!thread) {
    throw new ApiCallerError("thread_not_found", { code: 404 });
  }
  let order = void 0;
  if (!sortDirection || sortDirection === "DESCENDING") {
    order = "DESC";
  }
  if (sortDirection === "ASCENDING") {
    order = "ASC";
  }
  if (!order) {
    throw new ApiCallerError("invalid_request", {
      message: "sortDirection value is invalid: must be 'ascending' or 'descending'"
    });
  }
  const messages = await MessageEntity.findAll({
    where: {
      threadID: thread.id
    },
    order: [["timestamp", order]]
  });
  if (messages.length <= 0) {
    return res.status(200).json([]);
  }
  const loaders = await getNewLoaders(
    Viewer.createOrgViewer(thread.orgID, platformApplicationID)
  );
  const threadNotNull = thread;
  const results = await Promise.all(
    messages.map(
      async (msg) => await getCoreMessageData(loaders, msg, threadNotNull)
    )
  );
  return res.status(200).json(results);
}
var ListThreadMessagesHandler_default = forwardHandlerExceptionsToNext(listThreadMessagesHandler);

// server/src/public/routes/platform/messages/CreateThreadMessageHandler.ts
import { v4 as uuid8 } from "uuid";
import { unique as unique13 } from "radash";

// server/src/message/util/validateMessageContent.ts
import Ajv2 from "ajv";
var TextSchema = {
  type: "object",
  properties: {
    // You might expect this to have an enforced non-zero length, but
    // actually our own composer produces text nodes with empty string
    // values. It would be nasty of us to produce messages that we
    // wouldn't accept back directly.
    text: { type: "string" },
    bold: { type: "boolean" },
    italic: { type: "boolean" },
    underline: { type: "boolean" },
    code: { type: "boolean" },
    class: { type: "string" }
  },
  required: ["text"],
  additionalProperties: false
};
var MentionSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^mention$" },
    class: { type: "string" },
    user: {
      type: "object",
      properties: { id: { type: "string" } },
      required: ["id"],
      additionalProperties: false
    },
    children: {
      type: "array",
      minItems: 1,
      maxItems: 1,
      items: {
        type: "object",
        properties: {
          // these are names from our customers' users, which includes email addresses
          text: { type: "string", pattern: "^@.+$" }
        },
        required: ["text"],
        additionalProperties: false
      }
    }
  },
  required: ["type", "user", "children"],
  additionalProperties: false
};
var TaskSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^assignee$" },
    user: {
      type: "object",
      properties: { id: { type: "string" } },
      required: ["id"],
      additionalProperties: false
    },
    children: {
      type: "array",
      minItems: 1,
      maxItems: 1,
      items: {
        type: "object",
        properties: {
          // these are names from our customers' users, which includes email addresses
          text: { type: "string", pattern: "^[+].+$" }
        },
        required: ["text"],
        additionalProperties: false
      }
    }
  },
  required: ["type", "user", "children"],
  additionalProperties: false
};
var LinkSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^link$" },
    class: { type: "string" },
    url: { type: "string" },
    // TODO: Swap this for a uri -- AJV was unhappy with me
    children: {
      type: "array",
      items: { anyOf: [TextSchema, MentionSchema] }
    }
  },
  required: ["type", "url", "children"],
  additionalProperties: false
};
var ParagraphSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^p$" },
    class: { type: "string" },
    children: {
      type: "array",
      items: { anyOf: [TextSchema, MentionSchema, TaskSchema, LinkSchema] },
      minItems: 1
    }
  },
  required: ["type", "children"],
  additionalProperties: false
};
var BulletSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^bullet$" },
    class: { type: "string" },
    children: {
      type: "array",
      minItems: 1,
      items: { anyOf: [ParagraphSchema] }
    },
    indent: { type: "integer", minimum: 0, maximum: MAX_BULLET_INDENT }
  },
  required: ["type", "children"],
  additionalProperties: false
};
var NumberBulletSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^number_bullet$" },
    class: { type: "string" },
    children: {
      type: "array",
      minItems: 1,
      items: { anyOf: [ParagraphSchema] }
    },
    bulletNumber: { type: "integer" },
    indent: { type: "integer", minimum: 0, maximum: MAX_BULLET_INDENT }
  },
  required: ["type", "children"],
  additionalProperties: false
};
var QuoteSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^quote$" },
    class: { type: "string" },
    children: {
      type: "array",
      items: {
        anyOf: [
          ParagraphSchema,
          BulletSchema,
          NumberBulletSchema,
          TextSchema,
          MentionSchema,
          TaskSchema,
          LinkSchema
        ]
      },
      minItems: 1
    }
  },
  required: ["type", "children"],
  additionalProperties: false
};
var CodeSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^code$" },
    class: { type: "string" },
    children: {
      type: "array",
      items: { anyOf: [TextSchema] },
      minItems: 1
    }
  },
  required: ["type", "children"],
  additionalProperties: false
};
var AnnotationSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^annotation$" },
    children: {
      type: "array",
      items: { anyOf: [TextSchema] }
    },
    annotation: {
      type: "object",
      properties: {
        id: { type: "string" }
      },
      required: ["id"],
      additionalProperties: false
    }
  },
  required: ["annotation", "children"],
  additionalProperties: false
};
var ExperimentalCustomMessageSchema = {
  type: "object",
  properties: {
    type: {
      type: "string",
      pattern: "^(?!p$|quote$|annotation$|code$|bullet$|number_bullet$|link$|mention$|assignee$|markdown$)[a-z]+$"
    }
  },
  additionalProperties: true,
  required: ["type"]
};
var MarkdownMessageSchema = {
  type: "object",
  properties: {
    type: { type: "string", pattern: "^markdown$" },
    children: {
      type: "array",
      minItems: 1,
      maxItems: 1,
      items: { type: "object", properties: { text: { type: "string" } } }
    }
  },
  required: ["type", "children"],
  additionalProperties: false
};
var MessageAJVSchema = {
  type: "array",
  items: {
    anyOf: [
      ExperimentalCustomMessageSchema,
      ParagraphSchema,
      QuoteSchema,
      CodeSchema,
      TaskSchema,
      MentionSchema,
      BulletSchema,
      NumberBulletSchema,
      AnnotationSchema,
      LinkSchema,
      MarkdownMessageSchema
    ]
  },
  minItems: 0
  // Nodes have minimum children of 1, but an empty message is valid
};
var ajv2 = new Ajv2.default({
  verbose: true
});
var validateMessageContentAgainstSchema = ajv2.compile(MessageAJVSchema);
function validateMessageContent(msg) {
  if (!validateMessageContentAgainstSchema(msg)) {
    throw new Error(
      "Message contents contained invalid element(s): " + JSON.stringify(msg, null, 4)
    );
  }
}

// server/src/schema/common.ts
import { GraphQLScalarType } from "graphql";
import { GraphQLJSON } from "graphql-type-json";

// server/src/entity/message_mention/MessageMentionMutator.ts
import { Op as Op20 } from "sequelize";
var MessageMentionMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  // createMessageMentions creates a mention (userID, messageID) for each user
  // in userIDs. It returns a list of userIDs for which mentions were actually
  // created, i.e. that were not mentioned in the message previously.
  async createMessageMentions(messageID, userIDs) {
    if (userIDs.length === 0) {
      return [];
    }
    const [returnedColumns] = await getSequelize().query(
      `INSERT INTO
      "${MessageMentionEntity.tableName}"
      ("userID", "messageID")
      VALUES
      ${userIDs.map(() => "(?)").join(",")}
      ON CONFLICT DO NOTHING
      RETURNING "userID"`,
      {
        replacements: userIDs.map((userID) => [userID, messageID])
      }
    );
    const newUserIDs = returnedColumns.map(
      (row) => row.userID
    );
    return newUserIDs;
  }
  async deleteExcludingUsers(messageID, excludedUsers) {
    const where = { messageID };
    if (excludedUsers.length > 0) {
      where.userID = { [Op20.notIn]: excludedUsers };
    }
    await MessageMentionEntity.destroy({ where });
  }
};

// server/src/schema/common.ts
async function createOrUpdateMessageMentions(context, messageId, content, isUpdate) {
  const mentionedUsers = getMentionedUserIDs(content);
  const mutator = new MessageMentionMutator(context.session.viewer);
  if (isUpdate) {
    await mutator.deleteExcludingUsers(messageId, mentionedUsers);
  }
  return await mutator.createMessageMentions(messageId, mentionedUsers);
}
var createMessageMentions = (context, messageId, content) => createOrUpdateMessageMentions(context, messageId, content, false);
var updateMessageMentions = (context, messageId, content) => createOrUpdateMessageMentions(context, messageId, content, true);
var getMessageAnnotationAttachmentsFromInput = (viewer, annotationAttachments) => {
  const attachmentWithBothLocations = annotationAttachments.find(
    (annotation) => annotation.location && annotation.customLocation
  );
  if (attachmentWithBothLocations) {
    new Logger(viewer).warn(
      "AnnotationAttachmentInput contains both location and customLocation",
      { attachment: attachmentWithBothLocations }
    );
  }
  return annotationAttachments.map(
    ({
      id,
      screenshotFileID,
      blurredScreenshotFileID,
      location,
      customLocation,
      customHighlightedTextConfig,
      customLabel,
      coordsRelativeToTarget
    }) => ({
      id,
      type: "annotation" /* ANNOTATION */,
      data: {
        screenshotFileID: screenshotFileID ?? null,
        blurredScreenshotFileID: blurredScreenshotFileID ?? null,
        location: location ?? null,
        customLocation: customLocation ?? null,
        customHighlightedTextConfig,
        customLabel: customLabel ?? null,
        coordsRelativeToTarget: coordsRelativeToTarget ?? null
      }
    })
  );
};
var SimpleValueScalarType = new GraphQLScalarType({
  name: "SimpleValue",
  description: "Simple value",
  // serialization/deserialization works just like for JSON
  serialize: GraphQLJSON.serialize,
  parseValue: GraphQLJSON.parseValue,
  parseLiteral: GraphQLJSON.parseLiteral
});
var MessageContentScalarType = new GraphQLScalarType({
  name: "MessageContent",
  description: "Message content",
  // serialization/deserialization works just like for JSON
  serialize: GraphQLJSON.serialize,
  parseValue: GraphQLJSON.parseValue,
  parseLiteral: GraphQLJSON.parseLiteral
});
var FlatJSONObjectScalarType = new GraphQLScalarType({
  name: "FlatJSONObject",
  description: "A JSONObject where all values are string, number or boolean",
  // serialization/deserialization works just like for JSON, with further
  // validation
  serialize: GraphQLJSON.serialize,
  parseValue: (value) => {
    const result = GraphQLJSON.parseValue(value);
    if (!isValidFlatJsonObject(result)) {
      throw new Error("Invalid flat JSON object");
    }
    return result;
  },
  parseLiteral: (astNode, variables) => {
    const result = GraphQLJSON.parseLiteral(astNode, variables);
    if (!isValidFlatJsonObject(result)) {
      throw new Error("Invalid flat JSON object");
    }
    return result;
  }
});
var ContextScalarType = new GraphQLScalarType({
  ...FlatJSONObjectScalarType,
  name: "Context",
  description: "Context"
});
var MetadataScalarType = new GraphQLScalarType({
  ...FlatJSONObjectScalarType,
  name: "Metadata",
  description: "Metadata"
});
var SimpleTranslationParametersScalarType = new GraphQLScalarType({
  ...FlatJSONObjectScalarType,
  name: "SimpleTranslationParameters",
  description: "SimpleTranslationParameters"
});
var ElementIdentifierVersionScalarType = new GraphQLScalarType({
  name: "ElementIdentifierVersion",
  serialize: (x) => x,
  // already JSON serializable
  parseValue: (x) => {
    if (typeof x !== "string") {
      return null;
    }
    return parseElementIdentifierVersion(x);
  },
  parseLiteral: (astNode) => {
    if (astNode.kind === "StringValue") {
      return parseElementIdentifierVersion(astNode.value);
    }
    return null;
  }
});
var JsonObjectReducerDataScalarType = new GraphQLScalarType({
  name: "JsonObjectReducerData",
  description: "Data type for jsonObjectReducer",
  // serialization/deserialization works just like for JSON
  serialize: GraphQLJSON.serialize,
  parseValue: GraphQLJSON.parseValue,
  parseLiteral: GraphQLJSON.parseLiteral
});

// server/src/message/new_message_tasks/addNewMessageAttachments.ts
async function addNewMessageAttachments(context, message, fileAttachments, annotationAttachments, screenshotAttachment) {
  const messageAttachmentMutator = new MessageAttachmentMutator(
    context.session.viewer,
    context.loaders
  );
  await messageAttachmentMutator.setMessageAttachments(message, [
    ...fileAttachments.map(({ id, fileID }) => ({
      id,
      type: "file" /* FILE */,
      data: { fileID }
    })),
    ...getMessageAnnotationAttachmentsFromInput(
      context.session.viewer,
      annotationAttachments
    ),
    ...screenshotAttachment ? [
      {
        id: screenshotAttachment.id,
        type: "screenshot" /* SCREENSHOT */,
        data: {
          screenshotFileID: screenshotAttachment.screenshotFileID,
          blurredScreenshotFileID: screenshotAttachment.blurredScreenshotFileID
        }
      }
    ] : []
  ]);
}

// server/src/message/new_message_tasks/markThreadSeenForViewer.ts
async function markThreadSeenForViewer(viewer, threadID, transaction) {
  const threadParticipantMutator = new ThreadParticipantMutator(viewer, null);
  await threadParticipantMutator.markThreadSeen({
    threadID,
    setSubscribed: true,
    transaction
  });
}

// server/src/third_party_tasks/trello/actions.ts
async function getAccessToken(viewer) {
  const tokens = await getExternalAuthData(viewer, "trello");
  if (!tokens?.accessToken) {
    return null;
  }
  return tokens.accessToken;
}
async function getTrelloWorkSpace(viewer) {
  const accessToken = await getAccessToken(viewer);
  if (!accessToken) {
    return null;
  }
  return await getUserResources(accessToken);
}
async function createTrelloTask(logger, viewer, task) {
  const accessToken = await getAccessToken(viewer);
  if (!accessToken) {
    return null;
  }
  const message = await MessageEntity.findByPk(task.messageID);
  if (!message) {
    logger.error(
      `Failed to fetch message ${task.messageID} linked to task ${task.id}`
    );
    return;
  }
  const name = taskTitleFromMessageContent(message.content);
  const messageContent = convertStructuredMessageToText(message.content);
  const cordReference = `This task was created using Cord, see original task here ${message.url}`;
  const desc = messageContent + "\n" + cordReference;
  const userPreferenceLoader = new UserPreferenceLoader(viewer);
  const userTrelloList = await userPreferenceLoader.loadPreferenceValueForViewer(
    TRELLO_CONNECTED_LIST
  );
  if (!userTrelloList) {
    return null;
  }
  const { id } = await createCard(accessToken, {
    name,
    desc,
    idList: userTrelloList
  });
  if (!id) {
    logger.error("Failed to get card id from response");
    return;
  }
  await TaskThirdPartyReference.create({
    taskID: task.id,
    externalID: id,
    externalConnectionType: "trello"
  });
  return id;
}
async function addAssigneesToTrelloTask(viewer, taskID, taskAssigneesUserIDs) {
  const accessToken = await getAccessToken(viewer);
  if (!accessToken) {
    return;
  }
  const thirdPartyReference = await TaskThirdPartyReference.findForTask(
    taskID,
    "trello"
  );
  if (!thirdPartyReference) {
    return;
  }
  const trelloCardID = thirdPartyReference.externalID;
  const connectedTrelloTaskAssignees = await getTrelloMatchedUsers(
    viewer,
    taskAssigneesUserIDs
  );
  const connectedTaskAssigneesMemberIDs = connectedTrelloTaskAssignees.map(
    (thirdPartyData) => thirdPartyData.externalID
  );
  await Promise.all(
    connectedTaskAssigneesMemberIDs.map(
      (memberID) => addMemberToCard(accessToken, trelloCardID, memberID)
    )
  );
}
async function getTrelloMatchedUsers(viewer, taskAssigneesUserIDs) {
  const { orgID } = assertViewerHasIdentity(viewer);
  const connectedAssigneesUsers = await ThirdPartyConnectionEntity.findAll({
    where: {
      userID: taskAssigneesUserIDs,
      orgID,
      type: "trello"
    }
  });
  return connectedAssigneesUsers;
}

// server/src/third_party_tasks/monday/actions.ts
import { v4 as uuid6 } from "uuid";

// server/src/third_party_tasks/monday/api.ts
import FormData2 from "form-data";
import { unique as unique11 } from "radash";
async function completeOAuthFlow5(code) {
  const params = new URLSearchParams();
  params.append("client_id", Env_default.MONDAY_APP_CLIENT_ID);
  params.append("client_secret", Env_default.MONDAY_APP_CLIENT_SECRET);
  params.append("redirect_uri", MONDAY_AUTH_REDIRECT_URL);
  params.append("code", code);
  const response = await fetch("https://auth.monday.com/oauth2/token", {
    method: "POST",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: params
  });
  const { access_token } = await response.json();
  const userInfo2 = await getUserInfo2(access_token);
  if (!userInfo2) {
    throw new Error("Could not fetch Monday user information.");
  }
  return [access_token, userInfo2];
}
async function apiRequest2(query, accessToken, variables = null) {
  return await thirdPartyGraphQLRequest(
    "monday",
    query,
    accessToken,
    variables
  );
}
async function getUserInfo2(accessToken) {
  const query = `
    query UserInfo {
      me {
        id
        email
      }
      boards {
        id
        subitem_board {
          id
        }
      }
    }`;
  return await apiRequest2(query, accessToken);
}
async function getBoards(accessToken) {
  const query = `
  query Boards {
    boards {
      id
      name
      subitem_board {
        id
      }
      groups {
        id
        title
        position
      }
    }
  }`;
  const responseJson = await apiRequest2(
    query,
    accessToken
  );
  return removeSubitemBoards(responseJson.boards);
}
function removeSubitemBoards(boards) {
  return boards ? boards.filter(
    (board) => !boards.some(
      (otherBoard) => board.id === otherBoard.subitem_board?.id
    )
  ) : [];
}
async function createUpdate(accessToken, itemID, text) {
  const query = `
    mutation CreateUpdate($itemID: Int!, $text: String!) {
      create_update(item_id: $itemID, body: $text) {
        id
      }
    }`;
  await apiRequest2(query, accessToken, {
    itemID: parseInt(itemID, 10),
    text
  });
}
async function createItem(accessToken, boardID, groupID, title, update) {
  const mutation = `
    mutation CreateItem($boardID: Int!, $groupID: String, $title: String!) {
      create_item(board_id: $boardID, group_id: $groupID, item_name: $title) {
        id
      }
    }`;
  const responseJson = await apiRequest2(
    mutation,
    accessToken,
    {
      boardID: parseInt(boardID, 10),
      groupID,
      title
    }
  );
  const itemID = responseJson?.create_item?.id;
  if (!itemID) {
    throw new Error("Didn't receive an ID back from Monday");
  }
  await createUpdate(accessToken, itemID, update);
  return itemID;
}
async function createSubItem(accessToken, parentItemID, title, update) {
  const mutation = `
    mutation CreateSubItem($parentItemID: Int!, $title: String!) {
      create_subitem(parent_item_id: $parentItemID, item_name: $title) {
        id
      }
    }`;
  const responseJson = await apiRequest2(
    mutation,
    accessToken,
    {
      parentItemID: parseInt(parentItemID, 10),
      title
    }
  );
  const subItemID = responseJson?.create_subitem?.id;
  if (!subItemID) {
    throw new Error("Didn't receive an ID back from Monday");
  }
  await createUpdate(accessToken, subItemID, update);
  return subItemID;
}
async function canCreateSubItems(accessToken, itemID) {
  const query = `
    query SubItemCheck($itemID: Int!) {
      items(ids: [$itemID]) {
        board {
          columns {
            type
          }
        }
      }
    }`;
  const responseJson = await apiRequest2(
    query,
    accessToken,
    {
      itemID: parseInt(itemID, 10)
    }
  );
  return !!responseJson.items[0].board.columns.some(
    (c) => c.type === "subtasks"
  );
}
async function getMondayPreviewData(accessToken, itemID) {
  const query = `
    query PreviewData($itemID: Int!) {
      me {
        account {
          slug
        }
      }
      items(ids: [$itemID]) {
        name
        board {
          id
          columns {
            id
            type
            settings_str
          }
        }
        column_values {
          id
          type
          value
        }
      }
    }
  `;
  const responseJson = await apiRequest2(
    query,
    accessToken,
    { itemID: parseInt(itemID, 10) }
  );
  const item = responseJson.items[0];
  const assigneeColumn = item.column_values.find(
    (c) => c.type === "multiple-person"
  );
  const assigneeIDs = assigneeColumn?.value ? (
    // Monday can have the same person assigned multiple times (?!), so
    // uniqify the list of assignees
    unique11(
      JSON.parse(assigneeColumn.value)?.personsAndTeams?.map(
        (p) => p.id
      ) ?? []
    )
  ) : [];
  let assignee = void 0;
  if (assigneeIDs.length === 1) {
    const userQuery = `
      query UserQuery($userID: Int!) {
        users(ids: [$userID]) {
          name
        }
      }`;
    const userResponseJson = await apiRequest2(userQuery, accessToken, { userID: parseInt(assigneeIDs[0], 10) });
    assignee = userResponseJson.users[0]?.name;
  } else if (assigneeIDs.length > 0) {
    assignee = `${assigneeIDs.length} people`;
  }
  const doneColumn = findDoneColumn(item.board.columns);
  let done = false;
  if (doneColumn) {
    const doneColumnValue = item.column_values.find(
      (cv) => cv.id === doneColumn.id
    );
    if (doneColumnValue?.value) {
      const index = JSON.parse(doneColumnValue.value).index;
      done = doneColumn.doneValues.includes(index);
    }
  }
  return {
    title: item.name,
    url: `https://${responseJson.me.account.slug}.monday.com/boards/${item.board.id}/pulses/${itemID}`,
    assignee,
    done,
    assigneeColumnID: assigneeColumn?.id,
    statusColumnID: doneColumn?.id
  };
}
async function addAssignees(accessToken, itemID, assignees, logger) {
  const query = `
    query AssigneeData($itemID: Int!) {
      items(ids: [$itemID]) {
        board {
          id
        }
        column_values {
          id
          type
          value
        }
      }
    }`;
  const responseJson = await apiRequest2(
    query,
    accessToken,
    { itemID: parseInt(itemID, 10) }
  );
  const item = responseJson.items[0];
  const firstPersonColumn = item.column_values.find(
    (c) => c.type === "multiple-person"
  );
  if (!firstPersonColumn) {
    logger.error("No person column found when trying to assign a Monday task", {
      boardID: item.board.id,
      itemID
    });
    return;
  }
  const columnValue = JSON.parse(
    firstPersonColumn.value ?? '{"personsAndTeams": []}'
  );
  const existingIDs = columnValue.personsAndTeams.map((p) => p.id.toString());
  columnValue.personsAndTeams.push(
    ...assignees.filter((a) => !existingIDs.includes(a)).map((a) => ({ id: parseInt(a, 10), kind: "person" }))
  );
  const mutation = `
    mutation AssignItem($boardID: Int!, $itemID: Int!, $columnID: String!, $assignees: JSON!) {
      change_column_value(board_id: $boardID, item_id: $itemID, column_id: $columnID, value: $assignees) {
        id
      }
    }`;
  await apiRequest2(mutation, accessToken, {
    itemID: parseInt(itemID, 10),
    boardID: parseInt(item.board.id, 10),
    columnID: firstPersonColumn.id,
    assignees: JSON.stringify(columnValue)
  });
}
var MONDAY_TASK_NOT_DONE_STATUS = 5;
var MONDAY_DEFAULT_DONE_COLORS = [1];
async function setItemStatus(accessToken, itemID, done, logger) {
  const query = `
    query ColumnData($itemID: Int!) {
      items(ids: [$itemID]) {
        board {
          id
          columns {
            id
            type
            settings_str
          }
        }
      }
    }`;
  const columnData = await apiRequest2(query, accessToken, {
    itemID: parseInt(itemID, 10)
  });
  const item = columnData.items[0];
  const doneColumn = findDoneColumn(item.board.columns);
  if (!doneColumn) {
    logger.error(
      "No status column found when trying to change status of a Monday task",
      {
        boardID: item.board.id,
        itemID
      }
    );
    return;
  }
  const statusToSet = !done ? MONDAY_TASK_NOT_DONE_STATUS : doneColumn.doneValues[0];
  if (!statusToSet) {
    logger.error(
      "No done status found when trying to change status of a Monday task",
      {
        boardID: item.board.id,
        itemID
      }
    );
    return;
  }
  const mutation = `
    mutation UpdateStatus($boardID: Int!, $itemID: Int!, $columnID: String!, $status: String!) {
      change_simple_column_value(board_id: $boardID, item_id: $itemID, column_id: $columnID, value: $status) {
        id
      }
    }`;
  await apiRequest2(mutation, accessToken, {
    boardID: parseInt(item.board.id, 10),
    itemID: parseInt(itemID, 10),
    columnID: doneColumn.id,
    status: statusToSet.toString()
  });
}
function findDoneColumn(columns) {
  const firstStatusColumn = columns.find((c) => c.type === "color");
  if (!firstStatusColumn) {
    return null;
  }
  const settings = JSON.parse(
    firstStatusColumn.settings_str
  );
  if (!settings.done_colors) {
    settings.done_colors = MONDAY_DEFAULT_DONE_COLORS;
  }
  return {
    id: firstStatusColumn.id,
    doneValues: settings.done_colors.filter((c) => c in settings.labels)
  };
}
async function findOldestUpdate(accessToken, itemID) {
  const query = `
    query OldestMutation($itemID: Int!) {
      items(ids: [$itemID]) {
        updates {
          id
          created_at
        }
      }
    }`;
  const responseJson = await apiRequest2(
    query,
    accessToken,
    {
      itemID: parseInt(itemID, 10)
    }
  );
  const updates = responseJson.items[0].updates;
  updates.sort((a, b) => a.created_at.localeCompare(b.created_at));
  return updates[0]?.id ?? null;
}
async function uploadFile(accessToken, updateID, filename, contentType, filesize, stream) {
  const mutation = `
    mutation add_file($updateID: Int!, $file: File!) {
      add_file_to_update(update_id: $updateID, file: $file) {
        id
      }
    }`;
  const form = new FormData2();
  form.append("query", mutation, { contentType: "application/json" });
  form.append(
    "variables",
    JSON.stringify({ updateID: parseInt(updateID, 10) }),
    { contentType: "application/json" }
  );
  form.append("map", JSON.stringify({ attachment: "variables.file" }), {
    contentType: "application/json"
  });
  form.append("attachment", stream, {
    filename,
    contentType,
    knownLength: filesize
  });
  return await fetch("https://api.monday.com/v2/file", {
    method: "POST",
    headers: {
      Authorization: accessToken
    },
    body: form.getBuffer()
  });
}
async function createWebhook2(accessToken, boardID, url6) {
  const mutation = `
    mutation CreateWebhook($boardID: Int!, $url: String!) {
      create_webhook(board_id:$boardID, url:$url, event:change_column_value) {
        id
      }
    }`;
  const responseJson = await apiRequest2(
    mutation,
    accessToken,
    {
      boardID: parseInt(boardID, 10),
      url: url6
    }
  );
  return responseJson?.create_webhook?.id ?? null;
}

// server/src/third_party_tasks/asana/util.ts
var import_types33 = __toESM(require_cjs(), 1);
import { encode as encode2 } from "html-entities";
function textNodeToHtml(node) {
  let before = "";
  let after = "";
  if (node.bold) {
    before += "<strong>";
    after += "</strong>";
  }
  if (node.italic) {
    before = "<em>" + before;
    after += "</em>";
  }
  if (node.underline) {
    before = "<u>" + before;
    after += "</u>";
  }
  return before + encode2(node.text) + after;
}
function convertNodeToAsanaHtml(node) {
  if (node.type === void 0) {
    return textNodeToHtml(node);
  } else {
    switch (node.type) {
      case import_types33.MessageNodeType.LINK:
        return `<a href="${encodeURI(node.url)}">${encode2(
          node.children[0].text
        )}</a>`;
      case import_types33.MessageNodeType.PARAGRAPH:
        return `${convertNodeListToAsanaHtml(node.children)}
`;
      case import_types33.MessageNodeType.TODO:
      case import_types33.MessageNodeType.BULLET:
      case import_types33.MessageNodeType.NUMBER_BULLET:
        return `<li>${convertNodeListToAsanaHtml(node.children)}</li>`;
      case import_types33.MessageNodeType.ASSIGNEE:
      case import_types33.MessageNodeType.MENTION:
        return encode2(node.children[0].text);
      case import_types33.MessageNodeType.QUOTE:
        return `${convertNodeListToAsanaHtml(node.children)}
`;
      case import_types33.MessageNodeType.CODE:
        return `<code>${convertNodeListToAsanaHtml(node.children)}</code>`;
      case import_types33.MessageNodeType.MARKDOWN:
        return convertNodeListToAsanaHtml(node.children);
    }
  }
}
function convertNodeListToAsanaHtml(nodes) {
  let html2 = "";
  let unorderedListStarted = false;
  let orderedListStarted = false;
  for (const node of nodes) {
    const nodeHtml = convertNodeToAsanaHtml(node);
    const isOrderedItem = node.type === import_types33.MessageNodeType.NUMBER_BULLET;
    const isUnorderedItem = node.type === import_types33.MessageNodeType.BULLET || node.type === import_types33.MessageNodeType.TODO;
    if (!isOrderedItem && orderedListStarted) {
      orderedListStarted = false;
      html2 += "</ol>";
    }
    if (!isUnorderedItem && unorderedListStarted) {
      unorderedListStarted = false;
      html2 += "</ul>";
    }
    if (isOrderedItem && !orderedListStarted) {
      orderedListStarted = true;
      html2 += "<ol>";
    }
    if (isUnorderedItem && !unorderedListStarted) {
      unorderedListStarted = true;
      html2 += "<ul>";
    }
    html2 += nodeHtml;
  }
  if (unorderedListStarted) {
    html2 += "</ul>";
  }
  if (orderedListStarted) {
    html2 += "</ol>";
  }
  return html2;
}
function messageContentToMondayHtml(content, footer) {
  return `${convertNodeListToAsanaHtml(content)}
${footer}`;
}
function messageContentToAsanaHtml(content, footer) {
  return `<body>${convertNodeListToAsanaHtml(content)}
${footer}</body>`;
}

// server/src/third_party_tasks/monday/actions.ts
async function getMondayCredentials(viewer) {
  try {
    const { userID, orgID } = assertViewerHasIdentity(viewer);
    const key = cacheKey({ type: "monday_credentials", userID, orgID });
    let credentials2 = cache.get(key);
    if (credentials2 !== void 0) {
      return credentials2;
    }
    const externalData = await getExternalAuthData(viewer, "monday");
    if (externalData === null) {
      return null;
    }
    const { accessToken } = externalData;
    credentials2 = {
      accessToken
    };
    cache.set(key, credentials2, 60 * 60 * 24 * 365);
    return credentials2;
  } catch (e) {
    handleThirdPartyException("getMondayCredentials", e, "monday", viewer);
    return null;
  }
}
async function fetchMondayBoards(viewer) {
  try {
    const credentials2 = await getMondayCredentials(viewer);
    if (!credentials2) {
      return [];
    }
    const { accessToken } = credentials2;
    return await getBoards(accessToken);
  } catch (e) {
    handleThirdPartyException("fetchMondayBoards", e, "monday", viewer);
    return [];
  }
}
async function createMondayTask(viewer, task) {
  try {
    const credentials2 = await getMondayCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const message = await MessageEntity.findByPk(task.messageID);
    if (!message) {
      throw new Error(
        `Failed to fetch message ${task.messageID} linked to task ${task.id}`
      );
    }
    const title = taskTitleFromMessageContent(message.content);
    let footerText = await getTaskFooterText(viewer, message, "monday");
    if (typeof footerText !== "string") {
      footerText = "";
    }
    const htmlNotes = messageContentToMondayHtml(message.content, footerText);
    const preferences = await getConnectionPreferences(viewer);
    if (!preferences) {
      throw new Error(
        `Could not get Monday connection preferences, which we need to choose the Monday board, when creating task ${task.id}`
      );
    }
    const itemID = await createItem(
      accessToken,
      preferences.boardID,
      preferences.groupID,
      title,
      htmlNotes
    );
    const previewData = await getMondayPreviewData(accessToken, itemID);
    const externalReference = await TaskThirdPartyReference.create({
      taskID: task.id,
      externalID: itemID,
      externalConnectionType: "monday",
      previewData
    });
    if (task.done) {
      await updateMondayTask(viewer, externalReference, true);
    }
    await ensureWebhook(viewer, accessToken, preferences.boardID);
  } catch (e) {
    handleThirdPartyException(
      `Failed to create Monday task for task ${task.id}`,
      e,
      "monday",
      viewer
    );
  }
}
async function getConnectionPreferences(viewer) {
  const userID = assertViewerHasUser(viewer);
  const response = await UserPreferenceEntity.findOne({
    where: {
      userID,
      key: MONDAY_CONNECTION_PREFERENCES
    }
  });
  return response ? response.value : void 0;
}
async function addMondayAssignees(viewer, taskID, newAssigneeUserIDs) {
  const logger = new Logger(viewer);
  try {
    const credentials2 = await getMondayCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const thirdPartyReference = await TaskThirdPartyReference.findForTask(
      taskID,
      "monday"
    );
    if (!thirdPartyReference) {
      return;
    }
    const itemID = thirdPartyReference.externalID;
    const [matchedAccountIDs, unmatchedUsers] = await getThirdPartyMatchedAccounts(viewer, newAssigneeUserIDs, "monday");
    await addAssignees(accessToken, itemID, matchedAccountIDs, logger);
    await updateItemPreviewData(accessToken, thirdPartyReference);
    if (unmatchedUsers.length > 0) {
      await createUpdate(
        accessToken,
        itemID,
        unmatchedUsersText(unmatchedUsers)
      );
    }
  } catch (e) {
    handleThirdPartyException(`updateMondayAssignees`, e, "monday", viewer);
  }
}
async function updateItemPreviewData(accessToken, externalReference) {
  if (!externalReference.taskTodoID) {
    const itemID = externalReference.externalID;
    const previewData = await getMondayPreviewData(accessToken, itemID);
    await externalReference.update({ previewData });
    await publishMessageUpdateForTask(externalReference);
  }
}
function unmatchedUsersText(noMatchUsers) {
  if (noMatchUsers.length === 0) {
    return "";
  }
  return [
    "This task was assigned to the following Cord users who did not have Monday connected:",
    ...noMatchUsers.map((user) => `${userDisplayName(user)} (${user.email})`)
  ].join("\n");
}
async function updateMondayTask(viewer, externalReference, done) {
  const logger = new Logger(viewer);
  try {
    if (externalReference.externalConnectionType !== "monday") {
      throw new Error(
        `Expected connection type "monday" but got ${externalReference.externalConnectionType} instead.`
      );
    }
    const credentials2 = await getMondayCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    await setItemStatus(
      accessToken,
      externalReference.externalID,
      done,
      logger
    );
    await updateItemPreviewData(accessToken, externalReference);
  } catch (e) {
    handleThirdPartyException("updateMondayTask", e, "monday", viewer);
    return;
  }
}
async function createMondaySubtasks(viewer, taskID, todos) {
  try {
    const credentials2 = await getMondayCredentials(viewer);
    if (!credentials2) {
      return;
    }
    const { accessToken } = credentials2;
    const [task, thirdPartyReference] = await Promise.all([
      TaskEntity.findByPk(taskID),
      TaskThirdPartyReference.findForTask(taskID, "monday")
    ]);
    if (!task || !thirdPartyReference) {
      return;
    }
    const { messageID } = task;
    const message = await MessageEntity.findByPk(messageID);
    if (!message) {
      return;
    }
    const itemID = thirdPartyReference.externalID;
    if (!await canCreateSubItems(accessToken, itemID)) {
      return;
    }
    const createdTodoIDs = new Set(todos.map((todo) => todo.id));
    const todoNodes = todoNodesFromMessage(message.content).filter(
      (node) => createdTodoIDs.has(node.todoID)
    );
    let footerText = await getTaskFooterText(viewer, message, "monday");
    if (typeof footerText !== "string") {
      footerText = "";
    }
    const description = messageContentToMondayHtml([], footerText);
    const subItemIDs = await Promise.all(
      todoNodes.map(
        (todoNode) => createSubItem(
          accessToken,
          itemID,
          textFromNodeRecursive(todoNode),
          description
        )
      )
    );
    const externalReferences = (await Promise.all(
      subItemIDs.map((subItemID, i) => {
        if (!subItemID) {
          return;
        }
        return TaskThirdPartyReference.create({
          taskID,
          externalID: subItemID,
          externalConnectionType: "monday",
          taskTodoID: todoNodes[i].todoID,
          previewData: null
        });
      })
    )).filter(isDefined);
    await Promise.all(
      todoNodes.map((todoNode, i) => {
        if (!todos.find(({ id }) => todoNode.todoID === id)?.done) {
          return null;
        }
        const externalReference = externalReferences.find(
          // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
          (externalReference2) => externalReference2.externalID === subItemIDs[i]
        );
        if (!externalReference) {
          return null;
        }
        return updateMondayTask(viewer, externalReference, true);
      })
    );
  } catch (e) {
    handleThirdPartyException("createMondaySubtasks", e, "monday", viewer);
    return;
  }
}
async function addMondayTaskAttachments(viewer, itemID, files) {
  try {
    const credentials2 = await getMondayCredentials(viewer);
    if (credentials2 === null) {
      return;
    }
    const { accessToken } = credentials2;
    const s3BucketLoader = new S3BucketLoader(viewer);
    const updateID = await findOldestUpdate(accessToken, itemID);
    if (!updateID) {
      return;
    }
    await Promise.all(
      files.filter((file) => file.uploadStatus === "uploaded").map(async (file) => {
        const url6 = await file.getSignedDownloadURL(s3BucketLoader);
        const response = await fetch(url6);
        if (response.status === 200) {
          await uploadFile(
            accessToken,
            updateID,
            file.name,
            file.mimeType,
            file.size,
            response.body
          );
        } else {
          throw new Error(
            `failed to attach file ${file.id} to Monday task ${itemID}`
          );
        }
      })
    );
  } catch (e) {
    handleThirdPartyException(
      `Failed to attach file to Monday task ${itemID}`,
      e,
      "monday",
      viewer
    );
  }
}
async function ensureWebhook(viewer, accessToken, boardID) {
  if (await getRedis().incrAndExpire(
    `subscription-create-monday-${boardID}`,
    60
  ) !== 1) {
    return;
  }
  const subscription = await TaskThirdPartySubscriptionEntity.findOne({
    where: {
      externalConnectionType: "monday",
      "subscriptionDetails.boardID": boardID
    }
  });
  if (subscription) {
    return;
  }
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  const id = uuid6();
  const url6 = `https://${API_SERVER_HOST}${MONDAY_EVENTS_PATH_BASE}/${id}`;
  const webhookID = await createWebhook2(accessToken, boardID, url6);
  if (webhookID) {
    await TaskThirdPartySubscriptionEntity.create({
      id,
      userID,
      orgID,
      externalConnectionType: "monday",
      subscriptionDetails: {
        boardID,
        webhookID
      }
    });
  }
}
async function webhookUpdateAssignee(itemID, event) {
  try {
    const entities = await findTaskAndMessageEntitiesFromExternalTaskID(
      itemID,
      "monday"
    );
    if (!entities) {
      return;
    }
    const { taskEntity, messageEntity, thirdPartyTaskEntity } = entities;
    const previewData = thirdPartyTaskEntity.previewData;
    if (previewData?.assigneeColumnID !== event.columnId) {
      return;
    }
    const newIDs = (event.value?.personsAndTeams ?? []).map(
      (pat) => pat.id.toString()
    );
    const oldIDs = (event.previousValue?.personsAndTeams ?? []).map(
      (pat) => pat.id.toString()
    );
    const toRemove = oldIDs.filter((id) => !newIDs.includes(id));
    const toAdd = newIDs.filter((id) => !oldIDs.includes(id));
    const taskID = taskEntity.id;
    const { orgID } = messageEntity;
    await Promise.all([
      ...toRemove.map(async (id) => {
        const thirdPartyConnection = await ThirdPartyConnectionEntity.findOne({
          where: { externalID: id, orgID }
        });
        if (!thirdPartyConnection) {
          anonymousLogger().info(
            `Could not find Monday user ${id} as a Cord user`
          );
          return;
        } else {
          const { userID } = thirdPartyConnection;
          return await TaskAssigneeEntity.destroy({
            where: { taskID, userID, orgID }
          });
        }
      }),
      ...toAdd.map(async (id) => {
        const thirdPartyConnection = await ThirdPartyConnectionEntity.findOne({
          where: { externalID: id, orgID }
        });
        if (!thirdPartyConnection) {
          anonymousLogger().info(
            `Could not find Monday user ${id} as a Cord user`
          );
        } else {
          const { userID } = thirdPartyConnection;
          await TaskAssigneeEntity.findOrCreate({
            where: { taskID, userID, orgID }
          });
        }
      })
    ]);
    await thirdPartyTaskEntity.update({
      previewData: {
        ...previewData,
        assignee: newIDs.length ? (
          // NOTE(flooey): Ideally we would use the person's name, but it's not
          // delivered in the event, so we would have to call the API to get
          // it
          pluralize(newIDs.length, "person", "people")
        ) : null
      }
    });
    await publishMessageUpdateForTask(thirdPartyTaskEntity);
  } catch (e) {
    handleThirdPartyException(
      `Failed to update Monday assignee in task ${itemID}`,
      e,
      "monday"
    );
  }
}
async function webhookUpdateStatus(itemID, event) {
  try {
    const entities = await findTaskAndMessageEntitiesFromExternalTaskID(
      itemID,
      "monday"
    );
    if (!entities) {
      return;
    }
    const { taskEntity, thirdPartyTaskEntity } = entities;
    const previewData = thirdPartyTaskEntity.previewData;
    if (previewData?.statusColumnID !== event.columnId) {
      return;
    }
    await taskEntity.update({
      done: !!event.value?.label.is_done
    });
    await thirdPartyTaskEntity.update({
      previewData: {
        ...previewData,
        done: !!event.value?.label.is_done
      }
    });
    await publishMessageUpdateForTask(thirdPartyTaskEntity);
  } catch (e) {
    handleThirdPartyException(
      `Failed to update Monday status in task ${itemID}`,
      e,
      "monday"
    );
  }
}

// server/src/entity/task/TaskMutator.ts
var TaskMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.logger = new Logger(viewer);
  }
  async createTask(task, messageID) {
    const orgID = assertViewerHasOrg(this.viewer);
    const entity = await TaskEntity.create({
      id: task.id,
      messageID,
      done: task.done,
      orgID
    });
    await this.createExternalTask(entity, task.type);
    return entity;
  }
  async createExternalTask(task, type) {
    switch (type) {
      case "jira": {
        await createSimpleJiraTask(this.viewer, task);
        break;
      }
      case "asana": {
        await createAsanaTask(this.viewer, task);
        break;
      }
      case "linear": {
        await createLinearTask(this.viewer, task);
        break;
      }
      case "trello": {
        await createTrelloTask(this.logger, this.viewer, task);
        break;
      }
      case "monday": {
        await createMondayTask(this.viewer, task);
        break;
      }
    }
    const messageAttachmentLoader = new MessageAttachmentLoader(this.viewer);
    const messageAttachments = await messageAttachmentLoader.loadAttachmentsForMessage(task.messageID);
    const fileIDs = getFileAttachmentEntities(messageAttachments).map((attachment) => {
      switch (attachment.type) {
        case "file" /* FILE */:
          return attachment.data.fileID;
        case "annotation" /* ANNOTATION */:
          return attachment.data.screenshotFileID;
        case "screenshot" /* SCREENSHOT */:
          return null;
        default:
          return null;
      }
    }).filter(isDefined);
    if (fileIDs.length > 0) {
      const fileLoader = new FileLoader(this.viewer);
      const files = await fileLoader.loadFiles(fileIDs);
      return await new MessageAttachmentMutator(
        this.viewer,
        this.loaders
      ).attachFilesToExternalTasks(task, files);
    }
    return;
  }
  async createOrUpdateTask(task, messageID) {
    const orgID = assertViewerHasOrg(this.viewer);
    const taskLoader = new TaskLoader(this.viewer);
    const existingTask = await taskLoader.loadTask(task.id, orgID);
    let lastUpdatedBy;
    if (task.doneStatusUpdate === "update") {
      lastUpdatedBy = this.viewer.userID;
    } else if (task.doneStatusUpdate === "remove") {
      lastUpdatedBy = null;
    }
    if (existingTask) {
      const [updateCount] = await TaskEntity.update(
        {
          done: task.done,
          ...lastUpdatedBy !== void 0 && {
            doneStatusLastUpdatedBy: lastUpdatedBy
          }
        },
        { where: { id: task.id, orgID } }
      );
      if (updateCount === 0) {
        return existingTask;
      } else {
        const entity = await TaskEntity.findByPk(task.id);
        if (entity && task.type !== "cord") {
          await this.updateOrCreateExternalTasks(entity, task.type);
        }
        return entity;
      }
    } else {
      return await this.createTask(task, messageID);
    }
  }
  async updateOrCreateExternalTasks(task, type) {
    const externalReference = await TaskThirdPartyReference.findForTask(
      task.id,
      type
    );
    if (externalReference) {
      switch (externalReference.externalConnectionType) {
        case "asana":
          return await updateAsanaTask(
            this.viewer,
            externalReference,
            task.done
          );
        case "linear":
          return await updateLinearTask(
            this.viewer,
            externalReference,
            task.done
          );
        case "jira":
          return await updateJiraTask(
            this.viewer,
            externalReference,
            task.done
          );
        case "monday":
          return await updateMondayTask(
            this.viewer,
            externalReference,
            task.done
          );
        default:
          this.logger.info(
            `updating of ${externalReference.externalConnectionType} is not supported yet`
          );
          return null;
      }
    } else {
      await this.createExternalTask(task, type);
    }
  }
  // Deleting task also deletes Todos and Assignees
  async deleteTaskFromMessageID(messageID, orgID) {
    return await TaskEntity.destroy({ where: { messageID, orgID } });
  }
};

// server/src/entity/task_assignee/TaskAssigneeMutator.ts
import { Op as Op21 } from "sequelize";
var TaskAssigneeMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
  }
  async createTaskAssignees(taskID, userIDs) {
    if (userIDs.length === 0) {
      return [];
    }
    const orgID = assertViewerHasOrg(this.viewer);
    const [returnedColumns] = await getSequelize().query(
      `INSERT INTO
      "${TaskAssigneeEntity.tableName}"
      ("userID", "taskID", "orgID", "assignerID")
      VALUES
      ${userIDs.map(() => "(?)").join(",")}
      ON CONFLICT DO NOTHING
      RETURNING "userID"`,
      // sequelize returns column names in lower-case
      {
        replacements: userIDs.map((userID) => [
          userID,
          taskID,
          orgID,
          this.viewer.userID
        ])
      }
    );
    const newUserIDs = returnedColumns.map(
      (row) => row.userID
    );
    await this.updateExternalTaskAssignees(taskID, newUserIDs, userIDs);
    return newUserIDs;
  }
  async updateTaskAssignees(taskID, userIDs) {
    const orgID = assertViewerHasOrg(this.viewer);
    const task = await new TaskLoader(this.viewer).loadTask(taskID, orgID);
    const removedAssignees = await TaskAssigneeEntity.findAll({
      attributes: ["userID"],
      where: {
        taskID,
        orgID,
        userID: { [Op21.notIn]: userIDs }
      }
    });
    const messageMutator = new MessageMutator(this.viewer, this.loaders);
    if (task !== null && task !== void 0 && removedAssignees.length > 0) {
      await messageMutator.removeAssignees(task.messageID, removedAssignees);
    }
    await TaskAssigneeEntity.destroy({
      where: {
        taskID,
        orgID,
        userID: { [Op21.notIn]: userIDs }
      }
    });
    const newAssigneeIDs = await this.createTaskAssignees(taskID, userIDs);
    return {
      newAssigneeIDs,
      removedAssigneeIDs: removedAssignees.map(({ userID }) => userID)
    };
  }
  async updateExternalTaskAssignees(taskID, newUserIDs, assigneeIDs) {
    const externalReferences = await TaskThirdPartyReference.findAllForTask(taskID);
    return await Promise.all(
      externalReferences.map((externalReference) => {
        switch (externalReference.externalConnectionType) {
          case "jira":
            return updateJiraTaskAssigneeAndWatchers(
              this.viewer,
              taskID,
              assigneeIDs
            );
          case "asana":
            return addAsanaTaskAssignees(this.viewer, taskID, newUserIDs);
          case "linear":
            return updateLinearTaskAssigneeAndSubscribers(
              this.viewer,
              taskID,
              assigneeIDs
            );
          case "trello":
            return addAssigneesToTrelloTask(this.viewer, taskID, newUserIDs);
          case "monday":
            return addMondayAssignees(this.viewer, taskID, newUserIDs);
        }
      })
    );
  }
};

// server/src/entity/task_todo/TaskTodoMutator.ts
var TaskTodoMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.logger = new Logger(viewer);
  }
  async createTaskTodos(taskID, todos) {
    if (todos.length === 0) {
      return [];
    }
    const orgID = assertViewerHasOrg(this.viewer);
    const entities = await TaskTodoEntity.bulkCreate(
      todos.map((todo) => ({
        id: todo.id,
        taskID,
        orgID,
        done: todo.done
      }))
    );
    await this.createExternalSubtasks(taskID, entities);
    return entities;
  }
  async updateTaskTodosDoneState(taskID, todos) {
    if (todos.length === 0) {
      return [];
    }
    const orgID = assertViewerHasOrg(this.viewer);
    const result = await Promise.all(
      todos.map(
        (todo) => TaskTodoEntity.update(
          { done: todo.done },
          { where: { id: todo.id, orgID, taskID } }
        )
      )
    );
    await this.updateExternalSubtasks(taskID, todos);
    return result;
  }
  async deleteTaskTodos(taskID, todos) {
    if (todos.length === 0) {
      return;
    }
    const orgID = assertViewerHasOrg(this.viewer);
    return await TaskTodoEntity.destroy({
      where: {
        taskID,
        orgID,
        id: todos.map(({ id }) => id)
      }
    });
  }
  async createExternalSubtasks(taskID, entities) {
    const externalReferences = await TaskThirdPartyReference.findAllForTask(taskID);
    return await Promise.all(
      externalReferences.map(async (externalReference) => {
        switch (externalReference.externalConnectionType) {
          case "jira":
            return await createJiraSubtasks(this.viewer, taskID, entities);
          case "asana":
            return await createAsanaSubtasks(this.viewer, taskID, entities);
          case "linear":
            return await createLinearSubtasks(this.viewer, taskID, entities);
          case "monday":
            return await createMondaySubtasks(this.viewer, taskID, entities);
          case "trello":
            this.logger.info(
              `attaching todos to trello tasks is not supported yet`
            );
            return null;
        }
      })
    );
  }
  async updateExternalSubtasks(taskID, todos) {
    const todoDoneState = Object.fromEntries(
      todos.map((todo) => [todo.id, todo.done])
    );
    const externalReferences = await TaskThirdPartyReference.findAllForTaskTodos(
      taskID,
      Object.keys(todoDoneState)
    );
    return await Promise.all(
      externalReferences.map((externalReference) => {
        switch (externalReference.externalConnectionType) {
          case "jira":
            return updateJiraTask(
              this.viewer,
              externalReference,
              todoDoneState[externalReference.taskTodoID]
            );
          case "asana":
            return updateAsanaTask(
              this.viewer,
              externalReference,
              todoDoneState[externalReference.taskTodoID]
            );
          case "linear":
            return updateLinearTask(
              this.viewer,
              externalReference,
              todoDoneState[externalReference.taskTodoID]
            );
          case "monday":
            return updateMondayTask(
              this.viewer,
              externalReference,
              todoDoneState[externalReference.taskTodoID]
            );
          default:
            this.logger.info(
              `updating of ${externalReference.externalConnectionType} is not supported yet`
            );
            return null;
        }
      })
    );
  }
  // Delete any deleted todos, update existing todos, add new todos
  async setTaskTodos(taskID, todos) {
    const orgID = assertViewerHasOrg(this.viewer);
    const oldTodos = await TaskTodoEntity.findAll({
      where: {
        taskID,
        orgID
      }
    });
    const oldTodosMap = new Map(oldTodos.map((todo) => [todo.id, todo]));
    const newTodosMap = new Map(todos.map((todo) => [todo.id, todo]));
    const todosToCreate = todos.filter(
      (newTodo) => !oldTodosMap.has(newTodo.id)
    );
    const todosToDelete = oldTodos.filter(
      (oldTodo) => !newTodosMap.has(oldTodo.id)
    );
    const todosToUpdateDone = todos.filter(
      (todo) => oldTodosMap.has(todo.id) && oldTodosMap.get(todo.id).done !== todo.done
    );
    const promises = [
      this.deleteTaskTodos(taskID, todosToDelete),
      this.updateTaskTodosDoneState(taskID, todosToUpdateDone),
      this.createTaskTodos(taskID, todosToCreate)
    ];
    return await Promise.all(promises);
  }
};

// server/src/message/new_message_tasks/addNewMessageTasks.ts
async function addNewMessageTasks(viewer, loaders, task, messageID) {
  const taskMutator = new TaskMutator(viewer, loaders);
  await taskMutator.createTask(task, messageID);
  const taskAssigneeMutator = new TaskAssigneeMutator(viewer, loaders);
  const taskAssigneeUserIDs = await taskAssigneeMutator.createTaskAssignees(
    task.id,
    task.assigneeIDs
  );
  const taskTodoMutator = new TaskTodoMutator(viewer);
  await taskTodoMutator.createTaskTodos(task.id, task.todos);
  return taskAssigneeUserIDs;
}

// server/src/message/new_message_tasks/publishNewMessageEvents.ts
async function publishNewMessageEvents(application, page, thread, message, isFirstMessageInThread, hasAnnotations, mentionedUserIDs, context, transaction) {
  const pageContextHash = thread.pageContextHash || page.contextHash;
  if (isFirstMessageInThread) {
    await publishNewThreadEvents(page.contextData, thread, transaction);
  }
  const notify = async () => {
    if (hasAnnotations && pageContextHash) {
      backgroundPromise(
        publishPubSubEvent("annotations-on-page-updated", {
          pageContextHash,
          orgID: thread.orgID
        })
      );
    }
    backgroundPromise(
      Promise.all([
        publishPubSubEvent(
          "thread-message-added",
          { threadID: thread.id },
          { messageID: message.id }
        ),
        publishEventToWebhook(application, {
          type: "thread-message-added",
          threadID: thread.id,
          messageID: message.id
        }),
        context.segmentLogger.publishMessageSendEvent(
          thread,
          message,
          isFirstMessageInThread,
          mentionedUserIDs.length
        )
      ]),
      context.logger
    );
  };
  if (transaction) {
    transaction.afterCommit(notify);
  } else {
    await notify();
  }
}

// server/src/message/new_message_tasks/maybeUnresolveThread.ts
import { v4 as uuid7 } from "uuid";

// common/const/MessageActions.ts
var MessageActions = {
  thread_resolved: "resolved this thread",
  thread_unresolved: "reopened this thread"
};
var MessageActionIconURLs = {
  thread_resolved: APP_ORIGIN + "/static/check-circle.svg",
  thread_unresolved: APP_ORIGIN + "/static/arrow-circle-up-right.svg"
};
var MessageActionTranslationKeys = {
  thread_resolved: "cord.thread_resolved",
  thread_unresolved: "cord.thread_unresolved"
};

// server/src/message/util/getActionMessageContent.ts
function getActionMessageContent(type, user) {
  return [
    {
      type: import_types2.MessageNodeType.PARAGRAPH,
      children: [
        createMentionNode(user.id, userDisplayName(user)),
        createMessageTextNode(" " + MessageActions[type])
      ]
    }
  ];
}

// server/src/entity/notification/NotificationMutator.ts
var counter6 = Counter2({
  name: "NotificationEntityCreated",
  help: "Count of created/sent notifications (raw DB rows)",
  labelNames: ["appID", "type"]
});
var markedCounter = Counter2({
  name: "NotificationEntityMarkedAsRead",
  help: "Count of NotificationEntity marked as read",
  labelNames: ["appID"]
});
var unmarkedCounter = Counter2({
  name: "NotificationEntityMarkedAsUnread",
  help: "Count of NotificationEntity marked as unread",
  labelNames: ["appID"]
});
var NotificationMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
    this.logger = new Logger(viewer);
  }
  async create(attrs, transaction) {
    const { userID, platformApplicationID } = assertViewerHasPlatformUser(
      this.viewer
    );
    const notif = await NotificationEntity.create(
      {
        ...attrs,
        senderID: userID,
        platformApplicationID
      },
      { transaction }
    );
    if (transaction) {
      transaction.afterCommit(async () => {
        await this.postCreate(notif);
      });
    } else {
      await this.postCreate(notif);
    }
    return notif;
  }
  async createExternal(attrs, transaction) {
    if (viewerHasIdentity(this.viewer)) {
      throw new Error(
        "Expected viewer to not have identity -- did you mean to use create instead of createExternal?"
      );
    }
    const notif = await NotificationEntity.create(
      {
        ...attrs,
        type: "external"
      },
      { transaction }
    );
    if (transaction) {
      transaction.afterCommit(async () => {
        await this.postCreate(notif);
      });
    } else {
      await this.postCreate(notif);
    }
    return notif;
  }
  async postCreate(notif) {
    counter6.inc({ type: notif.type, appID: notif.platformApplicationID }, 1);
    const app = await ApplicationEntity.findByPk(notif.platformApplicationID);
    if (!app) {
      throw new Error(`Cannot find app ${notif.platformApplicationID}`);
    }
    backgroundPromise(
      Promise.all([
        publishPubSubEvent(
          "notification-added",
          { userID: notif.recipientID },
          { notificationID: notif.id }
        ),
        publishEventToWebhook(app, {
          type: "notification-created",
          notificationID: notif.id,
          userID: notif.recipientID
        })
      ])
    );
  }
  async markAsRead(notif) {
    const [affectedCount] = await NotificationEntity.update(
      { readStatus: "read" },
      { where: whereAggregatedNotificationEntity(notif) }
    );
    backgroundPromise(
      publishPubSubEvent(
        "notification-read-state-updated",
        { userID: notif.recipientID },
        { notificationID: notif.id }
      ),
      this.logger
    );
    incCounterWithAppID(this.viewer, markedCounter, {}, affectedCount);
    return affectedCount;
  }
  async markAsUnread(notif) {
    const [affectedCount] = await NotificationEntity.update(
      { readStatus: "unread" },
      { where: whereAggregatedNotificationEntity(notif) }
    );
    backgroundPromise(
      publishPubSubEvent(
        "notification-read-state-updated",
        { userID: notif.recipientID },
        { notificationID: notif.id }
      ),
      this.logger
    );
    incCounterWithAppID(this.viewer, unmarkedCounter, {}, affectedCount);
    return affectedCount;
  }
};

// server/src/notifications/outbound/logging.ts
import { nanoid } from "nanoid";
async function generateOutboundNotificationLoggingURL({
  messageID,
  url: url6,
  targetOrgID,
  targetUserID,
  type,
  metadata,
  sharerUserID,
  sharerOrgID
}) {
  const entity = await MessageOutboundNotificationEntity.create({
    id: nanoid(NOTIFICATION_LOGGING_REDIRECT_ID_LENGTH),
    messageID,
    url: url6,
    type,
    targetUserID,
    targetOrgID,
    metadata,
    sharerUserID,
    sharerOrgID
  });
  if (!entity) {
    throw new Error(
      `Unable to create entity for message notification ${messageID}, type ${type}, url ${url6}`
    );
  }
  return `${CORD_TO_ORIGIN}${DEFAULT_NOTIFICATION_LOGGING_PATH}/${entity.id}`;
}

// server/src/asyncTier/jobs/sendSlackNotificationWithDelay.ts
var sendSlackNotificationWithDelay_default = new AsyncTierJobDefinition(
  "sendSlackNotificationWithDelay",
  sendSlackNotificationWithDelay
);
async function sendSlackNotificationWithDelay(data) {
  let viewer;
  if (!data.viewerUserID || !data.viewerOrgID) {
    throw new Error(
      "Trying to send slack notification without viewer userID or orgID"
    );
  }
  if (data.viewerPlatformApplicationID) {
    const [user, org] = await Promise.all([
      UserEntity.findByPk(data.viewerUserID),
      OrgEntity.findByPk(data.viewerOrgID)
    ]);
    if (!user?.externalID || !org?.externalID) {
      throw new Error(
        "Trying to send platform user slack notification without external user or org ID"
      );
    }
    viewer = await Viewer.createLoggedInPlatformViewer({
      user,
      org
    });
  } else {
    viewer = Viewer.createLoggedInViewer(data.viewerUserID, data.viewerOrgID);
  }
  const context = await contextWithSession(
    { viewer },
    getSequelize(),
    null,
    null
  );
  const message = await context.loaders.messageLoader.loadMessage(
    data.messageID
  );
  let canSkipSending = false;
  if (
    // we always want to send self-mentions
    data.viewerUserID !== data.targetUserID && message
  ) {
    const lastSeen = (await context.loaders.threadParticipantLoader.loadForUser({
      userID: data.targetUserID,
      threadID: message.threadID
    }))?.lastSeenTimestamp;
    canSkipSending = !!lastSeen && lastSeen >= message.timestamp;
  }
  if (canSkipSending) {
    return;
  }
  const notificationData = {
    context,
    senderUserID: data.senderUserID,
    senderOrgID: data.senderOrgID,
    senderName: data.senderName,
    targetUserID: data.targetUserID,
    messageID: data.messageID,
    url: data.url,
    pageName: data.pageName,
    providerName: data.providerName,
    actionText: data.actionText
  };
  if (data.notificationType === "thread_action") {
    await sendSlackThreadActionNotification({
      ...notificationData
    });
  } else {
    await sendSlackMentionNotification({
      ...notificationData,
      // using messageContent passed to this job instead of message.content since
      // message.content might have changed in the meantime
      messageContent: data.messageContent,
      allImageURLs: data.allImageURLs,
      actionText: data.actionText,
      annotationsHighlightedText: data.annotationsHighlightedText
    });
  }
}

// common/util/notifications.ts
var defaultNotificationPreference = {
  slack: true,
  email: true
};
var getNotificationChannels = (notificationChannelPreference, targetUserID, targetHasEmail, isTargetConnectedToSlack) => {
  let notificationChannels = notificationChannelPreference ?? defaultNotificationPreference;
  notificationChannels = {
    slack: notificationChannels.slack && isTargetConnectedToSlack,
    email: notificationChannels.email && targetHasEmail
  };
  return notificationChannels;
};

// server/src/util/findSlackUserEmailMatch.ts
async function findSlackUserEmailMatch(context, org, targetUser) {
  if (!targetUser.email) {
    return null;
  }
  if (org.externalProvider !== "platform") {
    return null;
  }
  const linkedOrgID = await context.loaders.linkedOrgsLoader.getConnectedSlackOrgID(org.id);
  if (!linkedOrgID) {
    return null;
  }
  const linkedUserID = (await context.loaders.linkedUsersLoader.loadLinkedUserFromSourceOrgScoped(
    targetUser.id,
    org.id
  ))?.linkedUserID;
  if (linkedUserID) {
    return null;
  }
  const platformUsersWithSameEmail = await context.loaders.userLoader.loadUserForEmailInOrg(
    targetUser.email,
    org.id
    // platform org
  );
  if (platformUsersWithSameEmail.length > 1) {
    return null;
  }
  const slackProfileWithMatchingEmail = await context.loaders.userLoader.loadUserForEmailInOrg(
    targetUser.email,
    linkedOrgID
    // slack org
  );
  if (slackProfileWithMatchingEmail.length === 0) {
    return null;
  }
  if (slackProfileWithMatchingEmail.length > 1) {
    return null;
  }
  const isSlackUserAlreadyLinked = !!await context.loaders.linkedUsersLoader.loadPlatformUserFromLinked({
    linkedUserID: slackProfileWithMatchingEmail[0].id,
    linkedOrgID,
    sourceOrgID: org.id
  });
  if (isSlackUserAlreadyLinked) {
    return null;
  }
  return slackProfileWithMatchingEmail[0];
}

// server/src/deep_link_threads/index.ts
import { URL as URL2 } from "url";
function makeKey(userID) {
  return `deepLinkThreadID/${userID}`;
}
async function getDeepLinkThreadMessageID(userID) {
  const value = await getRedis().get(makeKey(userID));
  if (value === null) {
    return null;
  }
  const parts = value.split("/");
  return {
    threadID: parts[0],
    messageID: parts[1]
  };
}
async function setDeepLinkThreadMessageID({
  userID,
  threadID,
  messageID
}) {
  const key = makeKey(userID);
  const value = messageID ? `${threadID}/${messageID}` : threadID;
  await getRedis().set(key, value, "EX", DEEP_LINK_THREAD_ID_TTL_SECONDS);
}
async function clearDeepLinkThreadMessageID(userID) {
  const key = makeKey(userID);
  await getRedis().del(key);
}
function injectDeeplinkQueryParamsV1(logger, url6, threadID, messageID) {
  try {
    const parsed = new URL2(url6);
    parsed.searchParams.set(
      CORD_DEEP_LINK_QUERY_PARAM,
      `v1_${threadID}_${messageID}`
    );
    return parsed.toString();
  } catch (e) {
    logger.logException("failed to parse url", e, { url: url6 }, void 0, "debug");
    return url6;
  }
}

// server/src/notifications/outbound/util.ts
function getIcon(actions) {
  if (actions.includes("assign-task") || actions.includes("unassign-task")) {
    return "task";
  } else if (actions.includes("mention") && actions.includes("attach-file")) {
    return "paperclip";
  } else {
    return "mention";
  }
}
async function loadPartitionedAttachments(context, messageID) {
  const attachments = await context.loaders.messageAttachmentLoader.loadAttachmentsForMessage(
    messageID
  );
  const fileIDs = [];
  const annotationIDs = [];
  const highlightedText = [];
  getFileAttachmentEntities(attachments).forEach((attachment) => {
    switch (attachment.type) {
      case "file" /* FILE */: {
        const attachmentData = attachment.data;
        fileIDs.push(attachmentData.fileID);
        break;
      }
      case "annotation" /* ANNOTATION */: {
        const attachmentData = attachment.data;
        annotationIDs.push(
          attachmentData.blurredScreenshotFileID ?? attachmentData.screenshotFileID
        );
        highlightedText.push(
          attachmentData.location?.highlightedTextConfig?.textToDisplay ?? attachmentData.customHighlightedTextConfig?.textToDisplay
        );
        break;
      }
    }
  });
  return await Promise.all([
    context.loaders.fileLoader.loadFiles(fileIDs),
    context.loaders.fileLoader.loadFiles(annotationIDs.filter(isDefined)),
    highlightedText.filter(isDefined)
  ]);
}
async function getNotificationPreference(context, target, orgID, emailMatchedSlackUserID) {
  const notificationChannelPreference = await context.loaders.userPreferenceLoader.loadPreferenceValueForUser(
    NOTIFICATION_CHANNELS,
    target.id
  );
  const notificationChannels = getNotificationChannels(
    notificationChannelPreference,
    target.id,
    !!target.email,
    !!await loadLinkedSlackUserOrgScoped(target, context, orgID) || !!emailMatchedSlackUserID
  );
  const emailNotificationsEnabled = await getTypedFeatureFlagValue(
    FeatureFlags2.ENABLE_EMAIL_NOTIFICATIONS,
    {
      userID: target.id,
      orgID,
      platformApplicationID: context.session.viewer.platformApplicationID ?? "extension",
      version: context.clientVersion,
      customerID: context.application?.customerID
    }
  );
  return {
    isEmailNotification: notificationChannels.email && emailNotificationsEnabled && context.application?.enableEmailNotifications,
    isSlackNotification: notificationChannels.slack
  };
}
async function getPartnerDetails(context, sender) {
  if (sender.platformApplicationID) {
    const application = await context.loaders.applicationLoader.load(
      sender.platformApplicationID
    );
    return application?.customEmailTemplate ?? void 0;
  } else {
    return void 0;
  }
}
async function generateOutboundNotificationData({
  context,
  targetUserID,
  message,
  userID
}) {
  const orgID = message.orgID;
  const messageID = message.id;
  const threadID = message.threadID;
  const [sender, target, org, targetOrgMember, thread] = await Promise.all([
    context.loaders.userLoader.loadUserInAnyViewerOrg(userID),
    context.loaders.userLoader.loadUser(targetUserID),
    context.loaders.orgLoader.loadOrg(orgID),
    context.loaders.orgMembersLoader.loadForSpecifiedPlatformOrgOrLinkedSlackOrg(
      context,
      targetUserID,
      orgID
    ),
    context.loaders.threadLoader.loadThread(threadID)
  ]);
  if (!thread) {
    context.logger.error(`Cannot load thread ${threadID}`);
    return;
  }
  if (!sender || !org) {
    context.logger.error("Cannot load user for " + userID, {
      messageID,
      threadID
    });
    return;
  }
  if (!target) {
    context.logger.error("Cannot load target user for " + targetUserID, {
      messageID,
      threadID
    });
    return;
  }
  if (target.state !== "active") {
    context.logger.info(
      "Not sending notification to deleted user " + targetUserID,
      { messageID, threadID }
    );
    return;
  }
  if (!targetOrgMember) {
    context.logger.error(
      `Target user ${targetUserID} does not exist in org ${orgID}, nor in org linked to it.`,
      { messageID, threadID }
    );
    return;
  }
  const emailMatchedSlackUserID = await findSlackUserEmailMatch(
    context,
    org,
    target
  ).then((value) => value?.id);
  const { isEmailNotification, isSlackNotification } = await getNotificationPreference(
    context,
    target,
    orgID,
    emailMatchedSlackUserID
  );
  if (!isEmailNotification && !isSlackNotification) {
    return;
  }
  const [partnerDetails, queryParamDeeplinkEnabled] = await Promise.all([
    getPartnerDetails(context, sender),
    getTypedFeatureFlagValue(FeatureFlags2.QUERY_PARAM_DEEP_LINKS, {
      userID: targetUserID,
      orgID: targetOrgMember.orgID,
      platformApplicationID: context.session.viewer.platformApplicationID ?? "extension",
      version: context.clientVersion,
      customerID: context.application?.customerID
    })
  ]);
  let pageURL = message.url ?? thread.url ?? null;
  if (queryParamDeeplinkEnabled && pageURL) {
    pageURL = injectDeeplinkQueryParamsV1(
      context.logger,
      pageURL,
      threadID,
      messageID
    );
  }
  return {
    thread,
    target,
    targetOrgMember,
    isEmailNotification,
    isSlackNotification,
    sender,
    org,
    partnerDetails,
    pageURL,
    emailMatchedSlackUserID
  };
}

// server/src/email/util.ts
var import_types37 = __toESM(require_cjs(), 1);
import { encode as encode3 } from "html-entities";

// common/const/Colors.ts
var GREY_X_DARK = "#191A1E";
var PURPLE = "#9A6AFF";
var OPACITY_33 = "54";
var Colors = {
  ALERT_LIGHT: "#FDEFEF",
  ALERT: "#EB5757",
  GREEN: "#71BC8F",
  GREY_X_LIGHT: "#F6F6F6",
  GREY_LIGHT: "#DADCE0",
  GREY: "#AAAAAC",
  GREY_DARK: "#76767A",
  GREY_X_DARK,
  ORANGE_LIGHT: "#FBE3D6",
  ORANGE: "#F88D76",
  PURPLE,
  PURPLE_LIGHT: "#D1D0F9",
  PURPLE_DARK: "#5F5EB3",
  BRAND_PURPLE_LIGHT: "#F6F1FF",
  BRAND_PURPLE_DARK: "#9A6AFF",
  BRAND_PURPLE_DARKER: "#6949AC",
  ACID_YELLOW: "#F4FFA0",
  YELLOW: "#F2FFA1",
  BLACK: "#000000",
  WHITE: "#FFFFFF",
  FOCUS: "#CAE3F1",
  TRANSLUCENT_DARK: GREY_X_DARK + OPACITY_33,
  TRANSLUCENT_PURPLE: PURPLE + OPACITY_33,
  TRANSPARENT: "transparent",
  INHERIT: "inherit",
  BRAND_PRIMARY: "#121314",
  CONTENT_PRIMARY: "#696A6C",
  CONTENT_SECONDARY: "#97979F"
};

// server/src/email/util.ts
function textNodeToHtml2(node) {
  let before = "";
  let after = "";
  if (node.bold) {
    before += "<strong>";
    after += "</strong>";
  }
  if (node.italic) {
    before = "<em>" + before;
    after += "</em>";
  }
  if (node.underline) {
    before = "<u>" + before;
    after += "</u>";
  }
  return before + encode3(node.text) + after;
}
function convertNodeToHtml(node) {
  if (node.type === void 0) {
    return textNodeToHtml2(node);
  } else {
    switch (node.type) {
      case import_types37.MessageNodeType.LINK:
        return `<a href="${encodeURI(node.url)}">${encode3(
          node.children[0].text
        )}</a>`;
      case import_types37.MessageNodeType.PARAGRAPH:
        return `<p>${convertNodeListToEmailHtml(node.children)}</p>`;
      case import_types37.MessageNodeType.TODO:
      case import_types37.MessageNodeType.BULLET:
      case import_types37.MessageNodeType.NUMBER_BULLET:
        return `<li>${convertNodeListToEmailHtml(node.children)}</li>`;
      case import_types37.MessageNodeType.ASSIGNEE:
      case import_types37.MessageNodeType.MENTION:
        return `<strong>${encode3(
          node.children[0].text
        )}</strong>`;
      case import_types37.MessageNodeType.QUOTE:
        return `<blockquote style="border-left: 1px solid ${Colors.GREY_LIGHT};padding-left: ${Sizes.MEDIUM}px;">${convertNodeListToEmailHtml(
          node.children
        )}</blockquote>`;
      case import_types37.MessageNodeType.CODE:
        return `<code>${convertNodeListToEmailHtml(node.children)}</code>`;
      case import_types37.MessageNodeType.MARKDOWN:
        return convertNodeListToEmailHtml(node.children);
    }
  }
}
function convertNodeListToEmailHtml(nodes) {
  let html2 = "";
  let unorderedListStarted = false;
  let orderedListStarted = false;
  for (const node of nodes) {
    const nodeHtml = convertNodeToHtml(node);
    const isOrderedItem = node.type === import_types37.MessageNodeType.NUMBER_BULLET;
    const isUnorderedItem = node.type === import_types37.MessageNodeType.BULLET || node.type === import_types37.MessageNodeType.TODO;
    if (!isOrderedItem && orderedListStarted) {
      orderedListStarted = false;
      html2 += "</ol></div>";
    }
    if (!isUnorderedItem && unorderedListStarted) {
      unorderedListStarted = false;
      html2 += "</ul></div>";
    }
    if (isOrderedItem && !orderedListStarted) {
      orderedListStarted = true;
      html2 += "<div><ol>";
    }
    if (isUnorderedItem && !unorderedListStarted) {
      unorderedListStarted = true;
      html2 += "<div><ul>";
    }
    html2 += nodeHtml;
  }
  if (unorderedListStarted) {
    html2 += "</ul></div>";
  }
  if (orderedListStarted) {
    html2 += "</ol></div>";
  }
  return html2;
}
async function getTemplateIDForNotification({
  notificationActionType,
  context,
  featureFlagUser
}) {
  const customer = context.application?.customerID ? await context.loaders.customerLoader.load(context.application.customerID) : null;
  const tier3 = customer?.pricingTier;
  const featureFlagTemplateIDs = await getTypedFeatureFlagValue(
    FeatureFlags2.EMAIL_NOTIFICATION_TEMPLATE_ID,
    featureFlagUser
  );
  const featureFlagTemplateID = featureFlagTemplateIDs[notificationActionType];
  const defaultTemplateID = getDefaultTemplateIDForNotificationType(
    notificationActionType
  );
  if (featureFlagTemplateID !== defaultTemplateID) {
    return featureFlagTemplateID;
  }
  if (tier3 === "pro" || tier3 === "scale") {
    return getPayingCustomerTemplateIDForNotificationType(
      notificationActionType
    );
  }
  return defaultTemplateID;
}
function getDefaultTemplateIDForNotificationType(notificationActionType) {
  switch (notificationActionType) {
    case "mention":
      return DEFAULT_MENTION_NOTIFICATION_V2_TEMPLATE_ID;
    case "thread_resolve":
      return DEFAULT_THREAD_RESOLVE_TEMPLATE_ID;
    case "share_to_email":
      return DEFAULT_SHARE_TO_EMAIL_TEMPLATE_ID;
    default: {
      const _ = notificationActionType;
      throw new Error(
        "Could not find a template ID for notification action type: " + notificationActionType
      );
    }
  }
}
function getPayingCustomerTemplateIDForNotificationType(notificationActionType) {
  switch (notificationActionType) {
    case "mention":
      return MENTION_NOTIFICATION_NO_POWERED_BY_CORD_TEMPLATE_ID;
    case "thread_resolve":
      return THREAD_RESOLVE_NO_POWERED_BY_CORD_TEMPLATE_ID;
    case "share_to_email":
      return SHARE_TO_EMAIL_NO_POWERED_BY_CORD_TEMPLATE_ID;
    default: {
      const _ = notificationActionType;
      throw new Error(
        "Could not find paying customer template ID for notification action type: " + notificationActionType
      );
    }
  }
}

// common/util/middleElideFileName.ts
function middleElideFileName(fileName, outputLength) {
  if (fileName.length <= outputLength) {
    return fileName;
  }
  const lengthMinusDots = outputLength - 3;
  const firstPartOfName = Math.ceil(lengthMinusDots / 2);
  const lastPartOfName = Math.floor(lengthMinusDots / 2);
  const stringLength = fileName.length - lastPartOfName;
  return `${fileName.slice(0, firstPartOfName)}...${fileName.slice(
    stringLength
  )}`;
}

// common/ui/getStableColorPalette.ts
var TOTAL_NUM_OF_PALETTES = 8;
function getStableColorPalette(userId) {
  let simpleHash = 0;
  for (const char of userId) {
    simpleHash += char.charCodeAt(0);
  }
  return simpleHash % TOTAL_NUM_OF_PALETTES + 1;
}

// server/src/util/email.ts
var MAX_NUM_MESSAGES_SHOWN = 3;
var MAX_NUM_ANNOTATIONS_SHOWN = 3;
var MAX_FILE_NAME_LENGTH = 50;
async function getThreadDetails({
  threadID,
  currentMessage,
  sender,
  currentMessageAttachments,
  currentFileAttachments,
  context
}) {
  try {
    const messageID = currentMessage.id;
    const messagesCountExcludingDeleted = await context.loaders.threadLoader.loadMessagesCountExcludingDeletedNoOrgCheck(
      threadID,
      messageID
    ) + 1;
    const senderDetailsForDisplay = await detailsForDisplay(sender, context);
    const senderName = senderDetailsForDisplay.displayName;
    const currentMessageUserDetails = await getUserDetails({
      context,
      sender,
      message: currentMessage
    });
    const currentMessageDetails = createMessageDetailsWithAnnotations(
      currentMessage.content,
      currentMessage.timestamp,
      currentMessageAttachments.length > 0 ? currentMessageAttachments : null,
      currentFileAttachments,
      currentMessage.type
    );
    let firstMessageUserDetails = null;
    let firstMessageDetails = null;
    let previousMessageUserDetails = null;
    let previousMessageDetails = null;
    const messagesCountLeft = messagesCountExcludingDeleted > MAX_NUM_MESSAGES_SHOWN ? messagesCountExcludingDeleted - MAX_NUM_MESSAGES_SHOWN : 0;
    if (messagesCountExcludingDeleted === 1) {
      return {
        senderName,
        firstMessageUserDetails,
        firstMessageDetails,
        previousMessageUserDetails,
        previousMessageDetails,
        currentMessageUserDetails,
        currentMessageDetails,
        messagesCountLeft
      };
    }
    const messages = await context.loaders.messageLoader.loadMessages({
      threadID,
      range: -1,
      ignoreDeleted: true,
      cursor: messageID
    });
    if (messages.length === 0 || messages[0].id === messageID) {
      throw Error(
        `Could not find previous messages in thread ${threadID}, current message: ${messageID}`
      );
    }
    const previousMessage = messages[0];
    previousMessageUserDetails = await getUserDetails({
      context,
      sender,
      message: previousMessage
    });
    previousMessageDetails = createMessageDetailsWithoutAnnotations(
      previousMessage.content,
      previousMessage.timestamp,
      previousMessage.type
    );
    if (messagesCountExcludingDeleted === 2) {
      return {
        senderName,
        firstMessageDetails,
        firstMessageUserDetails,
        previousMessageDetails,
        previousMessageUserDetails,
        currentMessageUserDetails,
        currentMessageDetails,
        messagesCountLeft
      };
    }
    const firstMessages = await context.loaders.messageLoader.loadMessages({
      threadID,
      range: 1,
      ignoreDeleted: true
    });
    if (firstMessages.length === 0) {
      throw Error(
        `Could not find previous messages in thread ${threadID}, current message: ${messageID}`
      );
    }
    const firstMessageOfThread = firstMessages[0];
    firstMessageUserDetails = await getUserDetails({
      context,
      sender,
      message: firstMessageOfThread
    });
    firstMessageDetails = createMessageDetailsWithoutAnnotations(
      firstMessageOfThread.content,
      firstMessageOfThread.timestamp,
      firstMessageOfThread.type
    );
    return {
      senderName,
      firstMessageDetails,
      firstMessageUserDetails,
      previousMessageDetails,
      previousMessageUserDetails,
      currentMessageUserDetails,
      currentMessageDetails,
      messagesCountLeft
    };
  } catch (e) {
    context.logger.logException("getThreadDetails failed", e, {
      threadID,
      currentMessageID: currentMessage.id,
      senderUserID: sender.id,
      currentMessageAttachments,
      currentFileAttachments,
      viewer: JSON.parse(JSON.stringify(context.session.viewer))
    });
    return null;
  }
}
async function createMessageUserDetails(user, context) {
  const userDisplayDetails = await detailsForDisplay(user, context);
  const name = userDisplayDetails.displayName;
  return {
    name,
    profile_picture: userDisplayDetails.profilePictureURL,
    initial: name.slice(0, 1).toUpperCase(),
    color_palette: getStableColorPalette(user.externalID)
  };
}
function createMessageDetailsWithoutAnnotations(messageContent, messageTimestamp, messageType) {
  return {
    message: convertNodeListToEmailHtml(messageContent),
    message_preview: convertStructuredMessageToText(messageContent),
    timestamp: messageTimestamp.toISOString(),
    message_type: messageType
  };
}
function createMessageDetailsWithAnnotations(messageContent, messageTimestamp, annotations = null, nonImageFileAttachmentNames, messageType) {
  const extraNumberOfAnnotations = annotations && annotations.length > MAX_NUM_ANNOTATIONS_SHOWN ? annotations.length - MAX_NUM_ANNOTATIONS_SHOWN : 0;
  return {
    message: convertNodeListToEmailHtml(messageContent),
    message_preview: convertStructuredMessageToText(messageContent),
    timestamp: messageTimestamp.toISOString(),
    annotations: annotations ? {
      first_annotation: annotations[0] ?? null,
      // only want the next 2 annotations on the list
      other_annotations: annotations.slice(1, MAX_NUM_ANNOTATIONS_SHOWN) ?? [],
      extra_number_annotations: extraNumberOfAnnotations
    } : null,
    file_names: nonImageFileAttachmentNames.map(
      (fileName) => middleElideFileName(fileName, MAX_FILE_NAME_LENGTH)
    ),
    message_type: messageType
  };
}
async function getUserDetails({
  context,
  sender,
  message
}) {
  if (message.sourceID === sender.id) {
    return await createMessageUserDetails(sender, context);
  } else {
    const user = await context.loaders.userLoader.loadUser(message.sourceID);
    if (!user) {
      throw new Error(`Could not load user for messageID: ${message.id}`);
    }
    return await createMessageUserDetails(user, context);
  }
}
async function buildOutboundEmailNotificationData({
  context,
  message,
  sender,
  orgID,
  target,
  actionText,
  targetOrgMember,
  actionIcon,
  thread,
  providerName,
  partnerDetails,
  allImageURLs,
  nonImageFileAttachmentNames,
  notificationType,
  pageURL,
  userID,
  ...rest
}) {
  const _ = rest;
  const threadID = thread.id;
  const messageID = message.id;
  const targetUserID = target.id;
  const isSubscribed = await context.loaders.emailSubscriptionLoader.isUserSubscribedToThread(
    targetUserID,
    threadID
  );
  if (!isSubscribed) {
    return;
  }
  const unsubscribeThreadToken = encodeUnsubscribeThreadToken({
    userID: targetUserID,
    orgID: targetOrgMember.orgID,
    threadID,
    appID: sender.platformApplicationID
  });
  const unsubscribeThreadURL = `${API_ORIGIN}${UNSUBSCRIBE_PATH}?token=${unsubscribeThreadToken}`;
  const notificationURL = await generateOutboundNotificationLoggingURL({
    messageID,
    url: pageURL,
    targetOrgID: targetOrgMember.orgID,
    targetUserID,
    type: "email",
    platformApplicationID: context.session.viewer.platformApplicationID,
    metadata: {},
    sharerUserID: userID,
    sharerOrgID: orgID
  });
  const threadDetails = await getThreadDetails({
    threadID,
    currentMessage: message,
    sender,
    currentMessageAttachments: allImageURLs,
    currentFileAttachments: nonImageFileAttachmentNames,
    context
  });
  if (!threadDetails) {
    context.logger.error("Could not generate threadDetails for v2 email");
    return;
  }
  return {
    viewerUserID: context.session.viewer.userID,
    viewerPlatformApplicationID: context.session.viewer.platformApplicationID,
    threadOrgID: orgID,
    targetUserID,
    targetOrgID: targetOrgMember.orgID,
    threadID,
    messageID,
    targetEmail: target.email,
    // Checked in notificationChannels
    actionText,
    actionIcon,
    pageName: thread.name,
    notificationURL,
    providerName,
    unsubscribeThreadURL,
    partnerDetails,
    threadDetails,
    notificationType
  };
}

// server/src/asyncTier/jobs/sendEmailNotificationWithDelay.ts
var sendEmailNotificationWithDelay_default = new AsyncTierJobDefinition(
  "sendEmailNotificationWithDelay",
  sendEmailNotification
);
async function sendEmailNotification(data) {
  let viewer;
  if (!data.viewerUserID || !data.threadOrgID) {
    throw new Error(
      "Trying to send email notification without viewer userID or orgID"
    );
  }
  if (data.viewerPlatformApplicationID) {
    const [user, org, app] = await Promise.all([
      UserEntity.findByPk(data.viewerUserID),
      OrgEntity.findByPk(data.threadOrgID),
      ApplicationEntity.findByPk(data.viewerPlatformApplicationID)
    ]);
    if (!user?.externalID || !org?.externalID || !app) {
      throw new Error(
        "Trying to send platform user email notification without external user or org ID"
      );
    }
    viewer = await Viewer.createLoggedInPlatformViewer({
      user,
      org
    });
  } else {
    viewer = Viewer.createLoggedInViewer(data.viewerUserID, data.threadOrgID);
  }
  const context = await contextWithSession(
    { viewer },
    getSequelize(),
    null,
    null
  );
  const message = await context.loaders.messageLoader.loadMessage(
    data.messageID
  );
  if (!message) {
    context.logger.log(
      "warn",
      "Attempting to send notification to message that no longer exists",
      { threadID: data.threadID, messageID: data.messageID }
    );
    return;
  }
  const { userID, orgID } = assertViewerHasIdentity(context.session.viewer);
  const featureFlagUser = {
    userID,
    orgID,
    platformApplicationID: context.session.viewer.platformApplicationID ?? "extension",
    version: null,
    customerID: context.application?.customerID
  };
  const templateId = await getTemplateIDForNotification({
    notificationActionType: data.notificationType === "thread_action" ? "thread_resolve" : "mention",
    context,
    featureFlagUser
  });
  let canSkipSending = false;
  if (
    // we always want to send self-mentions
    data.viewerUserID !== data.targetUserID && message
  ) {
    const lastSeen = (await context.loaders.threadParticipantLoader.loadForUser({
      userID: data.targetUserID,
      threadID: message.threadID
    }))?.lastSeenTimestamp;
    const alwaysSendEmail = await getFeatureFlagValue(
      "always_send_email_notification",
      featureFlagUser
    );
    canSkipSending = !alwaysSendEmail && !!lastSeen && lastSeen >= message.timestamp;
  }
  if (canSkipSending) {
    return;
  }
  const emailNotification = await EmailOutboundNotificationEntity.create({
    userID: data.targetUserID,
    orgID: data.targetOrgID,
    threadID: data.threadID,
    email: data.targetEmail,
    // Target user may not be in same org - could instead be part of Slack org
    threadOrgID: data.threadOrgID
  });
  await sendActionEmailNotification({
    context,
    recipientEmail: data.targetEmail,
    actionText: data.actionText,
    actionIconType: data.actionIcon,
    pageName: data.pageName,
    pageURL: data.notificationURL,
    providerName: data.providerName,
    unsubscribeURL: data.unsubscribeThreadURL,
    partnerDetails: data.partnerDetails,
    threadDetails: data.threadDetails,
    emailNotification,
    templateId,
    notificationType: data.notificationType
  });
}

// server/src/notifications/outbound/sendOutboundNotifications.ts
async function sendOutboundNotification(data) {
  const {
    context,
    targetUserID,
    message,
    providerName,
    screenshotID,
    notificationType
  } = data;
  const userID = assertViewerHasUser(context.session.viewer);
  if (!message) {
    return;
  }
  const baseNotificationData = await generateOutboundNotificationData({
    context,
    targetUserID,
    userID,
    message
  });
  if (!baseNotificationData) {
    return;
  }
  const {
    thread,
    target,
    targetOrgMember,
    isEmailNotification,
    isSlackNotification,
    sender,
    partnerDetails,
    pageURL,
    emailMatchedSlackUserID,
    org
  } = baseNotificationData;
  const messageID = message.id;
  const orgID = org.id;
  if (notificationType === "reply") {
    const actionText = headerText2(data.replyActions)[0];
    const actionIcon = getIcon(data.replyActions);
    const [
      screenshot,
      [files, annotationScreenshotFiles, annotationsHighlightedText]
    ] = await Promise.all([
      screenshotID ? context.loaders.fileLoader.loadFile(screenshotID) : null,
      loadPartitionedAttachments(context, messageID)
    ]);
    if (screenshot) {
      files.unshift(screenshot);
    }
    const imageAttachmentsURLs = files.filter((file) => isInlineDisplayableImage(file.mimeType)).map((file) => file.getPermanentDownloadURL());
    const annotationScreenshotURLs = annotationScreenshotFiles.map(
      (file) => file.getPermanentDownloadURL()
    );
    const allImageURLs = [...imageAttachmentsURLs, ...annotationScreenshotURLs];
    const nonImageFileAttachmentNames = files.filter((file) => !isInlineDisplayableImage(file.mimeType)).map((file) => file.name);
    if (isEmailNotification) {
      const emailData = await buildOutboundEmailNotificationData({
        context,
        message,
        sender,
        orgID,
        target,
        actionText,
        actionIcon,
        targetOrgMember,
        thread,
        providerName,
        partnerDetails,
        allImageURLs,
        nonImageFileAttachmentNames,
        notificationType,
        pageURL,
        userID
      });
      if (!emailData) {
        return;
      }
      if (process.env.IS_TEST) {
        await sendEmailNotification(emailData);
      } else if (process.env.NODE_ENV === "development") {
        setTimeoutAsync(() => sendEmailNotification(emailData), 40 * 1e3);
      } else {
        await submitAsync("sendEmailNotificationWithDelay", emailData, {
          startAfter: 40
        });
      }
    }
    if (isSlackNotification) {
      const [sendingUsername, notificationURL] = await Promise.all([
        detailsForDisplay(sender, context).then((value) => value.displayName),
        generateOutboundNotificationLoggingURL({
          messageID,
          url: pageURL,
          targetOrgID: targetOrgMember.orgID,
          targetUserID,
          type: emailMatchedSlackUserID ? "slackEmailMatched" : "slack",
          platformApplicationID: context.session.viewer.platformApplicationID,
          metadata: {},
          sharerUserID: userID,
          sharerOrgID: orgID
        })
      ]);
      const slackData = {
        viewerUserID: context.session.viewer.userID,
        viewerOrgID: orgID,
        viewerPlatformApplicationID: context.session.viewer.platformApplicationID,
        senderUserID: userID,
        senderOrgID: orgID,
        senderName: sendingUsername,
        targetUserID: emailMatchedSlackUserID ? emailMatchedSlackUserID : targetUserID,
        messageID,
        url: notificationURL,
        pageName: thread.name,
        annotationsHighlightedText,
        providerName,
        messageContent: message.content,
        allImageURLs,
        actionText,
        notificationType
      };
      if (process.env.IS_TEST) {
        await sendSlackNotificationWithDelay(slackData);
      } else if (process.env.NODE_ENV === "development") {
        setTimeoutAsync(
          () => sendSlackNotificationWithDelay(slackData),
          1 * 1e3
        );
      } else {
        await submitAsync("sendSlackNotificationWithDelay", slackData, {
          startAfter: 10
        });
      }
    }
  }
  if (notificationType === "thread_action") {
    const actionText = headerText(
      data.threadActionType
    )[0];
    const actionIcon = "mention";
    if (isEmailNotification) {
      const emailData = await buildOutboundEmailNotificationData({
        context,
        message,
        sender,
        orgID,
        target,
        actionText,
        actionIcon,
        targetOrgMember,
        thread,
        providerName,
        partnerDetails,
        allImageURLs: [],
        nonImageFileAttachmentNames: [],
        notificationType,
        pageURL,
        userID
      });
      if (!emailData) {
        return;
      }
      if (process.env.IS_TEST) {
        await sendEmailNotification(emailData);
      } else if (process.env.NODE_ENV === "development") {
        setTimeoutAsync(() => sendEmailNotification(emailData), 40 * 1e3);
      } else {
        await submitAsync("sendEmailNotificationWithDelay", emailData, {
          startAfter: 40
        });
      }
    }
    if (isSlackNotification) {
      const [sendingUsername, notificationURL] = await Promise.all([
        detailsForDisplay(sender, context).then((value) => value.displayName),
        generateOutboundNotificationLoggingURL({
          messageID,
          url: pageURL,
          targetOrgID: targetOrgMember.orgID,
          targetUserID,
          type: emailMatchedSlackUserID ? "slackEmailMatched" : "slack",
          platformApplicationID: context.session.viewer.platformApplicationID,
          metadata: {},
          sharerUserID: userID,
          sharerOrgID: orgID
        })
      ]);
      const slackData = {
        viewerUserID: context.session.viewer.userID,
        viewerOrgID: orgID,
        viewerPlatformApplicationID: context.session.viewer.platformApplicationID,
        senderUserID: userID,
        senderOrgID: orgID,
        senderName: sendingUsername,
        targetUserID: emailMatchedSlackUserID ? emailMatchedSlackUserID : targetUserID,
        messageID,
        url: notificationURL,
        pageName: thread.name,
        providerName,
        actionText,
        notificationType
      };
      if (process.env.IS_TEST) {
        await sendSlackNotificationWithDelay(slackData);
      } else if (process.env.NODE_ENV === "development") {
        setTimeoutAsync(
          () => sendSlackNotificationWithDelay(slackData),
          10 * 1e3
        );
      } else {
        await submitAsync("sendSlackNotificationWithDelay", slackData, {
          startAfter: 10
        });
      }
    }
  }
}

// server/src/entity/thread/update_thread_tasks/createThreadActionNotifications.ts
async function createThreadActionNotifications({
  context,
  threadID,
  messageID,
  threadActionType
}) {
  const viewerUserID = assertViewerHasUser(context.session.viewer);
  const usersToNotify = /* @__PURE__ */ new Set();
  const participants = await context.loaders.threadParticipantLoader.loadForThreadIDNoOrgCheck(
    threadID
  );
  participants.forEach(
    (tp) => tp.subscribed && tp.userID !== viewerUserID ? usersToNotify.add(tp.userID) : null
  );
  const message = await context.loaders.messageLoader.loadMessage(messageID);
  await Promise.all(
    [...usersToNotify].map((userIDToNotify) => {
      return Promise.all([
        sendOutboundNotification({
          context,
          targetUserID: userIDToNotify,
          providerName: void 0,
          message,
          notificationType: "thread_action",
          threadActionType
        }),
        new NotificationMutator(context.session.viewer).create({
          recipientID: userIDToNotify,
          type: "thread_action",
          threadActionType,
          threadID,
          messageID
        })
      ]);
    })
  );
}

// server/src/message/new_message_tasks/maybeUnresolveThread.ts
async function maybeUnresolveThread(context, thread, message) {
  if (thread && thread.resolvedTimestamp) {
    const userID = assertViewerHasUser(context.session.viewer);
    const user = await context.loaders.userLoader.loadUser(userID);
    if (!user) {
      throw new Error("User doesn't exist?!?");
    }
    const unresolveActionMessage = await new MessageMutator(
      context.session.viewer,
      context.loaders
    ).createMessage({
      id: uuid7(),
      thread,
      content: getActionMessageContent("thread_unresolved", user),
      url: null,
      iconURL: MessageActionIconURLs["thread_unresolved"],
      translationKey: MessageActionTranslationKeys["thread_unresolved"],
      type: "action_message",
      // Make sure resolve action message is displayed before the actual message in the UI
      timestamp: new Date(message.timestamp.getTime() - 1)
    });
    const threadMutator = new ThreadMutator(
      context.session.viewer,
      context.loaders
    );
    await threadMutator.setThreadResolved(thread.id, false);
    await Promise.all([
      publishPubSubEvent("thread-properties-updated", {
        threadID: thread.id
      }),
      publishPubSubEvent(
        "thread-filterable-properties-updated",
        { orgID: thread.orgID },
        {
          threadID: thread.id,
          changes: { resolved: { old: true, new: false } }
        }
      ),
      createThreadActionNotifications({
        context,
        threadID: thread.id,
        messageID: unresolveActionMessage.id,
        threadActionType: "unresolve"
      })
    ]);
    if (unresolveActionMessage) {
      const app = await ApplicationEntity.findByPk(
        unresolveActionMessage.platformApplicationID
      );
      if (!app) {
        throw new Error(
          `Could not find app ${unresolveActionMessage.platformApplicationID} when unresolving thread`
        );
      }
      backgroundPromise(
        Promise.all([
          publishPubSubEvent(
            "thread-message-added",
            { threadID: unresolveActionMessage.threadID },
            { messageID: unresolveActionMessage.id }
          ),
          publishEventToWebhook(app, {
            type: "thread-message-added",
            threadID: thread.id,
            messageID: unresolveActionMessage.id
          })
        ]),
        context.logger
      );
    }
  }
}

// server/src/message/util/getNotificationReplyActions.ts
function getNotificationReplyActions({
  userID,
  taskAssigneeUserIDs,
  mentionedUserIDs,
  fileAttachments,
  removedTaskAssigneeUserIDs,
  isFirstMessageInThread = false
}) {
  const actions = [];
  if (taskAssigneeUserIDs.includes(userID)) {
    actions.push("assign-task");
  }
  if (mentionedUserIDs.includes(userID)) {
    actions.push("mention");
  }
  if (fileAttachments.length > 0) {
    actions.push("attach-file");
  }
  if (isFirstMessageInThread) {
    actions.push("create-thread");
  } else if (removedTaskAssigneeUserIDs?.includes(userID)) {
    actions.push("unassign-task");
  }
  return actions;
}

// server/src/message/util/getUsersToNotify.ts
async function getUsersToNotify(args) {
  const viewerUserID = assertViewerHasUser(args.context.session.viewer);
  const [notifyVisitors, skipVisitorsIfSelfMentioned] = await Promise.all([
    getFeatureFlagValue(
      "notify_page_visitors_of_every_new_message",
      args.flagsUser
    ),
    getFeatureFlagValue(
      "skip_notify_page_visitors_if_self_mentioned",
      args.flagsUser
    )
  ]);
  const usersToNotify = new Set(args.referencedUsers);
  const selfMentioned = usersToNotify.has(viewerUserID);
  const threadParticipants = new Map(
    (await args.context.loaders.threadParticipantLoader.loadForThreadIDNoOrgCheck(
      args.threadID
    )).map((tp) => [tp.userID, tp.subscribed])
  );
  for (const [userID, subscribed] of threadParticipants) {
    if (subscribed && userID !== viewerUserID) {
      usersToNotify.add(userID);
    }
  }
  const pageVisitors = await args.context.loaders.pageVisitorLoader.loadForContextHash(
    args.pageContextHash
  );
  if (notifyVisitors === true && !(selfMentioned && skipVisitorsIfSelfMentioned === true)) {
    for (const { userID } of pageVisitors) {
      if (threadParticipants.get(userID) !== false && userID !== viewerUserID) {
        usersToNotify.add(userID);
      }
    }
  }
  return [...usersToNotify];
}

// server/src/bots/ApplicationSupportBot.ts
async function getApplicationSupportSlackOrgBotCredentials(supportOrgID) {
  const supportOrg = await OrgEntity.findByPk(supportOrgID);
  if (!supportOrg) {
    throw new Error("No application support org found");
  }
  const slackBotCredentials = await supportOrg.getSlackBotCredentials();
  if (!slackBotCredentials) {
    throw new Error(
      "No slack bot credentials found for application support bot"
    );
  }
  return slackBotCredentials;
}
async function shareThreadToApplicationSupportSlackChannel(application, context, threadID) {
  const slackChannelID = application.supportSlackChannelID;
  const supportOrgID = application.supportOrgID;
  const { userID, orgID } = assertViewerHasIdentity(context.session.viewer);
  try {
    if (!slackChannelID) {
      throw new Error("No support slack channel ID");
    }
    if (!supportOrgID) {
      throw new Error("No support slack org ID");
    }
    const slackBotCredentials = await getApplicationSupportSlackOrgBotCredentials(supportOrgID);
    const sharerUser = await context.loaders.userLoader.loadUserInAnyViewerOrg(userID);
    if (!sharerUser) {
      throw new Error("Missing valid sharerUser");
    }
    await addCordBotToSlackChannels(
      context,
      slackBotCredentials.bot_access_token,
      [slackChannelID]
    );
    const success = await addThreadToSelectedSlackChannel(
      context,
      slackBotCredentials,
      slackChannelID,
      sharerUser,
      threadID,
      "support"
    );
    return success;
  } catch (e) {
    context.logger.logException(
      "shareThreadToApplicationSupportSlackChannel:",
      e,
      {
        applicationID: application.id,
        applicationSupportOrg: application.supportOrgID,
        userID,
        orgID
      }
    );
    return false;
  }
}

// server/src/message/new_message_tasks/maybeNotifyReferencedUsers.ts
async function maybeNotifyReferencedUsers(context, flagsUser, application, page, thread, message, mentionedUserIDs, taskAssigneeUserIDs, fileAttachments, isFirstMessageInThread, subscribeToThread, screenshotID) {
  const userReferenceIDSet = /* @__PURE__ */ new Set([
    ...mentionedUserIDs,
    ...taskAssigneeUserIDs
  ]);
  if (application.supportBotID && application.supportOrgID && await getFeatureFlagValue(
    "share_every_thread_to_application_support_channel",
    flagsUser
  ) === true) {
    userReferenceIDSet.add(application.supportBotID);
  }
  const userReferenceIDs = [...userReferenceIDSet];
  const usersToNotify = await getUsersToNotify({
    context,
    flagsUser,
    threadID: message.threadID,
    referencedUsers: userReferenceIDs,
    pageContextHash: page.contextHash
  });
  const threadParticipantMutator = new ThreadParticipantMutator(
    context.session.viewer,
    context.loaders
  );
  if (subscribeToThread) {
    await threadParticipantMutator.setViewerSubscribed(thread, true);
  }
  if (userReferenceIDs.length > 0) {
    await threadParticipantMutator.subscribeUsersToThread(
      thread.id,
      userReferenceIDs
    );
  }
  await threadParticipantMutator.markThreadNewlyActiveForOtherUsers(
    thread.id,
    message.id
  );
  if (usersToNotify.length === 0) {
    return;
  }
  if (context.application?.id !== "9e7d98ae-5da5-42ca-b857-2f15dc9a63db") {
    await Promise.all(
      usersToNotify.map((userID) => {
        const replyActions = getNotificationReplyActions({
          userID,
          taskAssigneeUserIDs,
          mentionedUserIDs,
          fileAttachments,
          isFirstMessageInThread
        });
        return Promise.all([
          sendOutboundNotification({
            context,
            targetUserID: userID,
            message,
            providerName: void 0,
            replyActions,
            screenshotID,
            notificationType: "reply"
          }),
          new NotificationMutator(context.session.viewer).create({
            recipientID: userID,
            type: "reply",
            messageID: message.id,
            replyActions,
            threadID: message.threadID
          })
        ]);
      })
    );
  }
  if (application.supportBotID && userReferenceIDs.includes(application.supportBotID)) {
    shareThreadToApplicationSupportSlackChannel(
      application,
      context,
      thread.id
    ).catch(
      context.logger.exceptionLogger(
        "shareThreadToApplicationSupportSlackChannel in createThreadMessageResolver"
      )
    );
    logServerEvent({
      session: context.session,
      type: "user-mentioned-application-support-bot",
      logLevel: "debug" /* DEBUG */,
      payload: {
        threadID: thread.id,
        messageID: message.id
      }
    });
  }
}

// server/src/message/update_message_tasks/notifyReferencedUsers.ts
import { unique as unique12 } from "radash";
async function notifyReferencedUsers({
  context,
  message,
  mentionedUserIDs,
  taskAssigneeUserIDs = [],
  removedTaskAssigneeUserIDs = [],
  fileAttachments = []
}) {
  const usersToNotify = unique12([
    ...mentionedUserIDs,
    ...taskAssigneeUserIDs,
    ...removedTaskAssigneeUserIDs
  ]);
  if (usersToNotify.length === 0) {
    return;
  }
  await Promise.all(
    usersToNotify.map(async (userID) => {
      const replyActions = getNotificationReplyActions({
        userID,
        taskAssigneeUserIDs,
        mentionedUserIDs,
        fileAttachments: fileAttachments ?? [],
        removedTaskAssigneeUserIDs
      });
      return await Promise.all([
        sendOutboundNotification({
          context,
          targetUserID: userID,
          message,
          replyActions,
          notificationType: "reply"
        }),
        new NotificationMutator(context.session.viewer).create({
          recipientID: userID,
          type: "reply",
          messageID: message.id,
          replyActions,
          threadID: message.threadID
        })
      ]);
    })
  );
}

// server/src/message/update_message_tasks/publishUpdatedMessageEvents.ts
function publishUpdatedMessageEvents(context, thread, message, updateAnnotations, newUserReferenceIDs, originalSubscribers) {
  const pageContextHash = thread.pageContextHash;
  if (pageContextHash && updateAnnotations) {
    backgroundPromise(
      publishPubSubEvent("annotations-on-page-updated", {
        pageContextHash,
        orgID: message.orgID
      })
    );
  }
  if (newUserReferenceIDs.length > 0) {
    const notify = async () => {
      const page = await context.loaders.pageLoader.loadPrimaryPageForThreadNoOrgCheck(
        thread.id
      );
      if (!page) {
        throw new Error("Unable to find thread location");
      }
      const location = page.contextData;
      await Promise.all(
        newUserReferenceIDs.map(
          (userID) => publishPubSubEvent(
            "inbox-updated",
            { userID },
            { threadID: thread.id, location }
          )
        )
      );
    };
    backgroundPromise(notify());
  }
  backgroundPromise(
    publishPubSubEvent(
      "thread-message-updated",
      { threadID: message.threadID },
      { messageID: message.id }
    )
  );
  backgroundPromise(
    (async () => {
      const newSubscribers = new Set(
        await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
          thread.id
        )
      );
      const removed = [...originalSubscribers].filter(
        (s) => !newSubscribers.has(s)
      );
      const added = [...newSubscribers].filter(
        (s) => !originalSubscribers.has(s)
      );
      if (removed.length > 0 || added.length > 0) {
        backgroundPromise(
          publishPubSubEvent(
            "thread-filterable-properties-updated",
            { orgID: thread.orgID },
            {
              threadID: thread.id,
              changes: { subscribers: { added, removed } }
            }
          )
        );
      }
    })()
  );
}
function publishAppendedMessageContentEvents(message, appendedContent) {
  backgroundPromise(
    publishPubSubEvent(
      "thread-message-content-appended",
      { threadID: message.threadID },
      {
        messageID: message.id,
        appendedContent
      }
    )
  );
}

// server/src/message/update_message_tasks/updateMessageAttachments.ts
async function updateMessageAttachments(context, message, fileAttachments, annotationAttachments) {
  const viewer = context.session.viewer;
  const messageAttachmentMutator = new MessageAttachmentMutator(
    viewer,
    context.loaders
  );
  const [deletedCount, created] = await messageAttachmentMutator.setMessageAttachments(message, [
    ...fileAttachments.map(({ id, fileID }) => ({
      id,
      type: "file" /* FILE */,
      data: { fileID }
    })),
    ...getMessageAnnotationAttachmentsFromInput(
      context.session.viewer,
      annotationAttachments
    )
  ]);
  return deletedCount || created.length;
}

// server/src/message/update_message_tasks/updateMessageTask.ts
async function updateMessageTask(context, message, task) {
  const viewer = context.session.viewer;
  const taskMutator = new TaskMutator(viewer, context.loaders);
  let newTaskAssignees = [];
  let removedTaskAssignees = [];
  if (task === null) {
    await taskMutator.deleteTaskFromMessageID(message.id, message.orgID);
  } else {
    const taskAssigneeMutator = new TaskAssigneeMutator(
      viewer,
      context.loaders
    );
    await taskMutator.createOrUpdateTask(task, message.id);
    const { newAssigneeIDs, removedAssigneeIDs } = await taskAssigneeMutator.updateTaskAssignees(task.id, task.assigneeIDs);
    newTaskAssignees = newAssigneeIDs;
    removedTaskAssignees = removedAssigneeIDs;
    const taskTodoMutator = new TaskTodoMutator(viewer);
    await taskTodoMutator.setTaskTodos(task.id, task.todos);
  }
  return { newTaskAssignees, removedTaskAssignees };
}

// server/src/asyncTier/jobs/generateLinkPreviews.ts
import axios from "axios";
import { load as cheerioLoad } from "cheerio";
import * as linkify from "linkifyjs";
var import_types40 = __toESM(require_cjs(), 1);

// server/src/entity/message_link_preview/MessageLinkPreviewMutator.ts
var MessageLinkPreviewMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
  }
  async upsert(args, transaction) {
    const { messageID, url: url6, title, description, img } = args;
    const [result, _] = await MessageLinkPreviewEntity.upsert(
      {
        messageID,
        url: url6,
        title,
        description,
        img,
        hidden: false
      },
      { transaction }
    );
    return result;
  }
  async hide(linkPreviewID) {
    if (!this.loaders) {
      throw new Error("loaders cannot be null for messagLinkPreviewMutator");
    }
    const userID = assertViewerHasUser(this.viewer);
    const linkPreview = await this.loaders.messageLinkPreviewLoader.loadLinkPreview(
      linkPreviewID
    );
    if (!linkPreview) {
      throw new Error("Link preview was not loaded");
    }
    const message = await this.loaders.messageLoader.loadMessage(
      linkPreview?.messageID
    );
    if (!message) {
      throw new Error("Cannot find message.");
    }
    if (message.sourceID !== userID) {
      throw new Error("Only the message author can edit the link previews");
    }
    const [updated] = await MessageLinkPreviewEntity.update(
      {
        hidden: true
      },
      {
        where: {
          id: linkPreviewID
        }
      }
    );
    backgroundPromise(
      publishPubSubEvent(
        "thread-message-updated",
        { threadID: message.threadID },
        { messageID: message.id }
      )
    );
    return updated > 0;
  }
};

// server/src/asyncTier/jobs/generateLinkPreviews.ts
var generateLinkPreviews_default = new AsyncTierJobDefinition(
  "generateLinkPreviews",
  generateLinkPreviews
);
var REQUEST_TIMEOUT = 5e3;
async function generateLinkPreviews(data, logger) {
  logger.info("Starting Generate Link Previews sync");
  const { messageID } = data;
  try {
    const message = await MessageEntity.findOne({ where: { id: messageID } });
    if (!message) {
      logger.warn(
        `Could not generate link previews for message. Cannot load message ${messageID}`
      );
      return;
    }
    const existingPreviews = await MessageLinkPreviewEntity.findAll({
      where: { messageID }
    });
    const links = Array.from(getLinksForMessage(message.content)) ?? [];
    await Promise.all([
      addLinks(messageID, existingPreviews, links),
      removeLinks(existingPreviews, links)
    ]);
    backgroundPromise(
      publishPubSubEvent(
        "thread-message-updated",
        { threadID: message.threadID },
        { messageID }
      )
    );
  } catch (error) {
    logger.logException("Error generationg link previews", error, {
      messageID
    });
  }
}
function findLinks(node) {
  const links = /* @__PURE__ */ new Set();
  if (node.type === import_types40.MessageNodeType.LINK) {
    links.add(node.url);
    return links;
  } else if (!node.type && node.type !== import_types40.MessageNodeType.MENTION) {
    const urls = linkify.find(node.text);
    if (urls) {
      for (const url6 of urls) {
        if (url6.type === "url") {
          links.add(url6.href);
        }
      }
    }
  }
  if ("children" in node && node.children) {
    for (let i = 0; i < node.children.length; i++) {
      const childrenLinks = findLinks(node.children[i]);
      for (const childrenLink of childrenLinks) {
        links.add(childrenLink);
      }
    }
  }
  return links;
}
async function getPreviewForURL(url6) {
  let previewURL = url6;
  if (!previewURL.startsWith("http")) {
    previewURL = "http://" + previewURL;
  }
  try {
    const { data } = await axios.get(previewURL, {
      timeout: REQUEST_TIMEOUT,
      httpAgent: manageConnection(previewURL),
      httpsAgent: manageConnection(previewURL)
    });
    const loadedWebsite = cheerioLoad(data);
    const getMetaTag = (name) => {
      return loadedWebsite(`meta[name=${name}]`).attr("content") || loadedWebsite(`meta[propety="twitter${name}"]`).attr("content") || loadedWebsite(`meta[property="og:${name}"]`).attr("content");
    };
    let previewImage = getMetaTag("image");
    if (previewImage && previewImage.length > 0) {
      if (previewImage[0] === "/") {
        previewImage = new URL(previewURL).origin + previewImage;
      }
      if (!previewImage.startsWith("http")) {
        previewImage = "https://" + previewImage;
      }
    }
    return {
      title: getMetaTag("title") ?? loadedWebsite("title").first().text() ?? getMetaTag("site_name"),
      description: getMetaTag("description"),
      url: previewURL,
      img: previewImage
    };
  } catch (e) {
    anonymousLogger().logException(
      "MessageLinkPreview error",
      e,
      void 0,
      void 0,
      "info"
    );
    return null;
  }
}
function getLinksForMessage(content) {
  const allLinks = /* @__PURE__ */ new Set();
  for (const node of content) {
    const newLinks = findLinks(node);
    for (const link of newLinks) {
      allLinks.add(link);
    }
  }
  return allLinks;
}
async function addLinks(messageID, existingPreviews, links) {
  const newLinks = links?.filter((link) => {
    return !existingPreviews.find((preview) => preview.url === link);
  });
  const previews = await Promise.all(newLinks.map(getPreviewForURL));
  const viewer = Viewer.createServiceViewer();
  const messageLinkPreviewMutator = new MessageLinkPreviewMutator(viewer, null);
  await Promise.all(
    previews.filter(isDefined).map(async (link) => {
      await messageLinkPreviewMutator.upsert({
        messageID,
        url: link.url,
        img: link.img ?? null,
        description: link.description ?? null,
        title: link.title ?? null
      });
    })
  );
}
async function removeLinks(existingPreviews, links) {
  const linksToRemove = existingPreviews.filter((preview) => {
    return !links.find((link) => preview.url === link);
  });
  await Promise.all(
    linksToRemove.map(async (preview) => {
      await preview.destroy();
    })
  );
}

// server/src/message/new_message_tasks/scheduleGenerateLinkPreviews.tsx
async function scheduleGenerateLinkPreviews(context, message) {
  if (message.skipLinkPreviews) {
    return;
  }
  const flagUser = flagsUserFromContext(context);
  const linkPreviewsEnabled = await getTypedFeatureFlagValue(
    FeatureFlags2.SHOW_LINK_PREVIEWS,
    flagUser
  );
  if (!linkPreviewsEnabled) {
    return;
  }
  const existingPreviewCount = await MessageLinkPreviewEntity.count({
    where: { messageID: message.id }
  });
  const links = getLinksForMessage(message.content);
  if (existingPreviewCount === 0 && links.size === 0) {
    return;
  }
  void submitAsync(
    "generateLinkPreviews",
    {
      messageID: message.id
    },
    { singletonKey: message.id }
  );
}
async function scheduleUpdateLinkPreviews(context, message) {
  if (message.skipLinkPreviews) {
    await MessageLinkPreviewEntity.destroy({
      where: { messageID: message.id }
    });
  } else {
    const flagUser = flagsUserFromContext(context);
    const linkPreviewsEnabled = await getTypedFeatureFlagValue(
      FeatureFlags2.SHOW_LINK_PREVIEWS,
      flagUser
    );
    if (!linkPreviewsEnabled) {
      return;
    }
    void submitAsync(
      "generateLinkPreviews",
      {
        messageID: message.id
      },
      { singletonKey: message.id }
    );
  }
}

// server/src/message/executeMessageTasks.ts
async function executeNewMessageCreationTasks({
  context,
  flagsUser,
  application,
  page,
  thread,
  message,
  fileAttachments,
  annotationAttachments,
  screenshotAttachment,
  isFirstMessage,
  task,
  subscribeToThread,
  sendNotifications = true
}) {
  await addNewMessageAttachments(
    context,
    message,
    fileAttachments,
    annotationAttachments,
    screenshotAttachment
  );
  let taskAssigneeUserIDs = [];
  if (task) {
    taskAssigneeUserIDs = await addNewMessageTasks(
      context.session.viewer,
      context.loaders,
      task,
      message.id
    );
  }
  const mentionedUserIDs = await createMessageMentions(
    context,
    message.id,
    message.content
  );
  if (sendNotifications) {
    await maybeNotifyReferencedUsers(
      context,
      flagsUser,
      application,
      page,
      thread,
      message,
      mentionedUserIDs,
      taskAssigneeUserIDs,
      fileAttachments,
      isFirstMessage,
      subscribeToThread,
      screenshotAttachment?.blurredScreenshotFileID || screenshotAttachment?.screenshotFileID || void 0
    );
  }
  const showActivationNux = await getFeatureFlagValue(
    "show_activation_welcome_message_nux",
    flagsUser
  );
  if (showActivationNux) {
    const userID = assertViewerHasUser(context.session.viewer);
    const userPreferenceMutator = new UserPreferenceMutator(
      context.session.viewer
    );
    await userPreferenceMutator.setPreferenceForUser(
      userID,
      ACTIVATION_FIRST_MESSAGE_SENT,
      true
    );
  }
  await getSequelize().transaction(async (transaction) => {
    await publishNewMessageEvents(
      application,
      page,
      thread,
      message,
      isFirstMessage,
      annotationAttachments.length > 0,
      mentionedUserIDs,
      context,
      transaction
    );
    await markThreadSeenForViewer(
      context.session.viewer,
      thread.id,
      transaction
    );
  });
  await maybeUnresolveThread(context, thread, message);
  await scheduleGenerateLinkPreviews(context, message);
}
async function executeUpdateMessageTasks({
  context,
  message,
  thread,
  task,
  fileAttachments,
  annotationAttachments,
  wasDeletedOrUndeleted,
  authorUpdated,
  content,
  originalSubscribers
}) {
  const viewer = context.session.viewer;
  let updateAnnotationsOnPage = false;
  if (fileAttachments && annotationAttachments) {
    const attachmentsUpdated = await updateMessageAttachments(
      context,
      message,
      fileAttachments,
      annotationAttachments
    );
    if (attachmentsUpdated) {
      updateAnnotationsOnPage = true;
    }
  }
  let newTaskAssigneeUserIDs = [];
  let removedTaskAssigneeUserIDs = [];
  if (task !== void 0) {
    ({
      newTaskAssignees: newTaskAssigneeUserIDs,
      removedTaskAssignees: removedTaskAssigneeUserIDs
    } = await updateMessageTask(context, message, task));
  }
  if (wasDeletedOrUndeleted) {
    const threadParticipationMutator = new ThreadParticipantMutator(
      viewer,
      context.loaders
    );
    await threadParticipationMutator.updateLastUnseenMessageTimestamp(
      message.threadID,
      message.orgID
    );
    const threadHasAnnotations = await context.loaders.messageAttachmentLoader.loadThreadHasAnnotations(
      message.threadID
    );
    if (threadHasAnnotations) {
      updateAnnotationsOnPage = true;
    }
  }
  if (authorUpdated) {
    const threadHasAnnotations = await context.loaders.messageAttachmentLoader.loadThreadHasAnnotations(
      message.threadID
    );
    if (threadHasAnnotations) {
      updateAnnotationsOnPage = true;
    }
  }
  const newUserReferenceIDs = [];
  let newMentionUserIDs = [];
  if (content !== void 0 && content !== null) {
    newMentionUserIDs = await updateMessageMentions(
      context,
      message.id,
      content
    );
    newUserReferenceIDs.push(...newMentionUserIDs);
  }
  if (newUserReferenceIDs.length > 0 || removedTaskAssigneeUserIDs.length > 0) {
    const threadParticipantMutator = new ThreadParticipantMutator(
      viewer,
      context.loaders
    );
    await threadParticipantMutator.subscribeUsersToThread(
      message.threadID,
      newUserReferenceIDs
    );
    await notifyReferencedUsers({
      context,
      message,
      mentionedUserIDs: newMentionUserIDs,
      taskAssigneeUserIDs: newTaskAssigneeUserIDs,
      removedTaskAssigneeUserIDs,
      fileAttachments
    });
  }
  if (content !== void 0 && content !== null) {
    await scheduleUpdateLinkPreviews(context, message);
  }
  publishUpdatedMessageEvents(
    context,
    thread,
    message,
    updateAnnotationsOnPage,
    newUserReferenceIDs,
    originalSubscribers
  );
}
async function executeAppendMessageContentTasks({
  context,
  message,
  appendedContent
}) {
  await scheduleUpdateLinkPreviews(context, message);
  publishAppendedMessageContentEvents(message, appendedContent);
}

// server/src/entity/message_reaction/MessageReactionMutator.ts
var MessageReactionMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
  }
  async createOne(messageID, unicodeReaction, timestamp, transaction) {
    const userID = assertViewerHasUser(this.viewer);
    if (unicodeReaction.length > REACTION_MAX_LENGTH) {
      throw new ApiCallerError("invalid_field", {
        message: `Reaction is too long, must be less than ${REACTION_MAX_LENGTH} characters`
      });
    }
    const result = await MessageReactionEntity.create(
      {
        userID,
        messageID,
        unicodeReaction,
        timestamp
      },
      { transaction }
    );
    this.loaders?.messageReactionLoader.clearAll();
    return result;
  }
  async deleteReaction(messageID, reactionID) {
    const userID = assertViewerHasUser(this.viewer);
    const deleteRow = await MessageReactionEntity.destroy({
      where: {
        id: reactionID,
        userID,
        messageID
      }
    });
    this.loaders?.messageReactionLoader.clearAll();
    return deleteRow === 1;
  }
  async deleteUnicodeReaction(messageID, unicodeReaction, transaction) {
    const userID = assertViewerHasUser(this.viewer);
    const deleteRow = await MessageReactionEntity.destroy({
      where: {
        userID,
        messageID,
        unicodeReaction
      },
      transaction
    });
    this.loaders?.messageReactionLoader.clearAll();
    return deleteRow === 1;
  }
};

// server/src/public/routes/platform/addGroupIDWhereOrgIDExists.ts
function addGroupIDIfNotExistCreateThreadMessageHandler(reqBody, platformApplicationID) {
  if (typeof reqBody !== "object" || !reqBody) {
    return reqBody;
  }
  if (!("createThread" in reqBody)) {
    return reqBody;
  }
  if (typeof reqBody["createThread"] !== "object" || !reqBody["createThread"]) {
    return reqBody;
  }
  if ("groupID" in reqBody["createThread"]) {
    return reqBody;
  }
  if ("organizationID" in reqBody["createThread"]) {
    deprecated(
      "createThreadMessageHandler:organizationID",
      platformApplicationID
    );
    return {
      ...reqBody,
      createThread: {
        ...reqBody["createThread"],
        groupID: reqBody["createThread"]["organizationID"]
      }
    };
  }
  return reqBody;
}
function addGroupIDIfOrgIDExists(reqBody, platformApplicationID) {
  if (typeof reqBody !== "object" || !reqBody) {
    return reqBody;
  }
  if (!("organizationID" in reqBody)) {
    return reqBody;
  }
  deprecated("updateThreadHandler:organizationID", platformApplicationID);
  return { ...reqBody, groupID: reqBody.organizationID };
}
function addGroupIDIfNotExistUpdateUserPresenceHandler(reqBody, platformApplicationID) {
  if (typeof reqBody !== "object" || !reqBody) {
    return reqBody;
  }
  if (!("organizationID" in reqBody)) {
    return reqBody;
  }
  deprecated("updateUserPresenceHandler:organizationID", platformApplicationID);
  return { ...reqBody, groupID: reqBody.organizationID };
}

// server/src/public/routes/platform/messages/CreateThreadMessageHandler.ts
async function createThreadMessageHandler(req, res) {
  const reqBodyWithGroupID = addGroupIDIfNotExistCreateThreadMessageHandler(
    req.body,
    req.appID
  );
  const vars = validate.CreateMessageVariables(reqBodyWithGroupID);
  const message = await createThreadMessage({
    ...vars,
    platformApplicationID: req.appID,
    threadID: req.params.threadID,
    internalMessageID: uuid8()
  });
  res.status(200).json({
    success: true,
    message: "Message created.",
    messageID: message.externalID
  });
}
async function createThreadMessage({
  platformApplicationID,
  threadID: externalThreadID,
  id: externalMessageID,
  internalMessageID,
  authorID: externalSourceID,
  content: rawContent,
  url: url6,
  createdTimestamp: timestamp,
  deletedTimestamp,
  updatedTimestamp: lastUpdatedTimestamp,
  iconURL,
  translationKey,
  type,
  createThread: createThread2,
  metadata,
  extraClassnames,
  addReactions,
  addAttachments = [],
  skipLinkPreviews,
  subscribeToThread,
  screenshotAttachment,
  ...rest
}) {
  const _ = rest;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const app = await ApplicationEntity.findByPk(platformApplicationID);
  if (!app) {
    throw new ApiCallerError("invalid_request");
  }
  if (externalMessageID) {
    validateExternalID(externalMessageID, "id");
  }
  validateExternalID(externalSourceID, "authorID");
  const existingThread = await ThreadEntity.findOne({
    where: {
      externalID: externalThreadID,
      platformApplicationID
    }
  });
  if (!existingThread && !createThread2) {
    throw new ApiCallerError("thread_not_found", {
      message: "Could not find thread with ID " + externalThreadID
    });
  } else if (!existingThread) {
    validateExternalID(externalThreadID, "threadID");
  }
  if (externalMessageID) {
    const messageExists = await MessageEntity.findOne({
      where: {
        externalID: externalMessageID,
        platformApplicationID
      }
    });
    if (messageExists) {
      throw new ApiCallerError("message_already_exists", {
        message: `Message with id: ${externalMessageID} already exists. Please use a different ID or update the message via our update message endpoint https://docs.cord.com/rest-apis/messages#Update-a-message.`
      });
    }
  }
  const [org, sender] = await Promise.all([
    existingThread ? OrgEntity.findOne({
      where: {
        id: existingThread.orgID,
        platformApplicationID
      }
    }) : OrgEntity.findOne({
      where: {
        externalID: createThread2.organizationID ?? createThread2.groupID,
        platformApplicationID
      }
    }),
    UserEntity.findOne({
      where: {
        externalID: externalSourceID,
        platformApplicationID
      }
    })
  ]);
  if (!org) {
    throw new ApiCallerError("organization_not_found");
  }
  if (!sender) {
    throw new ApiCallerError("user_not_found", {
      message: `Invalid message sender user id: ${externalSourceID}.`
    });
  }
  const orgMemberCount = await OrgMembersEntity.count({
    where: {
      userID: sender.id,
      orgID: org.id
    }
  });
  if (orgMemberCount !== 1) {
    throw new ApiCallerError("invalid_request", {
      message: "message author is not a member of the organization the thread belongs to"
    });
  }
  let content;
  try {
    validateMessageContent(rawContent);
    content = await internalizeContent(
      rawContent,
      platformApplicationID,
      org.id
    );
  } catch (e) {
    throw new ApiCallerError("invalid_field", {
      message: "content field is invalid: " + e.message
    });
  }
  const pendingFileAttachments = await validateAddAttachments(
    addAttachments,
    sender
  );
  const reactionsToAdd = addReactions ?? [];
  const externalReactionUserIDs = unique13(
    reactionsToAdd.map((reaction) => reaction.userID)
  );
  const viewer = await Viewer.createLoggedInPlatformViewer({
    user: sender,
    org
  });
  const context = await contextWithSession(
    { viewer },
    getSequelize(),
    null,
    null
  );
  const externalToInternalReactionUsers = await getValidExternalToInternalReactionUsers(
    context,
    externalReactionUserIDs,
    org
  );
  const viewerReactionMutator = new MessageReactionMutator(
    viewer,
    context.loaders
  );
  const [message, thread, senderContext, isFirstMessage, fileAttachments] = (
    // We use SERIALIZABLE here because it's needed to ensure the threads and
    // preallocated_thread_ids tables remain consistent, see thread_by_external_id.ts
    await serializableTransactionWithRetries(async (transaction) => {
      let existingOrCreatedThread;
      let threadWasCreated = false;
      if (existingThread) {
        existingOrCreatedThread = existingThread;
      } else {
        if (!createThread2) {
          throw new ApiCallerError("thread_not_found");
        }
        if (createThread2.resolved !== void 0) {
          deprecated("createThreadMessageHandler:createThread:resolved");
        }
        const { thread: newThread } = await createThread({
          platformApplicationID,
          id: externalThreadID,
          transaction,
          viewer,
          ...createThread2
        });
        existingOrCreatedThread = newThread;
        threadWasCreated = true;
      }
      const createdMessage = await new MessageMutator(
        viewer,
        context.loaders
      ).createMessageExternal(
        {
          id: internalMessageID,
          thread: existingOrCreatedThread,
          sourceID: sender.id,
          externalID: externalMessageID,
          content,
          url: url6,
          timestamp: timestamp || /* @__PURE__ */ new Date(),
          deletedTimestamp: deletedTimestamp ?? void 0,
          lastUpdatedTimestamp: lastUpdatedTimestamp ?? void 0,
          type: type ?? "user_message",
          iconURL: iconURL ?? void 0,
          translationKey: translationKey ?? void 0,
          metadata,
          extraClassnames: extraClassnames ?? void 0,
          skipLinkPreviews
        },
        transaction
      );
      await Promise.all(
        reactionsToAdd.map(async (reactionToAdd) => {
          const user = externalToInternalReactionUsers.get(
            reactionToAdd.userID
          );
          if (!user) {
            return;
          }
          let mutator;
          if (user.id === viewer.userID) {
            mutator = viewerReactionMutator;
          } else {
            const reactionViewer = await Viewer.createLoggedInPlatformViewer({
              user,
              org
            });
            mutator = new MessageReactionMutator(reactionViewer, null);
          }
          return await mutator.createOne(
            createdMessage.id,
            reactionToAdd.reaction,
            reactionToAdd.timestamp,
            transaction
          );
        })
      );
      return [
        createdMessage,
        existingOrCreatedThread,
        context,
        threadWasCreated,
        pendingFileAttachments
      ];
    })
  );
  const flagsUser = {
    userID: message.sourceID,
    orgID: message.orgID,
    platformApplicationID: app.id,
    version: null,
    customerID: app.customerID
  };
  const page = await PageEntity.findOne({
    where: {
      contextHash: thread.pageContextHash,
      orgID: message.orgID
    }
  });
  if (!page) {
    throw new Error(
      `Could not find page for message ${message.id} and thread ${thread.id}`
    );
  }
  await executeNewMessageCreationTasks({
    context: senderContext,
    flagsUser,
    application: app,
    page,
    thread,
    message,
    fileAttachments: fileAttachments.map((a) => ({
      id: uuid8(),
      fileID: a.id
    })),
    annotationAttachments: [],
    isFirstMessage,
    task: null,
    screenshotAttachment,
    subscribeToThread: subscribeToThread ?? true
  });
  return message;
}
async function validateAddAttachments(addAttachments, sender, transaction) {
  const pendingFileAttachments = addAttachments.filter(
    (a) => a.type === "file"
  );
  const idsToAttach = new Set(pendingFileAttachments.map((f) => f.id));
  if (idsToAttach.size !== pendingFileAttachments.length) {
    throw new ApiCallerError("invalid_field", {
      message: "Cannot attach the same file multiple times"
    });
  }
  const filesToAttach = await FileEntity.findAll({
    where: {
      id: pendingFileAttachments.map((a) => a.id)
    },
    transaction
  });
  if (filesToAttach.length !== pendingFileAttachments.length) {
    throw new ApiCallerError("file_not_found");
  }
  if (filesToAttach.some((f) => f.userID !== sender.id)) {
    throw new ApiCallerError("file_belongs_to_different_user");
  }
  return pendingFileAttachments;
}
var CreateThreadMessageHandler_default = forwardHandlerExceptionsToNext(createThreadMessageHandler);

// server/src/admin/profiler.ts
import * as inspector from "inspector";
async function writeOutCPUProfileImpl(request, response) {
  {
    if (!request.context.session.isAdmin) {
      response.statusCode = 403;
      response.send("access denied");
      return;
    }
    response.statusCode = 200;
    response.setHeader("Content-type", "application/json");
    const session = new inspector.Session();
    session.connect();
    await enableProfiler(session);
    await startProfiler(session);
    const reqMs = Number(request.query.ms);
    const ms = reqMs && 0 < reqMs && reqMs <= 2 * 60 * 1e3 ? reqMs : 5e3;
    await sleep(ms);
    const { profile } = await stopProfiler(session);
    response.write(JSON.stringify(profile));
    session.disconnect();
    response.end();
  }
}
var writeOutCPUProfile = forwardHandlerExceptionsToNext(
  writeOutCPUProfileImpl
);
async function takeHeapSnapshotImpl(request, response) {
  if (!request.context.session.isAdmin) {
    response.statusCode = 403;
    response.send("access denied");
    return;
  }
  response.statusCode = 200;
  response.setHeader("Content-type", "application/json");
  const session = new inspector.Session();
  session.connect();
  session.on("HeapProfiler.addHeapSnapshotChunk", (m) => {
    response.write(m.params.chunk);
  });
  session.post("HeapProfiler.takeHeapSnapshot", void 0, () => {
    session.disconnect();
    response.end();
  });
}
function enableProfiler(session) {
  return sendMessage("Profiler.enable", session);
}
function startProfiler(session) {
  return sendMessage("Profiler.start", session);
}
function stopProfiler(session) {
  return sendMessage(
    "Profiler.stop",
    session
  );
}
function sendMessage(message, session) {
  return new Promise(
    (resolve2, reject) => session.post(message, (err, result) => {
      if (err != null) {
        reject(err);
      }
      resolve2(result);
    })
  );
}
var takeHeapSnapshot = forwardHandlerExceptionsToNext(takeHeapSnapshotImpl);

// server/src/middleware/request_context.ts
import * as cookie3 from "cookie";

// server/src/auth/session.ts
import { verify as verify6, decode as decode4 } from "jsonwebtoken";
import isUUID8 from "validator/lib/isUUID.js";

// common/auth/index.ts
import { decode as decode3 } from "js-base64";
var BEARER_PREFIX = "Bearer ";
function getTokenFromAuthorizationHeader(authHeader) {
  if (!authHeader.startsWith(BEARER_PREFIX)) {
    throw new Error("Malformed authorization header: no type prefix");
  }
  return authHeader.substring(BEARER_PREFIX.length);
}

// server/src/entity/user/ConsoleUserMutator.ts
var ConsoleUserMutator = class {
  constructor(viewer, loader) {
    this.viewer = viewer;
    this.logger = new Logger(viewer);
    this.loader = loader ?? new ConsoleUserLoader(viewer);
  }
  async upsertUser({
    email,
    name,
    picture,
    verified,
    auth0UserID
  }) {
    const user = await this.loader.loadUser(email);
    if (user) {
      return await user.update({ name, picture, verified, auth0UserID });
    }
    return await ConsoleUserEntity.create({
      email,
      name,
      picture,
      verified,
      auth0UserID
    });
  }
  async grantCustomerAccess(user, customerID, transaction) {
    try {
      await ConsoleUserEntity.update(
        { customerID },
        { where: { id: user.id }, transaction }
      );
      return true;
    } catch (error) {
      this.logger.logException(
        "Unable to grant user access to application",
        error,
        {
          consoleUserId: user.id,
          customerID
        }
      );
      return false;
    }
  }
  async removeCustomerAccess(user, customerID) {
    try {
      await ConsoleUserEntity.update(
        { customerID: null },
        { where: { id: user.id, customerID } }
      );
      return true;
    } catch (error) {
      this.logger.logException(
        "Unable to remove user access to application",
        error,
        {
          consoleUserId: user.id,
          customerID
        }
      );
      return false;
    }
  }
  async grantPendingUserCustomerAccess(user, customerID, transaction) {
    try {
      const [updatedCount] = await ConsoleUserEntity.update(
        { customerID, pendingCustomerID: null },
        { where: { id: user.id, pendingCustomerID: customerID }, transaction }
      );
      if (updatedCount === 1) {
        return true;
      }
      throw new Error(
        "Could not update console user - grantPendingUserCustomerAccess"
      );
    } catch (error) {
      this.logger.logException(
        "Unable to grant pending user access to application",
        error,
        {
          consoleUserId: user.id,
          pendingCustomerID: user.pendingCustomerID,
          customerID
        }
      );
      throw error;
    }
  }
  async denyPendingUserCustomerAccess(user, customerID, transaction) {
    try {
      const [updatedCount] = await ConsoleUserEntity.update(
        { pendingCustomerID: null },
        { where: { id: user.id, pendingCustomerID: customerID }, transaction }
      );
      if (updatedCount === 1) {
        return true;
      }
      throw new Error(
        "Could not update console user - denyPendingUserCustomerAccess"
      );
    } catch (error) {
      this.logger.logException(
        "Unable to deny pending user access to application",
        error,
        {
          consoleUserId: user.id,
          customerID
        }
      );
      throw error;
    }
  }
  async requestCustomerAccess(user, customerID) {
    try {
      const [updatedCount] = await ConsoleUserEntity.update(
        { pendingCustomerID: customerID },
        { where: { id: user.id, customerID: null } }
      );
      if (updatedCount === 1) {
        return true;
      }
      throw new Error("Could not update console user - requestCustomerAccess");
    } catch (error) {
      this.logger.logException(
        "Unable to request user access to application",
        error,
        {
          consoleUserId: user.id,
          customerID
        }
      );
      throw error;
    }
  }
  async revokeRequestCustomerAccess(user, customerID, transaction) {
    try {
      const [updatedCount] = await ConsoleUserEntity.update(
        { pendingCustomerID: null },
        { where: { id: user.id }, transaction }
      );
      if (updatedCount === 1) {
        return true;
      }
      throw new Error(
        "Could not update console user - revokeRequestCustomerAccess"
      );
    } catch (error) {
      this.logger.logException(
        "Unable to revoke request user access to application",
        error,
        {
          consoleUserId: user.id,
          revokeRequestCustomerID: customerID
        }
      );
      throw error;
    }
  }
};

// server/src/util/sampleTokenAppSecret.ts
import * as crypto7 from "crypto";
function sampleTokenAppSecret(appID) {
  return crypto7.createHmac("sha256", Env_default.JWT_SIGNING_SECRET).update(appID.toLowerCase()).digest("hex");
}

// server/src/auth/session.ts
async function decodeSessionFromJWT(token) {
  const logger = anonymousLogger();
  const decoded = decode4(token, { complete: true });
  if (typeof decoded?.payload === "string") {
    throw new ApiCallerError(
      "invalid_access_token",
      { message: formatInvalidSessionError("Invalid jwt") },
      {
        token
      }
    );
  }
  if (decoded?.header?.alg === "RS256" && decoded?.payload?.iss === `https://${Env_default.AUTH0_CUSTOM_LOGIN_DOMAIN}/`) {
    const key = await jwksClient.getSigningKey(decoded?.header?.kid);
    const validated = verify6(token, key.getPublicKey(), {
      algorithms: ["RS256"]
    });
    const email = validated["https://console.cord.com/email"];
    const email_verified = validated["https://console.cord.com/email_verified"];
    const auth0UserID = validated["auth0UserID"];
    if (!validated || !validated.sub || !email || !isDefined(email_verified)) {
      throw new ApiCallerError(
        "invalid_access_token",
        { message: formatInvalidSessionError("Invalid jwt") },
        {
          token
        }
      );
    }
    const viewer = Viewer.createConsoleViewer(email);
    const consoleLoader = new ConsoleUserLoader(viewer);
    const user = await consoleLoader.loadUser(email);
    if (!auth0UserID) {
      logger.error("Could not find auth0UserID", {
        attemptedLogin: { email }
      });
      throw new ApiCallerError("invalid_access_token");
    }
    if (!user || !user.auth0UserID) {
      await new ConsoleUserMutator(viewer).upsertUser({
        email,
        verified: email_verified,
        auth0UserID
      });
      return {
        viewer,
        console: {
          email_verified
        }
      };
    }
    if (auth0UserID !== user.auth0UserID) {
      logger.error("Console auth0 user does not match", {
        attemptedLogin: { email, auth0UserID }
      });
      throw new ApiCallerError("invalid_console_user");
    }
    return {
      viewer,
      console: {
        email_verified
      }
    };
  } else if (!decoded?.payload?.viewer) {
    const platformSession = await verifySessionToken(token);
    if (platformSession.group_details && !platformSession.group_id) {
      throw new ApiCallerError("group_not_found", {
        message: `Specified group_details to create/update a group, but not a group_id to create/update.`
      });
    }
    if (platformSession.user_details) {
      await updateUser(
        platformSession.app_id,
        platformSession.user_id,
        platformSession.user_details
      );
    }
    if (platformSession.group_id && platformSession.group_details) {
      await updateOrganization(
        platformSession.app_id,
        platformSession.group_id,
        platformSession.group_details
      );
    }
    if (platformSession.group_id && (platformSession.user_details || platformSession.group_details)) {
      await updateOrganizationMembers(
        platformSession.app_id,
        platformSession.group_id,
        { add: [platformSession.user_id] }
      );
    }
    const { user, org } = await loadFromSessionToken(platformSession);
    return {
      viewer: await Viewer.createLoggedInPlatformViewer({
        user,
        org
      })
    };
  } else {
    const {
      iat: _iat,
      exp: _exp,
      ...serializedSession
    } = verify6(token, Env_default.JWT_SIGNING_SECRET);
    return {
      ...serializedSession,
      viewer: Viewer.createFromSerializedState(serializedSession.viewer)
    };
  }
}
async function getSessionFromAuthHeader(authHeader, clientVersion) {
  let logger = anonymousLogger();
  if (authHeader) {
    let isClientTooOld = false;
    const clientVersionDaysOld = await getClientVersionDaysOld(clientVersion);
    if (clientVersionDaysOld > CLIENT_VERSION_MAX_DAYS_OLD) {
      isClientTooOld = true;
    }
    let session;
    let token;
    try {
      token = getTokenFromAuthorizationHeader(authHeader);
    } catch (e) {
      throw new ApiCallerError(
        "invalid_access_token",
        { message: formatInvalidSessionError(e.message) },
        {
          error: e,
          authHeader
        },
        { ...e instanceof CordError && e.loggingTags }
      );
    }
    try {
      session = await decodeSessionFromJWT(token);
    } catch (e) {
      throw new ApiCallerError(
        "invalid_access_token",
        { message: formatInvalidSessionError(e.message) },
        {
          error: e,
          encodedToken: token,
          decodedToken: decode4(token)
        },
        { ...e instanceof CordError && e.loggingTags }
      );
    }
    logger = new Logger(session.viewer);
    if (isClientTooOld && await getFeatureFlagValue("enable_blocking_old_clients", {
      platformApplicationID: session.viewer.platformApplicationID ?? "extension",
      userID: session.viewer.userID ?? "anonymous",
      orgID: session.viewer.orgID,
      version: null
    }) === true) {
      logger.info("Client too old.", {
        ...session.viewer,
        isAdmin: session.isAdmin,
        utmParameters: session.utmParameters,
        clientVersionDaysOld
      });
      throw new Error("client_too_old" /* CLIENT_TOO_OLD */);
    }
    if (session.viewer.userID) {
      const userLoader = new UserLoader(
        Viewer.createServiceViewer(),
        () => null
      );
      const user = await userLoader.loadUser(session.viewer.userID);
      if (!user || user.state === "deleted") {
        throw new ClientFacingError(
          formatInvalidSessionError(
            "The user could not be loaded or is deleted in org"
          ),
          {
            user_id: session.viewer.userID,
            org_id: session.viewer.orgID,
            app_id: session.viewer.platformApplicationID ?? "extension"
          }
        );
      }
      session.isAdmin = user.admin;
    }
    if (session.viewer.orgID) {
      const orgLoader = new OrgLoader(Viewer.createServiceViewer());
      const org = await orgLoader.loadOrg(session.viewer.orgID);
      if (!org || org.state === "inactive") {
        throw new ClientFacingError(
          formatInvalidSessionError(
            "The org could not be loaded or is inactive"
          ),
          {
            org_id: session.viewer.orgID,
            app_id: session.viewer.platformApplicationID ?? "extension"
          }
        );
      }
    }
    if (session.viewer.userID && session.viewer.orgID) {
      const orgMembership = await new OrgMembersLoader(
        Viewer.createServiceViewer()
      ).loadUserOrgMembership(session.viewer.userID, session.viewer.orgID);
      if (!orgMembership) {
        throw new ApiCallerError(
          "user_not_in_organization",
          {
            message: formatInvalidSessionError(
              "The user is not part of the org"
            )
          },
          {
            user_id: session.viewer.userID,
            org_id: session.viewer.orgID,
            app_id: session.viewer.platformApplicationID ?? "extension"
          }
        );
      }
    }
    return session;
  } else {
    logger.debug("Anonymous session");
    return createAnonymousSession();
  }
}
async function getClientVersionDaysOld(clientVersion) {
  if (!clientVersion) {
    return 0;
  }
  const mostRecentDeployment = await new DeploysLoader(
    Viewer.createAnonymousViewer()
  ).loadMostRecentSuccessfulDeploymentCached(
    clientVersion,
    Env_default.CORD_TIER
  );
  if (!mostRecentDeployment) {
    return 0;
  }
  const clientVersionDaysOld = Math.floor(
    (Date.now() - mostRecentDeployment.getTime()) / (1e3 * 60 * 60 * 24)
  );
  return clientVersionDaysOld;
}
function formatInvalidSessionError(message) {
  return "invalid_session" /* INVALID_SESSION */ + " - " + message;
}
var tokensWithNoAppIDCounter = Counter2({
  name: "tokensWithNoAppID",
  help: "Someone attempted to authenticate using a token with no app_id"
});
function appIDInData(data) {
  if (!data) {
    return false;
  }
  if (typeof data !== "object") {
    return false;
  }
  if (!("app_id" in data) && !("project_id" in data)) {
    return false;
  }
  const { app_id, project_id } = data;
  const appID = project_id ?? app_id;
  if (!appID || typeof appID !== "string" || !isUUID8.default(appID)) {
    return false;
  }
  return true;
}
function validateSessionData(data) {
  if (!appIDInData(data)) {
    tokensWithNoAppIDCounter.inc({});
    if (data && typeof data === "object" && !("app_id" in data) && !("project_id" in data)) {
      throw new ApiCallerError("invalid_session_token", {
        message: `Invalid ClientAuthTokenData:
Input ${JSON.stringify(data)} requires field: project_id.
Refer to https://docs.cord.com/reference/authentication/`,
        code: 401
      });
    }
  }
  const {
    app_id,
    user_id,
    organization_id,
    user_details,
    organization_details,
    group_details,
    group_id,
    project_id
  } = removeEmptyStringEmailIfExists(validate.ClientAuthTokenData(data));
  const orgID = group_id ?? organization_id;
  const appID = project_id ?? app_id;
  return {
    // at this point appID will not be undefined
    app_id: appID,
    user_id: user_id.toString(),
    //in case it was a number
    group_id: orgID?.toString(),
    // in case it was a number
    user_details,
    group_details: group_details ?? organization_details
  };
}
async function verifySessionToken(sessionToken, req) {
  let platformSession;
  try {
    const data = decode4(sessionToken);
    if (req && data instanceof Object) {
      req.appID = data?.app_id;
    }
    platformSession = validateSessionData(data);
    const application = await ApplicationEntity.findByPk(
      platformSession.app_id
    );
    if (application) {
      verify6(sessionToken, application.sharedSecret, {
        algorithms: ["HS256", "HS512"]
      });
      return platformSession;
    }
    const appID = platformSession.app_id ?? platformSession.project_id;
    const sharedSecret = sampleTokenAppSecret(appID);
    try {
      verify6(sessionToken, sharedSecret, {
        algorithms: ["HS256", "HS512"]
      });
    } catch (_) {
      throw new ApiCallerError("project_not_found", {
        message: `Platform project ${platformSession.app_id} not found.`
      });
    }
    await ApplicationEntity.create({
      id: platformSession.app_id,
      name: "Cord Sample Token",
      sharedSecret,
      environment: "sampletoken",
      customerID: CORD_SAMPLE_TOKEN_CUSTOMER_ID
    });
    const [org, user] = await Promise.all([
      OrgEntity.create({
        state: "active",
        name: "Cord Sample Group",
        externalID: DEMO_APPS_APP_GROUP_ID,
        // same as demo apps group because sometimes sample tokens are used for demo apps client code
        externalProvider: "platform" /* PLATFORM */,
        platformApplicationID: platformSession.app_id
      }),
      UserEntity.create({
        name: "Sample User",
        nameUpdatedTimestamp: /* @__PURE__ */ new Date(),
        profilePictureURL: `${APP_ORIGIN}/static/Anon-avatar-A.png`,
        externalID: platformSession.user_id,
        externalProvider: "platform" /* PLATFORM */,
        platformApplicationID: platformSession.app_id
      })
    ]);
    await OrgMembersEntity.create({
      userID: user.id,
      orgID: org.id
    });
    return platformSession;
  } catch (e) {
    if (e instanceof ApiCallerError) {
      throw e;
    } else {
      throw new ApiCallerError("invalid_session_token", { message: e });
    }
  }
}
async function loadFromSessionToken(platformSession) {
  const { app_id, user_id, group_id } = platformSession;
  const userLoader = new UserLoader(Viewer.createAnonymousViewer(), () => null);
  const [user, org] = await Promise.all([
    userLoader.loadUndeletedUser(user_id, app_id),
    group_id ? OrgEntity.findOne({
      where: {
        externalID: group_id,
        platformApplicationID: app_id
      }
    }) : null
  ]);
  if (!user) {
    throw new ApiCallerError(
      "user_not_found",
      {
        message: `Unable to load user ${user_id} in application ${app_id}. Perhaps the user is marked 'deleted'.`
      },
      { app_id }
    );
  }
  if (group_id && !org) {
    throw new ApiCallerError(
      "group_not_found",
      {
        message: `Platform group ${group_id} not found.`
      },
      { app_id }
    );
  }
  if (org) {
    const orgMembership = await OrgMembersEntity.findOne({
      where: {
        userID: user.id,
        orgID: org.id
      }
    });
    if (!orgMembership) {
      throw new ApiCallerError("user_not_in_group", void 0, {
        app_id,
        org_id: org.id,
        externalUserID: user.externalID,
        externalOrgID: org.externalID
      });
    }
  } else {
    const application = await ApplicationEntity.findByPk(app_id);
    const flagsUser = {
      userID: user.id,
      platformApplicationID: user.platformApplicationID ?? "extension",
      version: null,
      appEnvironment: application?.environment
    };
    const allowNullOrg = await getTypedFeatureFlagValue(
      FeatureFlags2.ALLOW_MAGIC_GRAPHQL_ORG_ID_OVERRIDE,
      flagsUser
    );
    if (!allowNullOrg) {
      throw new ApiCallerError("group_not_found", {
        message: `group_id missing from access token.`
      });
    }
  }
  return {
    appID: app_id,
    user,
    org
  };
}

// server/src/middleware/request_context.ts
var authenticatedRequestContext = async (authorization, clientVersion, deployment) => {
  try {
    const session = await getSessionFromAuthHeader(
      authorization,
      clientVersion
    );
    return await contextWithSession(
      session,
      getSequelize(),
      clientVersion,
      deployment
    );
  } catch (e) {
    if (e instanceof ClientFacingError || e instanceof ApiCallerError) {
      anonymousLogger().logException(
        e.message,
        e,
        void 0,
        void 0,
        "info"
      );
    } else {
      anonymousLogger().logException(e.message, e);
    }
    throw e;
  }
};
function getContextForHTTPRequest(req) {
  const authorizationHeader = req.header("Authorization");
  const cookieToken = cookie3.parse(req.header("Cookie") || "")["token"];
  return authenticatedRequestContext(
    authorizationHeader || cookieToken || "",
    req.header("X-Version") || null,
    toDeploymentType(req.header("X-Deployment"))
  );
}
function RequestContextMiddleware(req, res, next) {
  void (async () => {
    let logger = anonymousLogger();
    try {
      const context = await getContextForHTTPRequest(req);
      req.context = context;
      logger = context.logger;
    } catch (e) {
      res.status(403);
      res.json({ error: e.message });
      res.end();
      return;
    }
    logger.debug("Incoming connection (RequestContextMiddleware)", {
      headers: req.headers,
      remoteAddress: req.socket.remoteAddress
    });
    next();
  })();
}

// server/src/entity/email_subscription/EmailSubscriptionMutator.ts
var EmailSubscriptionMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async setEmailUnsubscribed(thread) {
    const userID = assertViewerHasUser(this.viewer);
    await new ThreadParticipantMutator(this.viewer, null).setViewerSubscribed(
      thread,
      false
    );
    await EmailSubscriptionEntity.upsert({
      userID,
      threadID: thread.id,
      subscribe: false
    });
  }
};

// common/page_context/templating/handlebars.js
import Handlebars from "handlebars/dist/cjs/handlebars.js";
var handlebars_default = Handlebars;

// server/src/public/routes/email/unsubscribe_thread/templates/handlebars.ts
var unsunscribeFromThreadPageTemplate = handlebars_default.compile(`
<main style="margin: 32px 0; text-align: center; font-family: Helvetica, Arial, sans-serif; font-size: 24px;">
  <p><img src="{{Image_URL}}" align="center" width="200" /></p>

  <p>To unsubscribe, please click the button below.</p>

  <form method="post">
    <button type="submit" style="padding: 16px 24px; background-color: #191A1E; color: #FFFFFF; font-size: 24px; border-style: none; border-radius: 8px;  cursor: pointer;">Unsubscribe from thread</button>
  <form>

</main>
`);
var successTemplate = handlebars_default.compile(`
<p style="margin: 32px 0; text-align: center"><img src="{{Image_URL}}" align="center" width="200" /></p>

<p style="margin: 32px 0; text-align: center; font-size: 24px; font-family: Helvetica, Arial, sans-serif;">You've been unsubscribed from the thread.</p>
`);
var errorTemplate = handlebars_default.compile(`
<p style="margin: 32px 0; text-align: center; font-size: 24px; font-family: Helvetica, Arial, sans-serif;">There was an error unsubscribing you from the thread.</p>
`);

// server/src/public/routes/email/unsubscribe_thread/index.ts
async function UnsubscribeThreadHandler(req, res) {
  const token = req.query.token;
  if (!token || typeof token !== "string") {
    return res.send(errorTemplate({}));
  }
  try {
    const { threadID, userID, orgID, appID } = decodeUnsubscribeThreadToken(token);
    const viewer = Viewer.createLoggedInViewer(userID, orgID);
    const logger = new Logger(viewer);
    const thread = await ThreadEntity.findByPk(threadID);
    if (!thread) {
      throw new Error(`Thread ${threadID} not found`);
    }
    const mutator = new EmailSubscriptionMutator(viewer);
    await mutator.setEmailUnsubscribed(thread);
    const imageURL = await generateImageURL(appID);
    const oneClickUnsubscribe = "List-Unsubscribe" in req.body && req.body["List-Unsubscribe"] === "One-Click";
    logger.log("info", "clicked-email-unsubscribe-from-thread", {
      userID,
      orgID,
      appID,
      oneClickUnsubscribe
    });
    logServerEvent({
      session: { viewer },
      type: "clicked-email-unsubscribe-from-thread",
      logLevel: "info" /* INFO */,
      metadata: {
        oneClickUnsubscribe
      }
    });
    return res.send(
      successTemplate({
        Image_URL: imageURL
      })
    );
  } catch (e) {
    return res.send(errorTemplate({}));
  }
}
async function RenderUnsubscribeThreadPage(req, res) {
  const token = req.query.token;
  if (!token || typeof token !== "string") {
    return res.send(errorTemplate({}));
  }
  try {
    const { appID } = decodeUnsubscribeThreadToken(token);
    const imageURL = await generateImageURL(appID);
    return res.send(
      unsunscribeFromThreadPageTemplate({
        Image_URL: imageURL
      })
    );
  } catch (e) {
    return res.send(errorTemplate({}));
  }
}
async function generateImageURL(appID) {
  if (appID) {
    const application = await ApplicationEntity.findByPk(appID);
    if (application?.customEmailTemplate?.imageURL) {
      return application?.customEmailTemplate?.imageURL;
    }
  }
  return `${APP_ORIGIN}/static/cord-wordmark.png`;
}

// server/src/public/routes/file/index.ts
async function FileProxyHandler(req, res) {
  const token = req.query.token;
  if (!token || typeof token !== "string") {
    return res.status(400).send();
  }
  try {
    const { id } = decodeFileProxyToken(token);
    const file = await FileEntity.findByPk(id);
    if (!file) {
      return res.status(404).send();
    }
    const signedDownloadURL = await file.getSignedDownloadURL();
    return res.redirect(302, signedDownloadURL);
  } catch (e) {
    return res.status(400).send();
  }
}

// server/src/public/routes/notifications_logging/handlebars.ts
var errorRedirectTemplate = handlebars_default.compile(`
<main style="margin: 32px 0; text-align: center; font-family: Helvetica, Arial, sans-serif; font-size: 24px;">
  <p><img src="{{imageURL}}" align="center" width="200" /></p>

  <p>Oops! Something went wrong :(</p>
</main>
`);

// server/src/util/redirectURI.ts
import * as jwt2 from "jsonwebtoken";
var CORD_REDIRECT_QUERY_PARAM = "cord_notifications";
async function applicationSupportsRedirect(platformApplicationID) {
  const application = await ApplicationEntity.findByPk(platformApplicationID);
  if (!application) {
    throw new Error("ApplicationEntity not found");
  }
  if (!application.redirectURI) {
    return false;
  }
  return true;
}
async function generateSignedExternalRedirectURI(platformApplicationID, url6, data) {
  return await generateSignedRedirectURIImplementation(
    platformApplicationID,
    url6,
    data
  );
}
async function generateSignedRedirectURIImplementation(platformApplicationID, url6, data) {
  if (!platformApplicationID) {
    return url6;
  }
  const application = await ApplicationEntity.findByPk(platformApplicationID);
  if (!application) {
    return url6;
  }
  const redirectURI = application.redirectURI;
  if (!redirectURI) {
    return url6;
  }
  const state = jwt2.sign(
    {
      notificationInfo: {
        ...data
      }
    },
    application.sharedSecret,
    { algorithm: "HS256" }
  );
  const parsed = new URL(redirectURI);
  parsed.searchParams.set(CORD_REDIRECT_QUERY_PARAM, state);
  return parsed.href;
}

// server/src/util/notificationRedirectURI.ts
async function getNotificationRedirectURI(logger, {
  messageNotificationEntity,
  targetOrgID,
  targetExternalOrgID,
  platformApplicationID,
  redirectID
}) {
  try {
    const appSupportsRedirect = await applicationSupportsRedirect(
      platformApplicationID
    );
    if (!appSupportsRedirect) {
      return messageNotificationEntity.url;
    }
    const data = await getNotificationRedirectURIData({
      messageNotificationEntity
    });
    logServerEvent({
      session: {
        viewer: Viewer.createOrgViewer(targetOrgID)
      },
      type: "notification-logging-redirect-uri",
      logLevel: "debug" /* DEBUG */,
      payload: {
        redirectURIInfo: JSON.parse(JSON.stringify(data)),
        orgID: targetOrgID,
        groupID: targetOrgID,
        platformApplicationID,
        redirectID,
        externalOrgID: targetExternalOrgID,
        messageNotifications: messageNotificationEntity.get({ plain: true })
      }
    });
    return await generateSignedExternalRedirectURI(
      platformApplicationID,
      messageNotificationEntity.url,
      data
    );
  } catch (error) {
    logger.error("getSharedToEmailRedirectURI:" + error, {
      orgID: targetOrgID,
      groupID: targetOrgID,
      platformApplicationID,
      redirectID,
      externalOrgID: targetExternalOrgID,
      messageNotifications: messageNotificationEntity.get({ plain: true })
    });
    return messageNotificationEntity.url;
  }
}
async function getNotificationRedirectURIData({
  messageNotificationEntity
}) {
  const {
    type,
    sharerUserID,
    sharerOrgID,
    targetUserID,
    targetOrgID,
    messageID,
    url: url6,
    timestamp,
    metadata
  } = messageNotificationEntity;
  if (!sharerUserID || !sharerOrgID) {
    throw new Error("SharerUserID or SharerOrgID not defined");
  }
  const [sharer, message, sharerOrg] = await Promise.all([
    UserEntity.findByPk(sharerUserID),
    MessageEntity.findByPk(messageID),
    OrgEntity.findByPk(sharerOrgID)
  ]);
  const context = await contextWithSession(
    {
      viewer: targetUserID ? Viewer.createLoggedInViewer(targetUserID, targetOrgID) : Viewer.createOrgViewer(targetOrgID)
    },
    getSequelize(),
    null,
    null
  );
  if (!sharer) {
    throw new Error("Sharer not found");
  }
  if (!sharer.externalID && sharer.userType === "person") {
    throw new Error("Sharer externalID not defined and user is not bot");
  }
  if (!sharer.externalProvider && sharer.userType === "person") {
    throw new Error("Sharer AuthProvider is null");
  }
  if (!message) {
    throw new Error("MessageEntity not found");
  }
  if (!sharerOrg || !sharerOrg.externalID) {
    throw new Error("Sharer Org not found or externalID not defined");
  }
  const thread = await ThreadEntity.findByPk(message.threadID);
  if (!thread) {
    throw new Error("ThreadEntity not found");
  }
  const threadID = thread.externalID;
  const sharerDisplayDetails = await detailsForDisplay(sharer, context);
  const sharerDetails = {
    userType: sharer.externalProvider,
    userID: sharer.externalID,
    email: sharer.email,
    name: sharerDisplayDetails.displayName,
    profilePictureURL: sharerDisplayDetails.profilePictureURL,
    orgID: sharerOrg.externalID,
    groupID: sharerOrg.externalID
  };
  const baseData = {
    sharerDetails,
    threadID,
    url: url6,
    timestamp
  };
  switch (type) {
    case "email": {
      const targetDetails = await getTargetDetails(
        type,
        targetOrgID,
        targetUserID,
        sharerDetails,
        sharerUserID,
        context
      );
      const emailMentionData = {
        type,
        ...baseData,
        messageID: externalizeID(message.id),
        targetDetails
      };
      return emailMentionData;
    }
    case "sharedToEmail": {
      const targetDetails = await getTargetDetails(
        type,
        targetOrgID,
        targetUserID,
        sharerDetails,
        sharerUserID,
        context,
        metadata
      );
      const sharedToEmailData = {
        type,
        targetDetails,
        ...baseData
      };
      return sharedToEmailData;
    }
    case "sharedToSlackChannel": {
      const targetDetails = await getTargetDetails(
        type,
        targetOrgID,
        targetUserID,
        sharerDetails,
        sharerUserID,
        context,
        metadata
      );
      const sharedToSlackChannelData = {
        type,
        targetDetails,
        ...baseData
      };
      return sharedToSlackChannelData;
    }
    case "slackEmailMatched":
    case "slack": {
      const targetDetails = await getTargetDetails(
        "slack",
        targetOrgID,
        targetUserID,
        sharerDetails,
        sharerUserID,
        context,
        metadata
      );
      const slackData = {
        type: "slack",
        targetDetails,
        messageID: externalizeID(message.id),
        ...baseData
      };
      return slackData;
    }
  }
}
function asSharedToEmailMetadata(metadata) {
  if ("type" in metadata && metadata.type === "sharedToEmail" && "targetEmail" in metadata && typeof metadata.targetEmail === "string") {
    return metadata;
  }
  return null;
}
function asSharedToSlackChannelMetadata(metadata) {
  if ("type" in metadata && metadata.type === "sharedToSlackChannel" && "targetSlackChannelID" in metadata && typeof metadata.targetSlackChannelID === "string") {
    return metadata;
  }
  return null;
}
async function getTargetDetails(notificationType, targetOrgID, targetUserID, sharerDetails, sharerUserID, context, metadata) {
  switch (notificationType) {
    case "slack":
    case "email": {
      if (!targetUserID) {
        throw new Error("targetUserID not defined");
      }
      if (targetUserID === sharerUserID) {
        return sharerDetails;
      }
      const [target, targetOrg] = await Promise.all([
        UserEntity.findByPk(targetUserID),
        OrgEntity.findByPk(targetOrgID)
      ]);
      if (!target || !target.externalID) {
        throw new Error("target not found or externalID not found");
      }
      if (!target.externalProvider) {
        throw new Error("Target AuthProvider is null");
      }
      if (!targetOrg || !targetOrg.externalID) {
        throw new Error("targetOrg not found or externalID not found");
      }
      const targetProfileDisplayDetails = await detailsForDisplay(
        target,
        context
      );
      return {
        userType: target.externalProvider,
        userID: target.externalID,
        name: targetProfileDisplayDetails.displayName,
        email: target.email,
        profilePictureURL: targetProfileDisplayDetails.profilePictureURL,
        orgID: targetOrg.externalID,
        groupID: targetOrg.externalID
      };
    }
    case "sharedToEmail": {
      if (!metadata) {
        throw new Error("Metadata does not exist");
      }
      const sharedToEmailMetadata = asSharedToEmailMetadata(metadata);
      if (!sharedToEmailMetadata) {
        throw new Error("SharedToEmailMetadata does not exist");
      }
      return {
        userType: null,
        email: sharedToEmailMetadata.targetEmail
      };
    }
    case "sharedToSlackChannel": {
      if (!metadata) {
        throw new Error("Metadata does not exist");
      }
      const sharedToSlackChannelMetadata = asSharedToSlackChannelMetadata(metadata);
      if (!sharedToSlackChannelMetadata) {
        throw new Error("SharedToSlackChannelMetadata does not exist");
      }
      const targetOrg = await OrgEntity.findByPk(targetOrgID);
      if (!targetOrg || !targetOrg.externalID) {
        throw new Error("targetOrg not found or externalID not found");
      }
      return {
        userType: "slack" /* SLACK */,
        orgID: targetOrg.externalID,
        groupID: targetOrg.externalID,
        slackChannelID: sharedToSlackChannelMetadata.targetSlackChannelID
      };
    }
    default: {
      const unhandledType = notificationType;
      throw new Error("Forgot to handle type: " + unhandledType);
    }
  }
}

// server/src/public/routes/notifications_logging/NotificationLoggingHandler.ts
async function NotificationLoggingHandler(req, res) {
  const { redirectID } = req.params;
  let logger = anonymousLogger();
  try {
    if (!redirectID) {
      throw new Error(`redirectID does not exist, url: ${req.url}`);
    }
    if (redirectID.length !== NOTIFICATION_LOGGING_REDIRECT_ID_LENGTH) {
      logger.warn(`redirectID length is incorrect, id: ${redirectID}`);
      return res.send(
        errorRedirectTemplate({
          imageURL: `${APP_ORIGIN}/static/cord-wordmark.png`
        })
      );
    }
    const messageNotificationEntity = await MessageOutboundNotificationEntity.findByPk(redirectID);
    if (!messageNotificationEntity) {
      throw new Error(`notification does not exist, id:${redirectID}`);
    }
    const {
      url: originalURL,
      type,
      messageID,
      targetUserID,
      targetOrgID,
      sharerOrgID
    } = messageNotificationEntity;
    const org = await OrgEntity.findByPk(targetOrgID);
    if (!org) {
      logger.warn("Org not found", { orgID: targetOrgID, redirectID });
      return res.end();
    }
    const orgViewer = Viewer.createOrgViewer(org.id);
    logger = new Logger(orgViewer, {
      id: org.id,
      externalId: org.externalID,
      appId: org.platformApplicationID,
      name: org.name
    });
    let url6 = originalURL;
    if (!sharerOrgID) {
      logger.warn(`Sharer orgID does not exist`, {
        orgID: targetOrgID,
        redirectID
      });
    } else {
      const sharerOrg = await OrgEntity.findByPk(sharerOrgID);
      if (!sharerOrg) {
        throw new Error(`Sharer org does not exist: ${sharerOrgID}`);
      }
      url6 = !sharerOrg.platformApplicationID ? originalURL : await getNotificationRedirectURI(logger, {
        targetOrgID,
        platformApplicationID: sharerOrg.platformApplicationID,
        redirectID,
        targetExternalOrgID: org.externalID,
        messageNotificationEntity
      });
    }
    const fromSlackUnfurler = requestFromSlackUnfurler(req);
    if (!fromSlackUnfurler) {
      let loggedInViewer = null;
      if (targetUserID) {
        const orgMembership = await OrgMembersEntity.findOne({
          where: { userID: targetUserID, orgID: targetOrgID }
        });
        if (orgMembership) {
          loggedInViewer = Viewer.createLoggedInViewer(
            targetUserID,
            targetOrgID
          );
        }
      }
      const targetUserEventMutator = new EventMutator({
        viewer: loggedInViewer ?? orgViewer
      });
      await targetUserEventMutator.createEvent({
        pageLoadID: null,
        installationID: null,
        eventNumber: null,
        clientTimestamp: new Date(Date.now()),
        logLevel: "debug" /* DEBUG */,
        type: `notification-logging`,
        payload: {
          messageNotifications: messageNotificationEntity.get({ plain: true }),
          userAgent: req.get("User-Agent")
        },
        metadata: {}
      });
      if (targetUserID) {
        await maybeDeeplinkViaRedis({
          logger,
          userID: targetUserID,
          org,
          url: url6,
          redirectID,
          messageID
        });
      }
    }
    logger.debug(`notifications-logging-${type}`, {
      url: url6,
      type,
      fromSlackUnfurler,
      userAgent: req.get("User-Agent")
    });
    return res.redirect(302, url6);
  } catch (error) {
    logger.logException("notifications-logging-error", error, {
      redirectID,
      url: req.url,
      headers: req.headers,
      remoteAddress: req.socket.remoteAddress
    });
    return res.send(
      errorRedirectTemplate({
        imageURL: `${APP_ORIGIN}/static/cord-wordmark.png`
      })
    );
  }
}
function requestFromSlackUnfurler(req) {
  const userAgent = req.get("User-Agent");
  return userAgent !== void 0 && userAgent.includes("Slackbot-LinkExpanding");
}
async function maybeDeeplinkViaRedis({
  logger,
  userID,
  org,
  url: url6,
  messageID,
  redirectID
}) {
  let application;
  if (org.platformApplicationID) {
    application = await ApplicationEntity.findByPk(org.platformApplicationID);
  }
  const shouldDeepLinkMessageViaRedis = await getFeatureFlagValue(
    "deep_link_message_from_notification" /* DEEP_LINK_MESSAGE_FROM_NOTIFICATION */,
    {
      userID,
      orgID: org.id,
      platformApplicationID: org.platformApplicationID ?? "extension",
      version: null,
      customerID: application?.customerID
    }
  );
  if (!shouldDeepLinkMessageViaRedis) {
    return;
  }
  const deepLinkParams = extractDeepLinkQueryParams(url6);
  const queryParamDeeplinkEnabled = await getFeatureFlagValue(
    "query_param_deep_links" /* QUERY_PARAM_DEEP_LINKS */,
    {
      userID,
      orgID: org.id,
      platformApplicationID: org.platformApplicationID ?? "extension",
      version: null,
      customerID: application?.customerID
    }
  );
  const deepLinkingViaQueryParams = !!deepLinkParams && queryParamDeeplinkEnabled;
  if (deepLinkingViaQueryParams) {
    return;
  }
  const message = await MessageEntity.findOne({
    where: { id: messageID }
  });
  const threadID = message?.threadID;
  if (!threadID) {
    logger.error("threadID was undefined", { messageID, redirectID });
    return;
  }
  await setDeepLinkThreadMessageID({
    threadID,
    messageID,
    userID
  });
}

// server/src/const.ts
var SLACK_EVENT_PATH = "/slack/event";
var SLACK_INTERACTIVE_EVENT_PATH = "/slack/interactiveEvent";

// server/src/public/routes/handlers/SendGridWebhookHandler.ts
import { v4 as uuid9 } from "uuid";
async function SendGridWebhookHandler(req, res, _next) {
  let logger = anonymousLogger();
  logger.debug("SendGridWebhookHandler", {
    body: req.body,
    headers: req.headers
  });
  const reqBody = req.body;
  if (reqBody === null || reqBody === void 0) {
    logger.warn("request body missing");
    return res.end();
  }
  let headers;
  if (reqBody.headers && typeof reqBody.headers === "string") {
    headers = parseRelevantHeaders(reqBody.headers);
  } else {
    logger.warn('"Missing headers in Sendgrid request payload');
  }
  const toAddress = reqBody.to;
  if (typeof toAddress !== "string") {
    logger.warn('Email "To" address is missing');
    return res.end();
  }
  const fromAddress = reqBody.from;
  if (typeof fromAddress !== "string") {
    logger.warn('Email "From" address is missing');
    return res.end();
  }
  if (headers?.autoSubmitted && headers?.autoSubmitted !== "no") {
    logger.warn("Email reply was autogenerated, discarding", {
      autoSubmitted: headers.autoSubmitted,
      sendgridMessageID: headers?.messageID
    });
    return res.end();
  }
  const notification = await getNotification(
    toAddress,
    headers?.inReplyTo,
    fromAddress,
    logger
  );
  if (notification === null) {
    logger.warn(
      "Notification id is not present in email address, could not be derived from headers, or notification is not present in db",
      {
        toAddress,
        inReplyTo: headers?.inReplyTo,
        fromAddress,
        sendgridMessageID: headers?.messageID
      }
    );
    return res.end();
  }
  const [orgMember, user, thread] = await Promise.all([
    OrgMembersEntity.findOne({
      where: {
        userID: notification.userID,
        orgID: notification.orgID
      }
    }),
    UserEntity.findOne({
      where: {
        id: notification.userID
      }
    }),
    ThreadEntity.findByPk(notification.threadID)
  ]);
  if (!orgMember) {
    logger.warn("User who sent the email is no longer part of the org", {
      userID: notification.userID,
      orgID: notification.orgID
    });
    return res.end();
  }
  if (!user || user.state !== "active") {
    logger.warn("User who sent the email is no longer active", {
      userID: notification.userID,
      orgID: notification.orgID,
      state: user?.state
    });
    return res.end();
  }
  if (!thread) {
    logger.warn("Cannot add message to non-existent thread");
    return res.end();
  }
  const [org, application] = await Promise.all([
    OrgEntity.findByPk(notification.orgID),
    ApplicationEntity.findByPk(thread.platformApplicationID)
  ]);
  if (!org) {
    logger.warn("Org not found", {
      orgID: notification.orgID,
      notificationId: notification.id
    });
    return res.end();
  }
  if (!application) {
    logger.warn("Application not found", {
      platformApplicationID: user.platformApplicationID,
      notificationID: notification.id
    });
    return res.end();
  }
  const flagsUser = {
    userID: notification.userID,
    orgID: notification.orgID,
    platformApplicationID: org.platformApplicationID ?? "extension",
    version: null,
    customerID: application?.customerID
  };
  const emailRepliesEnabled = await getFeatureFlagValue(
    "email_replies",
    flagsUser
  );
  if (!emailRepliesEnabled) {
    return res.end();
  }
  if (notification.threadOrgID && notification.orgID !== notification.threadOrgID) {
    const linkedOrg = await LinkedOrgsEntity.findOne({
      where: {
        sourceOrgID: notification.threadOrgID,
        linkedOrgID: notification.orgID
      }
    });
    if (!linkedOrg) {
      logger.error("Email reply: linked org not found", {
        threadOrgId: notification.threadOrgID,
        notificationId: notification.id
      });
      return res.end();
    }
  }
  const emailText = reqBody.text;
  if (typeof emailText !== "string" || emailText.length === 0) {
    logger.warn("email body not found or empty", emailText);
    return res.end();
  }
  const viewer = await Viewer.createLoggedInPlatformViewer({ user, org });
  logger = new Logger(viewer);
  try {
    const context = await contextWithSession(
      { viewer },
      getSequelize(),
      null,
      null
    );
    const attachments = reqBody.attachments;
    if (typeof attachments !== "string" || attachments.length === 0) {
      logger.warn(
        "attachment body not found or empty",
        attachments
      );
      return res.end();
    }
    const content = emailTextToMessageContent(emailText, attachments);
    const message = await new MessageMutator(
      viewer,
      context.loaders
    ).createMessage({
      id: uuid9(),
      thread,
      content,
      url: null,
      replyToEmailNotificationID: notification.id
    });
    const page = await PageEntity.findOne({
      where: {
        contextHash: thread?.pageContextHash
      }
    });
    if (!page) {
      throw new Error(
        `Could not find page for message ${message.id} and thread ${thread?.id}`
      );
    }
    await executeNewMessageCreationTasks({
      context,
      flagsUser,
      application,
      page,
      thread,
      message,
      fileAttachments: [],
      annotationAttachments: [],
      isFirstMessage: false,
      task: null,
      screenshotAttachment: null,
      sendNotifications: !!viewer.platformApplicationID,
      subscribeToThread: false
    });
    const eventMutator = new EventMutator(
      (await contextWithSession(
        {
          viewer: Viewer.createLoggedInViewer(
            notification.userID,
            notification.orgID
          )
        },
        getSequelize(),
        null,
        null
      )).session
    );
    await eventMutator.createEvent({
      pageLoadID: null,
      installationID: null,
      eventNumber: null,
      clientTimestamp: new Date(Date.now()),
      logLevel: "debug" /* DEBUG */,
      type: "reply-via-email",
      payload: {
        messageID: message.id,
        notificationID: notification.id,
        sendgridMessageID: headers?.messageID
      },
      metadata: {}
    });
  } catch (e) {
    logger.logException("failed to create a message from email reply", e);
  }
  return res.end();
}

// server/src/public/routes/notification-uri-test/handlebars.ts
handlebars_default.registerHelper(
  "equals",
  (stringOne, stringTwo) => stringOne === stringTwo
);
var demoRedirectTemplate = handlebars_default.compile(`
<main style="margin: 32px 16px; text-align: center; font-family: Helvetica, Arial, sans-serif; font-size: 24px;">
  <p><img src="{{imageURL}}" align="center" width="200" /></p>

  <h3 style="font-weight: bold;font-size: 18px; margin: 16px 0px">Notifications Info</h3>
  <pre style="
    text-align: left; 
    font-size: 16px; 
    line-height:24px; 
    background-color: #FBE3D6;
    border-radius: 4px;
    padding: 16px 16px;
    overflow: hidden;
    text-overflow: ellipsis;
    "
  >
    <code>
    {
      "notificationInfo": {{notificationInfo}}
      "iat": {{iat}} ({{iatParsed}})
    }
    </code>
  </pre>
</main>
`);

// server/src/public/routes/notification-uri-test/NotificationRedirectURIHandler.ts
function NotificationRedirectURIHandler(req, res) {
  const { cord_notifications } = req.query;
  try {
    if (typeof cord_notifications !== "string") {
      throw new Error("cord_notifications query is not a string");
    }
    const segments = cord_notifications.split(".");
    if (segments.length !== 3) {
      throw new Error("cord_notifications not jwt format");
    }
    const [_, payload] = segments;
    const info = JSON.parse(Buffer.from(payload, "base64").toString());
    if (typeof info !== "object") {
      throw new Error("Info is not an object");
    }
    if (!("notificationInfo" in info)) {
      throw new Error("notificationInfo does not exist in info object");
    }
    if (!("iat" in info)) {
      throw new Error("iat does not exist in info object");
    }
    const infoState = info;
    if (typeof infoState.iat !== "number") {
      throw new Error("iat is not a number");
    }
    const iatParsed = new Date(infoState.iat * 1e3).toUTCString();
    return res.send(
      demoRedirectTemplate({
        imageURL: `${APP_ORIGIN}/static/cord-wordmark.png`,
        notificationInfo: JSON.stringify(
          infoState.notificationInfo,
          void 0,
          2
          // Insert extra spaces to match template indentation
        ).replaceAll("\n", "\n      "),
        iat: infoState.iat,
        iatParsed
      })
    );
  } catch (error) {
    anonymousLogger().error(`NotificationRedirectURIHandler: ${error}`, {
      cord_notifications
    });
    return res.send("Oops something went wrong");
  }
}

// server/src/public/routes/demo-apps/GetDemoAppsSignedTokenHandler.ts
import * as jwt3 from "jsonwebtoken";
import { v4 as uuid11 } from "uuid";

// common/const/TeamProfiles.ts
var TEAM_PROFILES = [
  {
    firstName: "Tom",
    profilePictureURL: `${APP_ORIGIN}/static/Tom.png`
  },
  {
    firstName: "Dave",
    profilePictureURL: `${APP_ORIGIN}/static/Dave.png`
  },
  {
    firstName: "Jackson",
    profilePictureURL: `${APP_ORIGIN}/static/Jackson.png`
  },
  {
    firstName: "Josh",
    profilePictureURL: `${APP_ORIGIN}/static/Josh.png`
  },
  {
    firstName: "Khadija",
    profilePictureURL: `${APP_ORIGIN}/static/Khadija.png`
  },
  {
    firstName: "Leah",
    profilePictureURL: `${APP_ORIGIN}/static/Leah.png`
  },
  {
    firstName: "Nick",
    profilePictureURL: `${APP_ORIGIN}/static/Nick.png`
  },
  {
    firstName: "My Hoa",
    profilePictureURL: `${APP_ORIGIN}/static/MyHoa.png`
  }
];
var BOT_USERS = [
  {
    firstName: "Zora (Bot)",
    profilePictureURL: `${APP_ORIGIN}/static/Zora.png`
  }
];
var SALES_TEAM_USERS = [
  {
    firstName: "Nimrod",
    profilePictureURL: `${APP_ORIGIN}/static/Nimrod.png`,
    email: "np@cord.com"
  },
  {
    firstName: "Sam",
    profilePictureURL: `${APP_ORIGIN}/static/Sam.png`,
    email: "sam@cord.com"
  },
  {
    firstName: "Kevin",
    profilePictureURL: `${APP_ORIGIN}/static/Kevin.png`,
    email: "kevin@cord.com"
  }
];

// common/util/secondsToFormattedTimestamp.ts
function secondsToFormattedTimestamp(durationSeconds) {
  const hrs = Math.floor(durationSeconds / 3600);
  const mins = Math.floor(durationSeconds % 3600 / 60);
  const secs = Math.floor(durationSeconds) % 60;
  let timestamp = "";
  if (hrs > 0) {
    timestamp += "" + hrs + ":" + (mins < 10 ? "0" : "");
  }
  timestamp += "" + mins + ":" + (secs < 10 ? "0" : "");
  timestamp += "" + secs;
  return timestamp;
}

// server/src/public/routes/demo-apps/utils.ts
import { v4 as uuid10 } from "uuid";
var import_types47 = __toESM(require_cjs(), 1);

// server/src/entity/page_visitor/PageVisitorMutator.ts
import { Sequelize as Sequelize15 } from "sequelize";
var PageVisitorMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  /**
   * Make the logged in user a visitor of the given page and/or set
   * lastPresentTimestamp to now
   *
   *
   * pageContextHash must refer to an existing page in the current org.
   */
  async markPresentInPage(pageContextHash, transaction) {
    const { userID, orgID } = assertViewerHasIdentity(this.viewer);
    await PageVisitorEntity.upsert(
      {
        userID,
        orgID,
        pageContextHash,
        lastPresentTimestamp: Sequelize15.fn("NOW")
      },
      { transaction }
    );
  }
};

// server/src/public/routes/demo-apps/utils.ts
function getReplyContent(messageAnnotationType) {
  switch (messageAnnotationType) {
    case "dashboard":
      return `Some ideas: reply to this comment, click on the barchart to add your own comment, or share this link with someone else to collaborate live!`;
    case "videoPlayer":
      return `Some ideas: reply to this comment, click "Comment on a frame" and then on the video to add a comment on a specific point in time, or share this link with someone else to collaborate live!`;
    case "document":
      return "Edit, resolve, and delete messages";
    case "canvas-new":
      return "Did you have any feedback or are you just showing off how good Cord is?";
    default:
      throw new Error("Invalid message annotation type");
  }
}
async function createDemoAppsMessage({
  addReply = false,
  content,
  org,
  anonymousUser,
  sentBy,
  threadTitle,
  URL: URL3,
  cordLocation,
  messageAnnotationType,
  threadExternalId,
  threadMetadata
}) {
  const senderViewer = await createDummyViewer(sentBy, org);
  const senderLoaders = await getNewLoaders(senderViewer);
  const { page } = await createDemoAppsPageContext(senderViewer, cordLocation);
  const thread = await createDemoAppsThread({
    externalID: threadExternalId,
    createdBy: senderViewer,
    title: threadTitle,
    URL: URL3,
    page,
    metadata: threadMetadata,
    appID: org.platformApplicationID
  });
  const threadParticipants = [senderViewer.userID, anonymousUser.id];
  const threadParticipantMutator = new ThreadParticipantMutator(
    senderViewer,
    senderLoaders
  );
  await threadParticipantMutator.subscribeUsersToThread(
    thread.id,
    threadParticipants
  );
  const message = await new MessageMutator(
    senderViewer,
    senderLoaders
  ).createMessage({
    id: uuid10(),
    thread,
    url: URL3,
    content: content ?? [
      {
        type: import_types47.MessageNodeType.PARAGRAPH,
        children: [
          { text: "Welcome, " },
          createMentionNode(anonymousUser.id, anonymousUser.name),
          { text: "!" }
        ]
      },
      createParagraphNode("You can comment and mention on this page.")
    ]
  });
  if (messageAnnotationType === "dashboard") {
    await new NotificationMutator(senderViewer).create({
      recipientID: anonymousUser.id,
      type: "reply",
      messageID: message.id,
      replyActions: ["create-thread", "mention"],
      threadID: message.threadID
    });
  }
  if (addReply) {
    await addReplyToThread({
      replyContent: [
        createParagraphNode(getReplyContent(messageAnnotationType))
      ],
      senderViewer,
      senderLoaders,
      cordLocation,
      thread,
      replyReactions: ["\u{1F44D}\uFE0F", "\u2764\uFE0F"],
      threadParticipantMutator
    });
  }
  return { thread, senderViewer, threadParticipantMutator };
}
async function createDemoAppsPageContext(viewer, cordLocation) {
  const pageContext = {
    providerID: null,
    data: cordLocation
  };
  const pageContextHash = await new PageMutator(viewer).createPageIfNotExists(
    pageContext
  );
  const page = await new PageLoader(viewer).getPageFromContextHash(
    pageContextHash
  );
  await new PageVisitorMutator(viewer).markPresentInPage(pageContextHash);
  return { page, pageContextHash };
}
async function createDemoAppsThread({
  externalID,
  createdBy,
  URL: URL3,
  page,
  title,
  metadata,
  appID
}) {
  return await getSequelize().transaction(
    async (transaction) => await new ThreadMutator(createdBy, null).createThreadOnPage(
      uuid10(),
      URL3,
      page,
      title,
      transaction,
      appID,
      externalID ?? null,
      { ...metadata, autogenerated: true }
    )
  );
}
async function addReplyToThread({
  senderViewer,
  senderLoaders,
  replyReactions,
  replyContent,
  thread,
  threadParticipantMutator,
  cordLocation
}) {
  await createDemoAppsPageContext(senderViewer, cordLocation);
  const reply = await new MessageMutator(
    senderViewer,
    senderLoaders
  ).createMessage({
    id: uuid10(),
    thread,
    url: thread.url,
    content: replyContent,
    metadata: { autogenerated: true }
  });
  for (const reaction of replyReactions) {
    await new MessageReactionMutator(senderViewer, senderLoaders).createOne(
      reply.id,
      reaction
    );
  }
  await threadParticipantMutator.markThreadNewlyActiveForOtherUsers(
    thread.id,
    reply.id
  );
}
function createDummyViewer(user, org) {
  return Viewer.createLoggedInPlatformViewer({
    user,
    org
  });
}
function getDashboardExternalThreadId(chartThreadMetadata, orgExternalID) {
  return `${orgExternalID}_${chartThreadMetadata.chartId}_${chartThreadMetadata.seriesId}_${chartThreadMetadata.x}_${chartThreadMetadata.y}`;
}

// server/src/public/routes/demo-apps/demos.ts
async function populateDocumentDemoWithData({
  org,
  anonymousUser,
  dummyUsers
}) {
  const { thread, threadParticipantMutator } = await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Document Demo",
    sentBy: dummyUsers[0],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/document`,
    cordLocation: { page: "document" },
    messageAnnotationType: "document",
    threadMetadata: {
      startNodeId: "p1",
      startOffset: 57,
      endNodeId: "p1",
      endOffset: 60,
      floatingThreadVisible: true
    },
    content: [createParagraphNode("You can customize every element of the UI")]
  });
  const dummyUserTwoViewer = await createDummyViewer(dummyUsers[1], org);
  const dummyUserTwoLoaders = await getNewLoaders(dummyUserTwoViewer);
  await addReplyToThread({
    thread,
    senderViewer: dummyUserTwoViewer,
    senderLoaders: dummyUserTwoLoaders,
    threadParticipantMutator,
    cordLocation: { page: "document" },
    replyContent: [
      createParagraphNode(
        "While stuff like file attachments, timestamps, and real-time delivery are taken care of out-of-the-box"
      )
    ],
    replyReactions: ["\u2728", "\u{1F3C3}"]
  });
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Document Demo",
    sentBy: dummyUsers[2],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/document`,
    cordLocation: { page: "document" },
    messageAnnotationType: "document",
    threadMetadata: {
      startNodeId: "p2",
      startOffset: 7,
      endNodeId: "p2",
      endOffset: 20,
      floatingThreadVisible: true
    },
    content: [
      createParagraphNode(
        "Reply or react to one of the comments already on the page, or highlight some text and add your own"
      )
    ]
  });
}
async function populateDashboardDemoWithData({
  org,
  anonymousUser,
  dummyUsers
}) {
  const dashboardChartThreadMetadata = {
    type: "chart",
    // matches the id in sample-apps/dashboard/src/components/Dashboard.tsx
    chartId: "some-unique-and-stable-id-of-this-chart",
    // matches the id in sample-apps/dashboard/src/chartData.json
    seriesId: "unique-id-of-this-series-2",
    seriesName: "Notion",
    x: 2014,
    y: 82.07
    // For us to open the thread initially on the client side
  };
  const dashboardChartThreadExternalId = getDashboardExternalThreadId(
    dashboardChartThreadMetadata,
    org.externalID
  );
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Dashboard Demo",
    sentBy: dummyUsers[0],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/dashboard`,
    cordLocation: { page: "dashboard" },
    messageAnnotationType: "dashboard",
    threadExternalId: dashboardChartThreadExternalId,
    threadMetadata: dashboardChartThreadMetadata,
    content: [
      createMessageNode(import_types2.MessageNodeType.PARAGRAPH, {
        children: [
          {
            text: `${dashboardChartThreadMetadata.seriesName}: ${dashboardChartThreadMetadata.x} Market cap`,
            class: `metadata-quote ${dashboardChartThreadMetadata.seriesName.toLowerCase()}`
          }
        ]
      }),
      createParagraphNode(
        "Click any data point to leave a comment on the chart (or just reply to this one)"
      )
    ],
    addReply: false
  });
  const dashboardChartThread2Metadata = {
    type: "chart",
    chartId: "some-unique-and-stable-id-of-this-chart",
    seriesId: "unique-id-of-this-series",
    seriesName: "Figma",
    x: 2020,
    y: 129.99
  };
  const dashboardChartThread2ExternalId = getDashboardExternalThreadId(
    dashboardChartThread2Metadata,
    org.externalID
  );
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Dashboard Demo",
    sentBy: dummyUsers[1],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/dashboard`,
    cordLocation: { page: "dashboard" },
    messageAnnotationType: "dashboard",
    threadExternalId: dashboardChartThread2ExternalId,
    threadMetadata: dashboardChartThread2Metadata,
    content: [
      createMessageNode(import_types2.MessageNodeType.PARAGRAPH, {
        children: [
          {
            text: `${dashboardChartThread2Metadata.seriesName}: ${dashboardChartThread2Metadata.x} Market cap`,
            class: `metadata-quote ${dashboardChartThread2Metadata.seriesName.toLowerCase()}`
          }
        ]
      }),
      createParagraphNode(
        "You can have conversations with your team where it's most important"
      )
    ],
    addReply: false
  });
  const dashboardGridThreadMetadata = {
    type: "grid",
    headerName: "Figma",
    colId: "figma-valuation",
    gridId: "some-unique-and-stable-id-of-this-grid",
    rowId: 2015
  };
  const dashboardGridThreadExternalId = `${org.externalID}_${dashboardGridThreadMetadata.gridId}_${dashboardGridThreadMetadata.rowId}_${dashboardGridThreadMetadata.colId}`;
  const { thread, threadParticipantMutator } = await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Dashboard Demo",
    sentBy: dummyUsers[2],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/dashboard`,
    cordLocation: { page: "dashboard" },
    messageAnnotationType: "dashboard",
    threadExternalId: dashboardGridThreadExternalId,
    threadMetadata: dashboardGridThreadMetadata,
    addReply: false,
    content: [
      createMessageNode(import_types2.MessageNodeType.PARAGRAPH, {
        children: [
          {
            text: `${dashboardGridThreadMetadata.headerName}: ${dashboardGridThreadMetadata.rowId} Revenue`,
            class: `metadata-quote ${dashboardGridThreadMetadata.headerName.toLowerCase()}`
          }
        ]
      }),
      createParagraphNode("You can also leave comments on any of the cells.")
    ]
  });
  const dummyUserTwoViewer = await createDummyViewer(dummyUsers[2], org);
  const dummyUserTwoLoaders = await getNewLoaders(dummyUserTwoViewer);
  await addReplyToThread({
    thread,
    senderViewer: dummyUserTwoViewer,
    senderLoaders: dummyUserTwoLoaders,
    threadParticipantMutator,
    cordLocation: { page: "dashboard-new" },
    replyContent: [createParagraphNode("Give it a try!")],
    replyReactions: []
  });
}
async function populateVideoDemoWithData({
  org,
  anonymousUser,
  dummyUsers
}) {
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Video player Demo",
    sentBy: dummyUsers[0],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/video-player`,
    cordLocation: { page: "video" },
    messageAnnotationType: "videoPlayer",
    threadMetadata: {
      xPercent: 90,
      yPercent: 10,
      timestamp: 0,
      initallyOpen: true
    },
    content: [
      createMessageNode(import_types2.MessageNodeType.PARAGRAPH, {
        children: [
          { text: `${secondsToFormattedTimestamp(0)} `, class: "timestamp" },
          { text: "Drop comments anywhere in the video\u2026 try it!" }
        ]
      })
    ],
    addReply: false
  });
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Video player Demo",
    sentBy: dummyUsers[2],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/video-player`,
    cordLocation: { page: "video" },
    messageAnnotationType: "videoPlayer",
    threadMetadata: {
      xPercent: 85,
      yPercent: 20,
      timestamp: 4,
      durationOnVideo: 6
    },
    content: [
      createMessageNode(import_types2.MessageNodeType.PARAGRAPH, {
        children: [
          { text: `${secondsToFormattedTimestamp(4)} `, class: "timestamp" },
          { text: "You can reply, react, and resolve comments, too" }
        ]
      })
    ]
  });
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Video player Demo",
    sentBy: dummyUsers[1],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/video-player`,
    cordLocation: { page: "video" },
    messageAnnotationType: "videoPlayer",
    threadMetadata: {
      xPercent: 20,
      yPercent: 30,
      timestamp: 21
    },
    content: [
      createMessageNode(import_types2.MessageNodeType.PARAGRAPH, {
        children: [
          { text: `${secondsToFormattedTimestamp(21)} `, class: "timestamp" },
          { text: "Click this comment and see what happens \u{1F440}" }
        ]
      })
    ]
  });
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Video player Demo",
    sentBy: dummyUsers[2],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/video-player`,
    cordLocation: { page: "video" },
    messageAnnotationType: "videoPlayer",
    threadMetadata: {
      xPercent: 80,
      yPercent: 85,
      timestamp: 23,
      durationOnVideo: 2
    },
    content: [
      createMessageNode(import_types2.MessageNodeType.PARAGRAPH, {
        children: [
          { text: `${secondsToFormattedTimestamp(23)} `, class: "timestamp" },
          {
            text: "Way better than giving feedback over Slack and e-mail alongside timestamps, right?"
          }
        ]
      })
    ]
  });
}
async function populateCanvasDemoWithData({
  org,
  anonymousUser,
  dummyUsers
}) {
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Canvas Demo",
    sentBy: dummyUsers[0],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/canvas-new`,
    cordLocation: { page: "canvas-new" },
    messageAnnotationType: "canvas-new",
    threadMetadata: {
      elementName: "square",
      relativeX: 330,
      relativeY: 100
    },
    content: [createParagraphNode("Build comments just like Figma or Miro!")]
  });
  await createDemoAppsMessage({
    org,
    anonymousUser,
    threadTitle: "Canvas Demo",
    sentBy: dummyUsers[1],
    URL: `${DOCS_ORIGIN}/get-started/demo-apps/canvas-new`,
    cordLocation: { page: "canvas-new" },
    messageAnnotationType: "canvas-new",
    threadMetadata: {
      elementName: "circle",
      relativeX: -45,
      relativeY: 15
    },
    content: [
      createParagraphNode(
        "Hey you found me! Why not try clicking and dragging the shapes about?"
      )
    ]
  });
}

// server/src/public/routes/demo-apps/GetDemoAppsSignedTokenHandler.ts
var ANONYMOUS_ORG_NAME = "Cord Demo Apps Group";
var NUM_OF_CORD_AVATARS = TEAM_PROFILES.length;
var DUMMY_USERS = TEAM_PROFILES.slice(-3);
var DUMMY_USERS_NAMES = DUMMY_USERS.map((dummyUser) => dummyUser.firstName);
async function getDemoAppsTokenHandler(req, res) {
  if (req.body.app_id !== void 0 && typeof req.body.app_id !== "string" || req.body.token !== void 0 && typeof req.body.token !== "string") {
    throw new ApiCallerError("invalid_field");
  }
  const app_id = req.body.app_id;
  const user_id = maybeGetUserId(req.body.token);
  let tokenUser = user_id && app_id ? await UserEntity.findOne({
    where: {
      externalID: user_id,
      platformApplicationID: app_id
    }
  }) : void 0;
  let tokenApp = app_id ? await ApplicationEntity.findOne({
    where: {
      id: app_id
    }
  }) : void 0;
  if (tokenApp && tokenApp.environment !== "demo") {
    anonymousLogger().warn("Request for non-demo demo token app", {
      ...req.body
    });
    res.status(401).send("Invalid app_id");
    return;
  }
  if (!tokenUser || !tokenApp) {
    const {
      newUser,
      org: newOrg,
      app: newApp,
      isFirstUserOfOrg
    } = await createDemoAppsUser(app_id);
    if (isFirstUserOfOrg) {
      await populateDemoAppGroup(newOrg, newUser);
    }
    tokenUser = newUser;
    tokenApp = newApp;
  }
  const session_token = jwt3.sign(
    {
      user_id: tokenUser.externalID,
      app_id: tokenApp.id
    },
    tokenApp.sharedSecret,
    {
      algorithm: "HS512",
      expiresIn: "24 h"
    }
  );
  res.send({
    session_token,
    client_auth_token: session_token,
    app_id: tokenApp.id
  });
}
async function createDemoAppsUser(appID) {
  const sharedSecret = process.env.DEMO_APPS_SHARED_SECRET;
  if (!sharedSecret) {
    throw new Error("shared secret env variable should be defined");
  }
  const [app] = await findOrCreatePlatformApplication(
    appID ?? uuid11(),
    "Cord Demo Apps",
    "demo",
    CORD_DEMO_APPS_TOKEN_CUSTOMER_ID,
    DEMO_APPS_WEBHOOK_URL,
    ["thread-message-added"],
    sharedSecret
  );
  const [org] = await findOrCreatePlatformOrganization(
    app.id,
    DEMO_APPS_APP_GROUP_ID,
    // Must be stable group id for component prop groupIds to work
    ANONYMOUS_ORG_NAME,
    "active"
  );
  const { orgMembersCount, isFirstUserOfOrg } = await getSequelize().transaction(async (transaction) => {
    const [[{ count: orgMembersCount2 }]] = await getSequelize().query(
      `SELECT count(*) FROM org_members, users
            WHERE org_members."orgID" = $orgID
            AND org_members."userID" = users.id
            AND users."userType" = 'person'
            AND NOT(users."name" = ANY($name))
            AND NOT(users."name" = ANY($salesname));
            `,
      {
        bind: {
          orgID: org.id,
          name: DUMMY_USERS_NAMES,
          salesname: [...SALES_TEAM_USERS, ...BOT_USERS].map(
            (dummyUser) => dummyUser.firstName
          )
        },
        transaction
      }
    );
    const [[{ count: dummyUserCount }]] = await getSequelize().query(
      `SELECT count(*) FROM org_members, users
            WHERE org_members."orgID" = $orgID
            AND org_members."userID" = users.id
            AND users."userType" = 'person'
            AND users."name" = ANY($name);
           `,
      {
        bind: {
          orgID: org.id,
          name: DUMMY_USERS_NAMES
        },
        transaction
      }
    );
    return {
      orgMembersCount: parseInt(orgMembersCount2, 10),
      isFirstUserOfOrg: parseInt(dummyUserCount, 10) === 0
    };
  });
  const index = orgMembersCount % NUM_OF_CORD_AVATARS;
  const newUser = await createDummyPlatformUser({
    applicationID: app.id,
    firstName: TEAM_PROFILES[index].firstName,
    orgID: org.id,
    profilePicture: TEAM_PROFILES[index].profilePictureURL,
    dummy: false
  });
  return {
    newUser,
    app,
    org,
    isFirstUserOfOrg
  };
}
async function populateDemoAppGroup(org, anonymousUser) {
  const dummyUsers = await Promise.all(
    [...DUMMY_USERS, ...BOT_USERS].map(
      (dummyUser) => createDummyPlatformUser({
        applicationID: org.platformApplicationID,
        orgID: org.id,
        firstName: dummyUser.firstName,
        profilePicture: dummyUser.profilePictureURL
      })
    )
  );
  await Promise.all(
    SALES_TEAM_USERS.map(
      (user) => createDummyPlatformUser({
        applicationID: org.platformApplicationID,
        orgID: org.id,
        firstName: user.firstName,
        profilePicture: user.profilePictureURL,
        email: user.email
      })
    )
  );
  await Promise.all([
    populateDocumentDemoWithData({
      org,
      anonymousUser,
      dummyUsers
    }),
    populateDashboardDemoWithData({
      org,
      anonymousUser,
      dummyUsers
    }),
    populateVideoDemoWithData({
      org,
      anonymousUser,
      dummyUsers
    }),
    populateCanvasDemoWithData({
      org,
      anonymousUser,
      dummyUsers
    })
  ]);
}
var GetDemoAppsSignedTokenHandler_default = forwardHandlerExceptionsToNext(getDemoAppsTokenHandler);
function maybeGetUserId(token) {
  if (!token) {
    return null;
  }
  const decodedToken = jwt3.decode(token);
  if (!(decodedToken instanceof Object) || !decodedToken.user_id) {
    return null;
  }
  return decodedToken.user_id;
}

// server/src/public/routes/handlers/SlackLinkingConfirmationHandler.ts
import * as cookie4 from "cookie";
import { nanoid as nanoid2 } from "nanoid";

// server/src/auth/encodeSlackLinkingToken.ts
async function encodeSlackLinkingToken(context, nonce, type) {
  let encodedSlackLinkingToken;
  if (type === "link_org") {
    const { userID, orgID: orgID2, platformApplicationID } = assertViewerHasPlatformIdentity(context.session.viewer);
    const state = {
      nonce,
      type,
      data: { userID, orgID: orgID2, platformApplicationID }
    };
    encodedSlackLinkingToken = encodeSlackOAuthState(state);
  }
  if (!encodedSlackLinkingToken) {
    throw new Error(`Encoded slack token missing: ${{ type, nonce }}`);
  }
  const orgID = assertViewerHasOrg(context.session.viewer);
  const org = await context.loaders.orgLoader.loadOrg(orgID);
  const linkedOrg = await org?.loadLinkedSlackOrg();
  return { token: encodedSlackLinkingToken, slackTeam: linkedOrg?.externalID };
}

// server/src/public/routes/handlers/SlackLinkingConfirmationHandler.ts
async function SlackLinkingConfirmationHandler(req, res, _next) {
  const nonce = cookie4.parse(req.headers.cookie || "")["nonce"] || nanoid2();
  const { authToken } = req.query;
  if (typeof authToken !== "string" || !authToken) {
    res.status(400).send("Bad request: Missing authToken parameter").end();
    return;
  }
  let session;
  try {
    session = await getSessionFromAuthHeader(`Bearer ${authToken}`, null);
  } catch (e) {
    res.status(400).send("Bad request: Invalid authToken").end();
    return;
  }
  const context = await contextWithSession(session, getSequelize(), null, null);
  const referer = req.headers.referer;
  if (!referer) {
    context.logger.error("missing referer in SlackLinkingConfirmationHandler");
    res.status(400).send("Bad request: Missing referer header").end();
    return;
  }
  const { token: state, slackTeam } = await encodeSlackLinkingToken(
    context,
    nonce,
    "link_org"
  );
  const team = session.viewer.platformApplicationID === CORD_SDK_TEST_APPLICATION_ID ? CORD_TEST_SLACK_TEAM_ID : slackTeam;
  const application = await ApplicationEntity.findByPk(
    session.viewer.platformApplicationID
  );
  if (!application) {
    throw new Error("Linking error - unable to find platform app");
  }
  const customAppDetails = application.getCustomSlackAppDetails();
  const slackUrl = slackLoginURL(state, team, customAppDetails?.clientID);
  res.cookie("nonce", nonce, {
    secure: true,
    maxAge: 1e3 * 60 * 60 * 24,
    // expire after a day
    // This linking flow (for SDK) could set "httpOnly: true" and "domain:
    // API_SERVER_HOST". However the Slack linking flow in embed uses the
    // "nonce" cookie too and that flow assumes that the cookie is not httpOnly
    // and is set on TOP_SERVER_HOST (cord.com). If a user goes through the
    // flow in embed and the same day in sdk, then they would end up with the
    // nonce cookie set on different domains and with different httpOnly
    // setting which might break the second flow.
    httpOnly: false,
    domain: TOP_SERVER_HOST
  });
  res.send(
    html({
      referer,
      slackUrl
    })
  );
  res.end();
}
var html = handlebars_default.compile(`
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <style>
      .container {
        text-align: center;
        padding: 100px 10px;
        max-width: 600px;
        margin: auto;
        font-family: apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji',
          'Segoe UI Symbol';
      }
      a {
        text-decoration: none;
        display: block;
        padding: 8px;
        background-color: black;
        color: white;
        text-align: center;
        max-width: 50%;
        margin: auto;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <p><b>{{referer}}</b> wants to connect with Slack.</p>
      <a href="{{slackUrl}}">Continue</a>
    </div>
  </body>
</html>
`);

// server/src/public/routes/handlers/TestbedTokensHandler.ts
import * as jwt4 from "jsonwebtoken";
function getClientAuthToken(app_id, app_secret, payload, expiresIn = "1 min") {
  return jwt4.sign({ ...payload, app_id }, app_secret, {
    algorithm: "HS512",
    expiresIn
  });
}
var APP_ID = "b6501bf5-46f7-4db7-9996-c42dd9f758b0";
var APP_SECRET = "cordrulez";
var USER_DETAILS = {
  andrei: {
    email: Env_default.TESTBED_USERS_EMAIL ?? "notification-spam+andrei@cord.com",
    profile_picture_url: "https://ca.slack-edge.com/T012Y0TBQLW-U0134UJMCG3-da029c9556f6-512",
    name: "Andrei"
  },
  flooey: {
    email: Env_default.TESTBED_USERS_EMAIL ?? "notification-spam+flooey@cord.com",
    profile_picture_url: "https://ca.slack-edge.com/T012Y0TBQLW-U02D2DNCS3H-71dafa543b5d-512",
    name: "Flooey"
  },
  nimrod: {
    email: Env_default.TESTBED_USERS_EMAIL ?? "notification-spam+np@cord.com",
    profile_picture_url: "https://avatars.slack-edge.com/2020-05-06/1107128068275_13105bc2580f354aa611_original.png",
    name: "Nimrod Priell, the CEO"
  }
};
var ORG_DETAILS = {
  cord: {
    name: "Cord"
  },
  secondorg: {
    name: "Test Org 2"
  },
  thirdorg: {
    name: "Test Org 3"
  }
};
function clientAuthBody(user, org) {
  return {
    user_id: user,
    organization_id: org,
    user_details: USER_DETAILS[user],
    ...org && { organization_details: ORG_DETAILS[org] }
  };
}
function TestbedTokensHandler(_req, res) {
  const tokens = {
    andrei: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("andrei", "cord")
    ),
    flooey: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("flooey", "cord")
    ),
    nimrod: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("nimrod", "cord")
    ),
    andrei_in_second_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("andrei", "secondorg")
    ),
    flooey_in_second_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("flooey", "secondorg")
    ),
    nimrod_in_second_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("nimrod", "secondorg")
    ),
    andrei_in_third_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("andrei", "thirdorg")
    ),
    flooey_in_third_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("flooey", "thirdorg")
    ),
    invalid_user_details: getClientAuthToken(APP_ID, APP_SECRET, {
      user_id: "invalid_user_details",
      organization_id: "cord",
      user_details: {
        name: "invalid_user_details"
        // don't include email on purpose
      }
    }),
    andrei2: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("andrei", "cord"),
      // expires in 2 min; this is to make it different from the andrei token
      "2 min"
    ),
    andrei_without_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("andrei")
    ),
    flooey_without_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("flooey")
    ),
    nimrod_without_org: getClientAuthToken(
      APP_ID,
      APP_SECRET,
      clientAuthBody("nimrod")
    ),
    missing_user: getClientAuthToken(APP_ID, APP_SECRET, {
      user_id: "nobody-that-exists"
    })
  };
  res.setHeader(
    "Access-Control-Allow-Origin",
    `https://${Env_default.APP_SERVER_HOST}`
  );
  res.setHeader("Access-Control-Allow-Credentials", "true");
  return res.status(200).json(tokens);
}

// server/src/public/routes/sample-token/GetSampleSignedTokenHandler.ts
import * as jwt5 from "jsonwebtoken";
import { v4 as uuid12 } from "uuid";
async function getSampleSignedTokenHandler({ headers }, res) {
  anonymousLogger().debug("Provisioned sample token", { headers });
  const appID = uuid12();
  const session_token = jwt5.sign(
    {
      app_id: appID,
      user_id: uuid12()
    },
    sampleTokenAppSecret(appID),
    {
      algorithm: "HS512",
      expiresIn: SAMPLE_TOKEN_EXPIRY_SECONDS
    }
  );
  res.json({ session_token, client_auth_token: session_token });
}
var GetSampleSignedTokenHandler_default = forwardHandlerExceptionsToNext(getSampleSignedTokenHandler);

// server/src/public/routes/handlers/MondayAuthRedirectHandler.ts
async function MondayAuthRedirectHandler(req, res) {
  let logger = anonymousLogger();
  if (req.query["error"] === "access_denied") {
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=monday&message=cancelled`
    );
  }
  try {
    const codeAndState = getOAuthCodeAndState(req);
    const [code, { userID, orgID, type }] = codeAndState;
    logger = new Logger(Viewer.createLoggedInViewer(userID, orgID));
    if (type !== "monday") {
      throw new Error(`incorrect redirect type, received ${type}`);
    }
    const [accessToken, userInfo2] = await completeOAuthFlow5(code);
    if (userInfo2.me.id >= Number.MAX_SAFE_INTEGER) {
      logger.error(
        `Monday API returned ID of ${userInfo2.me.id}, which may have been truncated`
      );
    }
    const preferences = {
      boardID: removeSubitemBoards(userInfo2.boards)[0].id
    };
    await Promise.all([
      UserPreferenceEntity.upsert({
        userID,
        key: MONDAY_CONNECTION_PREFERENCES,
        value: preferences
      }),
      ThirdPartyConnectionEntity.upsert({
        userID,
        orgID,
        type,
        // Use BigInt to prevent switching to exponential notation for large numbers
        externalID: BigInt(userInfo2.me.id).toString(),
        externalEmail: userInfo2.me.email,
        externalAuthData: {
          accessToken
        }
      })
    ]);
  } catch (e) {
    logger.logException(`MondayAuthRedirectHandler`, e);
    return res.redirect(
      `${APP_ORIGIN}/auth-error.html#service=monday&message=error`
    );
  }
  return res.redirect(`${APP_ORIGIN}/auth-complete.html#service=monday`);
}

// server/src/public/routes/handlers/MondayEventApiHandler.ts
async function MondayEventApiHandler(req, res) {
  const payload = req.body;
  anonymousLogger().debug("MondayEventApiHandler", { mondayEvent: payload });
  if (payload.challenge) {
    res.status(200).json({
      challenge: payload.challenge
    });
    return;
  }
  const subscription = await TaskThirdPartySubscriptionEntity.findByPk(
    req.params.subscriptionId
  );
  if (!subscription) {
    res.sendStatus(404);
    return;
  }
  res.sendStatus(200);
  await handleMondayEvent(payload.event);
}
async function handleMondayEvent(event) {
  const { pulseId: itemID, type, columnType } = event;
  if (type !== "update_column_value") {
    return;
  }
  if (columnType === "multiple-person") {
    await webhookUpdateAssignee(itemID.toString(), event);
  } else if (columnType === "color") {
    await webhookUpdateStatus(itemID.toString(), event);
  }
}

// server/src/public/routes/docs-sample-token/GetDocsSampleSignedTokenHandler.ts
import * as jwt6 from "jsonwebtoken";
import { v4 as uuid14 } from "uuid";

// server/src/public/routes/docs-sample-token/utils.ts
async function extractDocTokenFromReqBody(reqBody) {
  try {
    if (!(DOCS_TOKEN_KEY in reqBody)) {
      throw "docs token does not exist";
    }
    const previousToken = reqBody[DOCS_TOKEN_KEY];
    if (typeof previousToken !== "string") {
      throw "docs token not a string";
    }
    const session = await decodeSessionFromJWT(previousToken);
    const { platformApplicationID } = assertViewerHasPlatformIdentity(
      session.viewer
    );
    if (platformApplicationID !== CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID) {
      return null;
    }
    return previousToken;
  } catch {
    return null;
  }
}

// server/src/public/routes/docs-sample-token/populateLiveComponents.ts
import * as path from "path";
import * as url3 from "url";
import fs from "fs";
import { v4 as uuid13 } from "uuid";
async function addMessage({
  thread,
  viewer,
  transaction,
  message = "Hello!",
  timestamp
}) {
  const messageID = uuid13();
  assertViewerIsFromCordDocsApplication(viewer);
  const loaders = await getNewLoaders(viewer);
  const messageEntity = await new MessageMutator(viewer, loaders).createMessage(
    {
      id: messageID,
      thread,
      content: [
        {
          type: import_types2.MessageNodeType.PARAGRAPH,
          children: [
            {
              text: message
            }
          ]
        }
      ],
      url: null,
      timestamp
    },
    transaction
  );
  const threadParticipantMutator = new ThreadParticipantMutator(
    viewer,
    loaders
  );
  await threadParticipantMutator.markThreadSeen({
    threadID: thread.id,
    setSubscribed: true,
    transaction
  });
  return messageEntity;
}
async function addMessageWithMention({
  thread,
  viewer,
  transaction,
  messageBeforeMention = "Hello",
  mentionUserID,
  mentionName,
  messageAfterMention = ""
}) {
  const messageID = uuid13();
  assertViewerIsFromCordDocsApplication(viewer);
  const messageContent = [
    {
      type: import_types2.MessageNodeType.PARAGRAPH,
      children: [
        {
          text: messageBeforeMention + " "
        },
        {
          type: import_types2.MessageNodeType.MENTION,
          user: {
            id: mentionUserID
          },
          children: [
            {
              text: "@" + mentionName
            }
          ]
        },
        {
          text: " " + messageAfterMention
        }
      ]
    }
  ];
  const loaders = await getNewLoaders(viewer);
  await new MessageMutator(viewer, loaders).createMessage(
    {
      id: messageID,
      thread,
      content: messageContent,
      url: null
    },
    transaction
  );
  const threadParticipantMutator = new ThreadParticipantMutator(
    viewer,
    loaders
  );
  await MessageMentionEntity.create(
    {
      userID: mentionUserID,
      messageID
    },
    { transaction }
  );
  await Promise.all([
    threadParticipantMutator.markThreadSeen({
      threadID: thread.id,
      setSubscribed: true,
      transaction
    }),
    threadParticipantMutator.subscribeUsersToThread(
      thread.id,
      [mentionUserID],
      void 0,
      transaction
    )
  ]);
  await threadParticipantMutator.markThreadNewlyActiveForOtherUsers(
    thread.id,
    messageID,
    transaction
  );
}
async function createDummyUserAndViewerIfNotExist({
  platformApplicationID,
  org,
  firstName,
  context,
  profilePictureURL,
  userExternalID
}) {
  try {
    return await getSequelize().transaction(async (transaction) => {
      let dummyUser;
      dummyUser = await UserEntity.findOne({
        where: {
          platformApplicationID,
          externalID: userExternalID
        },
        transaction
      });
      if (!dummyUser) {
        dummyUser = await createDummyPlatformUser({
          applicationID: platformApplicationID,
          orgID: org.id,
          firstName,
          externalID: userExternalID,
          transaction,
          profilePicture: profilePictureURL
        });
      }
      const dummyViewer = await Viewer.createLoggedInPlatformViewer({
        user: dummyUser,
        org
      });
      return { viewer: dummyViewer, user: dummyUser };
    });
  } catch (error) {
    context.logger.logException(
      "Could not create or retrieve dummy users data on docs",
      error,
      { orgID: org.id, platformApplicationID }
    );
    throw error;
  }
}
async function createEmptyThreadIfNotExist({
  pageMutator,
  threadMutator,
  threadLoader,
  context,
  location,
  threadURL,
  threadExternalID,
  threadName
}) {
  try {
    assertViewerIsFromCordDocsApplication(context.session.viewer);
    await getSequelize().transaction(async (transaction) => {
      const pageContext = {
        providerID: null,
        data: { page: location }
      };
      const { page } = await pageMutator.getPageCreateIfNotExists(
        pageContext,
        transaction
      );
      let threadEntity;
      threadEntity = await threadLoader.loadByExternalIDStrictOrgCheck(
        threadExternalID,
        transaction
      );
      if (!threadEntity) {
        threadEntity = await threadMutator.createThreadOnPage(
          uuid13(),
          threadURL,
          page,
          threadName,
          transaction,
          CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID,
          threadExternalID
        );
      }
    });
  } catch (error) {
    context.logger.logException(
      "Could not create empty thread on docs",
      error,
      { location, threadURL }
    );
    throw error;
  }
}
async function createThreadWithMessageIfNotExist({
  pageMutator,
  threadMutator,
  threadLoader,
  context,
  dummyViewer,
  location,
  threadURL,
  threadExternalID,
  threadName,
  message,
  extraMessages = [],
  reactions,
  includeDummyAttachment = false
}) {
  try {
    assertViewerIsFromCordDocsApplication(context.session.viewer);
    await getSequelize().transaction(async (transaction) => {
      const pageContext = {
        providerID: null,
        data: { page: location }
      };
      const { page } = await pageMutator.getPageCreateIfNotExists(
        pageContext,
        transaction
      );
      let threadEntity;
      threadEntity = await threadLoader.loadByExternalIDStrictOrgCheck(
        threadExternalID,
        transaction
      );
      if (!threadEntity) {
        threadEntity = await threadMutator.createThreadOnPage(
          uuid13(),
          threadURL,
          page,
          threadName,
          transaction,
          CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID,
          threadExternalID
        );
        const messageEntity = await addMessage({
          thread: threadEntity,
          viewer: dummyViewer,
          transaction,
          message
        });
        let lastMessage = messageEntity;
        for (const [viewer, additionalMessage] of extraMessages) {
          lastMessage = await addMessage({
            thread: threadEntity,
            viewer,
            transaction,
            message: additionalMessage,
            timestamp: new Date(lastMessage.timestamp.getTime() + 1e3)
          });
        }
        if (reactions) {
          await Promise.all(
            reactions.map(async (reaction) => {
              await new MessageReactionMutator(dummyViewer, null).createOne(
                messageEntity.id,
                reaction,
                void 0,
                transaction
              );
            })
          );
        }
        if (includeDummyAttachment) {
          const fileID = uuid13();
          await uploadDummyAttachment(context, fileID);
          await MessageAttachmentEntity.create(
            {
              messageID: messageEntity.id,
              type: "file" /* FILE */,
              data: { fileID }
            },
            { transaction }
          );
        }
        return;
      }
      const messagesCount = await MessageEntity.count({
        where: {
          threadID: threadEntity.id
        }
      });
      if (messagesCount < 1) {
        let lastMessage = await addMessage({
          thread: threadEntity,
          viewer: dummyViewer,
          transaction,
          message
        });
        for (const [viewer, additionalMessage] of extraMessages) {
          lastMessage = await addMessage({
            thread: threadEntity,
            viewer,
            transaction,
            message: additionalMessage,
            timestamp: new Date(lastMessage.timestamp.getTime() + 1e3)
          });
        }
      }
    });
  } catch (error) {
    context.logger.logException(
      "Could not create thread and dummy data on docs",
      error,
      { location, threadURL }
    );
    throw error;
  }
}
async function uploadDummyAttachment(context, fileID) {
  const FILE_NAME = "dummy_file.txt";
  const MIME_TYPE = "text/plain";
  const mutator = new FileMutator(context.session.viewer, context.loaders);
  const buffer = fs.readFileSync(
    path.resolve(path.dirname(url3.fileURLToPath(import.meta.url)), FILE_NAME)
  );
  const file = await mutator.createFileForUpload(
    fileID,
    FILE_NAME,
    MIME_TYPE,
    buffer.length,
    "uploaded"
  );
  try {
    await fetch(await file.getSignedUploadURL(context.loaders.s3BucketLoader), {
      method: "PUT",
      body: buffer,
      headers: {
        "Content-Type": MIME_TYPE
      }
    });
  } catch (error) {
    context.logger.logException(
      "Could not upload docs dummy file in S3",
      error
    );
  }
}
function assertViewerIsFromCordDocsApplication(viewer) {
  const platformViewer = assertViewerHasPlatformIdentity(viewer);
  if (platformViewer.platformApplicationID !== CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID) {
    throw new Error("Viewer not part of the Cord Docs application");
  }
  return platformViewer;
}
async function addThreadToPageWithDummyDataIfNotExist({
  page,
  viewer,
  transaction,
  threadURL,
  threadName,
  otherViewer,
  messages
}) {
  const { platformApplicationID, userID } = assertViewerIsFromCordDocsApplication(viewer);
  const loaders = await getNewLoaders(viewer);
  const threadMutator = new ThreadMutator(viewer, loaders);
  const threadExternalID = `${threadURL}-${userID}`;
  let threadEntity;
  threadEntity = await loaders.threadLoader.loadByExternalIDStrictOrgCheck(
    threadExternalID,
    transaction
  );
  if (!threadEntity) {
    threadEntity = await threadMutator.createThreadOnPage(
      uuid13(),
      threadURL,
      page,
      threadName,
      transaction,
      platformApplicationID,
      threadExternalID
    );
    const firstMessage = await addMessage({
      thread: threadEntity,
      viewer,
      transaction,
      message: messages?.[0]
    });
    await addMessage({
      thread: threadEntity,
      viewer: otherViewer,
      transaction,
      message: messages?.[1] ?? "Hey there!",
      timestamp: new Date(firstMessage.timestamp.getTime() + 1e3)
    });
    return;
  }
  const messagesCount = await MessageEntity.count({
    where: {
      threadID: threadEntity.id
    }
  });
  if (messagesCount < 1) {
    const firstMessage = await addMessage({
      thread: threadEntity,
      viewer,
      transaction
    });
    await addMessage({
      thread: threadEntity,
      viewer: otherViewer,
      transaction,
      message: "Hey there!",
      timestamp: new Date(firstMessage.timestamp.getTime() + 1e3)
    });
  }
}
async function createAndPopulateThreadsIfNotExist({
  pageMutator,
  context,
  viewer,
  location,
  dummyViewers,
  threadURL,
  threadName,
  threadMessages
}) {
  try {
    await getSequelize().transaction(async (transaction) => {
      const pageContext = {
        providerID: null,
        data: { page: location }
      };
      const { page } = await pageMutator.getPageCreateIfNotExists(
        pageContext,
        transaction
      );
      const viewers = [viewer, ...dummyViewers];
      await Promise.all(
        // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
        viewers.map(
          (viewer2, index) => addThreadToPageWithDummyDataIfNotExist({
            page,
            viewer: viewer2,
            transaction,
            threadURL,
            threadName,
            otherViewer: index === viewers.length - 1 ? viewers[0] : viewers[index + 1],
            // using the other viewers in each thread
            messages: threadMessages?.[index]
          })
        )
      );
    });
  } catch (error) {
    context.logger.logException(
      "Could not create live thread list and dummy data on docs",
      error
    );
    throw error;
  }
}
async function createThreadWithMentionIfNotExist({
  pageMutator,
  threadMutator,
  threadLoader,
  context,
  location,
  threadName,
  threadURL,
  viewer,
  mentionedViewer,
  threadExternalID,
  messageBeforeMention,
  messageAfterMention
}) {
  try {
    const { orgID, userID: mentionedUserID } = assertViewerIsFromCordDocsApplication(mentionedViewer);
    await getSequelize().transaction(async (transaction) => {
      const pageContext = {
        providerID: null,
        data: { page: location }
      };
      const { page } = await pageMutator.getPageCreateIfNotExists(
        pageContext,
        transaction
      );
      let threadEntity;
      threadEntity = await threadLoader.loadByExternalIDStrictOrgCheck(
        threadExternalID,
        transaction
      );
      if (!threadEntity) {
        threadEntity = await threadMutator.createThreadOnPage(
          uuid13(),
          threadURL,
          page,
          threadName,
          transaction,
          CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID,
          threadExternalID
        );
      }
      const mentionedUser = await context.loaders.userLoader.loadUserInOrg(
        mentionedUserID,
        orgID
      );
      if (!mentionedUser) {
        throw new Error("Mentioned user not found");
      }
      const messagesCount = await MessageEntity.count({
        where: {
          threadID: threadEntity.id
        }
      });
      if (messagesCount < 1) {
        await addMessageWithMention({
          thread: threadEntity,
          viewer,
          transaction,
          mentionUserID: mentionedUserID,
          mentionName: userDisplayName(mentionedUser),
          messageBeforeMention,
          messageAfterMention
        });
      }
    });
  } catch (error) {
    context.logger.logException(
      "Could not create thread with viewer mention on docs",
      error,
      { threadURL }
    );
    throw error;
  }
}
async function viewerToVisitPageIfNotExist({
  pageMutator,
  viewer,
  context,
  location
}) {
  try {
    assertViewerIsFromCordDocsApplication(viewer);
    await getSequelize().transaction(async (transaction) => {
      const pageContext = {
        providerID: null,
        data: { page: location }
      };
      const { pageContextHash } = await pageMutator.getPageCreateIfNotExists(
        pageContext,
        transaction
      );
      await markPageVisitedByViewerIfNotExist({
        viewer,
        pageContextHash,
        transaction
      });
    });
  } catch (error) {
    context.logger.logException(
      "Could not create data for viewer to visit page on docs",
      error,
      { viewer: { ...viewer }, location }
    );
    throw error;
  }
}
async function markPageVisitedByViewerIfNotExist({
  viewer,
  pageContextHash,
  transaction
}) {
  const { orgID, userID } = assertViewerIsFromCordDocsApplication(viewer);
  const pageVisitor = await PageVisitorEntity.findOne({
    where: {
      userID,
      orgID,
      pageContextHash
    }
  });
  if (pageVisitor) {
    return;
  }
  const pageVisitorMutator = new PageVisitorMutator(viewer);
  await pageVisitorMutator.markPresentInPage(pageContextHash, transaction);
}
async function addExternalNotificationIfNotExist({
  pageMutator,
  threadMutator,
  threadLoader,
  context,
  recipient,
  sender
}) {
  const {
    platformApplicationID,
    userID: recipientID,
    externalUserID: recipientExternalID
  } = assertViewerIsFromCordDocsApplication(recipient);
  const { userID: senderID } = assertViewerIsFromCordDocsApplication(sender);
  const threadExternalID = `notification-example-thread-${senderID}`;
  await createThreadWithMessageIfNotExist({
    pageMutator,
    threadMutator,
    threadLoader,
    context,
    dummyViewer: sender,
    location: DOCS_LIVE_PAGE_LOCATIONS.liveNotificationList,
    threadURL: DOCS_URLS.tutorials.integrationGuide,
    threadExternalID,
    threadName: "Integration guide",
    message: "I love Cord's integration guide!"
  });
  await Promise.all([
    getSequelize().transaction(async (transaction) => {
      const notif = await NotificationEntity.findOne({
        where: {
          recipientID,
          senderID,
          type: "external"
        },
        transaction
      });
      if (notif) {
        return;
      }
      await new NotificationMutator(
        Viewer.createAnonymousViewer()
      ).createExternal(
        {
          recipientID,
          senderID,
          platformApplicationID,
          externalTemplate: "{{actor}} sent an example notification via the REST API",
          externalURL: `https://${DOCS_SERVER_HOST}/rest-apis/notifications`,
          externalID: `${LIVE_COMPONENT_ON_DOCS_EXTERNAL_NOTIFICATION_PREFIX}${recipientExternalID}`,
          extraClassnames: "external-notification"
        },
        transaction
      );
    }),
    getSequelize().transaction(async (transaction) => {
      const notif = await NotificationEntity.findOne({
        where: {
          recipientID,
          senderID,
          type: "reply"
        },
        transaction
      });
      if (notif) {
        return;
      }
      const thread = await ThreadEntity.findOne({
        where: { externalID: threadExternalID },
        transaction
      });
      if (!thread) {
        throw new Error("Just created thread for notif use, where is it");
      }
      const message = await MessageEntity.findOne({
        where: { threadID: thread.id },
        transaction
      });
      if (!message) {
        throw new Error("Just creatd message for notif user, where is it");
      }
      await new NotificationMutator(sender).create({
        recipientID,
        type: "reply",
        messageID: message.id,
        replyActions: ["create-thread"],
        threadID: message.threadID
      });
    })
  ]);
}
async function createDummyDataForDocsIfNotExist({
  sessionToken
}) {
  const session = await decodeSessionFromJWT(sessionToken);
  const { platformApplicationID, externalOrgID, orgID } = assertViewerIsFromCordDocsApplication(session.viewer);
  const [context, org] = await Promise.all([
    contextWithSession(session, getSequelize(), null, null),
    OrgEntity.findByPk(orgID)
  ]);
  if (!org) {
    throw new Error("org for docs user should exist by now");
  }
  const viewer = session.viewer;
  const threadMutator = new ThreadMutator(viewer, context.loaders);
  const threadLoader = context.loaders.threadLoader;
  const pageMutator = new PageMutator(viewer);
  const dummyUserNames = TEAM_PROFILES.slice(0, 2);
  const [{ viewer: dummyViewerOne }, { viewer: dummyViewerTwo }] = await Promise.all(
    dummyUserNames.map(
      ({ firstName, profilePictureURL }, index) => createDummyUserAndViewerIfNotExist({
        platformApplicationID,
        org,
        firstName,
        context,
        profilePictureURL,
        userExternalID: `${externalOrgID}:${index}`
      })
    )
  );
  await Promise.all([
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveCss,
      threadURL: DOCS_URLS.tutorials.getProductionReady.addYourBranding,
      threadExternalID: `${LIVE_CSS_ON_DOCS_THREAD_ID_PREFIX}${externalOrgID}`,
      threadName: "Thread on live css page",
      message: "Add your style \u{1F3A8} to this interactive thread component that only you can see. You can reply to this message - give it a try! "
    }),
    createEmptyThreadIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveThread,
      threadURL: DOCS_URLS.components.thread,
      threadExternalID: `${LIVE_COMPONENT_ON_DOCS_THREAD_ID_PREFIX}${externalOrgID}`,
      threadName: "Thread on thread component page"
    }),
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.cssCustomization,
      threadURL: DOCS_URLS.howTo.cssCustomization,
      threadExternalID: `${CSS_CUSTOMIZATION_ON_DOCS_PREFIX}${externalOrgID}`,
      threadName: "InterCord Thread",
      message: `This is a completely customised Cord Thread, to look like a messaging app!`,
      extraMessages: [
        [
          dummyViewerOne,
          "Feel free to play around with the code and this thread \u{1F601}"
        ]
      ]
    }),
    viewerToVisitPageIfNotExist({
      pageMutator,
      viewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.cssCustomization,
      context
    }),
    createAndPopulateThreadsIfNotExist({
      pageMutator,
      context,
      viewer,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveThreadList,
      dummyViewers: [dummyViewerOne, dummyViewerTwo],
      threadURL: DOCS_URLS.components.threadList,
      threadName: "Thread created on thread list component page",
      threadMessages: [
        ["Be sure to use the thread click handler"],
        ["Best used when connected with the thread component"],
        ["Use this component to render a list of threads"]
      ]
    }),
    createAndPopulateThreadsIfNotExist({
      pageMutator,
      context,
      viewer,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveThreadedComments,
      dummyViewers: [dummyViewerOne],
      threadURL: DOCS_URLS.components.threadedComments,
      threadName: "Thread created on threaded comments component page",
      threadMessages: [["Try looking at my replies!"]]
    }),
    createAndPopulateThreadsIfNotExist({
      pageMutator,
      context,
      viewer,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveSidebar,
      dummyViewers: [dummyViewerOne, dummyViewerTwo],
      threadURL: DOCS_URLS.components.sidebar,
      threadName: "Thread created on sidebar component page",
      threadMessages: [
        ["Try creating a new thread", "Or try resolving the thread."],
        [
          "Click on me to reply to this thread message",
          "There is already a reply! Why not add more"
        ],
        [
          "This is the conversations tab where you will see all threads written on this page, you can navigate to the inbox from here as well.",
          "\u2B50"
        ]
      ]
    }),
    createThreadWithMentionIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      viewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveInbox,
      threadURL: DOCS_URLS.components.inbox,
      threadName: "Thread on the inbox component page",
      mentionedViewer: viewer,
      threadExternalID: `${LIVE_COMPONENT_INBOX_THREAD_ID_PREFIX}${externalOrgID}`,
      messageBeforeMention: "Hello",
      messageAfterMention: "hover over me for more options."
    }),
    createThreadWithMentionIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      viewer: dummyViewerTwo,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveInboxLauncher,
      threadURL: DOCS_URLS.components.inboxLauncher,
      threadName: "Thread on the inbox launcher component page",
      mentionedViewer: viewer,
      threadExternalID: `${LIVE_COMPONENT_INBOX_LAUNCHER_THREAD_ID_PREFIX}${externalOrgID}`,
      messageBeforeMention: "Hey",
      messageAfterMention: "click on me to reply."
    }),
    createAndPopulateThreadsIfNotExist({
      pageMutator,
      context,
      viewer,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveSidebarLauncher,
      dummyViewers: [dummyViewerOne, dummyViewerTwo],
      threadURL: DOCS_URLS.components.sidebarLauncher,
      threadName: "Thread created on sidebar launcher component page"
    }),
    createAndPopulateThreadsIfNotExist({
      pageMutator,
      context,
      viewer,
      location: DOCS_URLS.howTo.customThreadedComments,
      dummyViewers: [dummyViewerOne],
      threadURL: DOCS_URLS.howTo.customThreadedComments,
      threadName: "Threaded Comments demo"
    }),
    viewerToVisitPageIfNotExist({
      pageMutator,
      viewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.livePagePresence,
      context
    }),
    addExternalNotificationIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      recipient: session.viewer,
      sender: dummyViewerOne
    }),
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveComposer,
      threadURL: DOCS_URLS.components.composer,
      threadExternalID: `${LIVE_COMPONENT_ON_DOCS_COMPOSER_THREAD_ID_PREFIX}${externalOrgID}`,
      threadName: "Thread on Composer component page",
      message: "The id of this thread is passed into the Composer component. Try responding by using the Composer below!"
    }),
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: viewer,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveMessage,
      threadURL: DOCS_URLS.components.message,
      threadExternalID: `${LIVE_COMPONENT_ON_DOCS_MESSAGE_THREAD_ID_PREFIX}${externalOrgID}`,
      threadName: "Thread on Message component page",
      message: `Hey, I'm a message component. Try editing me or deleting me!`,
      reactions: ["\u{1F44D}\uFE0F", "\u2B50", "\u{1F4AF}"]
    }),
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveReactions,
      threadURL: DOCS_URLS.components.reactions,
      threadExternalID: `${LIVE_COMPONENT_ON_DOCS_REACTIONS_THREAD_ID_PREFIX}${externalOrgID}`,
      threadName: "Thread on Reactions component page",
      message: `The Reactions component is hooked up to this message. Try adding and removing reactions with it!`,
      reactions: ["\u{1F44D}\uFE0F", "\u2B50", "\u{1F4AF}"]
    }),
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveMessageContent,
      threadURL: DOCS_URLS.components.messageContent,
      threadExternalID: `${LIVE_COMPONENT_ON_DOCS_MESSAGE_CONTENT_THREAD_ID_PREFIX}${externalOrgID}`,
      threadName: "Thread on Message Content component page",
      message: `I am the message content of a particular message. Try inspecting me!`,
      includeDummyAttachment: true
    }),
    // Create a user with no profile picture to show AvatarFallback
    createDummyUserAndViewerIfNotExist({
      platformApplicationID,
      org,
      firstName: "John Doe",
      context,
      userExternalID: `${externalOrgID}:${LIVE_COMPONENT_ON_DOCS_NO_AVATAR_USER_ID}`
    }),
    // Create conversation for Github demo
    await createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveReplacementsTutorial,
      threadURL: DOCS_URLS.howTo.replacements,
      threadExternalID: `${LIVE_CUSTOMIZATION_ON_DOCS_REPLACEMENTS_THREAD_ID_PREFIX}${externalOrgID}`,
      threadName: "Thread on Replacements tutorial page",
      message: "Hey there! Have you tried out the new Replacements API in Cord yet?",
      reactions: ["\u{1F44D}\uFE0F", "\u2B50", "\u{1F4AF}"],
      extraMessages: [
        [dummyViewerTwo, "Not yet! What's it all about?"],
        [
          dummyViewerOne,
          "You can swap out default components with your own custom ones for a personalized look and added features."
        ],
        [
          dummyViewerTwo,
          "I'll have to give it a try. Thanks for the heads up!"
        ]
      ]
    }),
    // For the new beta thread examples
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveBetaV2Thread,
      threadURL: DOCS_URLS.betaV2Components.thread,
      threadExternalID: `${BETA_V2_DOCS_PREFIX}thread-example-${externalOrgID}`,
      threadName: "Beta Thread",
      message: `This is a completely customised Cord Thread!`,
      extraMessages: [
        [
          dummyViewerOne,
          "You can make it look like a messenger app, just click the examples tab to see it \u{1F601}"
        ]
      ]
    }),
    // For the new beta threads examples
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveBetaV2Threads,
      threadURL: DOCS_URLS.betaV2Components.threads,
      threadExternalID: `${BETA_V2_DOCS_PREFIX}threads-example-${externalOrgID}-1`,
      threadName: "Beta Threads",
      message: `This is a completely customisable Cord Threads component, you can reply directly to this message, or start a new conversation \u{1F601}`,
      extraMessages: [
        [dummyViewerOne, "You can have multiple conversations in one place"]
      ]
    }),
    createThreadWithMessageIfNotExist({
      pageMutator,
      threadMutator,
      threadLoader,
      context,
      dummyViewer: dummyViewerOne,
      location: DOCS_LIVE_PAGE_LOCATIONS.liveBetaV2Threads,
      threadURL: DOCS_URLS.betaV2Components.threads,
      threadExternalID: `${BETA_V2_DOCS_PREFIX}threads-example-${externalOrgID}-2`,
      threadName: "Beta Threads",
      message: `Try resolving this thread to and check out the other examples!`,
      extraMessages: [
        [
          dummyViewerTwo,
          "Customise the look and feel of the component using our TabbedThreads component"
        ]
      ]
    })
  ]);
}

// server/src/public/routes/docs-sample-token/GetDocsSampleSignedTokenHandler.ts
async function getDocsSampleSignedTokenHandler({ body }, res) {
  anonymousLogger().debug("Provisioned docs sample token", { body });
  let session_token = await extractDocTokenFromReqBody(body);
  if (!session_token) {
    const application = await ApplicationEntity.findByPk(
      CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID
    );
    if (!application) {
      throw new Error("Sample docs token application missing");
    }
    const randomIndex = Math.floor(Math.random() * TEAM_PROFILES.length);
    session_token = jwt6.sign(
      {
        app_id: CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID,
        user_id: uuid14(),
        organization_id: uuid14(),
        user_details: {
          name: TEAM_PROFILES[randomIndex].firstName,
          email: `sample-doc-user@${Math.floor(
            Math.random() * 1e9
          )}.cord.com`,
          profile_picture_url: TEAM_PROFILES[randomIndex].profilePictureURL
        },
        organization_details: {
          name: "Sample Doc Org"
        }
      },
      application.sharedSecret,
      {
        algorithm: "HS512",
        expiresIn: DOCS_TOKEN_EXPIRY_SECONDS
      }
    );
  }
  try {
    await createDummyDataForDocsIfNotExist({ sessionToken: session_token });
  } catch (error) {
    const errorOptions = {};
    if (error instanceof Error) {
      errorOptions.cause = error;
    }
    throw new Error("Creating dummy data for docs failed", errorOptions);
  }
  return res.json({ client_auth_token: session_token });
}
var GetDocsSampleSignedTokenHandler_default = forwardHandlerExceptionsToNext(getDocsSampleSignedTokenHandler);

// server/src/public/routes/platform/users/DeletePlatformUserDataHandler.ts
import { QueryTypes as QueryTypes19 } from "sequelize";
async function deleteUserDataHandler(req, res) {
  const platformApplicationID = req.appID;
  const { permanently_delete, ...rest } = validate.DeleteUserVariables(
    req.body
  );
  const _ = rest;
  if (!platformApplicationID || !permanently_delete) {
    throw new ApiCallerError("invalid_request");
  }
  const externalID = req.params.userID;
  validateExternalID(externalID, "userID");
  const userToBeDeleted = await UserEntity.findOne({
    where: {
      externalID,
      platformApplicationID
    }
  });
  if (!userToBeDeleted) {
    throw new ApiCallerError("invalid_user_id", {
      message: `Invalid user id: ${externalID}.`
    });
  }
  const userToBeDeletedUserID = userToBeDeleted.id;
  const linkedUsers = await LinkedUsersEntity.findAll({
    where: {
      sourceUserID: userToBeDeletedUserID
    }
  });
  const linkedUserIDs = linkedUsers.map((user) => user.linkedUserID);
  const orgMemberEntities = await OrgMembersEntity.findAll({
    where: { userID: userToBeDeletedUserID }
  });
  const orgIDsUserIsMemberOf = orgMemberEntities.map(
    (orgMember) => orgMember.orgID
  );
  const failedDeletionFileIDs = [];
  const allUsers = [userToBeDeletedUserID, ...linkedUserIDs];
  const filesToBeDeleted = await FileEntity.findAll({
    where: {
      userID: allUsers
    }
  });
  const headers = {
    method: "DELETE"
  };
  await Promise.all(
    filesToBeDeleted.map(async (file) => {
      if (!process.env.JEST_WORKER_ID) {
        const deletionURL = await file.getDeleteURL();
        const deleteResponse = await fetch(deletionURL, headers);
        if (!deleteResponse.ok) {
          failedDeletionFileIDs.push(file.id);
        }
      }
      await file.destroy();
    })
  );
  await getSequelize().transaction(async (transaction) => {
    const threadIDsFromDeletedMessages = await getSequelize().query(
      `
        DELETE FROM cord.messages
        WHERE "sourceID" = ANY($1)
        AND "orgID" = ANY($2)
        RETURNING "threadID";
        `,
      {
        bind: [allUsers, orgIDsUserIsMemberOf],
        transaction,
        type: QueryTypes19.SELECT
      }
    );
    const threadIDs = new Set(
      threadIDsFromDeletedMessages.map((data) => data.threadID)
    );
    await getSequelize().query(
      `
      DELETE FROM cord.threads t
      WHERE t.id = ANY ($1)
      AND NOT EXISTS(
        SELECT 1 FROM cord.messages
        WHERE "threadID" = t.id
        );
    `,
      { bind: [[...threadIDs]], transaction }
    );
    await userToBeDeleted.destroy({ transaction });
  });
  anonymousLogger().info("User deleted", {
    platformApplicationID,
    externalID,
    usersDeleted: userToBeDeletedUserID
  });
  res.status(200).json({
    success: true,
    message: "User deleted.",
    userID: externalID,
    failedDeletionFileIDs
  });
}
var DeletePlatformUserDataHandler_default = forwardHandlerExceptionsToNext(deleteUserDataHandler);

// server/src/public/routes/platform/notifications/CreateNotificationHandler.ts
async function createNotificationHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const {
    actor_id: actorExternalIDsnake,
    actorID: actorExternalIDcamel,
    recipient_id: recipientExternalIDsnake,
    recipientID: recipientExternalIDcamel,
    template,
    url: url6,
    metadata,
    type: _type,
    extraClassnames,
    iconUrl,
    ...rest
  } = validate.CreateNotificationVariables(req.body);
  const _ = rest;
  if (actorExternalIDsnake) {
    deprecated(
      "snake:CreateNotificationHandler:actor_id",
      platformApplicationID
    );
  }
  if (recipientExternalIDsnake) {
    deprecated(
      "snake:CreateNotificationHandler:recipient_id",
      platformApplicationID
    );
  }
  const actorExternalID = actorExternalIDcamel ?? actorExternalIDsnake;
  const recipientExternalID = recipientExternalIDcamel ?? recipientExternalIDsnake;
  if (!recipientExternalID) {
    throw new ApiCallerError("invalid_request", {
      message: "Missing recipientID"
    });
  }
  actorExternalID && validateExternalID(actorExternalID, "actor");
  validateExternalID(recipientExternalID, "recipient");
  const [sender, recipient] = await Promise.all([
    actorExternalID ? await UserEntity.findOne({
      where: {
        externalID: actorExternalID,
        platformApplicationID
      }
    }) : null,
    UserEntity.findOne({
      where: {
        externalID: recipientExternalID,
        platformApplicationID
      }
    })
  ]);
  if (req.body.actor_id && !sender) {
    throw new ApiCallerError("invalid_user_id", {
      message: `Invalid recipient user id: ${recipientExternalID}.`
    });
  }
  if (!recipient) {
    throw new ApiCallerError("invalid_user_id", {
      message: `Invalid recipient user id: ${recipientExternalID}.`
    });
  }
  if (!sender && template.search("{{ ?actor ?}}") !== -1) {
    throw new ApiCallerError("invalid_field", {
      message: "Invalid template: must contain {{actor}} variable"
    });
  }
  const mutator = new NotificationMutator(Viewer.createAnonymousViewer());
  const notif = await mutator.createExternal({
    platformApplicationID,
    recipientID: recipient.id,
    senderID: sender?.id,
    externalTemplate: template,
    iconUrl,
    externalURL: url6,
    extraClassnames,
    metadata
  });
  res.status(200).json({
    success: true,
    message: "Notification created.",
    notificationID: notif.externalID
  });
}
var CreateNotificationHandler_default = forwardHandlerExceptionsToNext(createNotificationHandler);

// server/src/util/selfServe.ts
import freeEmailDomains2 from "free-email-domains";
import { QueryTypes as QueryTypes20 } from "sequelize";

// server/src/console/utils.ts
import freeEmailDomains from "free-email-domains";

// common/const/Billing.ts
var PRO_APP_LIMIT = 5;
var FREE_APP_LIMIT = 1;
var PRO_SEATS_LIMIT = 5;
var FREE_SEATS_LIMIT = 2;

// server/src/util/selfServe.ts
async function logCustomerActionLimit({
  customerID,
  action
}) {
  const flagsUser = {
    userID: "anonymous",
    platformApplicationID: "console",
    version: null,
    customerID
  };
  const billing_enabled_in_console = await getTypedFeatureFlagValue(
    FeatureFlags2.BILLING_ENABLED_IN_CONSOLE,
    flagsUser
  );
  if (!billing_enabled_in_console) {
    return;
  }
  const customer = await CustomerEntity.findByPk(customerID);
  if (!customer || customer.pricingTier === "scale" || customer.id === CORD_CUSTOMER_ID) {
    return;
  }
  const customerPricingTier = customer.pricingTier;
  if (action === "create_application") {
    const applicationsCount = await ApplicationEntity.count({
      where: { customerID }
    });
    const appLimit = customerPricingTier === "free" ? FREE_APP_LIMIT : PRO_APP_LIMIT;
    if (applicationsCount > appLimit) {
      await sendMessageToCord(
        `\u{1F4C8} Customer ${customer.name} ${ADMIN_ORIGIN}/customers/${customer.id} - has passed the maximum allowed applications (${applicationsCount}/${appLimit}) on their pricing tier (${customerPricingTier}).`,
        CORD_SELF_SERVE_SLACK_CHANNEL_ID,
        "selfserve"
      );
    }
  }
  if (action === "add_member") {
    const consoleUsersCount = await ConsoleUserEntity.count({
      where: { customerID }
    });
    const consoleUsersLimit = customerPricingTier === "free" ? FREE_SEATS_LIMIT : PRO_SEATS_LIMIT;
    if (consoleUsersCount > consoleUsersLimit) {
      await sendMessageToCord(
        `\u{1F4C8} Customer ${customer.name} ${ADMIN_ORIGIN}/customers/${customer.id} - has passed the maximum allowed members (${consoleUsersCount}/${consoleUsersLimit}) on their pricing tier (${customerPricingTier}).`,
        CORD_SELF_SERVE_SLACK_CHANNEL_ID,
        "selfserve"
      );
    }
  }
}

// server/src/public/routes/platform/applications/CreateApplicationHandler.ts
async function CreateApplicationHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_request");
  }
  const {
    name,
    iconURL,
    eventWebhookURL,
    redirectURI,
    emailSettings,
    ...rest
  } = validate.CreateApplicationVariables(req.body);
  const _ = rest;
  const application = await ApplicationEntity.create({
    name,
    iconURL,
    customerID,
    eventWebhookURL,
    customEmailTemplate: emailSettings ? emailSettingsToDbData(emailSettings, name) : void 0,
    enableEmailNotifications: emailSettings?.enableEmailNotifications,
    redirectURI
  });
  await logCustomerActionLimit({
    customerID,
    action: "create_application"
  });
  res.status(200).json({
    success: true,
    message: "Project created",
    applicationID: application.id,
    projectID: application.id,
    secret: application.sharedSecret
  });
}
var CreateApplicationHandler_default = forwardHandlerExceptionsToNext(CreateApplicationHandler);

// server/src/public/routes/platform/threads/UpdateThreadHandler.ts
import { v4 as uuid15 } from "uuid";
async function injectResolvedMessage(thread, resolvedTimestamp, originalResolvedTimestamp, externalUserID, platformApplicationID, transaction) {
  if (resolvedTimestamp === void 0) {
    return null;
  }
  if (resolvedTimestamp && originalResolvedTimestamp || !resolvedTimestamp && !originalResolvedTimestamp) {
    return null;
  }
  if (externalUserID === void 0) {
    return null;
  }
  const user = await UserEntity.findOne({
    where: {
      externalID: externalUserID,
      platformApplicationID
    }
  });
  if (!user) {
    throw new ApiCallerError("user_not_found", {
      message: `Unknown user ${externalUserID}`
    });
  }
  const org = await OrgEntity.findByPk(thread.orgID);
  if (!org) {
    throw new Error(`Somehow cannot find org for thread ${thread.id}`);
  }
  const viewer = await Viewer.createLoggedInPlatformViewer({
    user,
    org
  });
  const loaders = await getNewLoaders(viewer);
  const actionType = resolvedTimestamp ? "thread_resolved" : "thread_unresolved";
  const message = await new MessageMutator(viewer, loaders).createMessage(
    {
      id: uuid15(),
      thread,
      content: getActionMessageContent(actionType, user),
      url: null,
      iconURL: MessageActionIconURLs[actionType],
      translationKey: MessageActionTranslationKeys[actionType],
      type: "action_message"
    },
    transaction
  );
  const threadParticipantMutator = new ThreadParticipantMutator(
    viewer,
    loaders
  );
  await threadParticipantMutator.markThreadNewlyActiveForOtherUsers(
    thread.id,
    message.id,
    transaction
  );
  return { message, viewer };
}
async function getOrgID(platformApplicationID, externalOrgID) {
  if (!externalOrgID) {
    return void 0;
  }
  const org = await OrgEntity.findOne({
    where: { platformApplicationID, externalID: externalOrgID }
  });
  if (!org) {
    throw new ApiCallerError("organization_not_found");
  }
  return org.id;
}
async function updateThreadHandler(req, res) {
  const reqBodyWithGroupIDIfOrgIDExist = addGroupIDIfOrgIDExists(
    req.body,
    req.appID
  );
  const vars = validate.UpdateThreadVariables(reqBodyWithGroupIDIfOrgIDExist);
  await updateThread({
    ...vars,
    platformApplicationID: req.appID,
    threadID: req.params.threadID
  });
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully updated thread ${req.params.threadID}`
  });
}
async function updateThread({
  platformApplicationID,
  threadID,
  id: newExternalID,
  groupID: externalOrgID,
  name,
  resolvedTimestamp: resolvedTimestampInput,
  resolved: resolvedInput,
  location: locationInput,
  userID: externalUserID,
  url: url6,
  metadata,
  extraClassnames,
  typing: typingUserIDs,
  organizationID: _organizationID = externalOrgID,
  seenByUsers: seenByUsersInput,
  addSubscribers,
  removeSubscribers,
  ...rest
}) {
  const _ = rest;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const thread = await loadThread(platformApplicationID, threadID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  if (newExternalID) {
    if (!isValidExternalID(newExternalID)) {
      throw new ApiCallerError("invalid_field", {
        message: `${newExternalID} is not a valid identifier: https://docs.cord.com/reference/identifiers`
      });
    }
    const dupeThread = await loadThread(platformApplicationID, newExternalID);
    if (dupeThread) {
      throw new ApiCallerError("thread_already_exists", {
        message: `Cannot change ID to ${newExternalID} since a thread with that ID already exists`
      });
    }
  }
  if (addSubscribers && removeSubscribers) {
    for (const subscriberToAdd of addSubscribers) {
      for (const subscriberToRemove of removeSubscribers) {
        if (subscriberToAdd === subscriberToRemove) {
          throw new ApiCallerError("invalid_field", {
            message: "Adding and removing the same subscriber is invalid"
          });
        }
      }
    }
  }
  const orgID = await getOrgID(platformApplicationID, externalOrgID);
  let resolvedTimestamp = void 0;
  if (resolvedTimestampInput !== void 0) {
    resolvedTimestamp = resolvedTimestampInput;
  } else if (resolvedInput !== void 0) {
    resolvedTimestamp = resolvedInput ? /* @__PURE__ */ new Date() : null;
  }
  const originalResolvedTimestamp = thread.resolvedTimestamp;
  const originalPageContextHash = thread.pageContextHash;
  const originalLocation = await getThreadLocation(thread);
  const originalMetadata = thread.metadata;
  const originalOrgID = thread.orgID;
  const originalOrgViewer = Viewer.createOrgViewer(
    thread.orgID,
    platformApplicationID
  );
  const originalOrgViewerLoaders = await getNewLoaders(originalOrgViewer);
  const originalSubscribers = new Set(
    await originalOrgViewerLoaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  let pageContextHash = void 0;
  if (orgID || locationInput) {
    const orgViewer = Viewer.createOrgViewer(orgID ?? thread.orgID);
    const location = locationInput ?? originalLocation;
    pageContextHash = await new PageMutator(orgViewer).createPageIfNotExists({
      providerID: null,
      data: location
    });
  }
  const sequelize2 = getSequelize();
  const [updatedThread, _otherChangeOrgUpdates, injectedMessage] = await sequelize2.transaction(async (transaction) => {
    return await Promise.all([
      thread.update(
        {
          externalID: newExternalID,
          orgID,
          name,
          resolvedTimestamp,
          pageContextHash,
          url: url6,
          metadata,
          extraClassnames: extraClassnames ?? void 0
        },
        { transaction }
      ),
      // Update some denormalized places -- within the same transaction since we
      // may need to temporarily break foreign key constraints.
      orgID ? Promise.all([
        MessageEntity.update(
          { orgID },
          { where: { threadID: thread.id }, transaction }
        ),
        ThreadParticipantEntity.update(
          { orgID },
          { where: { threadID: thread.id }, transaction }
        ),
        EmailOutboundNotificationEntity.update(
          { threadOrgID: orgID },
          { where: { threadID: thread.id }, transaction }
        ),
        SlackMirroredThreadEntity.update(
          { threadOrgID: orgID },
          { where: { threadID: thread.id }, transaction }
        ),
        SlackMirroredSupportThreadEntity.update(
          { threadOrgID: orgID },
          { where: { threadID: thread.id }, transaction }
        )
      ]) : null,
      injectResolvedMessage(
        thread,
        resolvedTimestamp,
        originalResolvedTimestamp,
        externalUserID,
        platformApplicationID,
        transaction
      )
    ]);
  });
  if (addSubscribers || removeSubscribers) {
    await updateSubscribers(
      sequelize2,
      addSubscribers,
      removeSubscribers,
      thread
    );
  }
  if (typingUserIDs) {
    await updateTypingUsers(sequelize2, typingUserIDs, thread);
  }
  if (seenByUsersInput) {
    await updateSeenByUsers(sequelize2, seenByUsersInput, thread);
  }
  const newSubscribers = new Set(
    await originalOrgViewerLoaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  const removed = [...originalSubscribers].filter(
    (s) => !newSubscribers.has(s)
  );
  const added = [...newSubscribers].filter((s) => !originalSubscribers.has(s));
  const filterablePropertiesPayload = {
    threadID: thread.id,
    changes: {
      ...locationInput && !locationEqual(originalLocation, locationInput) && {
        location: { old: originalLocation, new: locationInput }
      },
      ...!!originalResolvedTimestamp !== !!thread.resolvedTimestamp && {
        resolved: {
          old: !!originalResolvedTimestamp,
          new: !!thread.resolvedTimestamp
        }
      },
      ...metadata && !metadataEqual(originalMetadata, thread.metadata) && {
        metadata: { old: originalMetadata, new: thread.metadata }
      },
      ...originalOrgID !== thread.orgID && {
        orgID: { old: originalOrgID, new: thread.orgID }
      },
      ...(added.length > 0 || removed.length > 0) && {
        subscribers: { added, removed }
      }
    }
  };
  const filterablePropertiesUpdated = Object.keys(filterablePropertiesPayload.changes).length > 0;
  const pubSubEvents = [
    publishPubSubEvent("annotations-on-page-updated", {
      pageContextHash: thread.pageContextHash,
      orgID: thread.orgID
    }),
    pageContextHash ? publishPubSubEvent("annotations-on-page-updated", {
      pageContextHash: originalPageContextHash,
      orgID: thread.orgID
    }) : null,
    publishPubSubEvent("thread-properties-updated", {
      threadID: thread.id
    }),
    filterablePropertiesUpdated && publishPubSubEvent(
      "thread-filterable-properties-updated",
      { orgID: thread.orgID },
      filterablePropertiesPayload
    )
  ];
  if (originalOrgID !== thread.orgID) {
    pubSubEvents.push(
      publishPubSubEvent(
        "thread-filterable-properties-updated",
        { orgID: originalOrgID },
        filterablePropertiesPayload
      )
    );
  }
  backgroundPromise(Promise.all(pubSubEvents));
  if (injectedMessage) {
    const app = await ApplicationEntity.findByPk(platformApplicationID);
    if (!app) {
      throw new Error(`Somehow cannot find app ${platformApplicationID}`);
    }
    const { message, viewer } = injectedMessage;
    const context = await contextWithSession(
      { viewer },
      getSequelize(),
      null,
      null
    );
    backgroundPromise(
      Promise.all([
        publishPubSubEvent(
          "thread-message-added",
          { threadID: message.threadID },
          { messageID: message.id }
        ),
        publishEventToWebhook(app, {
          type: "thread-message-added",
          threadID: thread.id,
          messageID: message.id
        }),
        //TODO: fix this to not requre the viewer - thread action messages should
        // not be tied to a message (in this case the resolved action message) and
        // should just be passed through if it exists but created eitherway
        createThreadActionNotifications({
          context,
          threadID: thread.id,
          messageID: message.id,
          threadActionType: updatedThread.resolvedTimestamp ? "resolve" : "unresolve"
        })
      ])
    );
  }
}
async function updateSubscribers(sequelize2, addSubscribers, removeSubscribers, thread) {
  await sequelize2.transaction(async (transaction) => {
    const orgViewer = Viewer.createOrgViewer(thread.orgID);
    const loaders = await getNewLoaders(orgViewer);
    const mutator = new ThreadParticipantMutator(orgViewer, loaders);
    if (addSubscribers && addSubscribers.length > 0) {
      const orgMembers = await getOrgMembersFromExternalUserIDs(
        addSubscribers,
        thread,
        transaction
      );
      await mutator.subscribeUsersToThread(
        thread.id,
        orgMembers.map((ome) => ome.userID),
        void 0,
        transaction
      );
    }
    if (removeSubscribers && removeSubscribers.length > 0) {
      const orgMembers = await getOrgMembersFromExternalUserIDs(
        removeSubscribers,
        thread,
        transaction
      );
      await mutator.unsubscribeUsersFromThread(
        thread.id,
        orgMembers.map((ome) => ome.userID),
        transaction
      );
    }
  });
}
async function updateTypingUsers(sequelize2, typingUserIDs, thread) {
  const orgViewer = Viewer.createOrgViewer(thread.orgID);
  const logger = new Logger(orgViewer);
  if (typingUserIDs.length === 0) {
    await removeAllTypingUsers(thread.id);
  } else {
    await sequelize2.transaction(async (transaction) => {
      const orgMembers = await getOrgMembersFromExternalUserIDs(
        typingUserIDs,
        thread,
        transaction
      );
      await Promise.all(
        orgMembers.map(
          ({ userID }) => setUserTyping(logger, thread.id, userID, true)
        )
      );
    });
  }
}
async function updateSeenByUsers(sequelize2, seenByUsersIDs, thread) {
  if (seenByUsersIDs.length === 0) {
    return;
  }
  await sequelize2.transaction(async (transaction) => {
    const orgMembers = await getOrgMembersFromExternalUserIDs(
      seenByUsersIDs.map((i) => i.userID),
      thread,
      transaction
    );
    const users = await UserEntity.findAll({
      where: { id: [...orgMembers.map((u) => u.userID)] },
      transaction
    });
    const org = await OrgEntity.findByPk(thread.orgID, { transaction });
    if (!org) {
      throw new Error(`Somehow cannot find org for thread ${thread.id}`);
    }
    const firstMessage = await MessageEntity.findOne({
      where: { threadID: thread.id },
      order: [["timestamp", "ASC"]],
      transaction
    });
    if (!firstMessage) {
      throw new Error("Could not find first message in thread");
    }
    await Promise.all(
      users.map(async (user) => {
        const viewer = await Viewer.createLoggedInPlatformViewer({
          user,
          org
        });
        const loaders = await getNewLoaders(viewer);
        const threadParticipantMutator = new ThreadParticipantMutator(
          viewer,
          loaders
        );
        const userData = seenByUsersIDs.find(
          (i) => i.userID === user.externalID
        );
        if (userData?.seen) {
          await threadParticipantMutator.markThreadSeen({
            threadID: thread.id
          });
        } else {
          await threadParticipantMutator.markThreadUnseenFromMessage({
            threadID: thread.id,
            messageID: firstMessage.id,
            transaction
          });
        }
      })
    );
  });
}
async function getOrgMembersFromExternalUserIDs(userIDs, thread, transaction) {
  const users = await UserEntity.findAll({
    where: {
      externalID: userIDs,
      platformApplicationID: thread.platformApplicationID
    },
    transaction
  });
  if (users.length === 0) {
    throw new ApiCallerError("user_not_found");
  }
  const internalUserIDs = new Set(users.map((user) => user.id));
  return await OrgMembersEntity.findAll({
    where: { userID: [...internalUserIDs], orgID: thread.orgID },
    transaction
  });
}
var UpdateThreadHandler_default = forwardHandlerExceptionsToNext(updateThreadHandler);

// server/src/public/routes/platform/threads/DeleteThreadHandler.ts
async function deleteThreadHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const thread = await loadThread(platformApplicationID, req.params.threadID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  await thread.destroy();
  backgroundPromise(
    Promise.all([
      publishPubSubEvent(
        "thread-deleted",
        { threadID: thread.id },
        { threadID: thread.id }
      ),
      publishPubSubEvent(
        "page-thread-deleted",
        { orgID: thread.orgID },
        { threadID: thread.id }
      )
    ])
  );
  return res.status(200).json({
    success: true,
    message: `\u{1F480} You successfully deleted thread ${req.params.threadID}`
  });
}
var DeleteThreadHandler_default = forwardHandlerExceptionsToNext(deleteThreadHandler);

// server/src/public/routes/platform/messages/DeleteThreadMessageHandler.ts
async function DeleteThreadMessageHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalThreadID = req.params.threadID;
  const thread = await loadThread(platformApplicationID, externalThreadID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  const externalMessageID = req.params.messageID;
  const message = await loadThreadMessage(thread.id, externalMessageID);
  if (!message) {
    throw new ApiCallerError("message_not_found");
  }
  await message.destroy();
  backgroundPromise(
    publishPubSubEvent(
      "thread-message-removed",
      { threadID: thread.id },
      { messageID: message.id }
    )
  );
  return res.status(200).json({
    success: true,
    message: `\u{1F480} You successfully deleted message ${req.params.messageID}`
  });
}
var DeleteThreadMessageHandler_default = forwardHandlerExceptionsToNext(DeleteThreadMessageHandler);

// server/src/public/routes/platform/threads/ListThreadsHandler.ts
import { QueryTypes as QueryTypes21 } from "sequelize";
var DEFAULT_LIMIT2 = 1e3;
function encodeToken2(token) {
  return btoa(JSON.stringify(token));
}
async function listThreadsHandler(req, res) {
  const results = await listThreads(req);
  return res.status(200).json(results);
}
async function loadTypingUsers2(threadIDs) {
  const typingUserByThread = await Promise.all(
    threadIDs.map(
      async (threadID) => [threadID, await getUsersTyping(threadID)]
    )
  );
  const allUserObjects = await UserEntity.findAll({
    where: { id: [...new Set(typingUserByThread.flatMap((tubt) => tubt[1]))] }
  });
  const usersByID = new Map(allUserObjects.map((u) => [u.id, u.externalID]));
  return new Map(
    typingUserByThread.map((tubt) => [
      tubt[0],
      tubt[1].map((id) => usersByID.get(id)).filter(isDefined)
    ])
  );
}
async function listThreads(req) {
  const {
    bindVariables,
    countBindVariables,
    locationFilter,
    filters,
    cursor,
    resultsLimit,
    limitQuery
  } = await parseThreadsRequest(req);
  const data = await getSequelize().query(
    `
SELECT
    t.id as "internalID",
    t."externalID" as id,
    o."externalID" as "organizationID",
    COALESCE(mc.count, 0)::INTEGER as total,
    COALESCE(mc.userMessagesCount, 0)::INTEGER as "userMessages",
    COALESCE(mc.actionMessagesCount, 0)::INTEGER as "actionMessages",
    COALESCE(mc.deletedMessagesCount, 0)::INTEGER as "deletedMessages",
    CASE WHEN t."resolvedTimestamp" IS NULL THEN FALSE ELSE TRUE END as resolved,
    t."resolvedTimestamp",
    TO_CHAR(COALESCE(mc."lastCreated", t."createdTimestamp"), 'YYYY-MM-DD HH24:MI:SS.US') as "nextCursorTimestamp",
    COALESCE(tps.participants, ARRAY[]::json[]) as participants,
    COALESCE(tps.subscribers, ARRAY[]::text[]) as subscribers,
    COALESCE(mm.mentioned, ARRAY[]::text[]) AS mentioned,
    COALESCE(rs.repliers, ARRAY[]::text[]) as repliers,
    COALESCE(rs."actionMessageRepliers", ARRAY[]::text[]) as "actionMessageRepliers",
    t.name,
    t.url,
    p."contextData" as location,
    t.metadata
FROM threads t
INNER JOIN orgs o ON t."orgID" = o.id
INNER JOIN pages p ON p."contextHash" = t."pageContextHash" AND p."orgID" = t."orgID" ${locationFilter}
LEFT JOIN (
    SELECT 
        m."threadID" as id, 
        COUNT (*), 
        SUM(CASE WHEN m."type" = 'user_message' AND m."deletedTimestamp" IS NULL THEN 1 ELSE 0 END) as userMessagesCount,
        SUM(CASE WHEN m."type" = 'action_message' AND m."deletedTimestamp" IS NULL THEN 1 ELSE 0 END) as actionMessagesCount,
        SUM(CASE WHEN m."deletedTimestamp" IS NOT NULL THEN 1 ELSE 0 END) as deletedMessagesCount,
        MAX(m.timestamp) as "lastCreated",
        MIN(m.timestamp) as "firstCreated"
    FROM messages m
    WHERE m."platformApplicationID" = $1
    GROUP BY m."threadID"
) as mc ON mc.id = t.id
LEFT JOIN (
    SELECT
        tp."threadID" as id,
        array_agg(json_build_object('lastSeenTimestamp', tp."lastSeenTimestamp", 'userID', u."externalID")) AS participants,
        array_agg(DISTINCT u."externalID") FILTER (WHERE tp.subscribed) AS subscribers
        FROM thread_participants tp
    INNER JOIN users u on tp."userID" = u.id
    INNER JOIN orgs o on tp."orgID" = o.id
    WHERE o."platformApplicationID" = $1
    GROUP BY tp."threadID"
) as tps ON tps.id = t.id
LEFT JOIN (
  SELECT
    "threadID" as id,
    array_agg(DISTINCT "externalID") FILTER (WHERE type = 'user_message') AS repliers,
    array_agg(DISTINCT "externalID") FILTER (WHERE type = 'action_message') AS "actionMessageRepliers" 
  FROM (
    SELECT
      m."threadID",
      m."type",
      u."externalID",
      m."deletedTimestamp",
      ROW_NUMBER() OVER (PARTITION BY m."threadID" ORDER BY m."timestamp") AS sorted_message_idx
    FROM messages m
    INNER JOIN users u ON m."sourceID" = u.id
    WHERE m."platformApplicationID" = $1
  ) as sub
  WHERE sorted_message_idx > 1
  AND "deletedTimestamp" IS NULL
  GROUP BY "threadID"
) as rs ON rs.id = t.id
LEFT JOIN (
  SELECT
    m."threadID" AS id,
    array_agg(DISTINCT u."externalID") AS mentioned
  FROM messages m
    INNER JOIN message_mentions mm ON (m.id = mm."messageID")
    INNER JOIN users u ON (u.id = mm."userID")
  WHERE m."platformApplicationID" = $1
  GROUP BY m."threadID"
) as mm ON mm.id = t.id
WHERE t."platformApplicationID" = $1 
${filters.join(" ")}
${cursor}
ORDER BY COALESCE(mc."lastCreated", t."createdTimestamp") DESC, t."externalID" ASC
${limitQuery}
`,
    {
      bind: bindVariables,
      type: QueryTypes21.SELECT
    }
  );
  const lastThread = data.length === 0 ? null : data[data.length - 1];
  const returnToken = data.length === resultsLimit && lastThread ? encodeToken2({
    externalID: lastThread.id,
    nextCursorTimestamp: lastThread.nextCursorTimestamp
  }) : null;
  const typingUsersByThread = await loadTypingUsers2(
    data.map((t) => t.internalID)
  );
  const results = data.map(
    ({ internalID, nextCursorTimestamp: _, ...rest }) => ({
      ...rest,
      groupID: rest.organizationID,
      typing: typingUsersByThread.get(internalID) ?? []
    })
  );
  const threadsTotal = await getSequelize().query(
    `
  SELECT COUNT(t.id)::integer FROM threads t
  INNER JOIN orgs o ON t."orgID" = o.id
  INNER JOIN pages p ON p."contextHash" = t."pageContextHash" AND p."orgID" = t."orgID" ${locationFilter}
  LEFT JOIN (
    SELECT
          m."threadID" as id,
          COUNT (*),
          MAX(m.timestamp) as "lastCreated",
          MIN(m.timestamp) as "firstCreated"
      FROM messages m
      GROUP BY m."threadID"
  ) as mc ON mc.id = t.id
  WHERE t."platformApplicationID" = $1
  ${filters.join(" ")}
  `,
    {
      bind: countBindVariables,
      type: QueryTypes21.SELECT
    }
  );
  const paginatedResults = {
    threads: results,
    pagination: {
      token: returnToken,
      total: threadsTotal[0].count
    }
  };
  return paginatedResults;
}
async function parseThreadsRequest(req) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const {
    location,
    metadata,
    firstMessageTimestamp,
    mostRecentMessageTimestamp,
    groupID,
    resolvedStatus
  } = validateFilter(req.query, {
    location: true,
    metadata: true,
    firstMessageTimestamp: true,
    mostRecentMessageTimestamp: true,
    groupID: true,
    authorID: false,
    resolvedStatus: true,
    viewer: false
  });
  const { limit, token } = req.query;
  const decodedToken = token && validatePaginationToken({
    token,
    endpoint: "threads"
  });
  const resultsLimit = validateLimit(limit, DEFAULT_LIMIT2);
  const bindVariables = [platformApplicationID];
  const filters = [];
  let cursor = "";
  let locationFilter = "";
  if (groupID) {
    const orgEntity = await OrgEntity.findOne({
      where: { externalID: groupID, platformApplicationID }
    });
    if (!orgEntity) {
      throw new ApiCallerError("group_not_found");
    }
    bindVariables.push(orgEntity.id);
    filters.push(`AND t."orgID" = $${bindVariables.length}`);
  }
  if (location) {
    bindVariables.push(JSON.stringify(location.value));
    locationFilter = `AND p."contextData" ${location.partialMatch ? "@>" : "="} $${bindVariables.length}::jsonb`;
  }
  if (metadata) {
    bindVariables.push(JSON.stringify(metadata));
    filters.push(`AND t.metadata @> $${bindVariables.length}::jsonb`);
  }
  if (firstMessageTimestamp) {
    if (firstMessageTimestamp.from) {
      bindVariables.push(firstMessageTimestamp.from);
      filters.push(
        `AND COALESCE(mc."firstCreated", t."createdTimestamp") >= $${bindVariables.length}::timestamp`
      );
    }
    if (firstMessageTimestamp.to) {
      bindVariables.push(firstMessageTimestamp.to);
      filters.push(
        `AND COALESCE(mc."firstCreated", t."createdTimestamp") <= $${bindVariables.length}::timestamp`
      );
    }
  }
  if (mostRecentMessageTimestamp) {
    if (mostRecentMessageTimestamp.from) {
      bindVariables.push(mostRecentMessageTimestamp.from);
      filters.push(
        `AND mc."lastCreated" >= $${bindVariables.length}::timestamp`
      );
    }
    if (mostRecentMessageTimestamp.to) {
      bindVariables.push(mostRecentMessageTimestamp.to);
      filters.push(
        `AND mc."lastCreated" <= $${bindVariables.length}::timestamp`
      );
    }
  }
  if (resolvedStatus) {
    switch (resolvedStatus) {
      case "any": {
        break;
      }
      case "resolved": {
        filters.push(`AND t."resolvedTimestamp" IS NOT NULL`);
        break;
      }
      case "unresolved": {
        filters.push(`AND t."resolvedTimestamp" IS NULL`);
        break;
      }
    }
  }
  const countBindVariables = [...bindVariables];
  bindVariables.push(resultsLimit);
  const limitQuery = `LIMIT $${bindVariables.length}`;
  if (decodedToken) {
    bindVariables.push(
      decodedToken.nextCursorTimestamp,
      decodedToken.externalID
    );
    cursor = `AND (
      COALESCE(mc."lastCreated", t."createdTimestamp") < $${bindVariables.length - 1}::timestamp
      OR
      (
        COALESCE(mc."lastCreated", t."createdTimestamp") = $${bindVariables.length - 1}::timestamp
        AND t."externalID" > $${bindVariables.length}
      )
    )`;
  }
  return {
    bindVariables,
    countBindVariables,
    locationFilter,
    filters,
    cursor,
    limitQuery,
    resultsLimit
  };
}
var ListThreadsHandler_default = forwardHandlerExceptionsToNext(listThreadsHandler);

// server/src/public/routes/platform/notifications/ListNotificationsHandler.ts
async function listNotificationsHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const user = await UserEntity.findOne({
    where: { platformApplicationID, externalID: req.params.userID }
  });
  if (!user) {
    throw new ApiCallerError("user_not_found");
  }
  const { location, metadata, groupID } = validateFilter(req.query, {
    location: true,
    metadata: true,
    firstMessageTimestamp: false,
    mostRecentMessageTimestamp: false,
    groupID: true,
    authorID: false,
    resolvedStatus: false,
    viewer: false
  });
  const context = await createViewerAndContext(
    platformApplicationID,
    user,
    "api"
  );
  const { nodes: gqlNotifs } = await fetchAndBuildNotifications(context, {
    ltCreatedTimestamp: void 0,
    limit: void 0,
    filter: {
      metadata,
      location,
      groupID
    }
  });
  res.status(200).json(
    await Promise.all(
      gqlNotifs.map(
        (notif) => gqlNotificationToNotificationVariables(context.loaders, notif)
      )
    )
  );
}
var ListNotificationsHandler_default = forwardHandlerExceptionsToNext(listNotificationsHandler);

// server/src/public/routes/platform/notifications/DeleteNotificationHandler.ts
async function deleteNotificationHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const notif = await NotificationEntity.findOne({
    where: { platformApplicationID, externalID: req.params.notificationID }
  });
  if (!notif) {
    throw new ApiCallerError("notification_not_found");
  }
  const affectedCount = await NotificationEntity.destroy({
    where: whereAggregatedNotificationEntity(notif)
  });
  deletedCounter.inc({ appID: platformApplicationID }, affectedCount);
  backgroundPromise(
    publishPubSubEvent(
      "notification-deleted",
      { userID: notif.recipientID },
      { notificationID: notif.id }
    )
  );
  res.status(200).json({
    success: true,
    message: `\u{1F480} You successfully deleted notification ${req.params.notificationID}`
  });
}
var DeleteNotificationHandler_default = forwardHandlerExceptionsToNext(deleteNotificationHandler);

// server/src/public/routes/platform/messages/UpdateThreadMessageHandler.ts
import { unique as unique14 } from "radash";
import { v4 as uuid16 } from "uuid";
async function UpdateThreadMessageHandler(req, res) {
  const vars = validate.UpdateMessageVariables(req.body);
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const [thread, message] = await Promise.all([
    ThreadEntity.findOne({
      where: {
        externalID: req.params.threadID,
        platformApplicationID
      }
    }),
    MessageEntity.findOne({
      where: {
        externalID: req.params.messageID,
        platformApplicationID
      }
    })
  ]);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  if (!message || message.threadID !== thread.id) {
    throw new ApiCallerError("message_not_found");
  }
  const [sender, org] = await Promise.all([
    UserEntity.findByPk(message.sourceID),
    OrgEntity.findByPk(message.orgID)
  ]);
  if (!org) {
    throw new ApiCallerError("organization_not_found");
  }
  if (!sender) {
    throw new ApiCallerError("user_not_found", {
      message: `Message author not found`
    });
  }
  const viewer = await Viewer.createLoggedInPlatformViewer({
    user: sender,
    org
  });
  const context = await contextWithSession(
    { viewer },
    getSequelize(),
    null,
    null
  );
  await updateThreadMessage({
    ...vars,
    context,
    thread,
    message
  });
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully updated message ${req.params.messageID}`
  });
}
async function updateThreadMessage({
  context,
  thread,
  message,
  id: externalID,
  content: rawContent,
  createdTimestamp,
  authorID: newExternalSourceID,
  url: url6,
  deleted,
  iconURL,
  translationKey,
  type,
  metadata,
  extraClassnames,
  deletedTimestamp: deletedTimestampInput,
  updatedTimestamp: updatedTimestampInput,
  addReactions,
  removeReactions,
  addAttachments = [],
  removeAttachments = [],
  skipLinkPreviews: skipLinkPreviewsRaw,
  ...rest
}) {
  const _ = rest;
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  if (externalID) {
    if (!isValidExternalID(externalID)) {
      throw new ApiCallerError("invalid_field", {
        message: `${externalID} is not a valid identifier: https://docs.cord.com/reference/identifiers`
      });
    }
    const dupeMessage = await loadThreadMessage(
      platformApplicationID,
      externalID
    );
    if (dupeMessage) {
      throw new ApiCallerError("message_already_exists", {
        message: `Cannot change ID to ${externalID} since a message with that ID already exists`
      });
    }
  }
  const [org, sender] = await Promise.all([
    context.loaders.orgLoader.loadOrg(thread.orgID),
    context.loaders.userLoader.loadUser(message.sourceID)
  ]);
  if (!org) {
    throw new ApiCallerError("organization_not_found");
  }
  if (!sender) {
    throw new ApiCallerError("user_not_found", {
      message: `Message author not found`
    });
  }
  let newAuthor = null;
  if (newExternalSourceID && sender.externalID !== newExternalSourceID) {
    newAuthor = await UserEntity.findOne({
      where: {
        externalID: newExternalSourceID,
        platformApplicationID
      }
    });
    if (!newAuthor) {
      throw new ApiCallerError("user_not_found", {
        message: `Invalid message author id: ${newExternalSourceID}.`
      });
    }
  }
  let updatedTimestamp = void 0;
  if (updatedTimestampInput !== void 0) {
    updatedTimestamp = updatedTimestampInput;
  }
  let content = void 0;
  if (rawContent && !isEqual(rawContent, message.content)) {
    try {
      validateMessageContent(rawContent);
      content = await internalizeContent(
        rawContent,
        platformApplicationID,
        message.orgID
      );
      if (updatedTimestampInput === void 0) {
        updatedTimestamp = /* @__PURE__ */ new Date();
      }
    } catch (e) {
      throw new ApiCallerError("invalid_field", {
        message: "content field is invalid: " + e.message
      });
    }
  }
  const skipLinkPreviews = skipLinkPreviewsRaw ?? message.skipLinkPreviews;
  let deletedTimestamp = void 0;
  if (deletedTimestampInput !== void 0) {
    deletedTimestamp = deletedTimestampInput;
  } else if (deleted !== void 0) {
    deletedTimestamp = deleted ? /* @__PURE__ */ new Date() : null;
  }
  const reactionsToAdd = addReactions ?? [];
  const reactionsToRemove = removeReactions ?? [];
  for (const reactionToAdd of reactionsToAdd) {
    for (const reactionToDelete of reactionsToRemove) {
      if (reactionToAdd.userID === reactionToDelete.userID && reactionToAdd.reaction === reactionToDelete.reaction) {
        throw new ApiCallerError("invalid_field", {
          message: "Adding and removing the same reaction is invalid."
        });
      }
    }
  }
  const externalReactionUserIDs = unique14([
    ...reactionsToAdd.map((reaction) => reaction.userID),
    ...reactionsToRemove.map((reaction) => reaction.userID)
  ]);
  const externalToInternalReactionUsers = await getValidExternalToInternalReactionUsers(
    context,
    externalReactionUserIDs,
    org
  );
  let fileAttachmentInputs = null;
  let annotationAttachmentInputs = null;
  if (addAttachments.length > 0 || removeAttachments.length > 0) {
    for (const addAttachment of addAttachments) {
      for (const removeAttachment of removeAttachments) {
        if (addAttachment.type === removeAttachment.type && addAttachment.id === removeAttachment.id) {
          throw new ApiCallerError("invalid_field", {
            message: "Adding and removing the same attachment is invalid."
          });
        }
      }
    }
    const fileIDsToRemove = new Set(
      removeAttachments.filter((remove2) => remove2.type === "file").map((remove2) => remove2.id)
    );
    const existingAttachments = getFileAttachmentEntities(
      await context.loaders.messageAttachmentLoader.loadAttachmentsForMessage(
        message.id
      )
    );
    annotationAttachmentInputs = existingAttachments.filter((a) => a.type === "annotation" /* ANNOTATION */).map((a) => {
      const data = a.data;
      return {
        id: a.id,
        screenshotFileID: data.screenshotFileID,
        blurredScreenshotFileID: data.blurredScreenshotFileID,
        location: data.location,
        customLocation: data.customLocation,
        customHighlightedTextConfig: data.customHighlightedTextConfig,
        customLabel: data.customLabel,
        coordsRelativeToTarget: data.coordsRelativeToTarget
      };
    });
    fileAttachmentInputs = existingAttachments.filter((a) => a.type === "file" /* FILE */).filter(
      (a) => !fileIDsToRemove.has(a.data.fileID)
    ).map((a) => {
      const data = a.data;
      return {
        id: a.id,
        fileID: data.fileID
      };
    });
    const newFileAttachments = await validateAddAttachments(
      addAttachments,
      sender
    );
    fileAttachmentInputs.push(
      ...newFileAttachments.map((a) => ({ id: uuid16(), fileID: a.id }))
    );
    const newlyAttachedInputs = new Set(
      fileAttachmentInputs.map((a) => a.fileID)
    );
    if (newlyAttachedInputs.size !== fileAttachmentInputs.length) {
      throw new ApiCallerError("invalid_field", {
        message: "Cannot attach an already-attached file"
      });
    }
  }
  const originalSubscribers = new Set(
    await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  await getSequelize().transaction(async (transaction) => {
    const viewerReactionMutator = new MessageReactionMutator(
      context.session.viewer,
      context.loaders
    );
    const viewerNotificationMutator = new NotificationMutator(
      context.session.viewer
    );
    const viewerThreadParticipantMutator = new ThreadParticipantMutator(
      context.session.viewer,
      context.loaders
    );
    await Promise.all([
      ...reactionsToAdd.map(async (reactionToAdd) => {
        const user = externalToInternalReactionUsers.get(reactionToAdd.userID);
        if (!user) {
          context.logger.logException(
            "Reaction author to add a reaction not found",
            void 0,
            {
              externalID: reactionToAdd.userID
            }
          );
          return;
        }
        const reactionExists = await MessageReactionEntity.findOne({
          where: {
            userID: user.id,
            messageID: message.id,
            unicodeReaction: reactionToAdd.reaction
          },
          transaction
        });
        if (reactionExists) {
          if (reactionToAdd.timestamp !== void 0) {
            reactionExists.timestamp = reactionToAdd.timestamp;
            await reactionExists.save({ transaction });
          }
          return;
        }
        let reactionMutator;
        let notificationMutator;
        let threadParticipantMutator;
        if (user.id === context.session.viewer.userID) {
          reactionMutator = viewerReactionMutator;
          notificationMutator = viewerNotificationMutator;
          threadParticipantMutator = viewerThreadParticipantMutator;
        } else {
          const reactionViewer = await Viewer.createLoggedInPlatformViewer({
            user,
            org
          });
          reactionMutator = new MessageReactionMutator(reactionViewer, null);
          notificationMutator = new NotificationMutator(reactionViewer);
          threadParticipantMutator = new ThreadParticipantMutator(
            reactionViewer,
            null
          );
        }
        const newReaction = await reactionMutator.createOne(
          message.id,
          reactionToAdd.reaction,
          reactionToAdd.timestamp,
          transaction
        );
        await Promise.all([
          message.sourceID !== user.id && notificationMutator.create(
            {
              recipientID: message.sourceID,
              type: "reaction",
              reactionID: newReaction.id,
              aggregationKey: message.id,
              messageID: message.id,
              threadID: message.threadID
            },
            transaction
          ),
          threadParticipantMutator.markThreadNewlyActiveForUser(
            thread.id,
            newReaction.id,
            message.sourceID,
            transaction
          )
        ]);
      }),
      ...reactionsToRemove.map(async (reactionToRemove) => {
        const user = externalToInternalReactionUsers.get(
          reactionToRemove.userID
        );
        if (!user) {
          context.logger.logException(
            "Reaction author to remove a reaction not found",
            void 0,
            {
              externalID: reactionToRemove.userID
            }
          );
          return;
        }
        if (user.id === context.session.viewer.userID) {
          await viewerReactionMutator.deleteUnicodeReaction(
            message.id,
            reactionToRemove.reaction,
            transaction
          );
        } else {
          await MessageReactionEntity.destroy({
            where: {
              userID: user.id,
              messageID: message.id,
              unicodeReaction: reactionToRemove.reaction
            },
            transaction
          });
        }
      })
    ]);
    const updatedMessage = await message.update(
      {
        externalID,
        content,
        url: url6,
        sourceID: newAuthor?.id,
        timestamp: createdTimestamp ?? void 0,
        deletedTimestamp,
        lastUpdatedTimestamp: updatedTimestamp,
        type,
        iconURL,
        translationKey,
        extraClassnames: extraClassnames ?? void 0,
        metadata,
        skipLinkPreviews
      },
      { transaction }
    );
    const wasDeletedOrUndeleted = !isEqual(
      message.deletedTimestamp,
      updatedMessage.deletedTimestamp
    );
    let contextForUpdateMessageTasks = context;
    if (newAuthor && context.session.viewer.userID !== newAuthor.id) {
      const newViewer = await Viewer.createLoggedInPlatformViewer({
        user: newAuthor,
        org
      });
      contextForUpdateMessageTasks = await contextWithSession(
        { viewer: newViewer },
        context.sequelize,
        null,
        null
      );
    }
    const hidePreviewLinksIDs = removeAttachments.filter((remove2) => remove2.type === "link_preview").map((remove2) => remove2.id);
    if (hidePreviewLinksIDs.length > 0) {
      const linkPreviews = await MessageLinkPreviewEntity.findAll({
        where: { id: hidePreviewLinksIDs, messageID: message.id },
        transaction
      });
      if (linkPreviews.length !== hidePreviewLinksIDs.length) {
        throw new Error("Link previews were not loaded");
      }
      if (message.sourceID !== contextForUpdateMessageTasks.session.viewer.userID) {
        throw new Error("Only the message author can edit the link previews");
      }
      await MessageLinkPreviewEntity.update(
        {
          hidden: true
        },
        {
          where: {
            id: hidePreviewLinksIDs
          },
          transaction
        }
      );
    }
    transaction.afterCommit(
      () => executeUpdateMessageTasks({
        context: contextForUpdateMessageTasks,
        message: updatedMessage,
        thread,
        wasDeletedOrUndeleted,
        content,
        authorUpdated: !!newAuthor,
        annotationAttachments: annotationAttachmentInputs,
        fileAttachments: fileAttachmentInputs,
        originalSubscribers
      })
    );
  });
}
var UpdateThreadMessageHandler_default = forwardHandlerExceptionsToNext(UpdateThreadMessageHandler);

// common/util/appendMessageContent.ts
var import_types54 = __toESM(require_cjs(), 1);
function appendMessageContent(content, appendedContent) {
  if (!content || content.length !== 1 || content[0].type !== import_types54.MessageNodeType.MARKDOWN) {
    return null;
  }
  const markdownNode = content[0];
  if (markdownNode.children.length !== 1 || !isMessageNodeText(markdownNode.children[0])) {
    return null;
  }
  return [
    {
      type: markdownNode.type,
      children: [{ text: markdownNode.children[0].text + appendedContent }]
    }
  ];
}

// server/src/public/routes/platform/messages/AppendMessageHandler.ts
async function AppendMessageHandler(req, res) {
  const vars = validate.AppendMessageVariables(req.body);
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const [context, updatedMessage] = await getSequelize().transaction(
    // Note that we don't bother to do most of the operations below through the
    // transaction, just the read+write of the message, so that we append the
    // content atomically. This endpoint is designed to be slammed by AI bots
    // streaming data, so having it be lightweight is important, but also
    // read-update races are likely to be more common than usual so we need to
    // deal with them.
    async (transaction) => {
      const [thread, message] = await Promise.all([
        ThreadEntity.findOne({
          where: {
            externalID: req.params.threadID,
            platformApplicationID
          }
        }),
        MessageEntity.findOne({
          where: {
            externalID: req.params.messageID,
            platformApplicationID
          },
          transaction
        })
      ]);
      if (!thread) {
        throw new ApiCallerError("thread_not_found");
      }
      if (!message || message.threadID !== thread.id) {
        throw new ApiCallerError("message_not_found");
      }
      const [sender, org] = await Promise.all([
        UserEntity.findByPk(message.sourceID),
        OrgEntity.findByPk(message.orgID)
      ]);
      if (!org) {
        throw new ApiCallerError("organization_not_found");
      }
      if (!sender) {
        throw new ApiCallerError("user_not_found", {
          message: `Message author not found`
        });
      }
      const viewer = await Viewer.createLoggedInPlatformViewer({
        user: sender,
        org
      });
      const context2 = await contextWithSession(
        { viewer },
        getSequelize(),
        null,
        null
      );
      const newContent = appendMessageContent(message.content, vars.text);
      if (!newContent) {
        throw new ApiCallerError("message_not_appendable");
      }
      const updatedMessage2 = await message.update(
        { content: newContent },
        { transaction }
      );
      return [context2, updatedMessage2];
    }
  );
  await executeAppendMessageContentTasks({
    context,
    message: updatedMessage,
    appendedContent: vars.text
  });
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully updated message ${req.params.messageID}`
  });
}
var AppendMessageHandler_default = forwardHandlerExceptionsToNext(AppendMessageHandler);

// server/src/presence/context.ts
var timeouts2 = /* @__PURE__ */ new Map();
function makeKey2(externalUserID, orgID, exclusivityRegion) {
  return `presenceContext/${orgID}/${externalUserID}/${(0, import_types.locationJson)(
    exclusivityRegion
  )}`;
}
function makeSequenceNumKey(externalUserID, orgID) {
  return `presenceContextSeq/${orgID}/${externalUserID}`;
}
function userIdFromKey(key) {
  const elements = key.split("/", 4);
  if (elements.length !== 4) {
    throw new Error("Invalid key");
  }
  return elements[2];
}
async function getPresenceValue(key) {
  const result = await getPredis().get(key);
  if (!result) {
    return null;
  }
  return toLocation(JSON.parse(result));
}
async function getUserPresence(orgID, externalUserID) {
  const redis2 = getPredis();
  const stream = redis2.scanStream({
    match: `presenceContext/${orgID}/${externalUserID}/*`,
    count: 1e3
  });
  const data = [];
  stream.on("data", (resultKeys) => {
    stream.pause();
    void Promise.all(
      resultKeys.map(
        (key) => getPresenceValue(key).then((value) => {
          if (value) {
            data.push(value);
          }
        })
      )
    ).then(() => {
      stream.resume();
    });
  });
  await new Promise((resolve2) => stream.on("end", resolve2));
  const sequenceNum = await getPredis().get(
    makeSequenceNumKey(externalUserID, orgID)
  );
  data.sort(locationCompare);
  return {
    contexts: data,
    sequenceNum: sequenceNum ? parseInt(sequenceNum, 10) : 0
  };
}
async function getAllUserPresence(orgID) {
  const redis2 = getPredis();
  const stream = redis2.scanStream({
    match: `presenceContext/${orgID}/*`,
    count: 1e3
  });
  const data = /* @__PURE__ */ new Map();
  stream.on("data", (resultKeys) => {
    stream.pause();
    void Promise.all(
      resultKeys.map(
        (key) => getPresenceValue(key).then((value) => {
          if (value) {
            const externalUserID = userIdFromKey(key);
            data.set(externalUserID, [
              ...data.get(externalUserID) ?? [],
              value
            ]);
          }
        })
      )
    ).then(() => {
      stream.resume();
    });
  });
  await new Promise((resolve2) => stream.on("end", resolve2));
  for (const arr of data.values()) {
    arr.sort(locationCompare);
  }
  return data;
}
async function setUserPresence(logger, externalUserID, orgID, context, exclusivityRegion) {
  if (!locationMatches(context, exclusivityRegion)) {
    throw new Error(
      "Cannot set a user present in a non-matching exclusivity region"
    );
  }
  const key = makeKey2(externalUserID, orgID, exclusivityRegion);
  const sequenceNumKey = makeSequenceNumKey(externalUserID, orgID);
  clearPreviousTimeout2(key);
  const errsAndVals = await getPredis().multi().getset(key, (0, import_types.locationJson)(context)).expire(key, PAGE_PRESENCE_LOSS_TTL_SECONDS).incr(sequenceNumKey).expire(sequenceNumKey, PAGE_PRESENCE_LOSS_TTL_SECONDS).exec();
  if (!multiOperationSucceeded(errsAndVals, "Failed getset presence")) {
    console.log("Had some errors");
    return;
  }
  const prevContextRaw = errsAndVals[0][1];
  const prevContext = typeof prevContextRaw === "string" ? toLocation(JSON.parse(prevContextRaw)) : null;
  const sequenceNum = errsAndVals[2][1];
  const timeoutID = setTimeoutAsync(
    () => notifyIfDeleted(externalUserID, orgID, context, exclusivityRegion).catch(
      logger.exceptionLogger("Failed to notify clients of expired presence")
    ),
    // do the check 100ms after Redis should have expired the presence
    PAGE_PRESENCE_LOSS_TTL_SECONDS * 1e3 + 100
  );
  timeouts2.set(key, timeoutID);
  if (!locationEqual(prevContext, context)) {
    await publishPubSubEvent(
      "context-presence",
      { orgID },
      {
        externalUserID,
        ephemeral: {
          ...prevContext && { departed: prevContext },
          arrived: context,
          sequenceNum
        }
      }
    );
  }
}
async function removeUserPresence(externalUserID, orgID, context, exclusivityRegion) {
  const key = makeKey2(externalUserID, orgID, exclusivityRegion);
  const numOfDeletedKeys = await getPredis().compareAndDelete(
    key,
    (0, import_types.locationJson)(context)
  );
  if (numOfDeletedKeys === 1) {
    clearPreviousTimeout2(key);
    const sequenceNum = await incrSequenceNum(externalUserID, orgID);
    await publishPubSubEvent(
      "context-presence",
      { orgID },
      {
        externalUserID,
        ephemeral: { departed: context, sequenceNum }
      }
    );
  }
}
function clearPreviousTimeout2(key) {
  const timeoutID = timeouts2.get(key);
  if (timeoutID !== void 0) {
    clearTimeout(timeoutID);
    timeouts2.delete(key);
  }
}
async function notifyIfDeleted(externalUserID, orgID, context, exclusivityRegion) {
  const key = makeKey2(externalUserID, orgID, exclusivityRegion);
  const keyIsDeleted = await getPredis().exists(key) === 0;
  if (keyIsDeleted) {
    const sequenceNum = await incrSequenceNum(externalUserID, orgID);
    await publishPubSubEvent(
      "context-presence",
      { orgID },
      {
        externalUserID,
        ephemeral: { departed: context, sequenceNum }
      }
    );
  }
}
async function incrSequenceNum(externalUserID, orgID) {
  const seqNumKey = makeSequenceNumKey(externalUserID, orgID);
  const errsAndVals = await getPredis().multi().incr(seqNumKey).expire(seqNumKey, PAGE_PRESENCE_LOSS_TTL_SECONDS).exec();
  if (!multiOperationSucceeded(errsAndVals, "Failed to increment sequence number")) {
    throw new Error("Failed to increment sequence number");
  }
  return errsAndVals[0][1];
}

// server/src/presence/utils.ts
async function setUserPresentContext({
  userContext,
  present,
  durable,
  exclusivityRegion,
  context
}) {
  const { userID, orgID, externalUserID } = assertViewerHasPlatformIdentity(
    context.session.viewer
  );
  if (!exclusivityRegion) {
    exclusivityRegion = userContext;
  }
  if (!isLocation(userContext)) {
    throw new Error("Invalid context");
  }
  if (!present && durable) {
    throw new Error("Cannot remove durable presence");
  }
  if (!isLocation(exclusivityRegion)) {
    throw new Error("Invalid exclusivity region");
  }
  if (durable) {
    const pageContextHash = await new PageMutator(
      context.session.viewer
    ).createPageIfNotExists({
      data: userContext,
      providerID: null
    });
    await new PageVisitorMutator(context.session.viewer).markPresentInPage(
      pageContextHash
    );
    const visit = await PageVisitorEntity.findOne({
      where: {
        orgID,
        userID,
        pageContextHash
      }
    });
    if (!visit) {
      throw new Error("Internal error");
    }
    await publishPubSubEvent(
      "context-presence",
      { orgID },
      {
        externalUserID,
        durable: {
          context: userContext,
          timestamp: visit.lastPresentTimestamp.getTime()
        }
      }
    );
  } else {
    if (present) {
      await setUserPresence(
        context.logger,
        externalUserID,
        orgID,
        userContext,
        exclusivityRegion
      );
    } else {
      await removeUserPresence(
        externalUserID,
        orgID,
        userContext,
        exclusivityRegion
      );
    }
  }
}

// server/src/public/routes/platform/presence/UpdateUserPresenceHandler.ts
async function updateUserPresenceHanlder(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.userID;
  validateExternalID(externalID, "userID");
  await updateUserPresence(platformApplicationID, externalID, req.body);
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully updated user ${externalID} presence`
  });
}
async function updateUserPresence(platformApplicationID, externalUserID, data) {
  const reqBodyWithGroupID = addGroupIDIfNotExistUpdateUserPresenceHandler(
    data,
    platformApplicationID
  );
  const {
    absent,
    durable,
    location: userContext,
    organizationID: _organizationID,
    groupID: externalOrgID,
    exclusiveWithin,
    ...rest
  } = validate.UpdateUserPresenceVariables(reqBodyWithGroupID);
  const _ = rest;
  const [user, org] = await Promise.all([
    UserEntity.findOne({
      where: {
        externalID: externalUserID,
        platformApplicationID
      }
    }),
    OrgEntity.findOne({
      where: {
        externalID: externalOrgID,
        platformApplicationID
      }
    })
  ]);
  if (!user) {
    throw new ApiCallerError("user_not_found");
  }
  if (!org) {
    throw new ApiCallerError("organization_not_found");
  }
  const orgMember = await OrgMembersEntity.findOne({
    where: {
      userID: user.id,
      orgID: org.id
    }
  });
  if (!orgMember) {
    throw new ApiCallerError("user_not_in_organization");
  }
  const viewer = await Viewer.createLoggedInPlatformViewer({
    user,
    org
  });
  const context = await contextWithSession(
    { viewer },
    getSequelize(),
    null,
    null
  );
  try {
    await setUserPresentContext({
      userContext,
      present: !absent,
      durable: Boolean(durable),
      exclusivityRegion: exclusiveWithin,
      context
    });
  } catch (e) {
    if (e instanceof Error) {
      throw new ApiCallerError("invalid_request", { message: e.message });
    }
  }
}
var UpdateUserPresenceHandler_default = forwardHandlerExceptionsToNext(updateUserPresenceHanlder);

// server/src/public/routes/handlers/Auth0LogsHandler.ts
import * as jwt7 from "jsonwebtoken";

// docs/lib/geoip/geoip.ts
async function ipToLocation(ip) {
  if (ip === "80.249.216.101") {
    return "Cord Office";
  }
  if (!Env_default.IPSTACK_API_SECRET) {
    return ip;
  }
  const resp = await fetch(
    "https://api.ipstack.com/" + ip + "?access_key=" + Env_default.IPSTACK_API_SECRET,
    {
      method: "GET"
    }
  );
  const json = await resp.json();
  if (json && typeof json === "object" && "country_code" in json && "city" in json && typeof json.country_code === "string" && typeof json.city === "string") {
    return json.city + ", " + json.country_code;
  }
  return ip;
}

// server/src/public/routes/handlers/Auth0LogsHandler.ts
var AUTH0_EVENT_LOG = {
  s: "console-successful-login",
  ss: "console-successful-signups",
  f: "console-failed-login",
  fs: "console-failed-signup"
};
function Auth0LogsHandler(req, res) {
  const viewer = Viewer.createAnonymousViewer();
  const anonLogger = new Logger(viewer);
  anonLogger.debug("Auth0LogsHandler", { payload: req.body });
  try {
    const auth = req.headers.authorization;
    if (!auth) {
      throw new Error("Authorization missing in headers");
    }
    const token = auth.split(" ")[1];
    if (!token) {
      throw new Error("Token missing");
    }
    jwt7.verify(token, Env_default.AUTH0_WEBHOOK_SECRET);
  } catch (e) {
    res.sendStatus(401);
    if (e instanceof Error) {
      anonLogger.error("Auth0LogsHandler: " + e.message, {
        payload: req.headers.authorization
      });
    }
    return;
  }
  res.sendStatus(200);
  const logs = req.body.logs;
  storeAuth0EventLogs(viewer, logs).catch((error) => {
    if (error instanceof Error) {
      anonLogger.error("Auth0LogsHandler: " + error.message, {
        payload: req.body
      });
    } else {
      anonLogger.error("Auth0LogsHandler", { payload: req.body });
    }
  });
}
async function storeAuth0EventLogs(viewer, logs) {
  if (!Array.isArray(logs)) {
    throw new Error("Logs should be array");
  }
  if (logs.length === 0) {
    throw new Error("No logs");
  }
  const eventMutator = new EventMutator({ viewer });
  const anonLogger = new Logger(viewer);
  await Promise.all(
    logs.map(async (log) => {
      if (!("data" in log)) {
        throw new Error("Data does not exist");
      }
      const dataLog = log.data;
      if (!("type" in dataLog) || typeof dataLog["type"] !== "string") {
        throw new Error("Type does not exist");
      }
      const logType = dataLog["type"];
      if (logType in AUTH0_EVENT_LOG) {
        await eventMutator.createEvent({
          eventNumber: null,
          pageLoadID: null,
          clientTimestamp: dataLog.date,
          installationID: null,
          type: AUTH0_EVENT_LOG[logType],
          payload: {
            email: dataLog.user_name,
            description: dataLog.description,
            connection: dataLog.connection
          },
          metadata: { log: dataLog },
          logLevel: "info"
        });
        await sendAuth0EventToSlack({
          type: logType,
          email: dataLog.user_name,
          ip: dataLog.ip,
          connection: dataLog?.connection ?? "user name and password",
          logger: anonLogger
        });
      }
    })
  );
}
async function sendAuth0EventToSlack({
  type,
  email,
  ip,
  connection,
  logger
}) {
  let location = ip;
  try {
    location = await ipToLocation(ip);
  } catch (error) {
    logger.logException("Auth0LogsHandler: Could not get geo location", {
      payload: { ip, email, connection, type }
    });
  }
  let message = `\u{1F525} Could not convert Auth0 log type: ${type} to slack message...`;
  switch (type) {
    case "s":
      message = `\u{1FAD2} (${location}) user with email ${email} logged in to the console using ${connection}.`;
      break;
    case "ss":
      message = `\u{1F680} (${location}) user with email ${email} signed up to the console using ${connection}.`;
      break;
    case "f":
      message = `\u{1F3F4}\u200D\u2620\uFE0F (${location}) user with email ${email} failed to log in to the console using ${connection}.`;
      break;
    case "fs":
      message = `\u2620\uFE0F (${location}) user with email ${email} failed to sign up to the console using ${connection}.`;
      break;
  }
  await sendMessageToCord(message, CORD_DEV_CONSOLE_LOGGING_SLACK_CHANNEL_ID);
}

// server/src/public/routes/platform/messages/ListMessagesHandler.ts
import { Op as Op22, Sequelize as Sequelize16 } from "sequelize";
var DEFAULT_LIMIT3 = 1e3;
function encodeToken3(token) {
  return btoa(JSON.stringify(token));
}
async function listMessagesHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const { location, metadata, authorID, groupID } = validateFilter(req.query, {
    location: true,
    metadata: true,
    firstMessageTimestamp: false,
    mostRecentMessageTimestamp: false,
    groupID: true,
    authorID: true,
    resolvedStatus: false,
    viewer: false
  });
  const { token, limit } = req.query;
  const decodedToken = validatePaginationToken({ token, endpoint: "messages" });
  const where = {
    platformApplicationID
  };
  let whereIncludedThread = {};
  if (metadata) {
    where["metadata"] = metadata;
  }
  if (location) {
    const pages = await PageEntity.findAll({
      where: {
        contextData: location.partialMatch ? { [Op22.contains]: location.value } : { [Op22.eq]: location.value }
      }
    });
    whereIncludedThread = {
      pageContextHash: pages.map((page) => page.contextHash)
    };
  }
  if (groupID) {
    const orgEntity = await OrgEntity.findOne({
      where: { externalID: groupID, platformApplicationID }
    });
    if (!orgEntity) {
      throw new ApiCallerError("group_not_found");
    }
    where["orgID"] = orgEntity.id;
  }
  if (authorID) {
    const user = await UserEntity.findOne({
      where: {
        externalID: authorID,
        platformApplicationID
      }
    });
    if (!user) {
      throw new ApiCallerError("user_not_found");
    }
    where["sourceID"] = user?.id;
  }
  const bind = [];
  const whereWithPagination = {
    ...where,
    ...decodedToken && {
      [Op22.or]: [
        Sequelize16.literal(`timestamp > $1`),
        {
          [Op22.and]: [
            Sequelize16.literal(`timestamp = $1`),
            {
              externalID: {
                [Op22.gt]: decodedToken.externalID
              }
            }
          ]
        }
      ]
    }
  };
  if (decodedToken) {
    bind.push(decodedToken?.createdAtWithMicros);
  }
  const resultsLimit = validateLimit(limit, DEFAULT_LIMIT3);
  const [untypedMessages, messagesCount] = await Promise.all([
    MessageEntity.findAll({
      where: whereWithPagination,
      bind,
      order: [
        ["timestamp", "ASC"],
        ["externalID", "ASC"]
      ],
      limit: resultsLimit,
      include: [
        {
          model: ThreadEntity,
          required: true,
          as: "thread",
          where: whereIncludedThread
        }
      ]
    }),
    MessageEntity.count({
      where,
      include: [
        {
          model: ThreadEntity,
          required: true,
          as: "thread",
          where: whereIncludedThread,
          attributes: []
        }
      ]
    })
  ]);
  const messages = untypedMessages;
  const perOrgLoadersMap = /* @__PURE__ */ new Map();
  await Promise.all(
    Array.from(new Set(messages.map((msg) => msg.thread.orgID))).map(
      async (orgID) => {
        const loaders = await getNewLoaders(
          Viewer.createOrgViewer(orgID, platformApplicationID)
        );
        perOrgLoadersMap.set(orgID, loaders);
      }
    )
  );
  const results = await Promise.all(
    messages.map(async (msg) => {
      return await getCoreMessageData(
        perOrgLoadersMap.get(msg.thread.orgID),
        msg,
        msg.thread
      );
    })
  );
  const lastMessage = messages.length === 0 ? null : messages[messages.length - 1];
  const returnToken = messages.length === resultsLimit && lastMessage ? encodeToken3({
    externalID: lastMessage.externalID,
    createdAtWithMicros: lastMessage.createdAtWithMicros
  }) : null;
  const result = {
    messages: results,
    pagination: {
      token: returnToken,
      total: messagesCount
    }
  };
  return res.status(200).json(result);
}
var ListMessagesHandler_default = forwardHandlerExceptionsToNext(listMessagesHandler);

// server/src/public/routes/platform/preferences/ListUserPreferencesHandler.ts
async function listUserPreferencesHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_request");
  }
  const user = await UserEntity.findOne({
    where: { platformApplicationID, externalID: req.params.userID }
  });
  if (!user) {
    throw new ApiCallerError("user_not_found");
  }
  const preference = await UserPreferenceEntity.findOne({
    where: { userID: user.id, key: NOTIFICATION_CHANNELS }
  });
  const value = preference?.value;
  const notificationPreferences = preference?.value ? {
    sendViaEmail: !!value.email,
    sendViaSlack: !!value.slack
  } : {
    sendViaSlack: defaultNotificationPreference.slack,
    sendViaEmail: defaultNotificationPreference.email
  };
  return res.status(200).json({ [NOTIFICATION_CHANNELS]: notificationPreferences });
}
var ListUserPreferencesHandler_default = forwardHandlerExceptionsToNext(listUserPreferencesHandler);

// server/src/public/routes/platform/preferences/UpdateUserPreferencesHandler.tsx
async function updateUserPreferencesHanlder(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.userID;
  const { key, value, ...rest } = validate.UpdateUserPreferenceVariables(
    req.body
  );
  const _ = rest;
  if (key !== NOTIFICATION_CHANNELS) {
    throw new ApiCallerError("invalid_field", {
      message: 'The only valid key for now is "notification_channels".'
    });
  }
  const user = await UserEntity.findOne({
    where: {
      externalID,
      platformApplicationID
    }
  });
  if (!user) {
    throw new ApiCallerError("user_not_found");
  }
  const context = await createViewerAndContext(
    platformApplicationID,
    user,
    "api"
  );
  const notificationChannels = {
    ...value.sendViaEmail !== void 0 && { email: value.sendViaEmail },
    ...value.sendViaSlack !== void 0 && { slack: value.sendViaSlack }
  };
  await new UserPreferenceMutator(context.session.viewer).setPreferenceForUser(
    user.id,
    key,
    notificationChannels
  );
  return res.status(200).json({
    success: true,
    message: `\u2705 You successfully updated user ${externalID} preferences`
  });
}
var UpdateUserPreferencesHandler_default = forwardHandlerExceptionsToNext(updateUserPreferencesHanlder);

// server/src/public/routes/platform/verify/ApplicationTokenHandler.ts
async function applicationTokenHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const app = await ApplicationEntity.findByPk(platformApplicationID);
  if (!app) {
    throw new ApiCallerError("project_not_found");
  }
  return res.status(200).json({
    success: true,
    application_id: platformApplicationID,
    application_name: app.name
  });
}
var ApplicationTokenHandler_default = forwardHandlerExceptionsToNext(applicationTokenHandler);

// server/src/public/routes/platform/webhooks/CreateWebhookHandler.ts
async function createWebhookHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const {
    url: eventWebhookURL,
    events: eventWebhookSubscriptions,
    ...rest
  } = validate.CreateWebhookVariables(req.body);
  const _ = rest;
  await ApplicationWebhookEntity.upsert({
    platformApplicationID,
    eventWebhookURL,
    eventWebhookSubscriptions
  });
  const webhookEntity = await ApplicationWebhookEntity.findOne({
    where: { platformApplicationID, eventWebhookURL }
  });
  if (!webhookEntity) {
    throw new ApiCallerError("invalid_request");
  }
  const webhookID = externalizeID(webhookEntity.id);
  return res.status(201).json({
    success: true,
    message: `Successfully created webhook with id: ${webhookID}`,
    webhookID
  });
}
var CreateWebhookHandler_default = forwardHandlerExceptionsToNext(createWebhookHandler);

// server/src/public/routes/platform/webhooks/DeleteWebhookHandler.ts
async function deleteWebhookHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const webhookID = req.params.webhookID;
  const id = extractInternalID(webhookID);
  if (!id) {
    throw new ApiCallerError("invalid_request");
  }
  const webhookEntity = await ApplicationWebhookEntity.findByPk(id);
  await webhookEntity?.destroy();
  return res.status(200).json({
    success: true,
    message: `\u{1F480} You have successfully deleted webhook: ${webhookID}`,
    deleted: webhookID
  });
}
var DeleteWebhookHandler_default = forwardHandlerExceptionsToNext(deleteWebhookHandler);

// server/src/public/routes/warm-demo-users/DemoUserHandler.ts
import { QueryTypes as QueryTypes22 } from "sequelize";

// server/src/public/routes/warm-demo-users/HomepageDemoUser.ts
var HomepageDemoUser_exports = {};
__export(HomepageDemoUser_exports, {
  create: () => create,
  numToKeep: () => numToKeep,
  reheat: () => reheat,
  version: () => version
});
import { v4 as uuid17 } from "uuid";
var defaultMessage = [
  {
    type: "p",
    children: [
      {
        text: "Oh, and comments! Like this. Go on, give it a try by replying \u{1F447}"
      }
    ]
  }
];
var altMessage1 = [
  {
    type: "p",
    children: [
      {
        text: "With Cord's SDK, you can add these features (and more) to your product in just a few lines of code"
      }
    ]
  },
  {
    type: "p",
    children: [{ text: "Seriously." }]
  }
];
var altMessage2 = [
  {
    type: "p",
    children: [
      {
        text: "Ya know, with features that make it easier for people to collaborate"
      }
    ]
  },
  {
    type: "p",
    children: [{ text: "Things like:" }]
  },
  {
    type: "bullet",
    children: [{ type: "p", children: [{ text: "Comments" }] }]
  },
  {
    type: "bullet",
    children: [{ type: "p", children: [{ text: "Live chat" }] }]
  },
  {
    type: "bullet",
    children: [{ type: "p", children: [{ text: "Notifications" }] }]
  }
];
var MESSAGES = [
  ["default", defaultMessage],
  ["alt1", altMessage1],
  ["alt2", altMessage2]
];
async function create() {
  const baseValue = uuid17();
  const userID = baseValue + ":user";
  const orgID = baseValue + ":org";
  const threadID = baseValue + ":thread";
  const user = await createPlatformUser(
    null,
    CORD_HOMEPAGE_APPLICATION_ID,
    userID,
    null,
    "You",
    null,
    null,
    "active",
    null,
    null
  );
  const [[org], [all]] = await Promise.all([
    findOrCreatePlatformOrganization(
      CORD_HOMEPAGE_APPLICATION_ID,
      orgID,
      "Your Org",
      "active"
    ),
    findOrCreatePlatformOrganization(
      CORD_HOMEPAGE_APPLICATION_ID,
      "all",
      "all",
      "active"
    )
  ]);
  await Promise.all([
    // These users are created by scripts/homepage-create-users.sh and should
    // always be present.
    updatePlatformOrganizationMembers(org, [
      userID,
      "sam",
      "nimrod",
      "khadija",
      "myhoa",
      "tom",
      "zora"
    ]),
    OrgMembersEntity.create({
      userID: user.id,
      orgID: all.id
    })
  ]);
  await Promise.all(
    MESSAGES.map(
      ([id, message]) => createThreadMessage({
        platformApplicationID: CORD_HOMEPAGE_APPLICATION_ID,
        threadID: threadID + "-" + id,
        internalMessageID: uuid17(),
        authorID: "zora",
        content: message,
        addReactions: [
          {
            userID: "tom",
            reaction: "\u{1F44D}"
          },
          {
            userID: "myhoa",
            reaction: "\u{1F44D}"
          },
          {
            userID: "tom",
            reaction: "\u2764\uFE0F"
          },
          {
            userID: "myhoa",
            reaction: "\u2764\uFE0F"
          },
          {
            userID: "khadija",
            reaction: "\u2764\uFE0F"
          },
          {
            userID: "sam",
            reaction: "\u2764\uFE0F"
          },
          {
            userID: "nimrod",
            reaction: "\u2764\uFE0F"
          }
        ],
        createThread: {
          name: "Hello",
          url: "https://v5.cord.com/",
          organizationID: orgID,
          groupID: orgID,
          location: {
            page: "homepage"
          }
        }
      })
    )
  );
  await createThreadMessage({
    platformApplicationID: CORD_HOMEPAGE_APPLICATION_ID,
    threadID: threadID + "-other",
    internalMessageID: uuid17(),
    authorID: "myhoa",
    content: [
      {
        type: import_types2.MessageNodeType.PARAGRAPH,
        children: [
          { text: "To see more of Cord, " },
          {
            type: import_types2.MessageNodeType.MENTION,
            user: { id: userID },
            children: [{ text: "@You" }]
          },
          { text: " should check out our " },
          {
            type: import_types2.MessageNodeType.LINK,
            url: "https://v5.cord.com/demos",
            children: [{ text: "demos" }]
          },
          { text: "!" }
        ]
      }
    ],
    createThread: {
      name: "Demos",
      url: "https://v5.cord.com/demos",
      organizationID: orgID,
      groupID: orgID,
      location: {
        page: "demos"
      }
    }
  });
  return {
    appID: CORD_HOMEPAGE_APPLICATION_ID,
    userID,
    orgID
  };
}
async function lookupGeoipIntoMetadata(req, demoUser) {
  try {
    const [geoip, user] = await Promise.all([
      ipToLocation(req.ip),
      UserEntity.findOne({
        where: {
          externalID: demoUser.userID,
          platformApplicationID: demoUser.appID
        }
      })
    ]);
    if (user && geoip !== req.ip) {
      await Promise.all([
        user.update({ metadata: { geoip } }),
        publishUserIdentityUpdate({
          userID: user.id,
          platformApplicationID: demoUser.appID
        })
      ]);
    }
  } catch (e) {
    anonymousLogger().logException(
      `HomepageDemoUser failed to geoip ${req.ip}`,
      e
    );
  }
}
async function reheat(req, user, token) {
  const baseValue = user.userID.substring(0, user.userID.indexOf(":"));
  backgroundPromise(lookupGeoipIntoMetadata(req, user));
  return {
    token,
    baseValue
  };
}
var numToKeep = 10;
var version = 3;

// server/src/public/routes/warm-demo-users/DemoUserHandler.ts
var import_server = __toESM(require_cjs3(), 1);
var DEMO_USER_TYPES = {
  homepage: HomepageDemoUser_exports
};
async function findUser(type) {
  try {
    const result = await getSequelize().query(
      `DELETE FROM warm_demo_users
       WHERE id IN (
         SELECT id FROM warm_demo_users WHERE "demoGroup" = $1 AND version = $2
         FOR UPDATE SKIP LOCKED
         LIMIT 1
       )
     RETURNING *`,
      {
        type: QueryTypes22.SELECT,
        bind: [type, DEMO_USER_TYPES[type].version],
        model: WarmDemoUserEntity
      }
    );
    if (result.length > 0) {
      return result[0];
    }
  } catch (err) {
    anonymousLogger().logException(
      "Failed to execute demo user find query",
      err,
      {
        type
      }
    );
  }
  return null;
}
function isValidType(type) {
  return type && type in DEMO_USER_TYPES;
}
async function refill(type) {
  const num = await WarmDemoUserEntity.count({
    where: { demoGroup: type }
  });
  const typeInfo = DEMO_USER_TYPES[type];
  const promises = [];
  for (let i = num; i < typeInfo.numToKeep; i++) {
    promises.push(
      (async () => {
        const newUser = await typeInfo.create();
        await WarmDemoUserEntity.create({
          platformApplicationID: newUser.appID,
          userID: newUser.userID,
          orgID: newUser.orgID,
          demoGroup: type,
          version: typeInfo.version
        });
      })()
    );
  }
  return await Promise.all(promises);
}
async function getDemoToken(req, res) {
  const type = req.query.type;
  if (!isValidType(type)) {
    res.status(404);
    return;
  }
  const typeInfo = DEMO_USER_TYPES[type];
  const user = await findUser(type);
  let demoUser;
  if (user) {
    demoUser = {
      appID: user.platformApplicationID,
      userID: user.userID,
      orgID: user.orgID
    };
  } else {
    try {
      demoUser = await typeInfo.create();
    } catch (err) {
      anonymousLogger().logException("Failed to create demo user", err, {
        type
      });
      throw err;
    }
  }
  const app = await ApplicationEntity.findByPk(demoUser.appID);
  if (!app) {
    res.status(404);
    return;
  }
  const clientAuthToken = (0, import_server.getClientAuthToken)(demoUser.appID, app.sharedSecret, {
    user_id: demoUser.userID,
    organization_id: demoUser.orgID
  });
  backgroundPromise(refill(type));
  res.json(await typeInfo.reheat(req, demoUser, clientAuthToken));
}
var DemoUserHandler_default = forwardHandlerExceptionsToNext(getDemoToken);

// server/src/public/routes/platform/files/CreateFileHandler.ts
import { readFile, unlink } from "fs/promises";
import { v4 as uuid18 } from "uuid";

// server/src/public/routes/platform/files/util.ts
function assertValid2(result) {
  if (!result.name) {
    throw new ApiCallerError("file_name_not_allowed", {
      message: `Cannot upload file named ${result.input.name}`
    });
  }
  if (!result.size) {
    throw new ApiCallerError("file_too_large");
  }
  if (!result.mimeType) {
    throw new ApiCallerError("file_type_not_allowed", {
      message: `Input ${result.input.mimeType} MIME type is not allowed`
    });
  }
}

// server/src/public/routes/platform/files/CreateFileHandler.ts
async function createFileHandler(req, res) {
  try {
    const platformApplicationID = req.appID;
    if (!platformApplicationID) {
      throw new ApiCallerError("invalid_request");
    }
    const {
      name: explicitName,
      ownerID,
      ...rest
    } = validate.CreateFileVariables(req.body);
    const _ = rest;
    if (!req.file) {
      throw new ApiCallerError("missing_field", {
        message: "Missing file contents"
      });
    }
    const owner = await UserEntity.findOne({
      where: {
        externalID: ownerID,
        platformApplicationID
      }
    });
    if (!owner) {
      throw new ApiCallerError("invalid_user_id", {
        message: "Invalid owner ID"
      });
    }
    const name = explicitName ?? req.file.originalname;
    assertValid2(
      validateFileForUpload("attachment", {
        name,
        mimeType: req.file.mimetype,
        size: req.file.size
      })
    );
    const viewer = await Viewer.createLoggedInPlatformViewer({
      user: owner,
      org: null
    });
    const loaders = await getNewLoaders(viewer);
    const fileMutator = new FileMutator(viewer, loaders);
    const file = await fileMutator.createFileForUpload(
      uuid18(),
      name,
      req.file.mimetype,
      req.file.size
    );
    const uploadURL = await file.getSignedUploadURL();
    const response = await fetch(uploadURL, {
      method: "PUT",
      body: await readFile(req.file.path),
      headers: {
        "Content-Type": file.mimeType
      }
    });
    if (response.status !== 200) {
      anonymousLogger().error("Error uploading file to S3", {
        uploadURL,
        statusCode: response.status,
        statusMessage: response.statusText
      });
      res.sendStatus(500);
      return;
    }
    await fileMutator.setFileUploadStatus(file.id, "uploaded");
    res.status(200).json({
      success: true,
      message: "\u2705 File created.",
      fileID: file.id
    });
  } finally {
    if (req.file) {
      backgroundPromise(unlink(req.file.path));
    }
  }
}
var CreateFileHandler_default = forwardHandlerExceptionsToNext(createFileHandler);

// opensource/cli/package.json
var package_default2 = {
  name: "@cord-sdk/cli",
  version: "1.4.0",
  description: "CLI tool for Cord",
  main: "index.js",
  homepage: "https://docs.cord.com/reference/cord-cli",
  bin: {
    cord: "dist/index.js"
  },
  files: [
    "dist/index.js",
    "README.md",
    "LICENSE"
  ],
  repository: {
    type: "git",
    url: "https://github.com/getcord/cli"
  },
  scripts: {
    build: "npm run build-common -- --minify",
    dev: "tsc --watch --preserveWatchOutput & npm run build-common -- --watch",
    check: "tsc && eslint src",
    "build-common": "esbuild src/index.ts --outdir=dist --bundle --sourcemap --platform=node",
    test: "jest"
  },
  keywords: [],
  author: "",
  license: "MIT",
  devDependencies: {
    "@cord-sdk/types": "^1.34.0",
    "@cspell/eslint-plugin": "^7.3.2",
    "@types/cli-box": "^6.0.2",
    "@types/inquirer": "^9.0.3",
    "@types/jest": "^29.5.7",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/markdown-it": "^13.0.4",
    "@types/mime": "^3.0.2",
    "@types/node": "^20.5.7",
    "@types/shell-quote": "^1.7.5",
    "@types/yargs": "^17.0.24",
    "@typescript-eslint/eslint-plugin": "^6.5.0",
    esbuild: "^0.19.2",
    eslint: "^8.48.0",
    "eslint-config-prettier": "^9.0.0",
    "eslint-import-resolver-typescript": "^3.6.0",
    "eslint-plugin-import": "^2.28.1",
    "eslint-plugin-no-relative-import-paths": "^1.5.2",
    "eslint-plugin-prettier": "^5.0.0",
    jest: "^29.7.0",
    "ts-jest": "^29.1.1",
    typescript: "^5.2.2"
  },
  dependencies: {
    "@cord-sdk/server": "^1.31.2",
    chalk: "^5.3.0",
    "cli-box": "^6.0.10",
    "formdata-node": "^5.0.1",
    inquirer: "^9.2.11",
    jsonwebtoken: "^9.0.2",
    "markdown-it": "^13.0.2",
    mime: "^3.0.0",
    "node-fetch": "^3.3.2",
    "shell-quote": "^1.8.1",
    yargs: "^17.7.2"
  },
  jest: {
    preset: "ts-jest",
    testEnvironment: "node",
    transform: {
      "^.+\\.ts?$": "ts-jest"
    },
    transformIgnorePatterns: [
      "<rootDir>/node_modules/"
    ],
    roots: [
      "<rootDir>"
    ],
    modulePaths: [
      "<rootDir>"
    ]
  }
};

// server/src/public/routes/handlers/CliVersionHandler.ts
async function CliVersionHandler(_, res) {
  res.send({ version: package_default2.version });
}
var CliVersionHandler_default = forwardHandlerExceptionsToNext(CliVersionHandler);

// server/src/public/routes/permissions/ExperimentalPlatformPermissionHandlers.ts
function multify(x) {
  if (Array.isArray(x)) {
    return x;
  } else {
    return [x];
  }
}
function filterToJsonpath(filter) {
  const result = [];
  if (filter.id) {
    result.push(
      ...multify(filter.id).map((id) => `$.id == ${JSON.stringify(id)}`)
    );
  }
  if (filter.metadata) {
    result.push(
      ...Object.entries(filter.metadata).map(
        ([k, v]) => `$.metadata.${JSON.stringify(k)} == ${JSON.stringify(v)}`
      )
    );
  }
  if (result.length === 0) {
    throw new ApiCallerError("missing_field", { message: "Empty filter" });
  }
  return result.join(" && ");
}
async function assertFeatureFlagEnabled(req) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const app = await ApplicationEntity.findByPk(platformApplicationID);
  if (!app) {
    throw new ApiCallerError("invalid_access_token");
  }
  const enablePerms = await getTypedFeatureFlagValue(
    FeatureFlags2.GRANULAR_PERMISSIONS,
    flagsUserFromApplication(app)
  );
  if (!enablePerms) {
    throw new ApiCallerError("invalid_request", {
      code: 418,
      message: "Permissions aren't available yet, but we'd love to hear from you if you're this eager to try them out!"
    });
  }
  return app;
}
async function createPlatformPermissionHandler(req, res) {
  const app = await assertFeatureFlagEnabled(req);
  const rule = await PermissionRuleEntity.create({
    platformApplicationID: app.id,
    userSelector: filterToJsonpath(req.body.userFilter),
    resourceSelector: filterToJsonpath(req.body.resourceFilter),
    permissions: multify(req.body.permission)
  });
  return res.status(201).json({
    success: true,
    message: `\u2705 ${externalizeID(rule.id)}`
  });
}
async function deletePlatformPermissionHandler(req, res) {
  const app = await assertFeatureFlagEnabled(req);
  if (!isExternalizedID(req.params.ruleID)) {
    throw new ApiCallerError("invalid_request");
  }
  await PermissionRuleEntity.destroy({
    where: {
      id: extractInternalID(req.params.ruleID),
      platformApplicationID: app.id
    }
  });
  return res.status(200).json({
    success: true,
    message: "\u{1F480}"
  });
}
var ExperimentalPlatformPermissionHandlers_default = {
  create: forwardHandlerExceptionsToNext(createPlatformPermissionHandler),
  delete: forwardHandlerExceptionsToNext(deletePlatformPermissionHandler)
};

// server/src/public/routes/handlers/StripeWebhookHandler.ts
import Stripe2 from "stripe";

// server/src/util/stripe.ts
import Stripe from "stripe";
async function getStripeCustomerID(customerID) {
  const customer = await CustomerEntity.findOne({ where: { id: customerID } });
  if (!customer) {
    throw new Error("could not load customer");
  }
  return customer.stripeCustomerID;
}
async function updateSubscriptionData(subscription, eventType) {
  if (subscription.metadata.env !== Env_default.CORD_TIER) {
    return;
  }
  const internalCustomer = await CustomerEntity.findOne({
    where: { stripeCustomerID: subscription.customer }
  });
  if (!internalCustomer) {
    throw new Error("unknown customer to update");
  }
  internalCustomer.pricingTier = await getBillingTierFromSubscription(
    subscription,
    internalCustomer
  );
  internalCustomer.billingStatus = subscription.status;
  internalCustomer.billingType = "stripe";
  internalCustomer.renewalDate = new Date(
    subscription.current_period_end * 1e3
  );
  const savedInternalCustomer = await internalCustomer.save();
  await Promise.all([
    publishPubSubEvent(
      "customer-subscription-updated",
      {
        customerID: internalCustomer.id
      },
      { customerID: internalCustomer.id }
    ),
    sendSubscriptionUpdateToClack(eventType, savedInternalCustomer)
  ]);
}
async function getBillingTierFromSubscription(subscription, internalCustomer) {
  try {
    if (internalCustomer && internalCustomer.pricingTier !== "free") {
      return internalCustomer.pricingTier;
    }
    const items = subscription.items.data;
    if (items.length !== 1) {
      throw new Error("more than 1 item in subscription");
    }
    const product = items[0].plan.product;
    const productID = typeof product === "string" ? product : product?.id;
    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
    const stripeProduct = await stripe.products.retrieve(productID);
    return getPricingPlanFromStripePricingTier(
      stripeProduct.metadata["pricing_tier"]
    );
  } catch (e) {
    anonymousLogger().logException("Problem getting billing tier", e, {
      subscriptionID: subscription.id
    });
    throw e;
  }
}
function getPricingPlanFromStripePricingTier(stripePricingTier) {
  switch (stripePricingTier) {
    case "pro" /* PRO */:
      return "pro";
    case "scale" /* SCALE */:
      return "scale";
  }
  throw new Error(`unknown stripe pricing tier: "${stripePricingTier}"`);
}
async function sendSubscriptionUpdateToClack(eventType, internalCustomer) {
  let message = null;
  const customerAddress = `${ADMIN_ORIGIN}/customers/${internalCustomer.id}`;
  const plan = internalCustomer.pricingTier;
  const status = internalCustomer.billingStatus;
  switch (eventType) {
    case "customer.subscription.created":
      message = `\u{1F4B0}\u2795 New Stripe subscription (${plan}, ${status}) - ${internalCustomer.name} - ${customerAddress}`;
      break;
    case "customer.subscription.updated":
      message = `\u{1F4B0}\u270F\uFE0F Stripe subscription updated (${plan}, ${status}) - ${internalCustomer.name} - ${customerAddress}`;
      break;
    case "customer.subscription.deleted":
      message = `\u{1F4B0}\u2796 Stripe subscription cancelled (${plan}, ${status}) - ${internalCustomer.name} - ${customerAddress}`;
      break;
  }
  if (message === null) {
    return;
  }
  await sendMessageToCord(
    message,
    CORD_SELF_SERVE_SLACK_CHANNEL_ID,
    "selfserve"
  );
}
async function getSubscriptionData(customer) {
  const stripeCustomerID = await getStripeCustomerID(customer.id);
  if (!stripeCustomerID) {
    return null;
  }
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
  const [activeSubscriptions, pastDueSubscriptions] = await Promise.all([
    stripe.subscriptions.list({
      customer: stripeCustomerID,
      status: "active"
    }),
    stripe.subscriptions.list({
      customer: stripeCustomerID,
      status: "past_due"
    })
  ]);
  if (activeSubscriptions.data.length + pastDueSubscriptions.data.length > 1) {
    throw new Error(
      `More than one subscription for the customer ${customer.id}`
    );
  } else if (activeSubscriptions.data.length > 0) {
    return activeSubscriptions.data[0];
  } else if (pastDueSubscriptions.data.length > 0) {
    return pastDueSubscriptions.data[0];
  }
  return null;
}

// server/src/public/routes/handlers/StripeWebhookHandler.ts
async function StripeWebhookHandler(req, res) {
  const sig = req.headers["stripe-signature"];
  if (typeof sig !== "string") {
    return res.status(400).send("Unexpected value for signature header");
  }
  const stripe = new Stripe2(process.env.STRIPE_SECRET_KEY);
  const endpointSecret = process.env.STRIPE_WEBHOOK_SECRET_KEY;
  let event;
  try {
    event = stripe.webhooks.constructEvent(
      req.rawBody,
      sig,
      endpointSecret
    );
  } catch (e) {
    anonymousLogger().logException(
      "StripeWebhookHandler error constructing event",
      e
    );
    return res.status(400).send(`Webhook Error: ${e?.message}`);
  }
  if (!event) {
    return res.status(400).send("Could not get event");
  }
  try {
    switch (event.type) {
      case "customer.subscription.created":
      case "customer.subscription.updated":
      case "customer.subscription.deleted":
        await updateSubscriptionData(event.data.object, event.type);
        break;
      default:
        return res.status(400).send(`Unhandled event type: ${event.type}`);
    }
  } catch (e) {
    anonymousLogger().logException(
      "StripeWebhookHandler error handling event",
      e,
      { webhookID: event.id }
    );
    return res.status(400).send(`Webhook Error: ${e?.message}`);
  }
  return res.json({ received: true });
}
var StripeWebhookHandler_default = forwardHandlerExceptionsToNext(StripeWebhookHandler);

// server/src/public/routes/platform/org_members/ListPlatformOrganizationMembersHandler.ts
import { Op as Op23 } from "sequelize";
var DEFAULT_LIMIT4 = 1e3;
function encodeToken4(token) {
  return btoa(JSON.stringify(token));
}
async function listOrganizationMembersHandler(req, res) {
  const platformApplicationID = req.appID;
  if (!platformApplicationID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const externalID = req.params.orgID;
  if (!externalID) {
    throw new ApiCallerError("group_not_found");
  }
  if (!isValidExternalID(externalID)) {
    throw new ApiCallerError("invalid_request");
  }
  const org = await OrgEntity.findOne({
    where: {
      externalID,
      externalProvider: "platform" /* PLATFORM */,
      platformApplicationID
    }
  });
  if (!org) {
    throw new ApiCallerError("group_not_found", { code: 404 });
  }
  const where = {
    orgID: org.id
  };
  const { token, limit } = req.query;
  const decodedToken = validatePaginationToken({
    token,
    endpoint: "org-members"
  });
  const parsedLimit = validateLimit(limit, DEFAULT_LIMIT4);
  const whereWithPagination = {
    ...where,
    ...decodedToken && { userID: { [Op23.gt]: decodedToken.userID } }
  };
  const [members, membersCount, membersRemainingCount] = await Promise.all([
    OrgMembersEntity.findAll({
      where: whereWithPagination,
      order: [["userID", "ASC"]],
      limit: parsedLimit
    }),
    OrgMembersEntity.count({
      where
    }),
    OrgMembersEntity.count({
      where: whereWithPagination
    })
  ]);
  const remaining = Math.max(membersRemainingCount - members.length, 0);
  const memberUserIDs = members.map((member) => member.userID);
  const users = await UserEntity.findAll({
    where: {
      id: memberUserIDs,
      platformApplicationID
    },
    order: [["id", "ASC"]]
  });
  if (members.length > users.length) {
    throw new ApiCallerError("group_members_missing");
  }
  const lastMember = users.length === 0 ? null : users[users.length - 1];
  const returnToken = remaining > 0 && lastMember ? encodeToken4({
    userID: lastMember.id,
    // Adding the externalID is purely to get over the validating pagination token
    externalID: lastMember.externalID
  }) : null;
  const result = {
    users: users.map(
      (user) => ({
        id: user.externalID,
        email: user.email,
        status: user.state,
        name: user.name,
        shortName: user.screenName,
        profilePictureURL: user.profilePictureURL,
        metadata: user.metadata,
        createdTimestamp: user.createdTimestamp
      })
    ),
    pagination: {
      token: returnToken,
      total: membersCount
    }
  };
  return res.status(200).json(result);
}
var ListPlatformOrganizationMembersHandler_default = forwardHandlerExceptionsToNext(listOrganizationMembersHandler);

// server/src/public/routes/platform/customer/thoughtspot/ThoughtspotApplicationMigrationHandler.ts
import Ajv3 from "ajv";
import addFormat2 from "ajv-formats";
import { QueryTypes as QueryTypes23 } from "sequelize";
var MigrationAJVSchema = {
  type: "object",
  properties: {
    sourceApplicationID: { type: "string", format: "uuid" },
    sourceGroupID: { type: "string" },
    destinationApplicationID: { type: "string", format: "uuid" },
    destinationGroupID: { type: "string" }
  },
  required: [
    "sourceApplicationID",
    "sourceGroupID",
    "destinationApplicationID",
    "destinationGroupID"
  ],
  additionalProperties: false
};
var ajv3 = new Ajv3.default({
  verbose: true,
  coerceTypes: true
});
addFormat2.default(ajv3, ["uuid"]);
var validateInputAgainstSchema = ajv3.compile(MigrationAJVSchema);
function validateMigrationInput(input) {
  if (!validateInputAgainstSchema(input)) {
    throw new Error("Incorrect arguments to endpoint");
  }
}
async function ThoughtspotApplicationMigrationHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_request");
  }
  if (customerID !== "43fdeae8-4b68-4e36-a58d-56085f8e2497") {
    res.sendStatus(404).end();
    return;
  }
  validateMigrationInput(req.body);
  const {
    sourceApplicationID,
    sourceGroupID,
    destinationApplicationID,
    destinationGroupID
  } = req.body;
  const [sourceApp, sourceOrg, destinationApp, destinationOrg] = await Promise.all([
    ApplicationEntity.findOne({
      where: { id: sourceApplicationID, customerID }
    }),
    OrgEntity.findOne({
      where: {
        externalID: sourceGroupID,
        platformApplicationID: sourceApplicationID
      }
    }),
    ApplicationEntity.findOne({
      where: { id: destinationApplicationID, customerID }
    }),
    // Maybe allow findOrCreate or only create
    OrgEntity.findOne({
      where: {
        externalID: destinationGroupID,
        platformApplicationID: destinationApplicationID
      }
    })
  ]);
  if (!sourceApp) {
    throw new ApiCallerError("project_not_found", {
      message: `Unable to load project : ${sourceApplicationID}`
    });
  }
  if (!sourceOrg) {
    throw new ApiCallerError("group_not_found", {
      message: `Unable to load group : ${sourceGroupID}`
    });
  }
  if (!destinationApp) {
    throw new ApiCallerError("project_not_found", {
      message: `Unable to load project : ${destinationApplicationID}`
    });
  }
  if (destinationOrg) {
    throw new ApiCallerError("group_already_exists", {
      message: `Destination group (${destinationGroupID}) already exists`
    });
  }
  const possibleLinkedOrg = await LinkedOrgsEntity.findOne({
    where: { sourceOrgID: sourceOrg.id }
  });
  if (possibleLinkedOrg) {
    throw new ApiCallerError("invalid_request", {
      message: `This endpoint does not support migrating groups that are linked with Slack`
    });
  }
  if (sourceApplicationID === destinationApplicationID) {
    await sourceOrg.update({ externalID: destinationGroupID });
  } else {
    let bindVariables = [sourceApplicationID];
    const sequelize2 = getSequelize();
    await sequelize2.transaction(
      // { deferrable: Sequelize.Deferrable.SET_DEFERRED, logging: console.log },
      { deferrable: "SET CONSTRAINTS ALL DEFERRED;" },
      async (transaction) => {
        const usersInMoreThanOneOrg = await sequelize2.query(
          `
SELECT u."externalID"
FROM users u
INNER JOIN org_members om ON u.id=om."userID"
WHERE "platformApplicationID" = $1
GROUP BY u.id
HAVING count(1) > 1`,
          {
            type: QueryTypes23.SELECT,
            bind: bindVariables,
            transaction
          }
        );
        if (usersInMoreThanOneOrg.length) {
          throw new ApiCallerError("invalid_request", {
            message: `User(s) [${usersInMoreThanOneOrg.map((u) => u.externalID).join(", ")}] exist in more than one group`
          });
        }
        const newDestinationOrg = await OrgEntity.create(
          {
            state: "active",
            name: destinationGroupID,
            externalID: destinationGroupID,
            externalProvider: "platform" /* PLATFORM */,
            platformApplicationID: destinationApplicationID
          },
          { transaction }
        );
        bindVariables = [destinationApplicationID, sourceApplicationID];
        await sequelize2.query(
          `
UPDATE users
SET "platformApplicationID" = $1
WHERE "platformApplicationID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        bindVariables = [newDestinationOrg.id, sourceOrg.id];
        await sequelize2.query(
          `
UPDATE org_members
SET "orgID" = $1
WHERE "orgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE pages
SET "orgID" = $1
WHERE "orgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE thread_participants
SET "orgID" = $1
WHERE "orgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE page_visitors
SET "orgID" = $1
WHERE "orgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE user_hidden_annotations
SET "orgID" = $1
WHERE "orgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE email_notifications
SET "orgID" = $1, "threadOrgID" = $1
WHERE "orgID" = $2 AND "threadOrgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE message_notifications
SET "targetOrgID" = $1, "sharerOrgID" = $1
WHERE "targetOrgID" = $2 AND "sharerOrgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        bindVariables = [
          newDestinationOrg.id,
          destinationApplicationID,
          sourceOrg.id,
          sourceApplicationID
        ];
        await sequelize2.query(
          `
UPDATE threads
SET "orgID" = $1, "platformApplicationID" = $2
WHERE "orgID" = $3 AND "platformApplicationID" = $4`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE messages
SET "orgID" = $1, "platformApplicationID" = $2
WHERE "orgID" = $3 AND "platformApplicationID" = $4`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        bindVariables = [destinationApplicationID, newDestinationOrg.id];
        await sequelize2.query(
          `
UPDATE files f
SET "platformApplicationID" = $1
FROM messages m
INNER JOIN message_attachments ma on m.id = ma."messageID"
WHERE f.id = (ma.data->>'fileID')::uuid AND m."orgID" = $2 AND m."platformApplicationID" = $1`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
        await sequelize2.query(
          `
UPDATE notifications n
SET "platformApplicationID" = $1
FROM org_members om1, org_members om2
WHERE n."recipientID" = om1."userID" AND n."senderID" = om2."userID"
AND om1."orgID" = om2."orgID" AND om1."orgID" = $2`,
          {
            bind: bindVariables,
            type: QueryTypes23.UPDATE,
            transaction
          }
        );
      }
    );
  }
  return res.json({
    success: true,
    message: `\u2705 migration successful`
  });
}
var ThoughtspotApplicationMigrationHandler_default = forwardHandlerExceptionsToNext(
  ThoughtspotApplicationMigrationHandler
);

// server/src/public/routes/platform/customer/community/CommunityGetUserHandler.ts
async function CommunityGetUserHandler(req, res) {
  const platformApplicationID = req.appID;
  if (platformApplicationID !== "564ddd42-7d11-4ac0-b22c-3bb4e95a3ce2") {
    return res.sendStatus(404).end();
  }
  const userID = req.params.userID;
  const result = {};
  const consoleUser = await ConsoleUserEntity.findOne({
    where: { auth0UserID: userID }
  });
  if (!consoleUser) {
    return res.status(200).send({ result });
  }
  const customerID = consoleUser.customerID;
  if (!customerID) {
    return res.status(200).send(result);
  }
  const customer = await CustomerEntity.findByPk(customerID);
  if (!customer) {
    return res.status(200).send(result);
  }
  result.customerID = customer.id;
  result.customerName = customer.name;
  result.supportEnabled = customer.enableCustomerSupport || customer.pricingTier === "scale" && customer.billingStatus !== "inactive";
  return res.status(200).send(result);
}
var CommunityGetUserHandler_default = forwardHandlerExceptionsToNext(CommunityGetUserHandler);

// server/src/schema/operations.ts
import { execute, subscribe } from "graphql";

// server/src/schema/resolvers.ts
import { GraphQLJSON as GraphQLJSON2, GraphQLJSONObject } from "graphql-type-json";
import { makeExecutableSchema } from "@graphql-tools/schema";

// server/src/public/queries/thread_by_external_id.ts
import { v4 as uuid19 } from "uuid";
import { Op as Op24 } from "sequelize";
var threadByExternalID2QueryResolver = async (_, { input: { externalThreadID } }, context) => {
  if (!isExternalizedID(externalThreadID) && !isValidExternalID(externalThreadID)) {
    throw new Error("external threadID is not valid");
  }
  const { viewer } = context.session;
  const platformApplicationID = assertViewerHasPlatformApplicationID(viewer);
  return await serializableTransactionWithRetries(async (transaction) => {
    const thread = await context.loaders.threadLoader.loadByExternalIDStrictOrgCheck(
      externalThreadID,
      transaction
    );
    if (thread) {
      return { id: thread.id, thread };
    } else {
      const orgIDs = assertViewerHasOrgs(viewer);
      const externalThreadIDUsedInDifferentOrg = await ThreadEntity.findOne({
        where: {
          externalID: externalThreadID,
          platformApplicationID,
          orgID: { [Op24.notIn]: orgIDs }
        },
        transaction
      });
      if (externalThreadIDUsedInDifferentOrg) {
        throw new ClientFacingError(
          "Thread ID is already in use by another group in this application"
        );
      }
    }
    if (isExternalizedID(externalThreadID)) {
      return {
        id: extractInternalID(externalThreadID),
        thread: null
      };
    }
    const [threadID] = await PreallocatedThreadIDEntity.findOrCreate({
      where: {
        platformApplicationID,
        externalID: externalThreadID
      },
      defaults: {
        id: uuid19(),
        platformApplicationID,
        externalID: externalThreadID
      },
      transaction
    });
    return {
      id: threadID.id,
      thread: null
    };
  });
};

// server/src/util/graphql-iso-date.js
import mod from "graphql-iso-date";
var GraphQLDate = mod.GraphQLDate;
var GraphQLTime = mod.GraphQLTime;
var GraphQLDateTime = mod.GraphQLDateTime;

// server/src/util/graphql-type-uuid.js
import GraphQLUUID from "graphql-type-uuid";
var graphql_type_uuid_default = GraphQLUUID;

// server/src/public/mutations/share_thread_to_email.ts
import addrs2 from "email-addresses";

// server/src/public/mutations/util/sendErrors.ts
function sendErrors(func) {
  return async (...args) => {
    try {
      return await func(...args);
    } catch (error) {
      if (error instanceof ApiCallerError || error instanceof ClientFacingError) {
        return {
          success: false,
          failureDetails: {
            code: error.name,
            message: error.message
          }
        };
      }
      throw error;
    }
  };
}

// server/src/public/mutations/share_thread_to_email.ts
var shareThreadToEmailResolver = sendErrors(async (_, args, originalContext) => {
  const { threadID, email, screenshotID, byExternalID } = args;
  const parsedEmailAddress = addrs2.parseOneAddress(email);
  const validDomain = parsedEmailAddress?.type === "mailbox" && parsedEmailAddress.domain.includes(".");
  if (!parsedEmailAddress || !validDomain) {
    throw new ApiCallerError("invalid_email");
  }
  const thread = byExternalID ? await originalContext.loaders.threadLoader.loadByExternalID(threadID) : await originalContext.loaders.threadLoader.loadThread(threadID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  const context = await getRelevantContext(originalContext, thread.orgID);
  const { viewer } = context.session;
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  const customerID = context.application?.customerID;
  const [forceShareViaEmailEnabled, shareViaEmailEnabled] = await Promise.all(
    [
      context.loaders.userPreferenceLoader.loadPreferenceValueForViewer(
        "email_sharing" /* EMAIL_SHARING */
      ),
      getTypedFeatureFlagValue(FeatureFlags2.EMAIL_SHARING, {
        userID,
        orgID,
        platformApplicationID: viewer.platformApplicationID ?? "extension",
        version: context.clientVersion,
        customerID
      })
    ]
  );
  if (shareViaEmailEnabled !== true && forceShareViaEmailEnabled !== true) {
    throw new ApiCallerError("invalid_request", {
      message: "Unable to share via email"
    });
  }
  const [sender, [lastMessage]] = await Promise.all([
    context.loaders.userLoader.loadUserInAnyViewerOrg(userID),
    context.loaders.messageLoader.loadMessages({
      threadID: thread.id,
      ignoreDeleted: true,
      range: -1
    })
  ]);
  if (!sender || !thread || !lastMessage) {
    context.logger.error(
      "Failed to share email because a required entity failed to load",
      {
        userID,
        fetched_user_id: sender?.id,
        threadID: thread.id,
        fetched_thread_id: thread?.id,
        fetched_last_message: lastMessage.id,
        email
      }
    );
    throw new ApiCallerError("invalid_request", {
      message: "Unable to share via email"
    });
  }
  let partnerDetails = void 0;
  if (sender.platformApplicationID) {
    const application = await context.loaders.applicationLoader.load(
      sender.platformApplicationID
    );
    partnerDetails = application?.customEmailTemplate ?? void 0;
  }
  const featureFlagUser = flagsUserFromContext(context);
  const injectDeeplinkQueryParams = await getFeatureFlagValue(
    "query_param_deep_links_in_share_to_slack" /* QUERY_PARAM_DEEP_LINKS_IN_SHARE_TO_SLACK */,
    featureFlagUser
  );
  let notificationURL = lastMessage.url || thread.url;
  if (injectDeeplinkQueryParams === true) {
    notificationURL = injectDeeplinkQueryParamsV1(
      context.logger,
      notificationURL,
      thread.id,
      lastMessage.id
    );
  }
  let targetUserID = null;
  const potentialEmailUsers = await context.loaders.userLoader.loadUserForEmailInOrg(email, orgID);
  if (potentialEmailUsers.length === 1) {
    targetUserID = potentialEmailUsers[0].id;
  }
  notificationURL = await generateOutboundNotificationLoggingURL({
    messageID: lastMessage.id,
    url: notificationURL,
    targetOrgID: orgID,
    targetUserID,
    type: "sharedToEmail",
    platformApplicationID: viewer.platformApplicationID,
    metadata: {
      type: "sharedToEmail",
      targetEmail: email
    },
    sharerUserID: userID,
    sharerOrgID: orgID
  });
  const messageAttachments = await context.loaders.messageAttachmentLoader.loadAttachmentsForMessage(
    lastMessage.id
  );
  const files = await context.loaders.fileLoader.loadFiles(
    getFileAttachmentEntities(messageAttachments).map((attachment) => {
      switch (attachment.type) {
        case "file" /* FILE */:
          return attachment.data.fileID;
        case "annotation" /* ANNOTATION */: {
          const data = attachment.data;
          return data.blurredScreenshotFileID ?? data.screenshotFileID;
        }
        case "screenshot" /* SCREENSHOT */: {
          const data = attachment.data;
          return data.blurredScreenshotFileID ?? data.screenshotFileID;
        }
        default:
          return null;
      }
    }).filter(isDefined)
  );
  const imageURLs = files.filter((file) => isInlineDisplayableImage(file.mimeType)).map((file) => file.getPermanentDownloadURL());
  const nonImageAttachmentNames = files.filter((file) => !isInlineDisplayableImage(file.mimeType)).map((file) => file.name);
  if (screenshotID && imageURLs.length === 0) {
    const screenshotFile = await context.loaders.fileLoader.loadFile(screenshotID);
    if (screenshotFile) {
      imageURLs.push(screenshotFile.getPermanentDownloadURL());
    } else {
      context.logger.error(
        "Failed to share email because a screenshotFile failed to load",
        {
          screenshotID,
          userID,
          threadID: thread.id,
          last_message: lastMessage.id,
          email
        }
      );
    }
  }
  const getThreadDetailsArgs = {
    threadID: thread.id,
    currentMessage: lastMessage,
    userID,
    sender,
    currentMessageAttachments: imageURLs,
    currentFileAttachments: nonImageAttachmentNames,
    context
  };
  const threadDetails = await getThreadDetails(getThreadDetailsArgs);
  if (!threadDetails) {
    context.logger.error(
      "Failed to share email because building threadDetails failed",
      {
        threadID,
        currentMessage: lastMessage.id,
        userID,
        sender: sender.id,
        currentMessageAttachments: imageURLs,
        currentFileAttachments: nonImageAttachmentNames,
        email
      }
    );
    throw new ApiCallerError("thread_not_found");
  }
  let emailNotification = null;
  if (targetUserID) {
    emailNotification = await EmailOutboundNotificationEntity.create({
      userID: targetUserID,
      orgID,
      threadID: thread.id,
      email,
      // Target user may not be in same org - could instead be part of Slack org
      threadOrgID: thread.orgID
    });
  }
  const templateID = await getTemplateIDForNotification({
    notificationActionType: "share_to_email",
    context,
    featureFlagUser
  });
  const success = await sendShareThreadToEmailEmail(
    context,
    email,
    thread.name,
    notificationURL,
    partnerDetails,
    threadDetails,
    emailNotification,
    templateID
  );
  return { success, failureDetails: null };
});

// server/src/public/mutations/add_thread_to_slack_channel.ts
var addThreadToSelectedSlackChannelResolver = sendErrors(async (_, args, originalContext) => {
  const { slackChannelID, threadID, installBot, byExternalID } = args;
  const thread = byExternalID ? await originalContext.loaders.threadLoader.loadByExternalID(threadID) : await originalContext.loaders.threadLoader.loadThread(threadID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  const org = await originalContext.loaders.orgLoader.loadOrg(thread.orgID);
  if (!org) {
    throw new ApiCallerError("group_not_found");
  }
  const slackOrg = await org.loadLinkedSlackOrg();
  if (!slackOrg) {
    throw new ApiCallerError("group_not_connected_to_slack");
  }
  const context = await getRelevantContext(originalContext, thread.orgID);
  const { viewer } = context.session;
  const userID = assertViewerHasUser(viewer);
  const sharerUser = await context.loaders.userLoader.loadUserInAnyViewerOrg(userID);
  if (!sharerUser) {
    throw new ApiCallerError("user_not_found");
  }
  const authData = await findSlackBotCredentials(context);
  if (!authData) {
    throw new ApiCallerError("slack_credentials_not_found");
  }
  const slackChannel = await context.loaders.slackChannelLoader.loadSlackChannel(slackChannelID);
  if (!slackChannel) {
    throw new ApiCallerError("slack_channel_not_found", {
      message: `Cannot load slack channel ${slackChannelID}`
    });
  }
  if (slackChannel.added || installBot) {
    await addCordBotToSlackChannels(context, authData.bot_access_token, [
      slackChannelID
    ]);
  } else {
    return { success: false, failureDetails: null };
  }
  const success = await addThreadToSelectedSlackChannel(
    context,
    authData,
    slackChannelID,
    sharerUser,
    thread.id,
    "internal"
  );
  return { success, failureDetails: null };
});

// server/src/public/mutations/create_file.ts
var createFileMutationResolver = async (_, args, originalContext) => {
  const { id, name, mimeType, size, provider, application, threadOrgID } = args;
  if (provider !== void 0) {
    deprecated("createFile: provider");
  }
  if (application !== void 0) {
    deprecated("createFile: application");
  }
  assertValid(
    validateFileForUpload("attachment", { name, mimeType, size: size ?? 0 })
  );
  const context = await getRelevantContext(originalContext, threadOrgID);
  const mutator = new FileMutator(context.session.viewer, context.loaders);
  const file = await mutator.createFileForUpload(
    id,
    name,
    mimeType,
    size ?? 0,
    void 0
  );
  return {
    uploadURL: size ? await file.getSignedUploadURL(context.loaders.s3BucketLoader) : null,
    downloadURL: await file.getSignedDownloadURL(
      context.loaders.s3BucketLoader
    )
  };
};

// server/src/public/mutations/create_reaction.ts
var createMessageReactionResolver = sendErrors(async (_, args, context) => {
  const { messageID, unicodeReaction } = args;
  const message = await context.loaders.messageLoader.loadMessage(messageID);
  if (!message) {
    return {
      success: false,
      failureDetails: null
    };
  }
  const thread = await context.loaders.threadLoader.loadThread(
    message.threadID
  );
  if (!thread) {
    return {
      success: false,
      failureDetails: null
    };
  }
  const { externalUserID } = assertViewerHasPlatformUser(
    context.session.viewer
  );
  const relevantContext = await getRelevantContext(context, message.orgID);
  await updateThreadMessage({
    context: relevantContext,
    thread,
    message,
    addReactions: [
      {
        reaction: unicodeReaction,
        userID: externalUserID
      }
    ]
  });
  return {
    success: true,
    failureDetails: null
  };
});

// server/src/public/mutations/create_thread_message.ts
import { UniqueConstraintError } from "sequelize";

// common/page_context/util.ts
import { parse as parse6 } from "url";
var inboxCountPrefixRegex = /^(\([0-9]+\)) (.+)$/;
function stripInboxCountPrefix(title) {
  const trimmedTitle = title.trim();
  const match = trimmedTitle.match(inboxCountPrefixRegex);
  if (!match) {
    return trimmedTitle;
  }
  if (match[2]) {
    return match[2].trim();
  }
  return trimmedTitle;
}

// server/src/public/mutations/create_thread_message.ts
var createThreadMessageResolver = async (_, args, originalContext) => {
  const { viewer: originalViewer } = originalContext.session;
  const {
    content: internalContent,
    externalContent,
    messageID,
    threadID,
    url: url6,
    fileAttachments,
    createNewThread,
    newThreadMetadata,
    newMessageMetadata,
    annotationAttachments,
    screenshotAttachment,
    task,
    pageName,
    threadOptions,
    externalMessageID,
    addReactions,
    iconURL,
    translationKey,
    extraClassnames,
    createThread: createThread2
  } = args.input;
  const { userID, platformApplicationID } = assertViewerHasPlatformUser(originalViewer);
  if (createNewThread) {
    assertViewerHasSingleOrgForWrite(
      originalViewer,
      "Thread ID does not exist and could not be created because a group ID was not specified for the new thread"
    );
  }
  if (args.input.type !== void 0) {
    deprecated("graphql: createThreadMessage type", platformApplicationID);
    if (args.input.type && args.input.type !== "user_message") {
      throw new ApiCallerError("invalid_field", {
        message: "Only user_messages can be sent with the JS API"
      });
    }
  }
  const pageMutator = new PageMutator(originalViewer);
  const application = await ApplicationEntity.findByPk(platformApplicationID);
  if (!application) {
    throw new Error(
      `Cannot access the create a new thread message resolver without having an application ID.`
    );
  }
  if (internalContent !== void 0) {
    deprecated(
      "create_thread_message: internalContent",
      platformApplicationID
    );
  }
  async function fetchPageAndExistingThread() {
    let page2;
    let existingThread2;
    if (createNewThread) {
      const pageContext = toPageContext(args.input.pageContext);
      const pageContextHash = pageContext && await pageMutator.createPageIfNotExists(pageContext);
      if (!pageContext || !pageContextHash || !url6) {
        throw new Error(`Thread cannot be created in null page context`);
      }
      page2 = await originalContext.loaders.pageLoader.getPageFromContextHash(
        pageContextHash
      );
    } else {
      existingThread2 = await originalContext.loaders.threadLoader.loadThread(threadID) ?? void 0;
      if (!existingThread2) {
        throw new Error("No thread found for reply");
      }
      page2 = await originalContext.loaders.pageLoader.loadPrimaryPageForThreadNoOrgCheck(
        threadID
      );
    }
    if (!page2) {
      throw new Error("No page found");
    }
    return [page2, existingThread2];
  }
  const [page, existingThread] = await fetchPageAndExistingThread();
  const content = externalContent ? await internalizeContent(
    externalContent,
    platformApplicationID,
    existingThread?.orgID ?? assertViewerHasOrg(originalViewer)
  ) : internalContent;
  if (!content) {
    throw new Error("No content");
  }
  validateMessageContent(content);
  const initialMessageCount = existingThread ? await originalContext.loaders.threadLoader.loadMessagesCountNoOrgCheck(
    existingThread.id
  ) : 0;
  const isFirstMessageOrNewThread = createNewThread || initialMessageCount === 0;
  let thread;
  let message;
  try {
    [message, thread] = await serializableTransactionWithRetries(
      async (transaction) => {
        let thread2 = existingThread;
        if (createNewThread) {
          if (!url6) {
            throw new Error(
              "Logic error: should have thrown in fetchPageAndExistingThread"
            );
          }
          const threadName = createThread2?.name ?? (pageName ? stripInboxCountPrefix(pageName) : url6);
          const threadIDEntity = await PreallocatedThreadIDEntity.findOne({
            where: {
              platformApplicationID,
              id: threadID
            },
            transaction
          });
          thread2 = await new ThreadMutator(
            originalViewer,
            originalContext.loaders
          ).createThreadOnPage(
            threadID,
            createThread2?.url ?? url6,
            page,
            threadName,
            transaction,
            application.id,
            threadIDEntity?.externalID ?? null,
            newThreadMetadata ?? createThread2?.metadata ?? {},
            createThread2?.extraClassnames,
            createThread2?.addSubscribers ?? threadOptions?.additionalSubscribersOnCreate
          );
        }
        if (!thread2) {
          throw new Error("Failed to find or create thread");
        }
        const messageMutator = new MessageMutator(
          originalViewer,
          originalContext.loaders
        );
        const reactionMutator = new MessageReactionMutator(
          originalViewer,
          originalContext.loaders
        );
        const message2 = await messageMutator.createMessage(
          {
            id: messageID,
            externalID: externalMessageID ?? void 0,
            thread: thread2,
            content,
            url: url6 ?? null,
            iconURL: iconURL ?? void 0,
            translationKey: translationKey ?? void 0,
            extraClassnames: extraClassnames ?? void 0,
            metadata: newMessageMetadata ?? {}
          },
          transaction
        );
        await Promise.all(
          (addReactions ?? []).map(async (reaction) => {
            return await reactionMutator.createOne(
              message2.id,
              reaction,
              void 0,
              transaction
            );
          })
        );
        return [message2, thread2];
      }
    );
  } catch (e) {
    if (e instanceof UniqueConstraintError && !process.env.IS_TEST) {
      return { success: true, failureDetails: null };
    }
    throw e;
  }
  const granularPermissionsEnabled = await getTypedFeatureFlagValue(
    FeatureFlags2.GRANULAR_PERMISSIONS,
    flagsUserFromContext(originalContext)
  );
  let context;
  if (granularPermissionsEnabled) {
    context = originalContext;
  } else {
    context = await getRelevantContext(originalContext, thread.orgID);
  }
  const flagsUser = {
    userID,
    orgID: thread.orgID,
    platformApplicationID: application?.id ?? "extension",
    version: context.clientVersion,
    customerID: application?.customerID
  };
  await executeNewMessageCreationTasks({
    context,
    flagsUser,
    application,
    page,
    thread,
    message,
    fileAttachments,
    annotationAttachments,
    screenshotAttachment,
    isFirstMessage: isFirstMessageOrNewThread,
    task,
    subscribeToThread: true
  });
  return { success: true, failureDetails: null };
};

// server/src/public/mutations/delete_reaction.ts
var deleteMessageReactionMutationResolver = sendErrors(async (_, args, context) => {
  const { messageID, reactionID } = args;
  const [message, reaction] = await Promise.all([
    context.loaders.messageLoader.loadMessage(messageID),
    context.loaders.messageReactionLoader.loadReactionNoOrgCheck(reactionID)
  ]);
  if (!message || !reaction) {
    return {
      success: false,
      failureDetails: null
    };
  }
  const thread = await context.loaders.threadLoader.loadThread(
    message.threadID
  );
  if (!thread) {
    return {
      success: false,
      failureDetails: null
    };
  }
  const { externalUserID } = assertViewerHasPlatformUser(
    context.session.viewer
  );
  const relevantContext = await getRelevantContext(context, message.orgID);
  await updateThreadMessage({
    context: relevantContext,
    thread,
    message,
    removeReactions: [
      {
        reaction: reaction.unicodeReaction,
        userID: externalUserID
      }
    ]
  });
  return {
    success: true,
    failureDetails: null
  };
});

// server/src/public/mutations/disconnect_third_party.ts
var disconnectThirdPartyMutationResolver = async (_, args, context) => {
  const { connectionType } = args;
  const success = await removeExternalConnection(
    context.session.viewer,
    connectionType
  );
  return {
    success,
    failureDetails: null
  };
};

// server/src/public/mutations/log_events.ts
var eventCountMetric = Counter2({
  name: "ClientEvent",
  help: "Log events received from the client",
  labelNames: ["type", "appID"]
});
var logEventsMutationResolver = async (_, args, context) => {
  const events = args.events;
  events.forEach((event) => {
    const level = event.logLevel;
    if (level === "debug") {
      context.segmentLogger.partnerLog(
        event.type,
        { installationID: event.installationID, ...event.metadata },
        event.payload,
        event.customEventMetadata ?? void 0
      );
    }
    let combinedMessage = event.type;
    if ("message" in event.payload) {
      combinedMessage += `: ${event.payload.message}`;
    }
    context.logger.log(
      level,
      combinedMessage,
      {
        pageLoadID: event.pageLoadID,
        installationID: event.installationID,
        eventNumber: event.eventNumber,
        ...event.payload,
        ...event.metadata,
        version: context.clientVersion,
        message: void 0
      },
      {
        // make sure Sentry won't aggregate too much into one issue, just
        // because we log everything from this place in the code.
        // See https://docs.sentry.io/platforms/javascript/usage/sdk-fingerprinting/#group-errors-with-greater-granularity
        // In addition to the default attributes, we make `event.type` part of
        // the fingerprint
        sentryFingerPrint: ["{{ default }}", event.type]
      }
    );
    eventCountMetric.inc({
      type: event.type,
      appID: context.session.viewer.platformApplicationID ?? "null"
    });
  });
  const promises = events.map(
    (event) => new EventMutator(context.session).createEvent(
      event,
      context.clientVersion,
      context.deployment
    )
  );
  const created = await Promise.all(promises);
  return events.length === created.filter((result) => !!result).length;
};

// server/src/public/mutations/set_file_upload_status.ts
var setFileUploadStatusMutationResolver = async (_, args, originalContext) => {
  const { id, status, threadOrgID } = args;
  const context = await getRelevantContext(originalContext, threadOrgID);
  const { viewer } = context.session;
  const fileMutator = new FileMutator(viewer, context.loaders);
  const file = await fileMutator.setFileUploadStatus(id, status);
  if (!file) {
    return { success: false, failureDetails: null };
  }
  const attachmentLoader = context.loaders.messageAttachmentLoader;
  const attachment = await attachmentLoader.getAttachmentFromFileID(id);
  if (attachment) {
    const messageLoader = context.loaders.messageLoader;
    const message = await messageLoader.loadMessage(attachment.messageID);
    if (message) {
      backgroundPromise(
        publishPubSubEvent(
          "thread-message-updated",
          { threadID: message.threadID },
          { messageID: message.id }
        ),
        context.logger
      );
    }
  }
  return {
    success: true,
    failureDetails: null
  };
};

// server/src/public/mutations/set_preference.ts
var MAX_VALUE_SIZE_BYTES = 1024;
var setPreferenceMutationResolver = async (_, args, context) => {
  const { key, value } = args;
  if (JSON.stringify(value).length >= MAX_VALUE_SIZE_BYTES) {
    throw new ApiCallerError("invalid_request", {
      message: "Value too large"
    });
  }
  const mutator = new UserPreferenceMutator(context.session.viewer);
  await mutator.setViewerPreference(key, value);
  return null;
};

// server/src/public/mutations/set_subscribed.ts
var setSubscribedMutationResolver = async (_, args, originalContext) => {
  const { threadID, subscribed } = args;
  const thread = await originalContext.loaders.threadLoader.loadThread(threadID);
  if (!thread) {
    throw new Error("Thread does not exist");
  }
  const context = await getRelevantContext(originalContext, thread.orgID);
  const originalSubscribers = new Set(
    await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  const threadParticipantMutator = new ThreadParticipantMutator(
    context.session.viewer,
    context.loaders
  );
  await threadParticipantMutator.setViewerSubscribed(thread, subscribed);
  const newSubscribers = new Set(
    await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  const removed = [...originalSubscribers].filter(
    (s) => !newSubscribers.has(s)
  );
  const added = [...newSubscribers].filter(
    (s) => !originalSubscribers.has(s)
  );
  if (removed.length > 0 || added.length > 0) {
    backgroundPromise(
      publishPubSubEvent(
        "thread-filterable-properties-updated",
        { orgID: thread.orgID },
        { threadID, changes: { subscribers: { added, removed } } }
      )
    );
  }
  return true;
};

// server/src/public/mutations/set_typing.ts
var setTypingMutationResolver = async (_, args, context) => {
  const { viewer } = context.session;
  const userID = assertViewerHasUser(viewer);
  const { typing, threadID } = args;
  const thread = await context.loaders.threadLoader.loadThread(threadID);
  if (!thread) {
    return false;
  }
  await setUserTyping(context.logger, threadID, userID, typing);
  return true;
};

// server/src/public/mutations/update_message.ts
var updateMessageResolver = async (_, args, originalContext) => {
  const {
    id,
    content,
    fileAttachments,
    annotationAttachments,
    deleted,
    task
  } = args;
  const message = await originalContext.loaders.messageLoader.loadMessage(id);
  if (message === null) {
    return {
      success: false,
      failureDetails: null
    };
  }
  if (message.type !== "user_message") {
    originalContext.logger.warn("Message cannot be updated", {
      messageID: message.id,
      messageType: message.type
    });
    return {
      success: false,
      failureDetails: null
    };
  }
  const context = await getRelevantContext(originalContext, message.orgID);
  const viewer = context.session.viewer;
  const thread = await ThreadEntity.findOne({
    where: {
      id: message.threadID,
      platformApplicationID: viewer.platformApplicationID
    }
  });
  if (!thread) {
    throw new ApiCallerError("thread_not_found", {
      message: `Could not find thread for message ${id}`
    });
  }
  const originalSubscribers = new Set(
    await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  const messageMutator = new MessageMutator(viewer, context.loaders);
  const wasDeletedOrUndeleted = deleted !== void 0 && deleted !== null;
  if (wasDeletedOrUndeleted) {
    await messageMutator.setDeleted(message, deleted);
  } else if (content !== void 0 && content !== null) {
    await messageMutator.updateContent(context.logger, message, content);
  }
  let newContentMessage = message;
  if (content !== void 0 && content !== null) {
    const updatedMessage = await context.loaders.messageLoader.loadMessage(id);
    if (updatedMessage === null) {
      context.logger.error(
        "Failed to re-load message after updating content",
        {
          messageID: id,
          userID: viewer.userID,
          orgID: viewer.orgID
        }
      );
      return {
        success: false,
        failureDetails: null
      };
    }
    newContentMessage = updatedMessage;
  }
  await executeUpdateMessageTasks({
    context,
    message: newContentMessage,
    thread,
    task,
    fileAttachments,
    annotationAttachments,
    wasDeletedOrUndeleted,
    content,
    originalSubscribers
  });
  return {
    success: true,
    failureDetails: null
  };
};

// server/src/public/queries/feature_flags.ts
var featureFlagsQueryResolver = async (_, args, context) => {
  const user = flagsUserFromContext(context);
  const flagValues = await Promise.all(
    args.keys.map(
      (key) => getFeatureFlagValue(key, user).then((value) => ({ key, value }))
    )
  );
  return flagValues.filter(
    (fv) => fv.value !== null
  );
};

// server/src/public/queries/ping.ts
var pingQueryResolver = () => "pong";

// server/src/public/queries/task.ts
var taskQueryResolver = async (_, args, context) => {
  const { orgID } = assertViewerHasIdentity(context.session.viewer);
  return await context.loaders.taskLoader.loadTask(args.id, orgID);
};

// server/src/public/queries/thread.ts
var threadQueryResolver = async (_, args, context) => {
  const { threadID } = args;
  const thread = await context.loaders.threadLoader.loadThread(threadID);
  if (!thread) {
    throw new Error("threadID does not exist");
  }
  return thread;
};

// server/src/auth/encodeSessionToJWT.ts
import { sign as sign9 } from "jsonwebtoken";
function encodeSessionToJWT(session, expiresInSeconds) {
  return sign9(session, Env_default.JWT_SIGNING_SECRET, { expiresIn: expiresInSeconds });
}

// server/src/public/queries/viewer.ts
var viewerQueryResolver = () => ({});
var viewerResolver = {
  accessToken: async (_, args, context) => {
    if (args.groupID !== void 0) {
      deprecated(
        "Viewer:AccessToken:groupID",
        context.session.viewer.platformApplicationID
      );
    }
    const expiresInSeconds = CLIENT_VERSION_MAX_DAYS_OLD * 24 * 60 * 60;
    if (args.groupID) {
      const viwerCanAccessOrg = await context.loaders.orgMembersLoader.viewerCanAccessOrg(args.groupID);
      if (!viwerCanAccessOrg) {
        throw new Error("Viewer not part of org");
      }
      const org = await context.loaders.orgLoader.loadOrg(args.groupID);
      if (!org) {
        throw new Error("Group not found");
      }
      const viewer = context.session.viewer;
      const viewerWithOrg = viewer.viewerInOtherOrg(
        args.groupID,
        org.externalID
      );
      return encodeSessionToJWT(
        { ...context.session, viewer: viewerWithOrg },
        expiresInSeconds
      );
    }
    return encodeSessionToJWT(context.session, expiresInSeconds);
  },
  user: async (_, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const user = await context.loaders.userLoader.loadUserInAnyViewerOrg(userID);
    if (!user) {
      throw new Error("Could not load user");
    }
    return user;
  },
  organization: async (_, _args, context) => {
    const { orgID } = context.session.viewer;
    if (!orgID) {
      return null;
    }
    const org = await context.loaders.orgLoader.loadOrg(orgID);
    if (!org) {
      throw new Error("Could not load org");
    }
    return org;
  },
  inbox: async (_, _args, context) => {
    assertViewerHasUser(context.session.viewer);
    return {};
  },
  email: async (_, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const user = await context.loaders.userLoader.loadUserInAnyViewerOrg(userID);
    if (user === null) {
      context.logger.error("Failed to load profile from DB", {
        userID
      });
      return null;
    }
    return user.email;
  },
  isSlackConnected: async (_, _args, context) => {
    if (!viewerHasIdentity(context.session.viewer)) {
      return false;
    }
    const userID = assertViewerHasUser(context.session.viewer);
    const user = await context.loaders.userLoader.loadSlackUserForUserOrgScoped(
      context,
      userID
    );
    return !!user;
  },
  thirdPartyConnection: (_, args) => args,
  deepLinkInfo: async (_, _args, context) => {
    if (!viewerHasIdentity(context.session.viewer)) {
      return null;
    }
    const userID = assertViewerHasUser(context.session.viewer);
    return await getDeepLinkThreadMessageID(userID);
  }
};
var viewerIdentityResolver = {
  user: viewerResolver.user,
  organization: viewerResolver.organization,
  email: viewerResolver.email,
  isSlackConnected: viewerResolver.isSlackConnected,
  organizations: async (_, _args, context) => {
    assertViewerHasUser(context.session.viewer);
    const result = await context.loaders.orgMembersLoader.loadAllImmediateOrgsForUser();
    return result;
  }
};

// server/src/public/subscriptions/inbox.ts
var inboxSubscriptionResolver = {
  resolve: async (_, _args, context) => {
    assertViewerHasUser(context.session.viewer);
    return {};
  },
  subscribe: (_root, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    return withRestartEvent({
      events: [["inbox-updated", { userID }]],
      userID,
      subscriptionName: "inboxSubscriptionResolver"
    })();
  }
};

// server/src/public/subscriptions/preferences.ts
var preferencesLiveQuerySubscriptionResolver = {
  resolve: (parent) => parent,
  subscribe: (_root, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    return liveQuery(
      [["user-preference-updated", { userID }]],
      async () => {
        const rows = await UserPreferenceEntity.findAll({
          where: { userID }
        });
        return {
          data: Object.fromEntries(
            rows.map(({ key, value }) => [key, value])
          )
        };
      },
      async (event) => {
        const key = event.payload.key;
        const row = await UserPreferenceEntity.findOne({
          where: {
            userID,
            key
          }
        });
        if (row) {
          return {
            update: { [row.key]: row.value }
          };
        } else {
          return {
            delete: [key]
          };
        }
      }
    );
  }
};

// server/src/public/subscriptions/thread_events.ts
var threadEventsSubscriptionResolver = {
  resolve: (payload) => payload,
  subscribe: (_root, { threadID }) => pubSubAsyncIterator(
    // this must map to the ThreadEvents type definition in mapping.ts
    ["thread-created", { threadID }],
    ["thread-message-added", { threadID }],
    ["thread-message-updated", { threadID }],
    ["thread-message-content-appended", { threadID }],
    ["thread-message-removed", { threadID }],
    ["thread-participants-updated-incremental", { threadID }],
    ["thread-typing-users-updated", { threadID }],
    ["thread-properties-updated", { threadID }],
    ["thread-share-to-slack", { threadID }],
    ["thread-subscriber-updated", { threadID }],
    ["thread-deleted", { threadID }]
  )
};
var threadEventTypeResolver = {
  __resolveType: (event) => {
    switch (event.name) {
      case "thread-created":
        return ThreadCreatedTypeName;
      case "thread-message-added":
        return ThreadMessageAddedTypeName;
      case "thread-message-updated":
        return ThreadMessageUpdatedTypeName;
      case "thread-message-content-appended":
        return ThreadMessageContentAppendedTypeName;
      case "thread-message-removed":
        return ThreadMessageRemovedTypeName;
      case "thread-participants-updated-incremental":
        return ThreadParticipantsUpdatedIncrementalTypeName;
      case "thread-typing-users-updated":
        return ThreadTypingUsersUpdatedTypeName;
      case "thread-share-to-slack":
        return ThreadShareToSlackTypeName;
      case "thread-properties-updated":
        return ThreadPropertiesUpdatedTypeName;
      case "thread-subscriber-updated":
        return ThreadSubscriberUpdatedTypeName;
      case "thread-deleted":
        return ThreadDeletedTypeName;
    }
  }
};

// server/src/schema/file.ts
var fileResolver = {
  url: (file, _args, context) => file.getSignedDownloadURL(context.loaders.s3BucketLoader)
};

// server/src/schema/inbox.ts
var inboxResolver = {
  count: async (_, _args, context) => await context.loaders.threadParticipantLoader.loadInboxCount(),
  threads: async (_, _args, context) => {
    const threadIDs = await context.loaders.threadParticipantLoader.loadNewlyActiveThreads();
    return await context.loaders.threadLoader.loadThreads(threadIDs);
  },
  threadsArchive: async (_, _args, context) => {
    const threadIDs = await context.loaders.threadParticipantLoader.loadThreadsInArchive();
    return await context.loaders.threadLoader.loadThreads(threadIDs);
  }
};

// server/src/schema/load_messages_result.ts
var loadMessagesResultResolver = {
  async olderMessagesCount({ threadID, messages }, _args, context) {
    if (messages.length) {
      return await context.loaders.threadLoader.loadMessagesCountBeforeNoOrgCheck(
        threadID,
        messages[0].id
      );
    } else {
      return 0;
    }
  }
};

// server/src/schema/message.ts
var messageResolver = {
  attachments: async (message, _, context) => {
    if (message.isDeleted()) {
      return [];
    }
    return await context.loaders.messageAttachmentLoader.loadAttachmentsForMessage(
      message.id
    );
  },
  thread: async (message, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(
      message.threadID
    );
    if (!thread) {
      throw new Error("Message refers to non-existent thread");
    }
    return thread;
  },
  content: (message) => !message.isDeleted() ? message.content : null,
  source: async (message, _, context) => {
    const user = await context.loaders.userLoader.loadUser(message.sourceID);
    if (user === null) {
      throw `Failed to find source for message id ${message.id} and sourceID ${message.sourceID}`;
    }
    return user;
  },
  reactions: (message, _, context) => !message.isDeleted() ? context.loaders.messageReactionLoader.loadReactionsForMessageNoOrgCheck(
    message.id
  ) : [],
  seen: async (message, _, context) => {
    const userID = context.session.viewer.userID;
    if (!userID) {
      return false;
    }
    if (message.sourceID === userID) {
      return true;
    }
    const participant = await context.loaders.threadParticipantLoader.loadForUserNoOrgCheck({
      threadID: message.threadID,
      userID
    });
    if (!participant?.lastSeenTimestamp) {
      return false;
    }
    return participant.lastSeenTimestamp >= message.timestamp;
  },
  importedFromSlackChannel: async (message, _, context) => {
    if (message.isDeleted()) {
      return null;
    }
    if (message.importedSlackChannelID === null) {
      return null;
    }
    const slackChannel = await context.loaders.slackChannelLoader.loadSlackChannel(
      message.importedSlackChannelID
    );
    if (slackChannel) {
      return slackChannel.name;
    } else {
      return "";
    }
  },
  referencedUserData: async (message, _, context) => {
    if (message.isDeleted()) {
      return [];
    }
    return await context.loaders.userLoader.loadReferencedUserData(
      context,
      getReferencedUserIDs(message.content)
    );
  },
  task: async (message, _, context) => await context.loaders.taskLoader.loadTaskForMessageNoOrgCheck(message.id),
  slackURL: async (message, _, context) => {
    const {
      importedSlackChannelID: channelID,
      importedSlackMessageTS: ts,
      importedSlackMessageThreadTS: threadTS
      // Only replies/in thread messages, have thread_ts
    } = message;
    if (!channelID || !ts) {
      return null;
    }
    if (channelID.startsWith("D")) {
      const userID = assertViewerHasUser(context.session.viewer);
      if (message.sourceID !== userID) {
        return null;
      }
    }
    const org = await context.loaders.orgLoader.loadOrg(message.orgID);
    if (!org || !org.domain) {
      return null;
    }
    return getSlackMessageURL(org.domain, channelID, ts, threadTS);
  },
  isFromEmailReply: (message) => message.replyToEmailNotificationID !== null,
  extraClassnames: (message) => message.extraClassnames,
  metadata: (message) => message.metadata,
  seenBy: async (message, _, context) => {
    const seenByUserIDs = await context.loaders.threadParticipantLoader.loadSeenByUsers(message);
    return seenByUserIDs;
  }
};
var messageSourceTypeResolver = {
  // TODO: once we have other source types besides users there will probably
  // need to be some way to distinguish between them
  __resolveType: () => "User"
};

// server/src/schema/message_annotation_attachment.ts
var messageAnnotationAttachmentResolver = {
  screenshot: async (messageAttachment, _, context) => {
    const { screenshotFileID } = messageAttachment.data;
    if (!screenshotFileID) {
      return null;
    }
    try {
      return await context.loaders.fileLoader.loadFile(screenshotFileID);
    } catch (e) {
      return null;
    }
  },
  blurredScreenshot: async (messageAttachment, _, context) => {
    const { blurredScreenshotFileID: screenshotFileID } = messageAttachment.data;
    if (!screenshotFileID) {
      return null;
    }
    try {
      return await context.loaders.fileLoader.loadFile(screenshotFileID);
    } catch (e) {
      return null;
    }
  },
  location: (messageAttachment) => {
    if ("location" in messageAttachment.data && messageAttachment.data.location) {
      return {
        ...messageAttachment.data.location,
        iframeSelectors: messageAttachment.data.location.iframeSelectors ?? []
      };
    }
    return void 0;
  },
  customLocation: (messageAttachment) => {
    if ("customLocation" in messageAttachment.data) {
      return messageAttachment.data.customLocation;
    }
    return void 0;
  },
  customHighlightedTextConfig: (messageAttachment) => {
    if ("customHighlightedTextConfig" in messageAttachment.data) {
      return messageAttachment.data.customHighlightedTextConfig;
    }
    return void 0;
  },
  customLabel: (messageAttachment) => {
    if ("customLabel" in messageAttachment.data) {
      return messageAttachment.data.customLabel;
    }
    return void 0;
  },
  coordsRelativeToTarget: (messageAttachment) => {
    if ("coordsRelativeToTarget" in messageAttachment.data) {
      return messageAttachment.data.coordsRelativeToTarget;
    }
    return void 0;
  },
  message: async (messageAttachment, _, context) => {
    const message = await context.loaders.messageLoader.loadMessage(
      messageAttachment.messageID
    );
    if (!message) {
      throw new Error("Attachment refers to non-existent message");
    }
    return message;
  }
};

// server/src/schema/message_attachment.ts
var messageAttachmentTypeResolver = {
  __resolveType(attachment) {
    if ("type" in attachment) {
      switch (attachment.type) {
        case "file" /* FILE */:
          return "MessageFileAttachment";
        case "annotation" /* ANNOTATION */:
          return "MessageAnnotationAttachment";
        case "screenshot" /* SCREENSHOT */:
          return "MessageScreenshotAttachment";
      }
    }
    if ("url" in attachment) {
      return "MessageLinkPreview";
    }
    throw new Error("Unexpected attachment type");
  }
};

// server/src/schema/message_file_attachment.ts
var messageFileAttachmentResolver = {
  file: async (messageAttachment, _, context) => {
    if (!("fileID" in messageAttachment.data)) {
      return null;
    }
    const { fileID } = messageAttachment.data;
    try {
      return await context.loaders.fileLoader.loadFile(fileID);
    } catch (e) {
      return null;
    }
  }
};

// server/src/schema/message_reaction.ts
var messageReactionResolver = {
  user: async (messageReaction, _, context) => {
    const user = await context.loaders.userLoader.loadUser(
      messageReaction.userID
    );
    if (!user) {
      throw new Error(
        `Failed to load userID: ${messageReaction.userID} for messageID: ${messageReaction.messageID}`
      );
    }
    return user;
  },
  unicodeReaction: (messageReaction, _, _context) => messageReaction.unicodeReaction
};

// server/src/schema/org.ts
var orgResolver = {
  usersWithOrgDetails: async (org, args, context) => {
    if (isDefined(args.nameQuery)) {
      const filteredUsers = await context.loaders.userLoader.loadNameFilteredUsersInOrg(
        org.id,
        args.nameQuery,
        org.platformApplicationID,
        MAX_NAME_FILTERED_AUTOCOMPLETE_ORG_USERS,
        args.sortUsersBy,
        args.sortUsersDirection
      );
      return filteredUsers.map((user) => ({ user, org }));
    } else {
      const filteredUsers = await context.loaders.userLoader.loadNameFilteredUsersInOrg(
        org.id,
        null,
        org.platformApplicationID,
        5,
        args.sortUsersBy,
        args.sortUsersDirection
      );
      return filteredUsers.map((user) => ({ user, org }));
    }
  },
  joinableSlackChannels: async (org, _args, originalContext) => {
    const context = await getRelevantContext(originalContext, org.id);
    const orgIDs = await context.loaders.linkedOrgsLoader.getOrgIDs();
    return await context.loaders.slackChannelLoader.loadJoinableSlackChannels(
      orgIDs
    );
  },
  joinedSlackChannels: async (org, _args, originalContext) => {
    const context = await getRelevantContext(originalContext, org.id);
    const orgIDs = await context.loaders.linkedOrgsLoader.getOrgIDs();
    return await context.loaders.slackChannelLoader.loadJoinedSlackChannels(
      orgIDs
    );
  },
  recentlyActiveThreads: async (org, _args, context) => {
    const ids = await context.loaders.threadLoader.loadRecentlyActiveThreads(
      org.id
    );
    return await context.loaders.threadLoader.loadThreads(ids);
  },
  linkedOrganization: async (org) => await org.getLinkedOrg(),
  imageURL: deprecatedFunction(() => null, "graphql: org.imageURL")
};
var linkedOrgResolver = {
  usersWithOrgDetails: (org, args, context) => orgResolver.usersWithOrgDetails(org, args, context)
};

// server/src/schema/page_thread_added.ts
var pageThreadAddedResolver = {
  thread: async ({ payload: { threadID } }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (!thread) {
      throw new Error("Thread does not exist.");
    }
    return thread;
  }
};

// server/src/schema/page_visitor.ts
var pageVisitorResolver = {
  user: (pageVisitor, _, context) => context.loaders.userLoader.loadUserInAnyViewerOrg(pageVisitor.userID)
};

// server/src/schema/page_visitors_updated.ts
var pageVisitorUpdatedResolver = {
  visitors: () => []
};

// server/src/schema/task.ts
var taskResolver = {
  assignees: async (task, _, context) => {
    const assignees = await context.loaders.taskAssigneeLoader.loadTaskAssigneesForTaskNoOrgCheck(
      task.id
    );
    return await context.loaders.userLoader.loadUsersNoOrgCheck(
      assignees.map((assignee) => assignee.userID)
    );
  },
  todos: async (task, _, context) => await context.loaders.taskTodoLoader.loadTaskTodosNoOrgCheck(task.id),
  doneStatusLastUpdatedBy: async (task, _, context) => {
    return task.doneStatusLastUpdatedBy ? await context.loaders.userLoader.loadUser(task.doneStatusLastUpdatedBy) : null;
  },
  thirdPartyReference: (task, args) => TaskThirdPartyReference.findForTask(task.id, args.type),
  thirdPartyReferences: (task) => TaskThirdPartyReference.findAllForTask(task.id)
};

// server/src/schema/task_third_party_reference.ts
var taskThirdPartyReferenceResolver = {
  type: (reference) => reference.externalConnectionType,
  canEdit: async (reference, _args, context) => {
    const authData = await getExternalAuthData(
      context.session.viewer,
      reference.externalConnectionType
    );
    if (!authData) {
      return false;
    }
    switch (reference.externalConnectionType) {
      case "jira": {
        const externalTaskCloudID = reference.externalLocationID;
        const { cloudID } = authData;
        return cloudID === externalTaskCloudID;
      }
      case "linear": {
        const { accessToken } = authData;
        const teamID = reference.externalLocationID;
        return await canUserEditTask(
          accessToken,
          teamID,
          context.session.viewer
        );
      }
      default:
        return true;
    }
  }
};

// server/src/schema/third_party_connection.ts
var thirdPartyConnectionResolver = {
  connected: async ({ type }, _, context) => {
    const { userID, orgID } = assertViewerHasIdentity(context.session.viewer);
    const entity = await ThirdPartyConnectionEntity.findOne({
      where: { userID, orgID, type }
    });
    return entity !== null;
  },
  oAuthStateToken: ({ type }, _, context) => encodeViewerForOAuthState(context.session.viewer, type),
  configuration: async ({ type }, _, context) => {
    switch (type) {
      case "jira": {
        return await fetchJiraProjects(context.session.viewer);
      }
      case "linear": {
        return await getLinearUserTeamInfo(context.session.viewer);
      }
      case "trello": {
        return await getTrelloWorkSpace(context.session.viewer);
      }
      case "asana": {
        return await fetchAsanaProjects(context.session.viewer);
      }
      case "monday":
        return await fetchMondayBoards(context.session.viewer);
      default: {
        return [];
      }
    }
  }
};

// server/src/schema/thread.ts
var threadResolver = {
  messages: (thread, args, context) => context.loaders.messageLoader.loadMessages({
    threadID: thread.id,
    cursor: args.cursor ?? void 0,
    range: args.range ?? void 0,
    ignoreDeleted: args.ignoreDeleted ?? void 0
  }),
  loadMessages: async (thread, args, context) => {
    const messages = await threadResolver.messages(thread, args, context);
    return {
      threadID: thread.id,
      messages,
      ignoreDeleted: !!args.ignoreDeleted
    };
  },
  participants: async (thread, _args, context) => await context.loaders.threadParticipantLoader.loadForThreadIDNoOrgCheck(
    thread.id
  ),
  mentioned: async (thread, _args, context) => await context.loaders.messageMentionLoader.loadMentionedUsersForThread(
    thread.id
  ),
  typingUsers: async (thread, _args, context) => {
    const userIDs = await getUsersTyping(thread.id);
    return await context.loaders.userLoader.loadUsersNoOrgCheck(userIDs);
  },
  newMessagesCount: (thread, _args, context) => context.loaders.threadLoader.loadNewMessageCountNoOrgCheck(thread.id),
  newReactionsCount: (thread, _args, context) => context.loaders.threadLoader.loadNewReactionsCountNoOrgCheck(thread.id),
  firstUnseenMessageID: (thread, _args, context) => {
    return context.loaders.threadLoader.getFirstUnseenMessageIDNoOrgCheck(
      thread.id
    );
  },
  subscribed: (thread, _args, context) => context.loaders.threadParticipantLoader.loadSubscribedNoOrgCheck(thread.id),
  messagesCountExcludingDeleted: (thread, _args, context) => context.loaders.threadLoader.loadMessagesCountExcludingDeletedNoOrgCheck(
    thread.id
  ),
  allMessagesCount: (thread, _args, context) => context.loaders.threadLoader.loadMessagesCountNoOrgCheck(thread.id),
  userMessagesCount: (thread, _args, context) => context.loaders.threadLoader.loadUserMessagesCountNoOrgCheck(thread.id),
  actionMessagesCount: (thread, _args, context) => context.loaders.threadLoader.loadActionMessagesCountNoOrgCheck(thread.id),
  replyCount: (thread, _args, context) => context.loaders.threadLoader.loadReplyCount(thread.id),
  initialMessagesInclDeleted: (thread, args, context) => context.loaders.threadLoader.loadInitialMessagesNoOrgCheck(
    thread.id,
    args.initialFetchCount
  ),
  viewerIsThreadParticipant: (thread, _args, context) => context.loaders.threadParticipantLoader.isViewerThreadParticipantNoOrgCheck(
    thread.id
  ),
  resolved: (thread, _args, _context) => thread.resolvedTimestamp !== null,
  sharedToSlack: (thread, _args, context) => context.loaders.threadLoader.loadSlackMirroredThreadInfoNoOrgCheck(
    thread.id
  ),
  loadNewestMessagesToTarget: async (thread, args, context) => {
    const messages = await context.loaders.messageLoader.loadNewestUntilTarget({
      threadID: thread.id,
      targetMessage: args.targetMessage
    });
    return {
      threadID: thread.id,
      messages,
      ignoreDeleted: args.ignoreDeleted ?? true
    };
  },
  replyingUserIDs: async (thread, _args, context) => await context.loaders.threadLoader.loadReplyingUserIDsNoOrgCheck(thread.id),
  actionMessageReplyingUserIDs: async (thread, _args, context) => await context.loaders.threadLoader.loadActionMessageReplyingUserIDsNoOrgCheck(
    thread.id
  ),
  externalOrgID: async (thread, _args, context) => {
    const org = await context.loaders.orgLoader.loadOrg(thread.orgID);
    return org.externalID;
  },
  location: async (thread, _args, context) => {
    const threadPageData = await context.loaders.pageLoader.loadPrimaryPageForThreadNoOrgCheck(
      thread.id
    );
    if (!threadPageData) {
      throw new Error("Unable to find thread location");
    }
    return threadPageData.contextData;
  },
  navigationURL: async (thread, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const userOrgIDs = assertViewerHasOrgs(context.session.viewer);
    if (userOrgIDs.includes(thread.orgID)) {
      return thread.url;
    }
    if (!context.session.viewer.platformApplicationID) {
      return thread.url;
    }
    const [user, org, primaryPage] = await Promise.all([
      UserEntity.findByPk(userID),
      OrgEntity.findByPk(thread.orgID),
      context.loaders.pageLoader.loadPrimaryPageForThreadNoOrgCheck(thread.id)
    ]);
    if (!user || !org || !primaryPage) {
      throw new Error(
        "Unable to resolve UserEntity, OrgEntity or Primary Page"
      );
    }
    const details = {
      userType: "platform" /* PLATFORM */,
      userID: user.externalID,
      orgID: org.externalID ?? externalizeID(org.id),
      groupID: org.externalID ?? externalizeID(org.id),
      name: user.name,
      email: user.email,
      profilePictureURL: user.profilePictureURL
    };
    const threadLocation = primaryPage.contextData;
    return await generateSignedExternalRedirectURI(
      context.session.viewer.platformApplicationID,
      thread.url,
      {
        type: "inbox",
        url: thread.url,
        location: threadLocation,
        threadID: thread.externalID,
        userDetails: details
      }
    );
  }
};

// server/src/schema/thread_message_added.ts
var threadMessageAddedResolver = {
  message: async ({ payload: { messageID } }, _, context) => {
    const message = await context.loaders.messageLoader.loadMessage(messageID);
    if (!message) {
      throw new Error("message does not exist");
    }
    return message;
  }
};

// server/src/schema/thread_message_updated.ts
var threadMessageUpdatedResolver = {
  message: async ({ payload: { messageID } }, _, context) => {
    const message = await context.loaders.messageLoader.loadMessage(messageID);
    if (!message) {
      throw new Error("message does not exist");
    }
    return message;
  }
};

// server/src/schema/thread_message_content_appended.ts
var threadMessageContentAppendedResolver = {
  id: ({ payload: { messageID } }, _, _context) => messageID,
  appendedContent: ({ payload: { appendedContent } }, _, _context) => appendedContent
};

// server/src/schema/thread_participant.ts
var threadParticipantResolver = {
  user: (threadParticipant, _, context) => context.loaders.userLoader.loadUser(threadParticipant.userID)
};

// server/src/schema/thread_participants_updated_incremental.ts
var threadParticipantUpdatedIncrementalResolver = {
  participant: async ({ args: { threadID }, payload: { userID } }, _, context) => {
    const participant = await context.loaders.threadParticipantLoader.loadForUserNoOrgCheck({
      threadID,
      userID
    });
    if (!participant) {
      throw new Error("Unable to find requested thread participant");
    }
    return participant;
  }
};

// server/src/schema/thread_typing_users_updated.ts
var threadTypingUsersUpdatedResolver = {
  users: async ({ payload: { users }, args }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(
      args.threadID
    );
    if (!thread) {
      return [];
    }
    return await context.loaders.userLoader.loadUsersNoOrgCheck(users);
  }
};

// server/src/schema/user.ts
var userResolver = {
  id: (user) => user.id,
  externalID: (user) => user.externalID,
  metadata: (user) => user.metadata,
  // In the case of platform users, names will come from the latest of a slack
  // linking, user updated name or platform api updated name
  displayName: async (user, _, context) => (await detailsForDisplay(user, context)).displayName,
  fullName: async (user, _, context) => (await detailsForDisplay(user, context)).fullName,
  name: (user) => user.name,
  shortName: (user) => user.screenName,
  // Like name, profilePictureURL will be the latest of a slack linking, user-
  // uploaded picture, or api update
  profilePictureURL: async (user, _, context) => (await detailsForDisplay(user, context)).profilePictureURL,
  userType: deprecatedFunction(
    async (user) => user.userType,
    "graphql: user.userType"
  )
};
var userWithOrgDetailsResolver = {
  // Shared fields with User
  id: ({ user }, args, context) => userResolver.id(user, args, context),
  metadata: ({ user }, args, context) => userResolver.metadata(user, args, context),
  externalID: ({ user }, args, context) => userResolver.externalID(user, args, context),
  displayName: ({ user }, args, context) => userResolver.displayName(user, args, context),
  fullName: ({ user }, args, context) => userResolver.fullName(user, args, context),
  name: ({ user }, args, context) => userResolver.name(user, args, context),
  shortName: ({ user }, args, context) => userResolver.shortName(user, args, context),
  profilePictureURL: ({ user }, args, context) => userResolver.profilePictureURL(user, args, context),
  userType: ({ user }, args, context) => userResolver.userType(user, args, context),
  // This is org-scoped and only used for email-matching at the moment
  linkedUserID: async ({ user, org }, _, context) => {
    if (org.externalProvider !== "platform") {
      return null;
    }
    return (await context.loaders.linkedUsersLoader.loadLinkedUserFromSourceOrgScoped(
      user.id,
      org.id
    ))?.linkedUserID;
  },
  // Org-scoped because this is used in relation to notifications
  canBeNotifiedOnSlack: async ({ user, org }, _, context) => !!await loadLinkedSlackUserOrgScoped(user, context, org.id),
  slackUserWithMatchingEmail: async ({ user, org }, _, context) => (await findSlackUserEmailMatch(context, org, user))?.id
};

// server/src/public/mutations/refresh_file_upload_url.ts
var refreshFileUploadURLMutationResolver = async (_, args, context) => {
  const userID = assertViewerHasUser(context.session.viewer);
  const { id, size } = args;
  const file = await context.loaders.fileLoader.loadFile(id);
  if (!file) {
    throw new Error("File not found");
  }
  if (file.userID !== userID) {
    throw new Error("File does not belong to viewer");
  }
  assertValid(
    validateFileForUpload("attachment", {
      name: file.name,
      mimeType: file.mimeType,
      size
    })
  );
  await file.update({ size });
  return await file.getSignedUploadURL(context.loaders.s3BucketLoader);
};

// server/src/schema/s3_bucket.ts
var s3BucketVisibleResolver = {};

// server/src/schema/heimdall_switch.ts
var heimdallSwitchResolver = {
  isOn: (heimdallEntity, _args, _context) => {
    return heimdallEntity.isOn();
  }
};

// server/src/public/mutations/set_deep_link_thread_id.ts
var setDeepLinkThreadIDMutationResolver = async (_, args, context) => {
  const { threadID } = args;
  const userID = assertViewerHasUser(context.session.viewer);
  await setDeepLinkThreadMessageID({ userID, threadID });
  return {
    success: true,
    failureDetails: null
  };
};

// server/src/public/mutations/clear_deep_link_thread_id.ts
var clearDeepLinkThreadIDMutationResolver = async (_, __, context) => {
  const userID = assertViewerHasUser(context.session.viewer);
  await clearDeepLinkThreadMessageID(userID);
  return {
    success: true,
    failureDetails: null
  };
};

// server/src/public/queries/application.ts
var applicationQueryResolver = async (_, _args, context) => {
  const { platformApplicationID, externalUserID, externalOrgID } = context.session.viewer;
  if (!platformApplicationID || !externalUserID) {
    return null;
  }
  const application = await context.loaders.applicationLoader.load(
    platformApplicationID
  );
  if (!application) {
    return null;
  }
  const fillInBlanks = (linkWithPlaceholders) => {
    if (!linkWithPlaceholders) {
      return null;
    }
    return linkWithPlaceholders.replace(/{{USER_ID}}/g, externalUserID).replace(/{{ORGANIZATION_ID}}/g, externalOrgID ?? "").replace(/{{ORGANISATION_ID}}/g, externalOrgID ?? "");
  };
  const links = {
    learnMore: fillInBlanks(application.customLinks?.learnMore),
    upgradePlan: fillInBlanks(application.customLinks?.upgradePlan),
    leaveFeedback: fillInBlanks(application.customLinks?.leaveFeedback)
  };
  return {
    id: application.id,
    name: application.name,
    customLinks: links,
    segmentWriteKey: application.segmentWriteKey,
    customNUX: application.customNUX,
    iconURL: application.iconURL,
    environment: application.environment
  };
};

// server/src/schema/application.ts
import * as jwt8 from "jsonwebtoken";
var applicationResolver = {
  customLinks: (application, _args, _context) => {
    return application.customLinks;
  },
  customEmailTemplate: (application, _args, _context) => {
    return application.customEmailTemplate;
  },
  customS3Bucket: async (application, _args, context) => {
    return await context.loaders.s3BucketLoader.loadForApplication(application);
  },
  supportBotInfo: async (application, _args, _context) => {
    if (!application.supportBotID) {
      return null;
    }
    const user = await UserEntity.findByPk(application.supportBotID);
    return user ? {
      name: userDisplayName(user),
      profilePictureURL: user.profilePictureURL
    } : null;
  },
  deploymentInfo: async (application, _args, context) => {
    if (!context.session.isAdmin) {
      throw new Error("Admin only");
    }
    return application;
  },
  usageMetrics: (application, args, context) => {
    if (!context.session.isAdmin) {
      throw new Error("Admin only");
    }
    const { metrics, days } = args;
    return context.loaders.applicationUsageMetricLoader.loadUsageMetrics(
      application.id,
      metrics,
      days
    );
  },
  serverAccessToken: (application, _args, _context) => {
    return jwt8.sign({ app_id: application.id }, application.sharedSecret, {
      algorithm: "HS512",
      expiresIn: "24 h"
    });
  },
  customerAccessToken: async (application, _args, _context) => {
    const customer = await CustomerEntity.findByPk(application.customerID);
    if (!customer) {
      throw new Error(`Customer not found`);
    }
    return jwt8.sign({ customer_id: customer.id }, customer.sharedSecret, {
      algorithm: "HS512",
      expiresIn: "24 h"
    });
  },
  setupInfo: async (application, _args, context) => {
    const [firstUser, firstOrg, isComponentInitialized] = await Promise.all([
      context.loaders.applicationLoader.getFirstUserInApplication(
        application.id
      ),
      context.loaders.applicationLoader.getFirstOrgInApplication(
        application.id
      ),
      context.loaders.applicationLoader.isComponentInitializedForApplication(
        application.id
      )
    ]);
    return {
      firstUser,
      firstOrg,
      isComponentInitialized
    };
  },
  defaultProvider: deprecatedFunction(
    () => null,
    "graphql: application.defaultProvider"
  )
};

// server/src/public/mutations/set_thread_resolved.ts
import { v4 as uuid20 } from "uuid";
var setThreadResolvedResolver = async (_, args, originalContext) => {
  const { threadID, resolved } = args;
  const thread = await originalContext.loaders.threadLoader.loadThread(threadID);
  if (!thread) {
    return {
      success: false,
      failureDetails: null
    };
  }
  const context = await getRelevantContext(originalContext, thread.orgID);
  const { viewer } = context.session;
  const { userID, orgID } = assertViewerHasIdentity(viewer);
  const user = await originalContext.loaders.userLoader.loadUser(userID);
  if (!user) {
    throw new Error("The user doesn't exist?!?");
  }
  if (thread.resolvedTimestamp !== null === resolved) {
    return { success: true, failureDetails: null };
  }
  const originalSubscribers = new Set(
    await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  const actionType = resolved ? "thread_resolved" : "thread_unresolved";
  try {
    const messageMutator = new MessageMutator(viewer, context.loaders);
    const threadMutator = new ThreadMutator(viewer, context.loaders);
    let result = false;
    const { success, message } = await getSequelize().transaction(
      async (transaction) => {
        const createdMessage = await messageMutator.createMessage(
          {
            id: uuid20(),
            thread,
            content: getActionMessageContent(actionType, user),
            url: null,
            iconURL: MessageActionIconURLs[actionType],
            translationKey: MessageActionTranslationKeys[actionType],
            type: "action_message"
          },
          transaction
        );
        const updateThread2 = await threadMutator.setThreadResolved(
          threadID,
          resolved,
          transaction
        );
        const threadParticipantMutator = new ThreadParticipantMutator(
          viewer,
          context.loaders
        );
        await threadParticipantMutator.setViewerSubscribed(
          thread,
          true,
          transaction
        );
        await threadParticipantMutator.markThreadSeen({
          threadID,
          setSubscribed: true,
          transaction
        });
        await threadParticipantMutator.markThreadNewlyActiveForOtherUsers(
          threadID,
          createdMessage.id,
          transaction
        );
        return {
          success: updateThread2 && !!createdMessage,
          message: createdMessage
        };
      }
    );
    result = success;
    if (result) {
      const app = await ApplicationEntity.findByPk(
        message.platformApplicationID
      );
      if (!app) {
        throw new Error("No application found when resolving thread");
      }
      backgroundPromise(
        Promise.all([
          publishPubSubEvent(
            "thread-message-added",
            { threadID: message.threadID },
            { messageID: message.id }
          ),
          publishEventToWebhook(app, {
            type: "thread-message-added",
            threadID: thread.id,
            messageID: message.id
          })
        ]),
        context.logger
      );
    }
    const page = await context.loaders.pageLoader.loadPrimaryPageForThreadNoOrgCheck(
      threadID
    );
    if (!page) {
      throw new Error(`Thread does not exist on a page.`);
    }
    const newSubscribers = new Set(
      await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
        thread.id
      )
    );
    const removed = [...originalSubscribers].filter(
      (s) => !newSubscribers.has(s)
    );
    const added = [...newSubscribers].filter(
      (s) => !originalSubscribers.has(s)
    );
    const pageContextHash = page.contextHash;
    await Promise.all([
      publishPubSubEvent(
        "thread-filterable-properties-updated",
        { orgID },
        {
          threadID,
          changes: {
            resolved: { old: !resolved, new: resolved },
            ...(added.length > 0 || removed.length > 0) && {
              subscribers: { added, removed }
            }
          }
        }
      ),
      publishPubSubEvent("thread-properties-updated", { threadID }),
      publishPubSubEvent("annotations-on-page-updated", {
        pageContextHash,
        orgID
      }),
      createThreadActionNotifications({
        context,
        threadID: thread.id,
        messageID: message.id,
        threadActionType: actionType === "thread_resolved" ? "resolve" : "unresolve"
      })
    ]);
    return { success: result, failureDetails: null };
  } catch (e) {
    context.logger.logException(
      "Error while setting resolve thread status",
      e,
      {
        userID,
        threadID,
        resolved
      }
    );
    return { success: false, failureDetails: null };
  }
};

// server/src/schema/page_thread_resolved.ts
var pageThreadResolvedResolver = {
  thread: async ({ payload: { threadID } }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (thread === null) {
      throw new Error(`Failed to load thread ID: ${threadID}`);
    }
    return thread;
  }
};

// server/src/schema/page_thread_unresolved.ts
var pageThreadUnresolvedResolver = {
  thread: async ({ payload: { threadID } }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (thread === null) {
      throw new Error(`Failed to load thread ID: ${threadID}`);
    }
    return thread;
  }
};

// server/src/entity/slack_mirrored_thread/SlackMirroredThreadMutator.ts
var SlackMirroredThreadMutator = class {
  /**
   * Mutator for SlackMirroredThread
   * @param viewer SlackOrg Viewer
   */
  constructor(viewer) {
    this.viewer = viewer;
  }
  async createOne(threadID, slackChannelID, slackMessageTimestamp, transaction) {
    const orgID = assertViewerHasOrg(this.viewer);
    return await SlackMirroredThreadEntity.create(
      {
        threadID,
        threadOrgID: orgID,
        slackOrgID: orgID,
        slackChannelID,
        slackMessageTimestamp
      },
      { transaction }
    );
  }
  /**
   * Unlink a given Slack thread
   *
   * @param slackChannelID
   * @param slackMessageTimestamp
   * @returns an object with threadID and threadOrgID of the unlinked thread, or
   * null if none was unlinked
   */
  async unlinkSlackThread(slackChannelID, slackMessageTimestamp) {
    const slackOrgID = assertViewerHasOrg(this.viewer);
    const [rows] = await getSequelize().query(
      `DELETE FROM slack_mirrored_threads
         WHERE "slackOrgID"=$1
         AND "slackChannelID"=$2
         AND "slackMessageTimestamp"=$3
         RETURNING "threadID", "threadOrgID";`,
      {
        bind: [slackOrgID, slackChannelID, slackMessageTimestamp]
      }
    );
    return rows.length > 0 ? rows[0] : null;
  }
  async unlinkAllThreads(threadOrgID, slackOrgID) {
    const orgIDs = await new LinkedOrgsLoader(this.viewer).getOrgIDs();
    if ([threadOrgID, slackOrgID].every((id) => orgIDs.includes(id))) {
      return await SlackMirroredThreadEntity.destroy({
        where: {
          threadOrgID,
          slackOrgID
        }
      });
    }
    return;
  }
};

// server/src/public/mutations/unlink_orgs.ts
var unlinkOrgsMutationResolver = async (_, __, context) => {
  const { userID, orgID } = assertViewerHasIdentity(context.session.viewer);
  const slackOrgToDisconnect = await context.loaders.linkedOrgsLoader.getConnectedSlackOrgID(orgID);
  if (!slackOrgToDisconnect) {
    context.logger.warn("No linked org to unlink");
    return { success: false, failureDetails: null };
  }
  const slackMirroredThreadMutator = new SlackMirroredThreadMutator(
    context.session.viewer
  );
  await slackMirroredThreadMutator.unlinkAllThreads(
    orgID,
    slackOrgToDisconnect
  );
  const linkedOrgsMutator = new LinkedOrgsMutator(
    context.session.viewer,
    context.loaders
  );
  const orgUnlinked = await linkedOrgsMutator.unlinkOrgs();
  if (orgUnlinked >= 1) {
    backgroundPromise(
      publishUserIdentityUpdate({
        userID,
        orgID,
        platformApplicationID: context.session.viewer.platformApplicationID
      })
    );
  }
  return { success: orgUnlinked >= 1, failureDetails: null };
};

// server/src/public/queries/annotations_on_page.ts
var annotationsOnPageQueryResolver = async (_, { pageContext, includeDeleted = false }, context) => {
  const { orgID, userID } = assertViewerHasIdentity(context.session.viewer);
  const [pageContextHash] = getPageContextHash(toPageContext(pageContext));
  return await getAnnotationsOnPage(
    context,
    pageContextHash,
    userID,
    orgID,
    includeDeleted ?? false
  );
};
async function getAnnotationsOnPage(context, pageContextHash, userID, orgID, includeDeleted) {
  const allAnnotationsOnPage = await context.loaders.messageAttachmentLoader.loadAnnotationAttachmentsOnPage(
    pageContextHash,
    includeDeleted
  );
  if (allAnnotationsOnPage.length === 0) {
    return { allAnnotations: [], hiddenAnnotationIDs: [] };
  }
  const annotationsHiddenByUser = await UserHiddenAnnotationsEntity.findAll({
    where: { userID, orgID, pageContextHash }
  });
  const hiddenAnnotationIDs = annotationsHiddenByUser.map(
    (value) => value.annotationID
  );
  return { allAnnotations: allAnnotationsOnPage, hiddenAnnotationIDs };
}

// server/src/public/mutations/set_annotation_visible.ts
var setAnnotationVisibleMutationResolver = async (_, { annotationID, visible }, context) => {
  const orgID = assertViewerHasSingleOrgForWrite(
    context.session.viewer,
    "Must specify a group ID for threads to be created"
  );
  const userID = assertViewerHasUser(context.session.viewer);
  try {
    const attachment = await context.loaders.messageAttachmentLoader.loadAttachment(
      annotationID
    );
    if (!attachment) {
      throw new Error("Cannot find attachment.");
    }
    const message = await context.loaders.messageLoader.loadMessage(
      attachment.messageID
    );
    if (!message) {
      throw new Error("Cannot find message.");
    }
    const thread = await context.loaders.threadLoader.loadThread(
      message.threadID
    );
    if (!thread) {
      throw new Error("Cannot find thread.");
    }
    const page = await context.loaders.pageLoader.loadPrimaryPageForThreadNoOrgCheck(
      thread.id
    );
    if (!page) {
      throw new Error("Cannot find page.");
    }
    const pageContextHash = page.contextHash;
    if (visible) {
      await UserHiddenAnnotationsEntity.destroy({
        where: { annotationID }
      });
    } else {
      await UserHiddenAnnotationsEntity.create({
        userID,
        orgID,
        annotationID,
        pageContextHash
      });
    }
    return { success: true, failureDetails: null };
  } catch {
    return { success: false, failureDetails: null };
  }
};

// server/src/public/subscriptions/annotations_on_page_updated.ts
var annotationsOnPageUpdatedSubscriptionResolver = {
  resolve: (event, args, context) => {
    const { orgID, userID } = assertViewerHasIdentity(context.session.viewer);
    return getAnnotationsOnPage(
      context,
      event.args.pageContextHash,
      userID,
      orgID,
      args.includeDeleted ?? false
    );
  },
  subscribe: async (_root, args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const orgID = assertViewerHasOrg(context.session.viewer);
    const [pageContextHash] = getPageContextHash(
      toPageContext(args.pageContext)
    );
    return withRestartEvent({
      events: [["annotations-on-page-updated", { orgID, pageContextHash }]],
      userID,
      subscriptionName: "annotationsOnPageUpdatedSubscriptionResolver"
    })();
  }
};

// server/src/public/mutations/reset_user_hidden_annotations.ts
var resetUserHiddenAnnotationsResolver = async (_, _args, context) => {
  const { userID, orgID } = assertViewerHasIdentity(context.session.viewer);
  try {
    await UserHiddenAnnotationsEntity.destroy({
      where: { userID, orgID }
    });
    return { success: true, failureDetails: null };
  } catch {
    return { success: false, failureDetails: null };
  }
};

// server/src/public/mutations/set_present_context.ts
var setPresentContextMutationResolver = async (_, args, context) => {
  const { present, durable, context: userContext, exclusivityRegion } = args;
  assertViewerHasSingleOrgForWrite(
    context.session.viewer,
    "Must specify a group ID when setting presence to control who can see it"
  );
  await setUserPresentContext({
    userContext,
    present,
    durable,
    context,
    exclusivityRegion
  });
  return true;
};

// server/src/public/queries/users_by_external_id.ts
var usersByExternalIDQueryResolver = async (_, args, context) => {
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  const orgIDs = assertViewerHasOrgs(context.session.viewer);
  if (platformApplicationID === CORD_HOMEPAGE_APPLICATION_ID) {
    const users = await Promise.all(
      args.externalIDs.map(
        (externalID) => context.loaders.userLoader.loadUserByExternalID(
          platformApplicationID,
          externalID
        )
      )
    );
    return users.filter(isDefined);
  }
  return await context.loaders.userLoader.loadUsersByExternalIDsInOrg(
    args.externalIDs,
    orgIDs
  );
};

// server/src/public/mutations/mark_thread_seen.ts
var markThreadSeenMutation = async (_, args, context) => {
  const { threadID } = args;
  const thread = await context.loaders.threadLoader.loadThread(threadID);
  if (!thread) {
    return {
      success: false,
      failureDetails: null
    };
  }
  const { viewer } = context.session;
  await new ThreadParticipantMutator(viewer, context.loaders).markThreadSeen({
    threadID
  });
  return {
    success: true,
    failureDetails: null
  };
};

// server/src/public/subscriptions/util/with_throttle.ts
import { $$asyncIterator } from "iterall";
function withThrottle(asyncIteratorFn, throttleMs, keyFunction = () => "") {
  return (rootValue, args, context, info) => {
    const asyncIterator = asyncIteratorFn(rootValue, args, context, info);
    const timers = /* @__PURE__ */ new Map();
    const storedResults = /* @__PURE__ */ new Map();
    const storedPromises = [];
    let nextResolve = void 0;
    let nextReject = void 0;
    function doResolve(result) {
      if (nextResolve) {
        const toCall = nextResolve;
        nextResolve = void 0;
        nextReject = void 0;
        toCall(result);
      } else {
        storedPromises.push(Promise.resolve(result));
      }
    }
    function doReject(reason) {
      if (nextReject) {
        const toCall = nextReject;
        nextResolve = void 0;
        nextReject = void 0;
        toCall(reason);
      } else {
        storedPromises.push(Promise.reject(reason));
      }
    }
    return {
      next() {
        if (storedPromises.length > 0) {
          return storedPromises.shift();
        }
        return new Promise((resolve2, reject) => {
          nextResolve = resolve2;
          nextReject = reject;
          const waitForIncomingPromise = () => {
            asyncIterator.next().then((payload) => {
              if (payload.done === true) {
                for (const timer of timers.values()) {
                  clearTimeout(timer);
                }
                timers.clear();
                for (const storedResult of storedResults.values()) {
                  doResolve(storedResult);
                }
                storedResults.clear();
                doResolve(payload);
                return;
              }
              const key = keyFunction(payload.value);
              if (!timers.has(key)) {
                const timerFn = () => {
                  const storedResult = storedResults.get(key);
                  if (storedResult) {
                    storedResults.delete(key);
                    timers.set(key, setTimeout(timerFn, throttleMs));
                    doResolve(storedResult);
                  } else {
                    timers.delete(key);
                  }
                };
                timers.set(key, setTimeout(timerFn, throttleMs));
                doResolve(payload);
                return;
              }
              storedResults.set(key, payload);
              waitForIncomingPromise();
            }).catch((err) => {
              doReject(err);
              return;
            });
          };
          waitForIncomingPromise();
        });
      },
      return() {
        return asyncIterator.return();
      },
      throw(error) {
        return asyncIterator.throw(error);
      },
      [$$asyncIterator]() {
        return this;
      }
    };
  };
}

// server/src/public/subscriptions/viewer_identity.ts
var THROTTLE_MS = 1e3;
var viewerIdentityLiveQueryResolver = {
  resolve: (value) => value,
  subscribe: async (_root, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const iterable = await liveQueryWithRestartEvent({
      events: [["user-identity", { userID }]],
      initialData: () => ({}),
      eventData: (_event) => ({}),
      userID,
      subscriptionName: "viewerIdentityLiveQueryResolver"
    });
    return withThrottle(
      () => iterable[Symbol.asyncIterator](),
      THROTTLE_MS
    )();
  }
};

// server/src/public/queries/users.ts
var usersQueryResolver = async (_, args, context) => {
  return await context.loaders.userLoader.loadUsersInViewerOrgs(args.ids);
};

// server/src/util/rateLimiter.ts
async function shouldRateLimit(context) {
  const config = await getTypedFeatureFlagValue(
    FeatureFlags2.RATE_LIMITS,
    flagsUserFromContext(context)
  );
  const key = `gql_${context.connectionID}`;
  const count = await getRedis().incrAndExpire(key, config.seconds);
  return count > config.maxCount;
}

// server/src/public/mutations/send_sample_welcome_message.ts
import { v4 as uuid21 } from "uuid";
var sendSampleWelcomeMessageResolver = async (_, args, context) => {
  const { userID, orgID, platformApplicationID } = assertViewerHasPlatformIdentity(context.session.viewer);
  const [application, isFirstOrgMessage] = await Promise.all([
    context.loaders.applicationLoader.load(platformApplicationID),
    MessageEntity.findOne({ where: { orgID } }).then((msg) => msg === null)
  ]);
  if (!application || application.environment !== "sampletoken" && application.id !== CORD_AUTOMATED_TESTS_APPLICATION_ID) {
    throw new Error("sendSampleWelcomeMessage: invalid application");
  }
  if (!isFirstOrgMessage) {
    return { success: true, failureDetails: null };
  }
  const firstName = "Albert from Cord (Example User)";
  const dummyUser = await createPlatformUser(
    context,
    application.id,
    uuid21(),
    // ExternalID
    null,
    firstName,
    // Display name
    void 0,
    // Screen name
    `${APP_ORIGIN}/static/Albert-from-Cord.jpeg`,
    "active",
    {}
    // metadata
  );
  await OrgMembersEntity.upsert({
    userID: dummyUser.id,
    orgID
  });
  const senderViewer = Viewer.createLoggedInViewer(dummyUser.id, orgID);
  const senderLoaders = await getNewLoaders(senderViewer);
  const { page } = await createPageContext(
    senderViewer,
    args.messageLocation
  );
  const thread = await getSequelize().transaction(
    async (transaction) => await new ThreadMutator(senderViewer, senderLoaders).createThreadOnPage(
      uuid21(),
      args.url,
      page,
      "Welcome to Cord!",
      transaction,
      application.id,
      null
    )
  );
  const threadParticipants = [senderViewer.userID, userID];
  const threadParticipantMutator = new ThreadParticipantMutator(
    senderViewer,
    senderLoaders
  );
  await threadParticipantMutator.subscribeUsersToThread(
    thread.id,
    threadParticipants
  );
  await new MessageMutator(senderViewer, senderLoaders).createMessage({
    id: uuid21(),
    thread,
    url: args.url,
    content: [
      {
        type: import_types2.MessageNodeType.PARAGRAPH,
        children: [
          { text: "Hey, " },
          {
            type: import_types2.MessageNodeType.MENTION,
            user: { id: userID },
            children: [{ text: `@Sample User` }]
          },
          { text: "!" }
        ]
      },
      {
        type: import_types2.MessageNodeType.PARAGRAPH,
        children: [
          {
            text: "Nice work! Your Cord demo is ready."
          }
        ]
      }
    ]
  });
  await publishNewThreadEvents(page.contextData, thread);
  return { success: true, failureDetails: null };
};
async function createPageContext(viewer, location) {
  const pageContext = {
    providerID: null,
    data: location
  };
  const pageContextHash = await new PageMutator(viewer).createPageIfNotExists(
    pageContext
  );
  const page = await new PageLoader(viewer).getPageFromContextHash(
    pageContextHash
  );
  await new PageVisitorMutator(viewer).markPresentInPage(pageContextHash);
  return { page, pageContextHash };
}

// server/src/schema/console_user.ts
var consoleUserResolver = {
  customer: (consoleUser, _args, context) => {
    const customerID = consoleUser.customerID;
    if (!customerID) {
      return null;
    }
    return context.loaders.customerLoader.load(customerID);
  }
};

// server/src/schema/application_deployment_info.ts
import { QueryTypes as QueryTypes24 } from "sequelize";
var applicationDeploymentInfoResolver = {
  messages: async (application) => {
    const result = await getSequelize().query(
      `SELECT COUNT(*)
          FROM messages m
          INNER JOIN orgs o ON m."orgID" = o.id
          WHERE o."platformApplicationID" = $1
            AND m.timestamp > NOW() - '1 week'::interval`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return parseInt(result[0].count, 10);
  },
  users: async (application) => {
    const result = await getSequelize().query(
      `SELECT COUNT(DISTINCT pv."userID")
          FROM page_visitors pv
          INNER JOIN orgs o ON pv."orgID" = o.id
          WHERE o."platformApplicationID" = $1
            AND pv."lastPresentTimestamp" > NOW() - '1 week'::interval`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return parseInt(result[0].count, 10);
  },
  usersSyncedAllTime: async (application) => {
    const result = await getSequelize().query(
      `SELECT COUNT(id)
          FROM users
          WHERE "platformApplicationID" = $1`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return parseInt(result[0].count, 10);
  },
  orgs: async (application) => {
    const result = await getSequelize().query(
      `SELECT COUNT(DISTINCT o.id)
          FROM page_visitors pv
          INNER JOIN orgs o ON pv."orgID" = o.id
          WHERE o."platformApplicationID" = $1
            AND pv."lastPresentTimestamp" > NOW() - '1 week'::interval`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return parseInt(result[0].count, 10);
  },
  orgsSyncedAllTime: async (application) => {
    const result = await getSequelize().query(
      `SELECT COUNT(id)
          FROM orgs
          WHERE "platformApplicationID" = $1`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return parseInt(result[0].count, 10);
  },
  components: async (application) => {
    const result = await getSequelize().query(
      `SELECT DISTINCT component
          FROM events e, jsonb_array_elements_text(e.payload->'components') as component
          WHERE e.type = 'sdk-components-used'
            AND e."platformApplicationID" = $1
            AND e."serverTimestamp" > NOW() - '1 week'::interval`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return result.map((c) => c.component.toLowerCase()).sort();
  },
  componentsInitializedAllTime: async (application) => {
    const result = await getSequelize().query(
      `SELECT DISTINCT component
          FROM events e, jsonb_array_elements_text(e.payload->'components') as component
          WHERE e.type = 'sdk-components-used'
            AND e."platformApplicationID" = $1`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return result.map((c) => c.component.toLowerCase()).sort();
  },
  reactPackageVersion: async (application) => {
    const results = await getSequelize().query(
      `SELECT DISTINCT payload->>'reactPackageVersion' as "reactPackageVersion"
          FROM events e
          WHERE e.type = 'sdk-init'
            AND jsonb_typeof(payload->'reactPackageVersion') = 'string'
            AND e.payload->>'appID' = $1
            AND e."serverTimestamp" > NOW() - '1 day'::interval
         `,
      {
        bind: [application.id],
        type: QueryTypes24.SELECT
      }
    );
    return results.map((result) => result.reactPackageVersion);
  },
  customLocations: async (application) => {
    const result = await getSequelize().query(
      `SELECT COUNT(DISTINCT p."contextData")
          FROM page_visitors pv
          INNER JOIN orgs o ON pv."orgID" = o.id
          INNER JOIN pages p ON pv."pageContextHash" = p."contextHash"
            AND pv."orgID" = p."orgID"
          WHERE o."platformApplicationID" = $1
            AND pv."lastPresentTimestamp" > NOW() - '1 week'::interval
            AND p."contextData" - 'location' != '{}'`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return parseInt(result[0].count, 10);
  },
  customLocationsAllTime: async (application) => {
    const result = await getSequelize().query(
      `SELECT COUNT(DISTINCT p."contextData")
          FROM pages p
          INNER JOIN orgs o ON p."orgID" = o.id
          AND p."orgID" = o.id
          WHERE o."platformApplicationID" = $1`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    );
    return parseInt(result[0].count, 10);
  },
  browsers: async (application) => {
    return (await getSequelize().query(
      // SELECT DISTINCT ON selects a single row per user, so this gives the
      // proportion by user, not by session or anything else.  If a user has
      // multiple records, we use the most recent one, so a user that uses
      // multiple browsers/OSes will get counted as just using one
      `SELECT payload->>'browserName' AS key, COUNT(*) AS count
          FROM (SELECT DISTINCT ON ("userID") payload
              FROM cord.events e
              WHERE e.type = 'sdk-client-info'
                AND e."platformApplicationID" = $1
                AND e."serverTimestamp" > NOW() - '1 week'::interval
              ORDER BY "userID", "serverTimestamp" DESC) AS e
          GROUP BY key
          ORDER BY count`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    )).map(({ key, count }) => ({ key, count: parseInt(count, 10) }));
  },
  operatingSystems: async (application) => {
    return (await getSequelize().query(
      // SELECT DISTINCT ON selects a single row per user, so this gives the
      // proportion by user, not by session or anything else.  If a user has
      // multiple records, we use the most recent one, so a user that uses
      // multiple browsers/OSes will get counted as just using one
      `SELECT payload->>'osName' AS key, COUNT(*) AS count
          FROM (SELECT DISTINCT ON ("userID") payload
              FROM cord.events e
              WHERE e.type = 'sdk-client-info'
                AND e."platformApplicationID" = $1
                AND e."serverTimestamp" > NOW() - '1 week'::interval
              ORDER BY "userID", "serverTimestamp" DESC) AS e
          GROUP BY key
          ORDER BY count`,
      { bind: [application.id], type: QueryTypes24.SELECT }
    )).map(({ key, count }) => ({ key, count: parseInt(count, 10) }));
  }
};

// server/src/schema/admin_chat_user.ts
var adminChatUserResolver = {
  user: (user) => user
};

// server/src/public/queries/organization.ts
var organizationQueryResolver = async (_, args, context) => {
  if (!await context.loaders.orgMembersLoader.viewerCanAccessOrg(args.id)) {
    throw new Error(`Viewer cannot access org ${args.id}`);
  }
  return await context.loaders.orgLoader.loadOrg(args.id);
};

// server/src/public/queries/notifications.ts
var notificationAttachmentResolver = {
  __resolveType: (attachment) => {
    if ("message" in attachment) {
      return "NotificationMessageAttachment";
    } else if ("thread" in attachment) {
      return "NotificationThreadAttachment";
    } else if ("url" in attachment) {
      return "NotificationURLAttachment";
    } else {
      throw new Error("Invalid attachment");
    }
  }
};
var notificationSenderResolver = {
  __resolveType: () => "User"
};
var notificationHeaderNodeResolver = {
  __resolveType: (node) => {
    if ("user" in node) {
      return "NotificationHeaderUserNode";
    } else if ("text" in node) {
      return "NotificationHeaderTextNode";
    } else {
      throw new Error("Invalid notification header");
    }
  }
};
var CURSOR_V1 = "v1";
var CURSOR_SEPARATOR = ":";
var notificationsResolver = async (_, args, context) => {
  let ltCreatedTimestamp = void 0;
  if (args.after) {
    const split = args.after.split(CURSOR_SEPARATOR);
    assert(split.length === 2 && split[0] === CURSOR_V1, "Invalid cursor");
    ltCreatedTimestamp = new Date(parseInt(split[1]));
  }
  if (args.filter?.organizationID) {
    const userCanAccess = await context.loaders.orgMembersLoader.viewerCanAccessOrgExternalID(
      args.filter?.organizationID
    );
    if (!userCanAccess) {
      throw new ClientFacingError("user_not_in_group" /* USER_NOT_IN_GROUP */);
    }
  }
  const { entities, nodes } = await fetchAndBuildNotifications(context, {
    ltCreatedTimestamp,
    filter: args.filter ? {
      metadata: args.filter.metadata ?? void 0,
      location: args.filter.location ? {
        value: args.filter.location,
        partialMatch: !!args.filter.partialMatch
      } : void 0,
      organizationID: args.filter.organizationID ?? void 0
    } : void 0,
    limit: args.first
  });
  return {
    nodes,
    paginationInfo: {
      // This is technically wrong when *exactly* as many notifs as exist are
      // requested. It's slightly fiddly/annoying to fix so we'll just roll
      // with it -- the client will need to deal with getting hasNextPage=true
      // but the next page being empty. Which will lead to a slightly weird UX
      // where a loading spinner comes up and results in no more notifs, but
      // is not a huge deal right now.
      hasNextPage: entities.length === args.first,
      endCursor: entities.length > 0 ? [
        CURSOR_V1,
        // Grab the timestamp, minus one millisecond -- even though we
        // do a strict less-than when consuming this, we still need to
        // subtract one: postgres stores microsecond resolution but JS
        // only deals in milisecond resolution, and so the microseconds
        // can get rounded *up* to the larger milisecond, which will
        // cause us to return a duplicate row from the previous page.
        // Subtracting the one means we will always be less. This could
        // cause weirdness if two notification rows come in within the
        // same milisecond and a pagination boundary falls between them,
        // but that is such an edge case I'm not worried. Once JS
        // properly supports microseconds and sequelize is updated, we
        // should switch to that and remove the subtraction here. cf.
        // https://github.com/sequelize/sequelize/issues/14295
        entities[entities.length - 1].createdTimestamp.getTime() - 1
      ].join(CURSOR_SEPARATOR) : ""
    }
  };
};

// server/src/public/mutations/notifications/mark_notification_as_read.ts
var markNotificationAsReadResolver = async (_, args, context) => {
  const { userID, platformApplicationID } = assertViewerHasPlatformUser(
    context.session.viewer
  );
  const notif = args.byExternalID ? await NotificationEntity.findOne({
    where: { externalID: args.notificationID, platformApplicationID }
  }) : await NotificationEntity.findByPk(args.notificationID);
  if (!notif || notif.recipientID !== userID) {
    return {
      success: false,
      failureDetails: { code: "404", message: "No such notification" }
    };
  }
  const notificationMutator = new NotificationMutator(context.session.viewer);
  const affectedCount = await notificationMutator.markAsRead(notif);
  logServerEvent({
    session: context.session,
    type: "notification-mark-as-read",
    logLevel: "debug" /* DEBUG */,
    payload: { id: notif.id, type: notif.type, affected: affectedCount }
  });
  return { success: true, failureDetails: null };
};
var markNotificationAsUnreadResolver = async (_, args, context) => {
  const { userID, platformApplicationID } = assertViewerHasPlatformUser(
    context.session.viewer
  );
  const notif = await NotificationEntity.findOne({
    where: { externalID: args.notificationExternalID, platformApplicationID }
  });
  if (!notif || notif.recipientID !== userID) {
    return {
      success: false,
      failureDetails: { code: "404", message: "No such notification" }
    };
  }
  const notificationMutator = new NotificationMutator(context.session.viewer);
  const affectedCount = await notificationMutator.markAsUnread(notif);
  logServerEvent({
    session: context.session,
    type: "notification-mark-as-unread",
    logLevel: "debug" /* DEBUG */,
    payload: { id: notif.id, type: notif.type, affected: affectedCount }
  });
  return { success: true, failureDetails: null };
};
var markAllNotificationsAsReadResolver = async (_, args, context) => {
  const userID = assertViewerHasUser(context.session.viewer);
  const readStatus = "unread";
  const {
    bindVariables: partialBind,
    extraJoins,
    extraCondition
  } = await createNotificationsQueryExpressionsFromFilters({
    filter: {
      metadata: args.filter?.metadata ?? void 0,
      location: args.filter?.location ? {
        value: args.filter.location,
        partialMatch: !!args.filter.partialMatch
      } : void 0,
      organizationID: args.filter?.organizationID ?? void 0
    },
    platformApplicationID: context.session.viewer.platformApplicationID,
    ltCreatedTimestamp: void 0,
    limit: void 0,
    viewer: context.session.viewer
  });
  const bindVariables = [...partialBind, userID, readStatus];
  const notificationFilter = `WHERE n."recipientID" = $${bindVariables.length - 1} AND n."readStatus" = $${bindVariables.length}`;
  const [affectedRows, __] = await getSequelize().query(
    `
       UPDATE notifications notifs
       SET "readStatus" = 'read'
       FROM (
        SELECT n.id as id from notifications n 
        ${extraJoins}
        ${notificationFilter}
        ${extraCondition}

       ) as sub
      WHERE notifs.id = sub.id
       RETURNING notifs."id";`,
    {
      bind: bindVariables
    }
  );
  backgroundPromise(
    Promise.all(
      affectedRows.map(
        (row) => publishPubSubEvent(
          "notification-read-state-updated",
          { userID },
          { notificationID: row.id }
        )
      )
    ),
    context.logger
  );
  incCounterWithAppID(
    context.session.viewer,
    markedCounter,
    {},
    affectedRows.length
  );
  return { success: true, failureDetails: null };
};

// server/src/public/queries/activity.ts
var activityQueryResolver = async (_, args, _context) => {
  const pageContext = toPageContext(args.pageContext);
  return {
    location: pageContext?.data,
    partialMatch: !!args.partialMatch,
    metadata: args.metadata ?? void 0,
    viewer: args.viewer ?? void 0,
    resolved: args.resolved ?? void 0
  };
};

// server/src/public/subscriptions/thread_activity_summary.ts
var ACTIVITY_THROTTLE_MS = 500;
var threadActivitySummarySubscriptionResolver = {
  subscribe: async (_root, args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const orgIDs = assertViewerHasOrgs(context.session.viewer);
    const filter = {
      location: toPageContext(args.pageContext)?.data,
      partialMatch: args.partialMatch ?? void 0,
      metadata: args.metadata ?? void 0,
      viewer: args.viewer ?? void 0,
      resolved: args.resolved ?? void 0
    };
    return withThrottle(
      withFilter(
        withRestartEvent({
          events: [
            ...orgIDs.flatMap(
              (orgID) => [
                ["page-thread-added-with-location", { orgID }],
                ["thread-filterable-properties-updated", { orgID }]
              ]
            ),
            ["inbox-updated", { userID }]
          ],
          userID,
          subscriptionName: "threadActivitySummarySubscriptionResolver"
        }),
        async ({ payload, name }) => {
          if (!payload || !("threadID" in payload)) {
            if (name !== "inbox-updated") {
              context.logger.error(
                `Unexpected empty payload for event ${name}`
              );
            }
            return true;
          }
          if (name === "thread-filterable-properties-updated") {
            return updateMightBeRelevant(
              context.logger,
              filter,
              payload,
              userID
            );
          }
          return await context.loaders.threadLoader.threadMatchesFilter(
            payload.threadID,
            filter
          );
        }
      ),
      ACTIVITY_THROTTLE_MS
    )();
  },
  resolve: (_root, args, context) => context.loaders.threadLoader.loadThreadActivitySummary({
    location: toPageContext(args.pageContext)?.data,
    partialMatch: args.partialMatch ?? void 0,
    metadata: args.metadata ?? void 0,
    viewer: args.viewer ?? void 0,
    resolved: args.resolved ?? void 0
  })
};

// server/src/schema/activity.ts
var activityResolver = {
  threadSummary: (root, _args, context) => context.loaders.threadLoader.loadThreadActivitySummary(root)
};

// server/src/schema/thread_message_removed.ts
var threadMessageRemovedResolver = {
  id: ({ payload: { messageID } }) => messageID
};

// server/src/schema/thread_share_to_slack.ts
var threadShareToSlackResolver = {
  id: ({ args: { threadID } }) => threadID,
  info: ({ payload: { info } }) => info
};

// server/src/public/mutations/set_thread_name.ts
var setThreadNameResolver = async (_, { threadID, name }, context) => {
  try {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (!thread) {
      return { success: false, failureDetails: null };
    }
    if (thread.name === name) {
      return { success: true, failureDetails: null };
    }
    const threadMutator = new ThreadMutator(
      context.session.viewer,
      context.loaders
    );
    const success = await threadMutator.setThreadName(threadID, name);
    if (success) {
      await publishPubSubEvent("thread-properties-updated", { threadID });
    }
    return { success, failureDetails: null };
  } catch {
    return { success: false, failureDetails: null };
  }
};

// server/src/public/mutations/notifications/delete_notification.ts
var deleteNotificationResolver = async (_, args, context) => {
  const userID = assertViewerHasUser(context.session.viewer);
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  const notif = args.byExternalID ? await NotificationEntity.findOne({
    where: { externalID: args.notificationID, platformApplicationID }
  }) : await NotificationEntity.findByPk(args.notificationID);
  if (!notif || notif.recipientID !== userID) {
    return {
      success: false,
      failureDetails: { code: "404", message: "No such notification" }
    };
  }
  const affectedCount = await NotificationEntity.destroy({
    where: whereAggregatedNotificationEntity(notif)
  });
  incCounterWithAppID(
    context.session.viewer,
    deletedCounter,
    {},
    affectedCount
  );
  backgroundPromise(
    publishPubSubEvent(
      "notification-deleted",
      { userID },
      { notificationID: notif.id }
    )
  );
  return { success: true, failureDetails: null };
};

// server/src/public/subscriptions/notification_events.ts
var notificationEventsSubscriptionResolver = {
  resolve: (payload) => payload,
  subscribe: async (_root, args, context) => {
    const { filter } = args;
    const userID = assertViewerHasUser(context.session.viewer);
    return withFilter(
      () => pubSubAsyncIterator(
        // this must map to the NotificationEvents type definition in mapping.ts
        ["notification-added", { userID }],
        ["notification-read-state-updated", { userID }],
        ["notification-deleted", { userID }]
      ),
      async ({ name, payload }) => {
        if (!payload) {
          return false;
        }
        if (name !== "notification-added") {
          return true;
        }
        const matchesFilter = await context.loaders.notificationLoader.notificationMatchesFilter(
          payload.notificationID,
          filter ? {
            metadata: filter.metadata ?? void 0,
            location: filter.location ? {
              value: filter.location,
              partialMatch: !!filter.partialMatch
            } : void 0,
            organizationID: filter.organizationID ?? void 0
          } : void 0
        );
        if (!matchesFilter) {
          return false;
        }
        return true;
      }
    )();
  }
};
var notificationEventTypeResolver = {
  __resolveType: (event) => {
    switch (event.name) {
      case "notification-added":
        return NotificationAddedTypeName;
      case "notification-read-state-updated":
        return NotificationReadStateUpdatedTypeName;
      case "notification-deleted":
        return NotificationDeletedTypeName;
    }
  }
};

// server/src/schema/notification_added.ts
var notificationAddedResolver = {
  notification: async ({ payload: { notificationID } }, _, context) => {
    assertViewerHasUser(context.session.viewer);
    const notificationEntity = await NotificationEntity.findByPk(notificationID);
    if (!notificationEntity) {
      throw new Error(
        `Notification not found despite receiving subscription event ${notificationID}`
      );
    }
    const notification = await buildNotification(context, [notificationEntity]);
    if (!notification) {
      throw new Error(`Something went wrong when preparing notification`);
    }
    return notification;
  }
};

// server/src/schema/notification_read_state_updated.ts
var notificationReadStateUpdatedResolver = {
  notification: async ({ payload: { notificationID } }, _, context) => {
    assertViewerHasUser(context.session.viewer);
    const notificationEntity = await NotificationEntity.findByPk(notificationID);
    if (!notificationEntity) {
      throw new Error(
        `Notification not found despite receiving subscription event ${notificationID}`
      );
    }
    const notification = await buildNotification(context, [
      notificationEntity
    ]);
    if (!notification) {
      throw new Error(
        `Something went wrong when preparing notification for NotificationEntity ${notificationID}`
      );
    }
    return notification;
  }
};

// server/src/schema/customer_issue.ts
var customerIssueResolver = {
  customer: async (customerIssue, _args, context) => {
    const customer = await context.loaders.customerLoader.load(
      customerIssue.customerID
    );
    if (!customer) {
      throw new Error("Customer missing");
    }
    return customer;
  },
  nextAction: (customerIssue) => {
    const { decision, communicationStatus } = customerIssue;
    if (communicationStatus === "none") {
      return "ack_receipt";
    }
    if (decision === "pending") {
      return "make_decision";
    }
    if (communicationStatus === "request_acked") {
      return "send_decision";
    }
    if (decision === "accepted") {
      return "do_work";
    }
    if ((decision === "done" || decision === "rejected") && communicationStatus === "decision_sent") {
      return "wait_for_ack";
    }
    if ((decision === "done" || decision === "rejected") && communicationStatus === "decision_acked") {
      return "done";
    }
    return "unknown";
  },
  history: async (customerIssue) => {
    return await AdminCRTCustomerIssueChangeEntity.findAll({
      where: { issueID: customerIssue.id },
      order: [["timestamp", "ASC"]]
    });
  },
  assignee: async (customerIssue, _args, context) => {
    return customerIssue.assignee ? await context.loaders.userLoader.loadUser(customerIssue.assignee) : null;
  },
  subscribed: async (customerIssue, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const issueID = customerIssue.id;
    const subscription = await AdminCRTCustomerIssueSubscriptionEntity.findOne({
      where: { issueID, userID }
    });
    return !!subscription;
  }
};

// server/src/schema/customer_issue_change.ts
var customerIssueChangeResolver = {
  user: async (change, _args, context) => {
    const orgID = assertViewerHasOrg(context.session.viewer);
    const user = await context.loaders.userLoader.loadUserInOrg(
      change.userID,
      orgID
    );
    if (!user) {
      throw new Error("Change log associated with nonexistent user?");
    }
    return user;
  },
  created: (change) => {
    return Boolean(change.changeDetail.created);
  },
  updated: (change) => change.changeDetail.updated ?? []
};

// server/src/public/queries/notification_summary.ts
function notificationFilterInputToNotificationListFilter(filter) {
  return {
    metadata: filter?.metadata ?? void 0,
    location: filter?.location ? { value: filter.location, partialMatch: !!filter.partialMatch } : void 0,
    organizationID: filter?.organizationID ?? void 0
  };
}
var notificationSummaryQueryResolver = (_, args, _context) => ({
  filter: notificationFilterInputToNotificationListFilter(args.filter)
});

// server/src/public/subscriptions/util/with_transformation.ts
import { $$asyncIterator as $$asyncIterator2 } from "iterall";
function withTransformation(asyncIteratorFn, transformFn) {
  return (rootValue, args, context, info) => {
    const asyncIterator = asyncIteratorFn(rootValue, args, context, info);
    return {
      next() {
        return new Promise((resolve2, reject) => {
          asyncIterator.next().then((payload) => {
            if (payload.done === true) {
              resolve2(payload);
              return;
            }
            Promise.resolve(transformFn(payload.value, args, context, info)).then((newResult) => resolve2({ done: false, value: newResult })).catch((err) => reject(err));
          }).catch((err) => {
            reject(err);
            return;
          });
        });
      },
      return() {
        return asyncIterator.return();
      },
      throw(error) {
        return asyncIterator.throw(error);
      },
      [$$asyncIterator2]() {
        return this;
      }
    };
  };
}

// server/src/public/subscriptions/notification_summary_updated.ts
var notificationSummaryUpdatedSubscriptionResolver = {
  resolve: (payload) => payload,
  subscribe: (_root, args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    return withFilter(
      withTransformation(
        () => pubSubAsyncIterator(
          ["notification-added", { userID }],
          ["notification-deleted", { userID }],
          ["notification-read-state-updated", { userID }]
        ),
        ({ payload, name }) => ({
          filter: notificationFilterInputToNotificationListFilter(
            args.filter
          ),
          payload,
          name
        })
      ),
      async ({ filter, name, payload }) => {
        if (!payload) {
          return false;
        }
        if (name !== "notification-added") {
          return true;
        }
        const matchesFilter = await context.loaders.notificationLoader.notificationMatchesFilter(
          payload.notificationID,
          filter
        );
        if (!matchesFilter) {
          return false;
        }
        return true;
      }
    )();
  }
};

// server/src/schema/notification_summary.ts
var notificationSummaryResolver = {
  unreadNotificationCount: async ({ filter }, _args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const filterGroupID = filter?.groupID ?? filter?.organizationID;
    if (filterGroupID) {
      const userCanAccess = await context.loaders.orgMembersLoader.viewerCanAccessOrgExternalID(
        filterGroupID
      );
      if (!userCanAccess) {
        throw new ClientFacingError("user_not_in_group" /* USER_NOT_IN_GROUP */);
      }
    }
    return await context.loaders.notificationLoader.loadUnreadNotificationCount(
      userID,
      {
        metadata: filter?.metadata ?? void 0,
        location: filter?.location ?? void 0,
        organizationID: filter?.organizationID ?? void 0
      }
    );
  }
};

// server/src/public/mutations/set_thread_metadata.ts
var setThreadMetadataResolver = async (_, { threadID, metadata }, context) => {
  try {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (!thread) {
      return { success: false, failureDetails: null };
    }
    if (!isValidMetadata(metadata)) {
      return {
        success: false,
        failureDetails: {
          code: "INVALID_METADATA",
          message: "Metadata must be a flat JSON object"
        }
      };
    }
    if (isEqual(thread.metadata, metadata)) {
      return { success: true, failureDetails: null };
    }
    const threadMutator = new ThreadMutator(
      context.session.viewer,
      context.loaders
    );
    const success = await threadMutator.setThreadMetadata(threadID, metadata);
    if (success) {
      await publishPubSubEvent("thread-properties-updated", { threadID });
    }
    return { success, failureDetails: null };
  } catch (e) {
    return {
      success: false,
      failureDetails: {
        code: e?.code ?? "",
        message: e?.message
      }
    };
  }
};

// server/src/schema/thread_properties_updated.ts
var threadPropertiesUpdatedResolver = {
  thread: async ({ args: { threadID } }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (!thread) {
      throw new Error("Thread does not exist");
    }
    return thread;
  }
};

// server/src/public/subscriptions/page_events_with_location.ts
var pageEventsWithLocationSubscriptionResolver = {
  resolve: (payload) => payload,
  subscribe: async (_root, args, context) => {
    const orgIDs = assertViewerHasOrgs(context.session.viewer);
    const userID = assertViewerHasUser(context.session.viewer);
    const filter = {
      location: args.location ?? void 0,
      partialMatch: args.partialMatch ?? void 0,
      metadata: args.filter?.metadata ?? void 0,
      viewer: args.filter?.viewer ?? void 0,
      resolved: args.resolved ?? void 0
    };
    return withFilter(
      withTransformation(
        withRestartEvent({
          events: orgIDs.flatMap(
            (orgID) => [
              ["page-thread-added-with-location", { orgID }],
              ["thread-filterable-properties-updated", { orgID }],
              ["page-thread-deleted", { orgID }]
            ]
          ),
          userID,
          subscriptionName: "pageEventsWithLocationSubscriptionResolver"
        }),
        async ({ payload, name }) => {
          if (name !== "thread-filterable-properties-updated") {
            return { payload, name };
          }
          return {
            payload,
            name,
            matchedFilters: await context.loaders.threadLoader.threadMatchesFilter(
              payload.threadID,
              filter
            )
          };
        }
      ),
      async ({ name, payload }) => {
        if (!payload) {
          return false;
        }
        if (name === "thread-filterable-properties-updated") {
          return updateMightBeRelevant(
            context.logger,
            filter,
            payload,
            userID
          );
        }
        if (name === "page-thread-deleted") {
          return true;
        }
        return await context.loaders.threadLoader.threadMatchesFilter(
          payload.threadID,
          filter
        );
      }
    )();
  }
};
var pageEventTypeResolver = {
  __resolveType: (event) => {
    switch (event.name) {
      case "page-thread-added-with-location":
        return PageThreadAddedTypeName;
      case "page-thread-deleted":
        return PageThreadDeletedTypename;
      case "thread-filterable-properties-updated":
        if ("matchedFilters" in event && event["matchedFilters"]) {
          return ThreadFilterablePropertiesMatchTypeName;
        } else {
          return ThreadFilterablePropertiesUnmatchTypeName;
        }
    }
  }
};

// server/src/public/queries/message_by_external_id.ts
var messageByExternalIDQueryResolver = async (_, args, context) => {
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  const { id } = args;
  const message = await context.loaders.messageLoader.loadMessageByExternalID(
    id,
    platformApplicationID
  );
  if (message) {
    await context.loaders.threadLoader.assertViewerHasThread(
      message.threadID
    );
  }
  return message;
};

// server/src/public/mutations/log_deprecation.ts
var logDeprecationMutationResolver = async (_, args, context) => {
  const key = args.key;
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  deprecated(`from-client:${key}`, platformApplicationID);
  return true;
};

// server/src/schema/notification_deleted.ts
var notificationDeletedResolver = {
  id: ({ payload: { notificationID } }) => notificationID
};

// server/src/public/queries/notification_by_external_id.ts
var notificationByExternalIDResolver = async (_, args, context) => {
  const userID = assertViewerHasUser(context.session.viewer);
  const externalID = args.externalID;
  const notifEntity = await NotificationEntity.findOne({
    where: {
      externalID,
      recipientID: userID
    }
  });
  if (!notifEntity) {
    return null;
  }
  const aggregateEntities = await NotificationEntity.findAll({
    where: whereAggregatedNotificationEntity(notifEntity)
  });
  const gqlNotif = await buildNotification(context, aggregateEntities);
  return gqlNotif ? { ...gqlNotif, externalID } : null;
};

// server/src/public/mutations/set_subscribed_by_external_id.ts
var setSubscribedByExternalIDMutationResolver = sendErrors(async (_, args, originalContext) => {
  const { externalID, subscribed } = args;
  const thread = await originalContext.loaders.threadLoader.loadByExternalID(externalID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  const context = await getRelevantContext(originalContext, thread.orgID);
  const originalSubscribers = new Set(
    await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  const threadParticipantMutator = new ThreadParticipantMutator(
    context.session.viewer,
    context.loaders
  );
  const result = await threadParticipantMutator.setViewerSubscribed(
    thread,
    subscribed
  );
  const newSubscribers = new Set(
    await context.loaders.threadParticipantLoader.loadSubscriberIDsForThreadNoOrgCheck(
      thread.id
    )
  );
  const removed = [...originalSubscribers].filter(
    (s) => !newSubscribers.has(s)
  );
  const added = [...newSubscribers].filter(
    (s) => !originalSubscribers.has(s)
  );
  if (removed.length > 0 || added.length > 0) {
    backgroundPromise(
      publishPubSubEvent(
        "thread-filterable-properties-updated",
        { orgID: thread.orgID },
        { threadID: thread.id, changes: { subscribers: { added, removed } } }
      )
    );
  }
  return { success: result, failureDetails: null };
});

// server/src/public/mutations/update_thread_by_external_id.ts
var updateThreadByExternalIDResolver = sendErrors(
  async (_, {
    externalThreadID,
    url: url6,
    name,
    metadata,
    resolved,
    extraClassnames,
    typing
  }, context) => {
    const { platformApplicationID, externalUserID } = assertViewerHasPlatformUser(context.session.viewer);
    const thread = await context.loaders.threadLoader.loadByExternalIDStrictOrgCheck(
      externalThreadID
    );
    if (!thread) {
      throw new ApiCallerError("thread_not_found");
    }
    await updateThread({
      platformApplicationID,
      threadID: externalThreadID,
      name: name ?? void 0,
      url: url6 ?? void 0,
      metadata: metadata ?? void 0,
      resolved: resolved ?? void 0,
      userID: externalUserID,
      extraClassnames,
      typing: typing ? [externalUserID] : void 0
    });
    return { success: true, failureDetails: null };
  }
);

// server/src/public/mutations/create_message_by_external_id.ts
import { v4 as uuid22 } from "uuid";
var createMessageByExternalIDResolver = sendErrors(async (_, args, context) => {
  const { platformApplicationID, externalUserID } = assertViewerHasPlatformUser(context.session.viewer);
  const { externalOrgID: viewerExternalOrgID } = context.session.viewer;
  const thread = await context.loaders.threadLoader.loadByExternalIDStrictOrgCheck(
    args.input.externalThreadID
  );
  let threadOrg;
  if (thread) {
    threadOrg = await context.loaders.orgLoader.loadOrg(thread?.orgID);
  }
  const externalOrgID = threadOrg?.externalID ?? viewerExternalOrgID;
  if (!externalOrgID) {
    throw new ApiCallerError("group_not_found", {
      message: "Must specify a groupID if creating a new thread"
    });
  }
  if (args.input.type !== void 0) {
    deprecated(
      "graphql: createMessageByExternalID type",
      platformApplicationID
    );
    if (args.input.type && args.input.type !== "user_message") {
      throw new ApiCallerError("invalid_field", {
        message: "Only user_messages can be sent with the JS API"
      });
    }
  }
  if (!args.input.messageID) {
    deprecated(
      "graphql: createMessageByExternalID missing messageID",
      platformApplicationID
    );
  }
  await createThreadMessage({
    platformApplicationID,
    threadID: args.input.externalThreadID,
    id: args.input.externalMessageID ?? void 0,
    internalMessageID: args.input.messageID ?? uuid22(),
    authorID: externalUserID,
    content: args.input.content,
    url: args.input.url ?? void 0,
    addReactions: args.input.addReactions?.map((reaction) => ({
      reaction,
      timestamp: /* @__PURE__ */ new Date(),
      userID: externalUserID
    })),
    addAttachments: args.input.addFileAttachments?.map((fileID) => ({
      type: "file",
      id: fileID
    })),
    iconURL: args.input.iconURL ?? void 0,
    translationKey: args.input.translationKey ?? void 0,
    extraClassnames: args.input.extraClassnames ?? "",
    createThread: args.input.createThread ? {
      organizationID: externalOrgID,
      groupID: externalOrgID,
      location: args.input.createThread.location,
      url: args.input.createThread.url,
      name: args.input.createThread.name,
      metadata: args.input.createThread.metadata ?? void 0,
      extraClassnames: args.input.createThread.extraClassnames ?? void 0,
      addSubscribers: args.input.createThread.addSubscribers ?? void 0
    } : void 0,
    metadata: args.input.metadata ?? void 0,
    subscribeToThread: args.input.subscribeToThread ?? void 0,
    screenshotAttachment: args.input.screenshotAttachment
  });
  return { success: true, failureDetails: null };
});

// server/src/public/mutations/update_message_by_external_id.ts
var updateMessageByExternalIDResolver = sendErrors(async (_, args, context) => {
  const { platformApplicationID, userID, externalUserID } = assertViewerHasPlatformUser(context.session.viewer);
  const message = await context.loaders.messageLoader.loadMessageByExternalID(
    args.input.externalMessageID,
    platformApplicationID
  );
  if (!message) {
    throw new ApiCallerError("message_not_found");
  }
  const thread = args.input.externalThreadID ? await context.loaders.threadLoader.loadByExternalIDStrictOrgCheck(
    args.input.externalThreadID
  ) : await context.loaders.threadLoader.loadThread(message.threadID);
  if (!thread) {
    throw new ApiCallerError("thread_not_found");
  }
  if (thread.id !== message.threadID) {
    throw new ApiCallerError("message_not_found");
  }
  if (!isReactionsOnlyUpdate(args.input) && message.sourceID !== userID) {
    throw new ApiCallerError("message_edit_forbidden");
  }
  if (args.input.type !== void 0) {
    deprecated(
      "graphql: updateMessageByExternalID type",
      platformApplicationID
    );
    if (args.input.type && args.input.type !== "user_message") {
      throw new ApiCallerError("invalid_field", {
        message: "Only user_messages can be sent with the JS API"
      });
    }
  }
  const removeAttachments = [
    ...args.input.removeFileAttachments?.map((fileID) => ({
      type: "file",
      id: fileID
    })) ?? [],
    ...args.input.removePreviewLinks?.map((previewID) => ({
      type: "link_preview",
      id: previewID
    })) ?? []
  ];
  await updateThreadMessage({
    context,
    thread,
    message,
    content: args.input.content ?? void 0,
    url: args.input.url ?? void 0,
    iconURL: args.input.iconURL ?? void 0,
    translationKey: args.input.translationKey ?? void 0,
    metadata: args.input.metadata ?? void 0,
    extraClassnames: args.input.extraClassnames ?? void 0,
    deleted: args.input.deleted ?? void 0,
    addReactions: args.input.addReactions?.map((reaction) => ({
      reaction,
      userID: externalUserID
    })),
    removeReactions: args.input.removeReactions?.map((reaction) => ({
      reaction,
      userID: externalUserID
    })),
    addAttachments: args.input.addFileAttachments?.map((fileID) => ({
      type: "file",
      id: fileID
    })),
    removeAttachments,
    skipLinkPreviews: args.input.skipLinkPreviews ?? void 0
  });
  return { success: true, failureDetails: null };
});
function isReactionsOnlyUpdate(input) {
  const allowedFields = [
    "externalMessageID",
    "externalThreadID",
    "addReactions",
    "removeReactions"
  ];
  for (const key in input) {
    if (!allowedFields.includes(key)) {
      return false;
    }
  }
  return true;
}

// server/src/public/subscriptions/user_live_query.ts
import { QueryTypes as QueryTypes25 } from "sequelize";
var THROTTLE_MS2 = 2e3;
var userLiveQueryResolver = {
  resolve: (data) => data,
  subscribe: async (_root, args, context) => {
    const platformApplicationID = context.session.viewer.platformApplicationID ?? null;
    const userID = assertViewerHasUser(context.session.viewer);
    const orgIDs = assertViewerHasOrgs(context.session.viewer);
    const iterable = await liveQueryWithRestartEvent({
      events: orgIDs.map((orgID) => ["org-user-identity", { orgID }]),
      initialData: async () => {
        return {
          users: args.since ? (
            // Find every active user that's been updated since the given
            // timestamp
            await context.sequelize.query(
              `
                  SELECT users.* FROM users, org_members
                  WHERE users."updatedTimestamp" >= $1
                    AND users.state != 'deleted'
                    AND users.id = org_members."userID"
                    AND users."platformApplicationID" = $2
                    AND org_members."orgID" = ANY($3)
                    LIMIT 1000;
                `,
              {
                bind: [new Date(args.since), platformApplicationID, orgIDs],
                type: QueryTypes25.SELECT,
                model: UserEntity
              }
            )
          ) : [],
          upto: (/* @__PURE__ */ new Date()).getTime()
        };
      },
      eventData: async (event) => {
        const user = await context.loaders.userLoader.loadUserInAnyViewerOrg(
          event.payload.userID
        );
        return {
          users: user ? [user] : [],
          upto: (/* @__PURE__ */ new Date()).getTime()
        };
      },
      userID,
      subscriptionName: "userLiveQueryResolver"
    });
    return withThrottle(
      () => iterable[Symbol.asyncIterator](),
      THROTTLE_MS2,
      // If this is an update about a single user, throttle it, otherwise let
      // it through (by returning a unique symbol) since we don't ever want to
      // skip an empty or multi-user update
      (data) => data.users.length === 1 ? data.users[0].id : Symbol()
    )();
  }
};

// server/src/public/mutations/mark_thread_unseen_from_external_message_id.ts
var markThreadUnseenFromExternalMessageIDResolver = async (_, args, originalContext) => {
  const { externalThreadID, externalMessageID } = args;
  const thread = await originalContext.loaders.threadLoader.loadByExternalIDStrictOrgCheck(
    externalThreadID
  );
  if (!thread) {
    return {
      success: false,
      failureDetails: { code: "404", message: "Thread not found" }
    };
  }
  const context = await getRelevantContext(originalContext, thread.orgID);
  const { platformApplicationID } = assertViewerHasPlatformIdentity(
    context.session.viewer
  );
  const threadParticipantMutator = new ThreadParticipantMutator(
    context.session.viewer,
    context.loaders
  );
  if (!externalMessageID) {
    await threadParticipantMutator.markThreadSeen({
      threadID: thread.id
    });
  } else {
    const message = await context.loaders.messageLoader.loadMessageByExternalID(
      externalMessageID,
      platformApplicationID
    );
    if (!message) {
      return {
        success: false,
        failureDetails: { code: "400", message: "Message not found" }
      };
    }
    await threadParticipantMutator.markThreadUnseenFromMessage({
      threadID: thread.id,
      messageID: message.id
    });
  }
  return {
    success: true,
    failureDetails: null
  };
};

// server/src/public/queries/message_content_search.ts
import { QueryTypes as QueryTypes26 } from "sequelize";
var messageContentSearchResolver = async (_, args, context) => {
  const {
    textToMatch: searchText,
    authorExternalID,
    orgExternalID,
    locationOptions,
    timestampRange,
    metadata,
    limit,
    sortBy,
    sortDirection
  } = args;
  const appID = assertViewerHasPlatformApplicationID(context.session.viewer);
  if (!searchText && !authorExternalID && !orgExternalID && !locationOptions && !timestampRange && !metadata) {
    return [];
  }
  const extraConditions = [];
  const extraJoins = [];
  const bindVariables = [appID];
  let subquery = "";
  const allOrgsForUser = await context.loaders.orgMembersLoader.loadAllImmediateOrgIDsForUser();
  if (orgExternalID) {
    const orgData = await context.loaders.orgLoader.loadPlatformOrg(
      appID,
      orgExternalID
    );
    if (!orgData) {
      context.logger.warn("Unable to find specified org external ID", {
        orgExternalID
      });
      return [];
    }
    const isOrgMember = allOrgsForUser.includes(orgData.id);
    if (!isOrgMember) {
      context.logger.warn("User is not a member of org", {
        orgExternalID
      });
      return [];
    } else {
      bindVariables.push(orgData.id);
      extraConditions.push(`m."orgID" = $${bindVariables.length}`);
    }
  } else {
    bindVariables.push(allOrgsForUser);
    extraConditions.push(`m."orgID" = ANY($${bindVariables.length})`);
  }
  if (authorExternalID) {
    const internalUserID = (await context.loaders.userLoader.loadUserByExternalID(
      appID,
      authorExternalID
    ))?.id;
    if (!internalUserID) {
      context.logger.warn("Unable to find specified author external ID", {
        authorExternalID
      });
      return [];
    } else {
      bindVariables.push(internalUserID);
      extraConditions.push(`"sourceID" = $${bindVariables.length}`);
    }
  }
  if (locationOptions) {
    extraJoins.push(`INNER JOIN threads t
      ON (t.id = m."threadID")
      INNER JOIN pages p
      ON (p."orgID" = t."orgID" AND p."contextHash" = t."pageContextHash")`);
    bindVariables.push(locationOptions.location);
    extraConditions.push(
      `p."contextData" ${locationOptions.partialMatch ? "@>" : "="} $${bindVariables.length}::jsonb`
    );
  }
  if (metadata) {
    bindVariables.push(metadata);
    extraConditions.push(`m.metadata @> $${bindVariables.length}::jsonb`);
  }
  if (timestampRange) {
    if (timestampRange.from && !isNaN(timestampRange.from.getTime())) {
      bindVariables.push(timestampRange.from);
      extraConditions.push(
        `m.timestamp >= $${bindVariables.length}::timestamp`
      );
    }
    if (timestampRange.to && !isNaN(timestampRange.to.getTime())) {
      bindVariables.push(timestampRange.to);
      extraConditions.push(
        `m.timestamp <= $${bindVariables.length}::timestamp`
      );
    }
  }
  if (searchText) {
    bindVariables.push(searchText);
    subquery = `WITH search AS (
        SELECT to_tsquery(string_agg(lexeme || ':*', ' & ' order by positions)) AS query
        FROM unnest(to_tsvector('english', $${bindVariables.length}))
    )`;
    extraConditions.push(`"contentTsVector" @@ search.query`);
  }
  const extraCondition = extraConditions.length > 0 ? `AND ${extraConditions.join(" AND ")}` : "";
  const extraJoin = extraJoins.join(" ");
  const limitCondition = `LIMIT ${isDefined(limit) && limit >= 0 ? Math.min(limit, 1e3) : 50}`;
  const { orderCondition, additionalOrderCondition } = getSearchSortingConditions({ sortBy, sortDirection, searchText });
  const queryToMaybeGetMostRelevantMessages = `SELECT m.*
    ${searchText ? ', ts_rank(m."contentTsVector", search.query) AS rank' : ""}
    FROM messages m
    ${extraJoin}
    ${searchText ? ", search" : ""}
    WHERE m."platformApplicationID" = $1
    AND m."deletedTimestamp" IS NULL
    ${extraCondition}
    ${orderCondition}
    ${limitCondition}`;
  const messages = await context.sequelize.query(
    `
      ${subquery}
      SELECT * FROM (
        ${queryToMaybeGetMostRelevantMessages}
      ) AS messages
      ${additionalOrderCondition}
    `,
    {
      bind: bindVariables,
      type: QueryTypes26.SELECT,
      model: MessageEntity
    }
  );
  return messages;
};
function getSearchSortingConditions({
  sortBy,
  sortDirection,
  searchText
}) {
  const sortDirectionValue = sortDirection === "ascending" ? "ASC" : "DESC";
  const sortByValue = sortBy === "created_timestamp" ? "timestamp" : "rank";
  const additionalOrderCondition = searchText ? `ORDER by ${sortByValue} ${sortDirectionValue}` : "";
  return {
    orderCondition: searchText ? `ORDER BY rank DESC` : `ORDER BY m.timestamp ${sortDirectionValue}`,
    additionalOrderCondition
  };
}

// server/src/public/queries/threads_at_location.ts
var threadsAtLocationQueryResolver = async (_, { location, filter, resolved, partialMatch, sort, limit, after }, context) => await context.loaders.threadLoader.loadThreadsForPage({
  filter: {
    location: location ?? void 0,
    partialMatch: partialMatch ?? void 0,
    resolved: resolved ?? void 0,
    metadata: filter?.metadata ?? void 0,
    viewer: filter?.viewer ?? void 0
  },
  sort,
  limit,
  after
});

// server/src/schema/message_screenshot_attachment.ts
var messageScreenshotAttachmentResolver = {
  screenshot: async (messageAttachment, _, context) => await loadScreenshotById(
    context,
    messageAttachment.data.screenshotFileID
  ),
  blurredScreenshot: async (messageAttachment, _, context) => await loadScreenshotById(
    context,
    messageAttachment.data.blurredScreenshotFileID
  )
};
async function loadScreenshotById(context, screenshotId) {
  if (!screenshotId) {
    return null;
  }
  try {
    return await context.loaders.fileLoader.loadFile(screenshotId);
  } catch (e) {
    return null;
  }
}

// server/src/schema/thread_created.ts
var threadCreatedResolver = {
  thread: async ({ payload: { threadID } }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (!thread) {
      throw new Error("Thread does not exist");
    }
    return thread;
  }
};

// server/src/public/mutations/hide_link_preview.ts
var hideLinkPreviewResolver = async (_, args, context) => {
  const { linkPreviewID } = args;
  const messageLinkPreviewMutator = new MessageLinkPreviewMutator(
    context.session.viewer,
    context.loaders
  );
  const result = await messageLinkPreviewMutator.hide(linkPreviewID);
  return {
    success: result,
    failureDetails: null
  };
};

// server/src/public/mutations/create_thread.ts
var createThreadResolver = sendErrors(async (_, args, context) => {
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  if (!context.session.viewer.orgID) {
    return {
      success: false,
      failureDetails: {
        code: "400",
        message: "Must specify a groupID."
      }
    };
  }
  await serializableTransactionWithRetries(async (transaction) => {
    const { thread } = await createThread({
      id: args.externalThreadID ?? void 0,
      url: args.input.url,
      location: args.input.location,
      name: args.input.name,
      metadata: args.input.metadata ?? void 0,
      extraClassnames: args.input.extraClassnames,
      transaction,
      viewer: context.session.viewer,
      platformApplicationID,
      addSubscribers: args.input.addSubscribers ?? void 0
    });
    await publishNewThreadEvents(args.input.location, thread, transaction);
  });
  return { success: true, failureDetails: null };
});

// server/src/schema/page_thread_reply_added.ts
var pageThreadReplyAddedResolver = {
  thread: async ({ payload: { threadID } }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (!thread) {
      throw new Error("Thread does not exist.");
    }
    return thread;
  },
  message: async ({ payload: { messageID } }, _, context) => {
    const message = await context.loaders.messageLoader.loadMessage(messageID);
    if (!message) {
      throw new Error("Message does not exist.");
    }
    return message;
  }
};

// server/src/public/mutations/clear_notifications_for_message.ts
var clearNotificationsForMessageMutation = async (_, args, context) => {
  const { messageID, byExternalID } = args;
  const internalMessageID = await getInternalMessageID(
    messageID,
    byExternalID ?? false,
    context
  );
  await markAttachedNotificationsAsSeen(internalMessageID, context);
  return {
    success: true,
    failureDetails: null
  };
};
async function getInternalMessageID(messageID, byExternalID, context) {
  if (!byExternalID) {
    return messageID;
  }
  const { platformApplicationID } = assertViewerHasPlatformUser(
    context.session.viewer
  );
  const message = await context.loaders.messageLoader.loadMessageByExternalID(
    messageID,
    platformApplicationID
  );
  if (!message) {
    throw new ApiCallerError("message_not_found");
  }
  return message.id;
}
async function markAttachedNotificationsAsSeen(messageID, context) {
  const { viewer } = context.session;
  const userID = assertViewerHasUser(viewer);
  const notifs = await NotificationEntity.findAll({
    where: {
      messageID,
      recipientID: userID,
      readStatus: "unread"
    }
  });
  const notificationMutator = new NotificationMutator(viewer);
  await Promise.all(
    notifs.map((notif) => notificationMutator.markAsRead(notif))
  );
}

// server/src/public/subscriptions/org_members_updated.ts
var orgMembersUpdatedSubscriptionResolver = {
  resolve: (payload) => payload,
  subscribe: async (_root, { externalOrgID }, context) => {
    const platformApplicationID = assertViewerHasPlatformApplicationID(
      context.session.viewer
    );
    const userID = assertViewerHasUser(context.session.viewer);
    const org = await context.loaders.orgLoader.loadPlatformOrg(
      platformApplicationID,
      externalOrgID
    );
    if (!org) {
      throw new Error("Org not found");
    }
    return withRestartEvent({
      // this must map to the OrgMemberEvent type definition in mapping.ts
      events: [
        ["org-member-added", { orgID: org.id }],
        ["org-member-removed", { orgID: org.id }]
      ],
      userID,
      subscriptionName: "orgMembersUpdatedSubscriptionResolver"
    })();
  }
};
var orgMemberEventTypeResolver = {
  __resolveType: (event) => {
    switch (event.name) {
      case "org-member-added":
        return OrgMemberAddedTypeName;
      case "org-member-removed":
        return OrgMemberRemovedTypeName;
    }
  }
};

// server/src/schema/org_member_added.ts
var orgMemberAddedResolver = {
  user: async ({ payload: { userID } }, _, context) => {
    assertViewerHasUser(context.session.viewer);
    const user = await context.loaders.userLoader.loadUser(userID);
    if (!user) {
      throw new Error(`User ${userID} not found`);
    }
    return user;
  }
};

// server/src/schema/org_member_removed.ts
var orgMemberRemovedResolver = {
  externalUserID: async ({ payload: { userID } }, _, context) => {
    const user = await context.loaders.userLoader.loadUser(userID);
    if (!user) {
      throw new Error("User not found");
    }
    return user.externalID;
  }
};

// server/src/public/queries/org_members_by_ext_id_paginated.ts
var orgMembersByExtIDPaginatedResolver = async (_, { externalOrgID, after, limit }, context) => {
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  const viewersOrgs = await context.loaders.orgMembersLoader.loadAllImmediateOrgIDsForUser();
  const org = await context.loaders.orgLoader.loadPlatformOrg(
    platformApplicationID,
    externalOrgID
  );
  if (!org) {
    context.logger.error(`Org not found for ${externalOrgID}`);
    return { users: [], hasMore: false, token: void 0 };
  }
  if (!viewersOrgs.includes(org.id)) {
    context.logger.error(`Viewer cannot access org`);
    return { users: [], hasMore: false, token: void 0 };
  }
  return await context.loaders.userLoader.loadAllUsersInOrgPaginatedByUserID(
    org.id,
    after ?? void 0,
    limit ?? void 0
  );
};

// server/src/public/queries/organization_by_external_id.ts
var organizationByExternalIDQueryResolver = async (_, args, context) => {
  const platformApplicationID = assertViewerHasPlatformApplicationID(
    context.session.viewer
  );
  const platformOrg = await context.loaders.orgLoader.loadPlatformOrg(
    platformApplicationID,
    args.id
  );
  if (!platformOrg) {
    throw new Error("Couldn't find platform org");
  }
  if (!await context.loaders.orgMembersLoader.viewerCanAccessOrg(
    platformOrg.id
  )) {
    throw new Error(`Viewer cannot access org ${args.id}`);
  }
  return platformOrg;
};

// server/src/public/subscriptions/slack_connected.ts
var SlackConnectedLiveQueryResolver = {
  resolve: (value) => value,
  subscribe: async (_root, args, context) => {
    const userID = assertViewerHasUser(context.session.viewer);
    const orgID = args.orgID;
    return await liveQueryWithRestartEvent({
      events: [
        ["org-member-removed", { orgID }],
        ["org-member-added", { orgID }],
        ["org-user-identity", { orgID }]
      ],
      initialData: async () => {
        return await isSlackConnected(context, userID, orgID);
      },
      eventData: async (_event) => {
        return await isSlackConnected(context, userID, orgID);
      },
      subscriptionName: "SlackConnectedLiveQueryResolver",
      userID
    });
  }
};
async function isSlackConnected(context, userID, orgID) {
  const org = await context.loaders.orgLoader.loadOrg(orgID);
  const response = {
    isOrgConnected: false,
    isUserConnected: false
  };
  if (!org) {
    return response;
  }
  const linkedOrg = await org.getLinkedOrg();
  if (!linkedOrg) {
    return response;
  }
  response.isOrgConnected = true;
  const linkedUser = await LinkedUsersEntity.findOne({
    where: {
      sourceOrgID: org.id,
      linkedOrgID: linkedOrg.id,
      sourceUserID: userID
    }
  });
  response.isUserConnected = Boolean(linkedUser);
  return response;
}

// server/src/schema/thread_subscriber_updated.ts
var threadSubscriberUpdatedResolver = {
  subscriber: async ({ args: { threadID }, payload: { userID } }, _, context) => {
    const participant = await context.loaders.threadParticipantLoader.loadForUserNoOrgCheck({
      threadID,
      userID
    });
    if (!participant) {
      throw new Error("Unable to find requested thread participant");
    }
    return participant;
  }
};

// server/src/schema/customer.ts
var customerResolver = {
  billingStatus: (customer, _args, _context) => {
    return getGraphQLBillingStatusFromCustomer(customer.billingStatus);
  },
  addons: (customer, _args, _context) => {
    const { addons } = customer;
    return Object.keys(addons).map((addon) => {
      const value = addons[addon];
      if (typeof value !== "boolean") {
        throw new Error(
          "only boolean values for addons are supported at the moment"
        );
      }
      return { key: addon, value };
    });
  },
  stripeSubscription: async (customer, _args, _context) => {
    const subscription = await getSubscriptionData(customer);
    if (!subscription) {
      return;
    }
    const amount = subscription.items.data.map((item) => item.price.unit_amount).reduce((a, b) => (a ?? 0) + (b ?? 0), 0) ?? 0;
    return {
      id: subscription.id,
      status: subscription.status,
      url: subscription.livemode ? `https://dashboard.stripe.com/subscriptions/${subscription.id}` : `https://dashboard.stripe.com/test/subscriptions/${subscription.id}`,
      startDate: new Date(subscription.start_date * 1e3),
      currentPeriodStart: new Date(subscription.current_period_start * 1e3),
      currentPeriodEnd: new Date(subscription.current_period_end * 1e3),
      amount,
      recurrence: (subscription.current_period_end - subscription.current_period_start) / (24 * 60 * 60) <= 31 ? "monthly" : "yearly"
    };
  }
};
function getGraphQLBillingStatusFromCustomer(billingStatus) {
  switch (billingStatus) {
    case "active":
      return "active";
    case "past_due":
      return "unpaid";
    case "inactive":
    case "canceled":
    case "incomplete":
    case "incomplete_expired":
    case "paused":
    case "trialing":
    case "unpaid":
      return "inactive";
  }
  throw new Error(`unknown billing status: ${billingStatus}`);
}

// server/src/public/subscriptions/presence_live_query.ts
var presenceLiveQueryResolver = {
  resolve: (payload) => payload,
  subscribe: async (_root, args, context) => {
    const orgIDs = assertViewerHasOrgs(context.session.viewer);
    const userID = assertViewerHasUser(context.session.viewer);
    if (!isLocation(args.input.matcher)) {
      throw new Error("Invalid matcher");
    }
    const matcher = args.input.matcher;
    const exactMatch = args.input.exactMatch;
    const matches = exactMatch ? (c) => locationEqual(c, matcher) : (c) => locationMatches(c, matcher);
    const includeDurable = !args.input.excludeDurable;
    const ephemeralCache = /* @__PURE__ */ new Map();
    return await liveQueryWithRestartEvent({
      events: orgIDs.map((orgID) => ["context-presence", { orgID }]),
      initialData: async () => {
        const durablePromise = includeDurable ? context.loaders.pageVisitorLoader.latestForContext(
          matcher,
          exactMatch
        ) : Promise.resolve(/* @__PURE__ */ new Map());
        const [ephemerals, durable] = await Promise.all([
          Promise.all(orgIDs.map(getAllUserPresence)),
          durablePromise
        ]);
        ephemeralCache.clear();
        for (let i = 0; i < orgIDs.length; i++) {
          for (const ephUserID of ephemerals[i].keys()) {
            const values = (ephemerals[i].get(ephUserID) ?? []).filter(
              matches
            );
            if (values.length > 0) {
              ephemeralCache.set(`${orgIDs[i]}/${ephUserID}`, values);
            }
          }
        }
        const result = [];
        for (const externalUserID of /* @__PURE__ */ new Set([
          ...ephemerals.flatMap((ephemeral) => [...ephemeral.keys()]),
          ...durable.keys()
        ])) {
          const eph = ephemerals.flatMap((ephemeral) => ephemeral.get(externalUserID) ?? []).filter(matches);
          result.push({
            externalUserID,
            ephemeral: eph.length > 0 ? { contexts: eph } : void 0,
            durable: durable.get(externalUserID)
          });
        }
        return {
          data: result.filter((r) => r.durable || r.ephemeral),
          complete: true
        };
      },
      eventData: async ({ args: eventArgs, payload }) => {
        if ("durable" in payload) {
          if (!includeDurable || !matches(payload.durable.context)) {
            return NO_VALUE;
          }
          return { data: [payload], complete: false };
        }
        if (!(payload.ephemeral.arrived && matches(payload.ephemeral.arrived) || payload.ephemeral.departed && matches(payload.ephemeral.departed))) {
          return NO_VALUE;
        }
        const rawData = await getUserPresence(
          eventArgs.orgID,
          payload.externalUserID
        );
        const newValues = rawData.contexts.filter(matches);
        if (newValues.length === 0) {
          ephemeralCache.delete(
            `${eventArgs.orgID}/${payload.externalUserID}`
          );
        } else {
          ephemeralCache.set(
            `${eventArgs.orgID}/${payload.externalUserID}`,
            newValues
          );
        }
        const allLocations = orgIDs.flatMap(
          (orgID) => ephemeralCache.get(`${orgID}/${payload.externalUserID}`) ?? []
        );
        return {
          data: [
            {
              externalUserID: payload.externalUserID,
              ephemeral: {
                contexts: allLocations.length > 0 ? allLocations : null
              }
            }
          ],
          complete: false
        };
      },
      userID,
      subscriptionName: "presenceLiveQueryResolver"
    });
  }
};

// server/src/public/mutations/mark_threads_seen.ts
var markThreadsSeenResolver = async (_, args, context) => {
  await new ThreadParticipantMutator(
    context.session.viewer,
    context.loaders
  ).markAllThreadsSeen(args.input);
  return {
    success: true,
    failureDetails: null
  };
};

// server/src/schema/thread_filterable_properties_match.ts
var threadFilterablePropertiesMatchResolver = {
  thread: async ({ payload: { threadID } }, _, context) => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (thread === null) {
      throw new Error(`Failed to load thread ID: ${threadID}`);
    }
    return thread;
  }
};

// server/src/schema/thread_filterable_properties_unmatch.ts
var threadFilterablePropertiesUnmatchResolver = {
  id: ({ payload: { threadID } }) => threadID,
  thread: deprecatedFunction(
    async ({ payload: { threadID } }, _, context) => {
      const thread = await context.loaders.threadLoader.loadThread(threadID);
      if (thread === null) {
        throw new Error(`Failed to load thread ID: ${threadID}`);
      }
      return thread;
    },
    "graphql: ThreadFilterablePropertiesUnmatch.thread"
  )
};

// server/src/public/schema.graphql
var documentNode = { "kind": "Document", "definitions": [{ "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "DateTime" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ElementIdentifierVersion" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SimpleValue" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "JSON" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "JSONObject" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Context" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Metadata" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SimpleTranslationParameters" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageContent" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "UUID" }, "directives": [] }, { "kind": "ScalarTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "JsonObjectReducerData" }, "directives": [] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Message" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "attachments" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAttachment" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "content" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageContent" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageSource" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "reactions" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageReaction" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "seen" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "seenBy" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "deletedTimestamp" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "lastUpdatedTimestamp" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "importedFromSlackChannel" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "referencedUserData" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ReferencedUserData" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "task" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Task" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "importedSlackMessageType" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ImportedSlackMessageType" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "isFromEmailReply" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "iconURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "translationKey" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ReferencedUserData" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageAttachment" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageScreenshotAttachment" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageFileAttachment" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "file" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "File" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "mimeType" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "uploadStatus" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FileUploadStatus" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "size" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "FileUploadStatus" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "uploaded" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "uploading" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "failed" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "cancelled" }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Point2D" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ViewerThreadFilter" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscribed" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "mentioned" }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadFilterInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewer" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerThreadFilter" } } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SortBy" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "first_message_timestamp" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "most_recent_message_timestamp" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SortDirection" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "ascending" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "descending" }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LocationFilter" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "value" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "partialMatch" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadSortInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortBy" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SortBy" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortDirection" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SortDirection" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationFilterInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "partialMatch" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "organizationID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "UserFilterInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MarkThreadsSeenInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "seen" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalThreadID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LocationFilter" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewer" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerThreadFilter" } } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageAnnotationAttachment" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DocumentLocation" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLocation" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customHighlightedTextConfig" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfig" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLabel" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "coordsRelativeToTarget" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Point2D" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AnnotationsOnPage" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "allAnnotations" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "hiddenAnnotationIDs" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "DocumentLocation" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "selector" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "iframeSelectors" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "onChart" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "textConfig" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LocationTextConfig" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "elementIdentifier" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ElementIdentifier" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "multimediaConfig" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MultimediaConfig" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "highlightedTextConfig" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfig" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "additionalTargetData" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdditionalTargetData" } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TargetType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "monacoEditor" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "reactTree" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "konvaCanvas" }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdditionalTargetData" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "targetType" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TargetType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "monacoEditor" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MonacoEditor" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "reactTree" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ReactTree" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "konvaCanvas" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "KonvaCanvas" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MonacoEditor" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "monacoID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "lineNumber" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ReactTree" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "treeID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "prefixCls" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "KonvaCanvas" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LocationTextConfig" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "selectedCharOffset" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "textToMatch" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "textToMatchOffset" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "nodeIndex" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "xVsPointer" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "yVsPointer" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MultimediaConfig" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "currentTime" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "HighlightedTextConfig" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "startElementSelector" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "endElementSelector" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "startNodeIndex" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "startNodeOffset" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "endNodeIndex" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "endNodeOffset" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "selectedText" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "textToDisplay" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ElementIdentifier" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "version" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ElementIdentifierVersion" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "identifier" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Thread" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "orgID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalOrgID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "messages" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "cursor" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "range" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "ignoreDeleted" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "loadMessages" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "cursor" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "range" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "ignoreDeleted" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LoadMessagesResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "participants" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipant" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "mentioned" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "typingUsers" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "newMessagesCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "newReactionsCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "replyCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "firstUnseenMessageID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "messagesCountExcludingDeleted" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "allMessagesCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "userMessagesCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "actionMessagesCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "initialMessagesInclDeleted" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "initialFetchCount" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewerIsThreadParticipant" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "navigationURL" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolvedTimestamp" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "sharedToSlack" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SlackMirroredThreadInfo" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "loadNewestMessagesToTarget" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "targetMessage" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "ignoreDeleted" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LoadMessagesResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "replyingUserIDs" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "actionMessageReplyingUserIDs" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MaybeThread" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SlackMirroredThreadInfo" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "channel" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LoadMessagesResult" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "messages" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "olderMessagesCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadParticipant" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "lastSeenTimestamp" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "User" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "userType" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "UserWithOrgDetails" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "userType" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "linkedUserID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "canBeNotifiedOnSlack" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "slackUserWithMatchingEmail" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PresenceLiveQueryInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "matcher" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "excludeDurable" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "exactMatch" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PresenceLiveQueryData" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "data" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserLocation" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "complete" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "UserLiveQueryData" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "users" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "upto" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageThreadsResult" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threads" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "hasMore" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "token" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Application" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "sharedSecret" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "serverAccessToken" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customerAccessToken" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLinks" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationLinks" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customEmailTemplate" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationEmailTemplate" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "enableEmailNotifications" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customS3Bucket" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "S3BucketVisible" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "segmentWriteKey" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customNUX" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationNUX" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "iconURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationTierType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "environment" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationEnvironment" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "defaultProvider" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "supportSlackChannelID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "supportBotInfo" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationSupportBotInfo" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "redirectURI" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customerID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "deploymentInfo" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationDeploymentInfo" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "usageMetrics" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metrics" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "days" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "eventWebhookURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "eventWebhookSubscriptions" }, "arguments": [], "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setupInfo" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationConsoleSetupInfo" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationDeploymentInfo" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "messages" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "users" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "usersSyncedAllTime" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "orgs" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "orgsSyncedAllTime" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLocations" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLocationsAllTime" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "reactPackageVersion" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "components" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "componentsInitializedAllTime" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "browsers" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "operatingSystems" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationConsoleSetupInfo" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "firstUser" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "firstOrg" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Organization" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "isComponentInitialized" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CustomerType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "verified" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sample" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CustomerImplementationStage" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "launched" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "implementing" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "proof_of_concept" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "inactive" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PricingTier" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "free" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pro" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "scale" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "BillingType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "stripe" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "manual" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "BillingStatus" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "active" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "unpaid" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "inactive" }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Addon" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "value" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "StripeSubscriptionRecurrence" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "monthly" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "yearly" }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "StripeSubscription" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "status" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "startDate" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "currentPeriodStart" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "currentPeriodEnd" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "amount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "recurrence" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "StripeSubscriptionRecurrence" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Customer" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "sharedSecret" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CustomerType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "enableCustomS3Bucket" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "enableCustomSegmentWriteKey" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "implementationStage" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CustomerImplementationStage" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "launchDate" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "slackChannel" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "signupCoupon" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "pricingTier" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PricingTier" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "billingStatus" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "BillingStatus" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "billingType" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "BillingType" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "stripeCustomerID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "addons" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Addon" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "renewalDate" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "planDescription" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "stripeSubscription" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "StripeSubscription" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ConsoleUser" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "email" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "picture" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customerID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customer" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Customer" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "pendingCustomerID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationTierType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "free" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "starter" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "premium" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationEnvironment" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "production" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "staging" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sample" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sampletoken" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "demo" }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageContext" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "data" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "providerID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageVisitor" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "lastPresentTimestamp" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "OrgMemberState" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "inactive" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "active" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "deleted" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "UserType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "person" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "bot" }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageSource" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageReaction" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "unicodeReaction" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Task" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "assignees" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "todos" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Todo" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "doneStatusLastUpdatedBy" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thirdPartyReference" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThirdPartyConnectionType" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TaskThirdPartyReference" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thirdPartyReferences" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TaskThirdPartyReference" } } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Todo" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TaskThirdPartyReference" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThirdPartyConnectionType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "previewData" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "canEdit" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "imported" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThirdPartyConnectionType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "asana" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "jira" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "linear" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "trello" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "monday" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SlackStateLinkingType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "link_org" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ImportedSlackMessageType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "reply" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "supportBotReply" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "action_message" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "user_message" }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageContextInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "data" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "providerID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ViewerIdentity" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "organization" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Organization" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "email" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "isSlackConnected" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "organizations" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Organization" } } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Viewer" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "accessToken" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "groupID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "organization" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Organization" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "inbox" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Inbox" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thirdPartyConnection" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThirdPartyConnectionType" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThirdPartyConnection" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "email" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "isSlackConnected" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "deepLinkInfo" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DeepLinkInfo" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Organization" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "domain" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "imageURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "usersWithOrgDetails" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserFilterInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "nameQuery" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortUsersBy" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortUsersDirection" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SortDirection" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserWithOrgDetails" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "state" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OrganizationState" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "joinableSlackChannels" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SlackChannelSchema" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "joinedSlackChannels" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SlackChannelSchema" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "recentlyActiveThreads" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "linkedOrganization" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LinkedOrganization" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LinkedOrganization" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "usersWithOrgDetails" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserFilterInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "nameQuery" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortUsersBy" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortUsersDirection" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SortDirection" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserWithOrgDetails" } } } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "OrganizationState" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "inactive" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "active" }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SlackChannelSchema" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "slackID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Inbox" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "count" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threads" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadsArchive" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThirdPartyConnection" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "connected" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "oAuthStateToken" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "configuration" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSON" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "HeimdallSwitch" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "isOn" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "FeatureFlag" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "value" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SimpleValue" } } }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LogEventInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageLoadID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "installationID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "eventNumber" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "clientTimestamp" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "payload" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "logLevel" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LogLevelType" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "customEventMetadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LogLevelType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "error" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "warn" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "info" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "debug" }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "FileAttachmentInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "fileID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Point2DInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "x" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "y" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AnnotationAttachmentInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshotFileID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "blurredScreenshotFileID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DocumentLocationInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLocation" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "customHighlightedTextConfig" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfigInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLabel" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "coordsRelativeToTarget" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Point2DInput" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ScreenshotAttachmentInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshotFileID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "blurredScreenshotFileID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "DocumentLocationInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "selector" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "x" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "y" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "iframeSelectors" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "onChart" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "textConfig" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LocationTextConfigInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "elementIdentifier" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ElementIdentifierInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "multimediaConfig" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MultimediaConfigInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "highlightedTextConfig" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfigInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "additionalTargetData" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdditionalTargetDataInput" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdditionalTargetDataInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "targetType" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TargetType" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "monacoEditor" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MonacoEditorInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "reactTree" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ReactTreeInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "konvaCanvas" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "KonvaCanvasInput" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MonacoEditorInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "monacoID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "lineNumber" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ReactTreeInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "key" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "treeID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "prefixCls" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "KonvaCanvasInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "x" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "y" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MultimediaConfigInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "currentTime" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "HighlightedTextConfigInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "startElementSelector" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "endElementSelector" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "startNodeIndex" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "startNodeOffset" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "endNodeIndex" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "endNodeOffset" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "selectedText" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "textToDisplay" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LocationTextConfigInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "selectedCharOffset" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "textToMatch" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "textToMatchOffset" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "nodeIndex" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "xVsPointer" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "yVsPointer" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ElementIdentifierInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "version" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ElementIdentifierVersion" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "identifier" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TaskInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "done" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "assigneeIDs" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "todos" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TaskTodoInput" } } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "doneStatusUpdate" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TaskDoneStatusUpdate" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TaskInputType" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TaskTodoInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "done" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TaskDoneStatusUpdate" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "update" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "remove" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "none" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TaskInputType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "cord" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "asana" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "jira" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "linear" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "trello" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "monday" }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CreateThreadMessageInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageContext" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageContextInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageName" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "createNewThread" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "newMessageMetadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": { "kind": "StringValue", "value": "Only used when createNewThread is true. To update metadata on an existing\nthread, use the setThreadMetadata mutation.", "block": true }, "name": { "kind": "Name", "value": "newThreadMetadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "content" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageContent" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalContent" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageContent" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "fileAttachments" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FileAttachmentInput" } } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "annotationAttachments" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AnnotationAttachmentInput" } } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshotAttachment" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ScreenshotAttachmentInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshotID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "task" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TaskInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadOptions" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadOptionsInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalMessageID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageType" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "addReactions" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "iconURL" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "translationKey" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "createThread" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateThreadInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CreateMessageByExternalIDInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalThreadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalMessageID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "content" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageContent" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageType" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "addReactions" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "iconURL" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "translationKey" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "createThread" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateThreadInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "addFileAttachments" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshotAttachment" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ScreenshotAttachmentInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscribeToThread" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "UpdateMessageByExternalIDInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalThreadID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalMessageID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "content" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageContent" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageType" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "iconURL" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "translationKey" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "deleted" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "addReactions" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "removeReactions" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "addFileAttachments" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "removeFileAttachments" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "removePreviewLinks" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CreateThreadInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "addSubscribers" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadOptionsInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "additionalSubscribersOnCreate" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadByExternalID2Input" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalThreadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CreateFileResult" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "uploadURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "downloadURL" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "IDResult" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": { "kind": "StringValue", "value": "The details of what kind of failure occurred during the operation.", "block": true }, "name": { "kind": "Name", "value": "FailureDetails" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "A code indicating the class of failure encountered.  For each operation,\nthere should be an enumerated list of possible failure codes that can occur\nhere.", "block": true }, "name": { "kind": "Name", "value": "code" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "A message with additional information about the failure.  This should be\nsafe to display to the user, though it may not be ideal.", "block": true }, "name": { "kind": "Name", "value": "message" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SuccessResult" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "success" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": { "kind": "StringValue", "value": "If success is false, this field may contain additional details about what\nkind of failure occurred.  If success is true, this field should always be\nnull.", "block": true }, "name": { "kind": "Name", "value": "failureDetails" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FailureDetails" } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "FileUploadStatusEnumType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "uploaded" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "uploading" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "failed" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "cancelled" }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadEvent" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadCreated" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadMessageAdded" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadMessageUpdated" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadMessageContentAppended" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadMessageRemoved" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipantsUpdatedIncremental" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadTypingUsersUpdated" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadShareToSlack" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadPropertiesUpdated" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadSubscriberUpdated" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadDeleted" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadCreated" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadDeleted" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadMessageAdded" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadMessageUpdated" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadMessageContentAppended" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "appendedContent" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadPropertiesUpdated" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadMessageRemoved" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadParticipantsUpdatedIncremental" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "participant" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipant" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadSubscriberUpdated" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscriber" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipant" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadTypingUsersUpdated" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "users" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadShareToSlack" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "info" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SlackMirroredThreadInfo" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "EphemeralLocation" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "contexts" }, "arguments": [], "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "DurableLocation" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "context" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "UserLocation" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalUserID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "ephemeral" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "EphemeralLocation" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "durable" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DurableLocation" } }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageEvent" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "PageThreadAdded" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "PageThreadDeleted" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "PageThreadReplyAdded" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "PageVisitorsUpdated" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "PageThreadResolved" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "PageThreadUnresolved" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadFilterablePropertiesMatch" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadFilterablePropertiesUnmatch" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageThreadAdded" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageThreadDeleted" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadFilterablePropertiesMatch" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadFilterablePropertiesUnmatch" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageThreadReplyAdded" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageVisitorsUpdated" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "visitors" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageVisitor" } } } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageThreadResolved" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PageThreadUnresolved" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "S3BucketVisible" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "region" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LogoConfigType" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "height" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "width" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "LogoConfigInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "height" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "width" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationEmailTemplate" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "partnerName" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "imageURL" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "sender" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "logoConfig" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LogoConfigType" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationLinks" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "learnMore" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "upgradePlan" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "leaveFeedback" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationColors" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "launcherOpen" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "launcherClose" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "actions" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "presence" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "avatarTint" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "underlay" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationSupportBotInfo" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PublicApplication" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customLinks" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ComputedCustomLinks" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customNUX" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationNUX" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "iconURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "environment" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ApplicationEnvironment" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ComputedCustomLinks" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "learnMore" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "upgradePlan" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "leaveFeedback" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CustomNUXStepContent" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "title" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "text" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "imageURL" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ApplicationNUX" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "initialOpen" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CustomNUXStepContent" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "welcome" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CustomNUXStepContent" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "DeepLinkInfo" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageID" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminChatUser" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationEvent" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationAdded" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationReadStateUpdated" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationDeleted" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationAdded" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "notification" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Notification" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationReadStateUpdated" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "notification" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Notification" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationDeleted" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Notification" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "senders" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationSender" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "iconUrl" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "header" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationHeaderNode" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "headerTranslationKey" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "headerSimpleTranslationParams" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SimpleTranslationParameters" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "attachment" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationAttachment" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "readStatus" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationReadStatus" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationReadStatus" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "unread" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "read" }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationAttachment" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationURLAttachment" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationMessageAttachment" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationThreadAttachment" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationURLAttachment" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationMessageAttachment" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationThreadAttachment" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationSender" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationPage" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "nodes" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Notification" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "paginationInfo" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PaginationInfo" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationHeaderTextNode" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "text" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "bold" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationHeaderUserNode" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationHeaderNode" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationHeaderTextNode" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationHeaderUserNode" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "NotificationSummary" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "unreadNotificationCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "PaginationInfo" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "endCursor" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "hasNextPage" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminGoRedirect" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "redirectCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminGoRedirectInputType" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Activity" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadSummary" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadActivitySummary" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "ThreadActivitySummary" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "totalThreadCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "unreadThreadCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "newThreadCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "unreadSubscribedThreadCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolvedThreadCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "emptyThreadCount" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TestToken" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "token" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminCRTComingFrom" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "us" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "them" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminCRTDecision" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "done" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "accepted" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "rejected" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pending" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminCRTCommunicationStatus" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "none" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "request_acked" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "decision_sent" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "decision_acked" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminCRTIssueType" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "request" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "bug" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "onboarding_step" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminCRTPriority" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "blocker" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "high" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "low" }, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "AdminCRTNextAction" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "unknown" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "ack_receipt" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "make_decision" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "send_decision" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "do_work" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "wait_for_ack" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "done" }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CustomerIssue" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "customer" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Customer" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "title" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "body" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "comingFrom" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdminCRTComingFrom" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "decision" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdminCRTDecision" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "communicationStatus" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdminCRTCommunicationStatus" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "nextAction" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdminCRTNextAction" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "lastTouch" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdminCRTIssueType" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "priority" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AdminCRTPriority" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externallyVisible" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "assignee" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "history" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CustomerIssueChange" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CustomerIssueUpdate" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "field" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "oldValue" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSON" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "newValue" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSON" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "CustomerIssueChange" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "created" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "updated" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CustomerIssueUpdate" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } } }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SearchLocationOptions" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "partialMatch" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "TimestampRange" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "from" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "to" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "DateTime" } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "EnumTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SearchSortByOptions" }, "directives": [], "values": [{ "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "created_timestamp" }, "directives": [] }, { "kind": "EnumValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "relevance" }, "directives": [] }] }, { "kind": "InputObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SearchSortInput" }, "directives": [], "fields": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortBy" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SearchSortByOptions" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortDirection" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SortDirection" } } }, "defaultValue": void 0, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "MessageLinkPreview" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "title" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "description" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "img" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "UnionTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "OrgMemberEvent" }, "directives": [], "types": [{ "kind": "NamedType", "name": { "kind": "Name", "value": "OrgMemberAdded" } }, { "kind": "NamedType", "name": { "kind": "Name", "value": "OrgMemberRemoved" } }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "OrgMemberAdded" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "OrgMemberRemoved" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalUserID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "OrgMembersResult" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "users" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "hasMore" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "token" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "SlackConnectedResult" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "isOrgConnected" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "isUserConnected" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Query" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewer" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Viewer" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewerIdentity" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerIdentity" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "organization" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Organization" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "organizationByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Organization" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "task" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Task" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "users" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "ids" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "usersByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalIDs" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "ping" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadByExternalID2" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "input" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadByExternalID2Input" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MaybeThread" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadsAtLocation" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadFilterInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "partialMatch" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sort" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadSortInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "limit" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "after" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageThreadsResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "application" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "token" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PublicApplication" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "featureFlags" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "keys" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FeatureFlag" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "annotationsOnPage" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageContext" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageContextInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "includeDeleted" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AnnotationsOnPage" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "notifications" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "first" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "after" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationFilterInput" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationPage" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "notificationByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Notification" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "activity" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageContext" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageContextInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "partialMatch" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewer" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerThreadFilter" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Activity" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "notificationSummary" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationFilterInput" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationSummary" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageContentSearch" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "textToMatch" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "authorExternalID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "orgExternalID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "locationOptions" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SearchLocationOptions" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "timestampRange" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TimestampRange" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "limit" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortBy" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SearchSortByOptions" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "sortDirection" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SortDirection" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } } } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "orgMembersByExternalIDPaginated" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalOrgID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "after" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "limit" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OrgMembersResult" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Mutation" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "logEvents" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "events" }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "LogEventInput" } } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "logDeprecation" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "key" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "createThreadMessage" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "input" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateThreadMessageInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "createMessageByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "input" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateMessageByExternalIDInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "updateMessage" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "content" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageContent" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "fileAttachments" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FileAttachmentInput" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "annotationAttachments" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AnnotationAttachmentInput" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "deleted" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "task" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "TaskInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "updateMessageByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "input" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UpdateMessageByExternalIDInput" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "updateThreadByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalThreadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "typing" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "createFile" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "mimeType" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "size" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "provider" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "application" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateFileResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "refreshFileUploadURL" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "size" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setTyping" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "typing" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setPresentContext" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "context" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "present" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "durable" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "exclusivityRegion" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSONObject" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "markThreadSeen" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "markThreadUnseenFromExternalMessageID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalThreadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalMessageID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "markThreadsSeen" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "input" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "MarkThreadsSeenInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "clearNotificationsForMessage" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "byExternalID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "createMessageReaction" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "unicodeReaction" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "deleteMessageReaction" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "reactionID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "addThreadToSlackChannel" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "slackChannelID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "installBot" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "byExternalID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setPreference" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "key" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "value" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSON" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JSON" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setFileUploadStatus" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "id" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "status" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "FileUploadStatusEnumType" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setSubscribed" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscribed" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setSubscribedByExternalID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "subscribed" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "disconnectThirdParty" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "connectionType" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThirdPartyConnectionType" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setDeepLinkThreadID" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "clearDeepLinkThreadID" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setAnnotationVisible" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "annotationID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "visible" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "resetUserHiddenAnnotations" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setThreadResolved" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "unlinkOrgs" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "shareThreadToEmail" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "email" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "screenshotID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "byExternalID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "sendSampleWelcomeMessage" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "messageLocation" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "url" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "markNotificationAsRead" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "notificationID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "byExternalID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "markNotificationAsUnread" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "notificationExternalID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "markAllNotificationsAsRead" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationFilterInput" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "deleteNotification" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "notificationID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "byExternalID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setThreadName" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "name" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "setThreadMetadata" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "hideLinkPreview" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "linkPreviewID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "createThread" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalThreadID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "input" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "CreateThreadInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SuccessResult" } } }, "directives": [] }] }, { "kind": "ObjectTypeDefinition", "description": void 0, "name": { "kind": "Name", "value": "Subscription" }, "interfaces": [], "directives": [], "fields": [{ "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadEvents" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadEvent" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "inbox" }, "arguments": [], "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Inbox" } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "presenceLiveQuery" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "input" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PresenceLiveQueryInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PresenceLiveQueryData" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "userLiveQuery" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "since" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Float" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UserLiveQueryData" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageEventsWithLocation" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "location" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "partialMatch" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadFilterInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageEvent" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "preferencesLiveQuery" }, "arguments": [], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "JsonObjectReducerData" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewerIdentityLiveQuery" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerIdentity" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "annotationsOnPageUpdated" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageContext" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageContextInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "includeDeleted" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "AnnotationsOnPage" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "threadActivitySummary" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "pageContext" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageContextInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "partialMatch" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "metadata" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "viewer" }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerThreadFilter" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "resolved" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "_externalOrgID" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadActivitySummary" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "notificationEvents" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationFilterInput" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationEvent" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "notificationSummaryUpdated" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "filter" }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationFilterInput" } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationSummary" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "orgMembersByExternalIDUpdated" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "externalOrgID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "OrgMemberEvent" } } }, "directives": [] }, { "kind": "FieldDefinition", "description": void 0, "name": { "kind": "Name", "value": "slackConnectedLiveQuery" }, "arguments": [{ "kind": "InputValueDefinition", "description": void 0, "name": { "kind": "Name", "value": "orgID" }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } }, "defaultValue": void 0, "directives": [] }], "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "SlackConnectedResult" } } }, "directives": [] }] }], "loc": { "start": 0, "end": 31824 } };
var schema_default = documentNode;

// server/src/public/queries/viewer_identity.ts
var viewerIdentityQueryResolver = () => ({});

// server/src/schema/thread_deleted.ts
var threadDeletedResolver = {
  id: ({ args: { threadID } }) => threadID
};

// server/src/schema/page_thread_deleted.ts
var pageThreadDeletedResolver = {
  id: ({ payload: { threadID } }) => threadID
};

// server/src/schema/resolvers.ts
function checkIfUserIsBlocked(query) {
  let key;
  for (key in query) {
    const originalResolver = query[key];
    query[key] = async (parent, args, context) => {
      const [blocked, rateLimited] = await Promise.all([
        getTypedFeatureFlagValue(
          FeatureFlags2.USER_IS_BLOCKED,
          flagsUserFromContext(context)
        ),
        shouldRateLimit(context)
      ]);
      if (blocked === true) {
        throw new Error("user_is_blocked" /* USER_IS_BLOCKED */);
      }
      if (rateLimited) {
        throw new Error("rate_limited" /* RATE_LIMITED */);
      }
      return originalResolver(parent, args, context);
    };
  }
  return query;
}
var allResolvers = {
  // custom scalars
  DateTime: GraphQLDateTime,
  ElementIdentifierVersion: ElementIdentifierVersionScalarType,
  SimpleValue: SimpleValueScalarType,
  JSON: GraphQLJSON2,
  JSONObject: GraphQLJSONObject,
  Context: ContextScalarType,
  Metadata: MetadataScalarType,
  MessageContent: MessageContentScalarType,
  SimpleTranslationParameters: SimpleTranslationParametersScalarType,
  UUID: graphql_type_uuid_default,
  JsonObjectReducerData: JsonObjectReducerDataScalarType,
  Query: checkIfUserIsBlocked({
    viewer: viewerQueryResolver,
    organization: organizationQueryResolver,
    organizationByExternalID: organizationByExternalIDQueryResolver,
    messageByExternalID: messageByExternalIDQueryResolver,
    task: taskQueryResolver,
    users: usersQueryResolver,
    usersByExternalID: usersByExternalIDQueryResolver,
    ping: pingQueryResolver,
    thread: threadQueryResolver,
    threadByExternalID2: threadByExternalID2QueryResolver,
    threadsAtLocation: threadsAtLocationQueryResolver,
    application: applicationQueryResolver,
    featureFlags: featureFlagsQueryResolver,
    annotationsOnPage: annotationsOnPageQueryResolver,
    notifications: notificationsResolver,
    activity: activityQueryResolver,
    notificationSummary: notificationSummaryQueryResolver,
    notificationByExternalID: notificationByExternalIDResolver,
    messageContentSearch: messageContentSearchResolver,
    orgMembersByExternalIDPaginated: orgMembersByExtIDPaginatedResolver,
    viewerIdentity: viewerIdentityQueryResolver
  }),
  Mutation: checkIfUserIsBlocked({
    logEvents: logEventsMutationResolver,
    logDeprecation: logDeprecationMutationResolver,
    createThreadMessage: createThreadMessageResolver,
    createMessageByExternalID: createMessageByExternalIDResolver,
    updateMessage: updateMessageResolver,
    updateMessageByExternalID: updateMessageByExternalIDResolver,
    updateThreadByExternalID: updateThreadByExternalIDResolver,
    createFile: createFileMutationResolver,
    refreshFileUploadURL: refreshFileUploadURLMutationResolver,
    setTyping: setTypingMutationResolver,
    setPresentContext: setPresentContextMutationResolver,
    markThreadSeen: markThreadSeenMutation,
    markThreadsSeen: markThreadsSeenResolver,
    clearNotificationsForMessage: clearNotificationsForMessageMutation,
    createMessageReaction: createMessageReactionResolver,
    deleteMessageReaction: deleteMessageReactionMutationResolver,
    addThreadToSlackChannel: addThreadToSelectedSlackChannelResolver,
    setPreference: setPreferenceMutationResolver,
    setFileUploadStatus: setFileUploadStatusMutationResolver,
    setSubscribed: setSubscribedMutationResolver,
    setSubscribedByExternalID: setSubscribedByExternalIDMutationResolver,
    disconnectThirdParty: disconnectThirdPartyMutationResolver,
    setDeepLinkThreadID: setDeepLinkThreadIDMutationResolver,
    clearDeepLinkThreadID: clearDeepLinkThreadIDMutationResolver,
    setThreadResolved: setThreadResolvedResolver,
    unlinkOrgs: unlinkOrgsMutationResolver,
    setAnnotationVisible: setAnnotationVisibleMutationResolver,
    resetUserHiddenAnnotations: resetUserHiddenAnnotationsResolver,
    shareThreadToEmail: shareThreadToEmailResolver,
    sendSampleWelcomeMessage: sendSampleWelcomeMessageResolver,
    markNotificationAsRead: markNotificationAsReadResolver,
    markNotificationAsUnread: markNotificationAsUnreadResolver,
    markAllNotificationsAsRead: markAllNotificationsAsReadResolver,
    deleteNotification: deleteNotificationResolver,
    setThreadName: setThreadNameResolver,
    setThreadMetadata: setThreadMetadataResolver,
    markThreadUnseenFromExternalMessageID: markThreadUnseenFromExternalMessageIDResolver,
    hideLinkPreview: hideLinkPreviewResolver,
    createThread: createThreadResolver
  }),
  Subscription: {
    threadEvents: threadEventsSubscriptionResolver,
    inbox: inboxSubscriptionResolver,
    viewerIdentityLiveQuery: viewerIdentityLiveQueryResolver,
    presenceLiveQuery: presenceLiveQueryResolver,
    userLiveQuery: userLiveQueryResolver,
    pageEventsWithLocation: pageEventsWithLocationSubscriptionResolver,
    preferencesLiveQuery: preferencesLiveQuerySubscriptionResolver,
    annotationsOnPageUpdated: annotationsOnPageUpdatedSubscriptionResolver,
    threadActivitySummary: threadActivitySummarySubscriptionResolver,
    notificationEvents: notificationEventsSubscriptionResolver,
    notificationSummaryUpdated: notificationSummaryUpdatedSubscriptionResolver,
    orgMembersByExternalIDUpdated: orgMembersUpdatedSubscriptionResolver,
    slackConnectedLiveQuery: SlackConnectedLiveQueryResolver
  },
  PaginationInfo: {},
  AnnotationsOnPage: {},
  Message: messageResolver,
  MessageFileAttachment: messageFileAttachmentResolver,
  File: fileResolver,
  MessageAnnotationAttachment: messageAnnotationAttachmentResolver,
  MessageScreenshotAttachment: messageScreenshotAttachmentResolver,
  DocumentLocation: {},
  LocationTextConfig: {},
  HighlightedTextConfig: {},
  MultimediaConfig: {},
  ElementIdentifier: {},
  AdditionalTargetData: {},
  MonacoEditor: {},
  ReactTree: {},
  KonvaCanvas: {},
  Point2D: {},
  Thread: threadResolver,
  MaybeThread: {},
  LoadMessagesResult: loadMessagesResultResolver,
  ThreadParticipant: threadParticipantResolver,
  User: userResolver,
  UserWithOrgDetails: userWithOrgDetailsResolver,
  HeimdallSwitch: heimdallSwitchResolver,
  PageContext: {},
  PageVisitor: pageVisitorResolver,
  S3BucketVisible: s3BucketVisibleResolver,
  Application: applicationResolver,
  Customer: customerResolver,
  ConsoleUser: consoleUserResolver,
  MessageReaction: messageReactionResolver,
  Task: taskResolver,
  Todo: {},
  TaskThirdPartyReference: taskThirdPartyReferenceResolver,
  Viewer: viewerResolver,
  ViewerIdentity: viewerIdentityResolver,
  PresenceLiveQueryData: {},
  UserLiveQueryData: {},
  Organization: orgResolver,
  SlackChannelSchema: {},
  Inbox: inboxResolver,
  ThirdPartyConnection: thirdPartyConnectionResolver,
  CreateFileResult: {},
  SuccessResult: {},
  FailureDetails: {},
  IDResult: {},
  ThreadCreated: threadCreatedResolver,
  ThreadDeleted: threadDeletedResolver,
  ThreadMessageAdded: threadMessageAddedResolver,
  ThreadMessageUpdated: threadMessageUpdatedResolver,
  ThreadMessageContentAppended: threadMessageContentAppendedResolver,
  ThreadMessageRemoved: threadMessageRemovedResolver,
  ThreadParticipantsUpdatedIncremental: threadParticipantUpdatedIncrementalResolver,
  ThreadTypingUsersUpdated: threadTypingUsersUpdatedResolver,
  ThreadPropertiesUpdated: threadPropertiesUpdatedResolver,
  EphemeralLocation: {},
  DurableLocation: {},
  UserLocation: {},
  PageThreadAdded: pageThreadAddedResolver,
  PageThreadDeleted: pageThreadDeletedResolver,
  PageThreadReplyAdded: pageThreadReplyAddedResolver,
  PageVisitorsUpdated: pageVisitorUpdatedResolver,
  MessageAttachment: messageAttachmentTypeResolver,
  MessageSource: messageSourceTypeResolver,
  ThreadEvent: threadEventTypeResolver,
  PageEvent: pageEventTypeResolver,
  ApplicationEmailTemplate: {},
  ApplicationColors: {},
  ApplicationLinks: {},
  ApplicationSupportBotInfo: {},
  ApplicationDeploymentInfo: applicationDeploymentInfoResolver,
  ComputedCustomLinks: {},
  PublicApplication: {},
  PageThreadResolved: pageThreadResolvedResolver,
  PageThreadUnresolved: pageThreadUnresolvedResolver,
  ThreadFilterablePropertiesMatch: threadFilterablePropertiesMatchResolver,
  ThreadFilterablePropertiesUnmatch: threadFilterablePropertiesUnmatchResolver,
  ReferencedUserData: {},
  LinkedOrganization: linkedOrgResolver,
  SlackMirroredThreadInfo: {},
  FeatureFlag: {},
  ApplicationNUX: {},
  CustomNUXStepContent: {},
  ThreadShareToSlack: threadShareToSlackResolver,
  DeepLinkInfo: {},
  AdminChatUser: adminChatUserResolver,
  Notification: {},
  NotificationAttachment: notificationAttachmentResolver,
  NotificationMessageAttachment: {},
  NotificationURLAttachment: {},
  NotificationThreadAttachment: {},
  NotificationSender: notificationSenderResolver,
  NotificationPage: {},
  NotificationHeaderTextNode: {},
  NotificationHeaderUserNode: {},
  NotificationHeaderNode: notificationHeaderNodeResolver,
  NotificationEvent: notificationEventTypeResolver,
  NotificationAdded: notificationAddedResolver,
  NotificationReadStateUpdated: notificationReadStateUpdatedResolver,
  NotificationDeleted: notificationDeletedResolver,
  NotificationSummary: notificationSummaryResolver,
  AdminGoRedirect: {},
  Activity: activityResolver,
  ThreadActivitySummary: {},
  TestToken: {},
  CustomerIssue: customerIssueResolver,
  CustomerIssueChange: customerIssueChangeResolver,
  CustomerIssueUpdate: {},
  LogoConfigType: {},
  PageThreadsResult: {},
  MessageLinkPreview: {},
  OrgMemberEvent: orgMemberEventTypeResolver,
  OrgMemberAdded: orgMemberAddedResolver,
  OrgMemberRemoved: orgMemberRemovedResolver,
  OrgMembersResult: {},
  SlackConnectedResult: {},
  ThreadSubscriberUpdated: threadSubscriberUpdatedResolver,
  Addon: {},
  StripeSubscription: {},
  ApplicationConsoleSetupInfo: {}
};
var apolloResolvers = allResolvers;
var graphQLSchema = makeExecutableSchema({
  typeDefs: schema_default,
  resolvers: apolloResolvers
});

// external/src/graphql/MessageByExternalIDWithThread.graphql
var documentNode2 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "FileFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mimeType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "uploadStatus" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "size" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "file" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfig" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedText" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToDisplay" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iframeSelectors" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "onChart" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedCharOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatch" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatchOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "nodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "xVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "yVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "elementIdentifier" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "identifier" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "version" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "highlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "multimediaConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "currentTime" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "additionalTargetData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "targetType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoEditor" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lineNumber" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactTree" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "treeID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "konvaCanvas" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLocation" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customHighlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLabel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "coordsRelativeToTarget" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "img" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "title" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "description" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "TaskFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Task" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "todos" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "assignees" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "doneStatusLastUpdatedBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thirdPartyReferences" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "previewData" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageReaction" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "unicodeReaction" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "content" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "attachments" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seen" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactions" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "referencedUserData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "deletedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastUpdatedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedFromSlackChannel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "task" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "TaskFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedSlackMessageType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "isFromEmailReply" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iconURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "translationKey" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seenBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipant" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastSeenTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "orgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalOrgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newReactionsCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "typingUsers" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mentioned" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "allMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "messagesCountExcludingDeleted" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "userMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "viewerIsThreadParticipant" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "navigationURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolved" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolvedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "sharedToSlack" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "channel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "participants" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "firstUnseenMessageID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessageReplyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "directives": [] }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "initialMessagesInclDeleted" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFragment" }, "directives": [] }] } }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "MessageByExternalIDWithThread" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "id" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "messageByExternalID" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "id" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "id" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "_externalOrgID" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFragment" }, "directives": [] }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragment" }, "directives": [] }] } }] } }] } }], "loc": { "start": 0, "end": 4252 } };
var MessageByExternalIDWithThread_default = documentNode2;

// external/src/graphql/NotificationSummaryQuery.graphql
var documentNode3 = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "NotificationSummary" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationFilterInput" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "notificationSummary" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "filter" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "unreadNotificationCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }], "loc": { "start": 0, "end": 138 } };
var NotificationSummaryQuery_default = documentNode3;

// external/src/graphql/NotificationsQuery.graphql
var documentNode4 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "FileFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mimeType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "uploadStatus" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "size" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "file" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfig" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedText" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToDisplay" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iframeSelectors" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "onChart" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedCharOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatch" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatchOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "nodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "xVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "yVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "elementIdentifier" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "identifier" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "version" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "highlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "multimediaConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "currentTime" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "additionalTargetData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "targetType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoEditor" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lineNumber" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactTree" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "treeID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "konvaCanvas" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLocation" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customHighlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLabel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "coordsRelativeToTarget" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "img" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "title" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "description" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "TaskFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Task" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "todos" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "assignees" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "doneStatusLastUpdatedBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thirdPartyReferences" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "previewData" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageReaction" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "unicodeReaction" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "content" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "attachments" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seen" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactions" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "referencedUserData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "deletedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastUpdatedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedFromSlackChannel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "task" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "TaskFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedSlackMessageType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "isFromEmailReply" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iconURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "translationKey" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seenBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipant" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastSeenTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "orgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalOrgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newReactionsCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "typingUsers" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mentioned" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "allMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "messagesCountExcludingDeleted" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "userMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "viewerIsThreadParticipant" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "navigationURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolved" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolvedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "sharedToSlack" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "channel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "participants" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "firstUnseenMessageID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessageReplyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "directives": [] }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "initialMessagesInclDeleted" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "NotificationsMessageFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragment" }, "directives": [] }] } }, { "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFragment" }, "directives": [] }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "NotificationsNodeFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Notification" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "senders" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "header" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationHeaderTextNode" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "text" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "bold" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationHeaderUserNode" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "headerTranslationKey" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "headerSimpleTranslationParams" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "attachment" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationURLAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationMessageAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "NotificationsMessageFragment" }, "directives": [] }] } }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationThreadAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragment" }, "directives": [] }] } }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iconUrl" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "readStatus" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "Notifications" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "first" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "after" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "NotificationFilterInput" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "notifications" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "first" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "first" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "after" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "after" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "filter" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "nodes" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "NotificationsNodeFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "paginationInfo" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endCursor" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "hasNextPage" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }], "loc": { "start": 0, "end": 5196 } };
var NotificationsQuery_default = documentNode4;

// external/src/graphql/OrgMembersByExtIDPaginatedQuery.graphql
var documentNode5 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "OrgMembersByExtIDPaginatedQuery" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "externalOrgID" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "after" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "limit" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "orgMembersByExternalIDPaginated" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "externalOrgID" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "externalOrgID" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "after" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "after" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "limit" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "limit" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "hasMore" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "token" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "users" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }] } }], "loc": { "start": 0, "end": 386 } };
var OrgMembersByExtIDPaginatedQuery_default = documentNode5;

// external/src/graphql/PresenceLiveQuerySubscription.graphql
var documentNode6 = { "kind": "Document", "definitions": [{ "kind": "OperationDefinition", "operation": "subscription", "name": { "kind": "Name", "value": "PresenceLiveQuerySubscription" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "input" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PresenceLiveQueryInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "presenceLiveQuery" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "input" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "input" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "_externalOrgID" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "data" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalUserID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "ephemeral" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "contexts" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "durable" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "context" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "complete" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }], "loc": { "start": 0, "end": 337 } };
var PresenceLiveQuerySubscription_default = documentNode6;

// external/src/graphql/ThreadActivityQuery.graphql
var documentNode7 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadActivitySummaryFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadActivitySummary" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "totalThreadCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "unreadThreadCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newThreadCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "unreadSubscribedThreadCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolvedThreadCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "emptyThreadCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "ThreadActivityQuery" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "pageContext" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "PageContextInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "partialMatch" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "metadata" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Metadata" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "resolved" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "viewer" } }, "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerThreadFilter" } } } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "activity" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "pageContext" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "pageContext" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "partialMatch" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "partialMatch" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "metadata" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "metadata" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "resolved" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "resolved" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "viewer" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "viewer" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "_externalOrgID" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "threadSummary" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadActivitySummaryFragment" }, "directives": [] }] } }] } }] } }], "loc": { "start": 0, "end": 643 } };
var ThreadActivityQuery_default = documentNode7;

// external/src/graphql/ThreadByExternalID2Query.graphql
var documentNode8 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "FileFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mimeType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "uploadStatus" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "size" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "file" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfig" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedText" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToDisplay" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iframeSelectors" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "onChart" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedCharOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatch" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatchOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "nodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "xVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "yVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "elementIdentifier" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "identifier" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "version" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "highlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "multimediaConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "currentTime" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "additionalTargetData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "targetType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoEditor" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lineNumber" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactTree" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "treeID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "konvaCanvas" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLocation" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customHighlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLabel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "coordsRelativeToTarget" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "img" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "title" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "description" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "TaskFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Task" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "todos" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "assignees" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "doneStatusLastUpdatedBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thirdPartyReferences" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "previewData" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageReaction" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "unicodeReaction" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "content" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "attachments" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seen" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactions" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "referencedUserData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "deletedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastUpdatedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedFromSlackChannel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "task" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "TaskFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedSlackMessageType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "isFromEmailReply" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iconURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "translationKey" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seenBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipant" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastSeenTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "orgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalOrgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newReactionsCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "typingUsers" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mentioned" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "allMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "messagesCountExcludingDeleted" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "userMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "viewerIsThreadParticipant" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "navigationURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolved" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolvedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "sharedToSlack" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "channel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "participants" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "firstUnseenMessageID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessageReplyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadByExternalIDFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "directives": [] }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "initialMessagesInclDeleted" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "initialFetchCount" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "initialFetchCount" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFragment" }, "directives": [] }] } }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "ThreadByExternalID2Query" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "input" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadByExternalID2Input" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "initialFetchCount" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "threadByExternalID2" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "input" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "input" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "_externalOrgID" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thread" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadByExternalIDFragment" }, "directives": [] }] } }] } }] } }], "loc": { "start": 0, "end": 4352 } };
var ThreadByExternalID2Query_default = documentNode8;

// external/src/graphql/ThreadListQuery.graphql
var documentNode9 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "FileFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "File" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mimeType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "uploadStatus" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "size" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "file" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "HighlightedTextConfig" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endElementSelector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "startNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "endNodeOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedText" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToDisplay" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selector" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iframeSelectors" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "onChart" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "selectedCharOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatch" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "textToMatchOffset" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "nodeIndex" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "xVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "yVsPointer" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "elementIdentifier" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "identifier" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "version" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "highlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "multimediaConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "currentTime" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "additionalTargetData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "targetType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoEditor" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "monacoID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lineNumber" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactTree" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "key" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "treeID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "konvaCanvas" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLocation" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customHighlightedTextConfig" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "HighlightedTextConfigFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "customLabel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "coordsRelativeToTarget" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "x" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "y" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "message" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "screenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "blurredScreenshot" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "FileFragment" }, "directives": [] }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "img" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "title" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "description" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "TaskFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Task" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "todos" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "done" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "assignees" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "doneStatusLastUpdatedBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "thirdPartyReferences" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "previewData" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageReaction" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "unicodeReaction" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "MessageFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Message" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "source" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "content" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "attachments" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageFileAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFileAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageAnnotationAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageAnnotationAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageScreenshotAttachment" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageScreenshotAttachmentFragment" }, "directives": [] }] } }, { "kind": "InlineFragment", "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "MessageLinkPreview" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageLinkPreviewFragment" }, "directives": [] }] } }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seen" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "reactions" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageReactionFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "referencedUserData" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "timestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "deletedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastUpdatedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedFromSlackChannel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "task" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "TaskFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "importedSlackMessageType" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "isFromEmailReply" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "type" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "iconURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "translationKey" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "seenBy" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "skipLinkPreviews" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadParticipant" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "lastSeenTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "orgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalOrgID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "newReactionsCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "subscribed" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "typingUsers" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "mentioned" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "allMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "messagesCountExcludingDeleted" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "userMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessagesCount" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "viewerIsThreadParticipant" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "url" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "navigationURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolved" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "resolvedTimestamp" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "sharedToSlack" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "channel" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "slackURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "participants" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadParticipantFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "firstUnseenMessageID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "replyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "actionMessageReplyingUserIDs" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "location" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "extraClassnames" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ThreadFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Thread" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragmentBase" }, "directives": [] }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "initialMessagesInclDeleted" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "MessageFragment" }, "directives": [] }] } }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "ThreadList" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "location" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Context" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadFilterInput" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "resolved" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "partialMatch" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Boolean" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "sort" } }, "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "ThreadSortInput" } } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "limit" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "Int" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "after" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }, { "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "threadsAtLocation" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "location" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "location" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "filter" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "filter" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "resolved" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "resolved" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "partialMatch" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "partialMatch" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "sort" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "sort" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "limit" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "limit" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "after" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "after" } } }, { "kind": "Argument", "name": { "kind": "Name", "value": "_externalOrgID" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "threads" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ThreadFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "hasMore" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "token" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }], "loc": { "start": 0, "end": 4525 } };
var ThreadListQuery_default = documentNode9;

// external/src/graphql/UsersByExternalIDQuery.graphql
var documentNode10 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "UsersByExternalIDQuery" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "externalIDs" } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } } } } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "usersByExternalID" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "externalIDs" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "externalIDs" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }], "loc": { "start": 0, "end": 261 } };
var UsersByExternalIDQuery_default = documentNode10;

// external/src/graphql/UsersQuery.graphql
var documentNode11 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "UsersQuery" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "ids" } }, "type": { "kind": "NonNullType", "type": { "kind": "ListType", "type": { "kind": "NonNullType", "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "UUID" } } } } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "users" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "ids" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "ids" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }] } }], "loc": { "start": 0, "end": 211 } };
var UsersQuery_default = documentNode11;

// external/src/graphql/ViewerIdentityQuery.graphql
var documentNode12 = { "kind": "Document", "definitions": [{ "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "OrganizationFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "Organization" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "__typename" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "linkedOrganization" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "UserFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "User" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "id" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "displayName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "fullName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "name" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "shortName" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "profilePictureURL" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "metadata" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }, { "kind": "FragmentDefinition", "name": { "kind": "Name", "value": "ViewerIdentityFragment" }, "typeCondition": { "kind": "NamedType", "name": { "kind": "Name", "value": "ViewerIdentity" } }, "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "user" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "UserFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "organization" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "OrganizationFragment" }, "directives": [] }] } }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "email" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "isSlackConnected" }, "arguments": [], "directives": [], "selectionSet": void 0 }, { "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "organizations" }, "arguments": [], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "externalID" }, "arguments": [], "directives": [], "selectionSet": void 0 }] } }] } }, { "kind": "OperationDefinition", "operation": "query", "name": { "kind": "Name", "value": "ViewerIdentityQuery" }, "variableDefinitions": [{ "kind": "VariableDefinition", "variable": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } }, "type": { "kind": "NamedType", "name": { "kind": "Name", "value": "String" } }, "defaultValue": void 0, "directives": [] }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "Field", "alias": void 0, "name": { "kind": "Name", "value": "viewerIdentity" }, "arguments": [{ "kind": "Argument", "name": { "kind": "Name", "value": "_externalOrgID" }, "value": { "kind": "Variable", "name": { "kind": "Name", "value": "_externalOrgID" } } }], "directives": [], "selectionSet": { "kind": "SelectionSet", "selections": [{ "kind": "FragmentSpread", "name": { "kind": "Name", "value": "ViewerIdentityFragment" }, "directives": [] }] } }] } }], "loc": { "start": 0, "end": 589 } };
var ViewerIdentityQuery_default = documentNode12;

// server/src/schema/operations.ts
async function executeGraphQL(document, context, variables) {
  return extractResult(
    await execute({
      schema: graphQLSchema,
      document,
      contextValue: context,
      variableValues: variables
    })
  );
}
async function subscribeGraphQL(document, context, variables) {
  const result = await subscribe({
    schema: graphQLSchema,
    document,
    contextValue: context,
    variableValues: variables
  });
  if (!(Symbol.asyncIterator in result)) {
    extractResult(result);
    throw new Error("Unknown GraphQL error");
  }
  return result;
}
function extractResult(result) {
  if (!result.data) {
    if (result.errors?.[0]?.originalError) {
      throw result.errors[0].originalError;
    }
    throw new Error(result.errors?.[0]?.message ?? "Unknown GraphQL error");
  }
  return result.data;
}
async function executeMessageByExternalIDWithThreadQuery(options) {
  return await executeGraphQL(MessageByExternalIDWithThread_default, options.context, options.variables);
}
async function executeNotificationSummaryQuery(options) {
  return await executeGraphQL(NotificationSummaryQuery_default, options.context, options.variables);
}
async function executeNotificationsQuery(options) {
  return await executeGraphQL(NotificationsQuery_default, options.context, options.variables);
}
async function executeOrgMembersByExtIDPaginatedQuery(options) {
  return await executeGraphQL(OrgMembersByExtIDPaginatedQuery_default, options.context, options.variables);
}
async function subscribePresenceLiveQuerySubscription(options) {
  return await subscribeGraphQL(PresenceLiveQuerySubscription_default, options.context, options.variables);
}
async function executeThreadActivityQuery(options) {
  return await executeGraphQL(ThreadActivityQuery_default, options.context, options.variables);
}
async function executeThreadByExternalID2Query(options) {
  return await executeGraphQL(ThreadByExternalID2Query_default, options.context, options.variables);
}
async function executeThreadListQuery(options) {
  return await executeGraphQL(
    ThreadListQuery_default,
    options.context,
    options.variables
  );
}
async function executeUsersByExternalIDQuery(options) {
  return await executeGraphQL(UsersByExternalIDQuery_default, options.context, options.variables);
}
async function executeUsersQuery(options) {
  return await executeGraphQL(
    UsersQuery_default,
    options.context,
    options.variables
  );
}
async function executeViewerIdentityQuery(options) {
  return await executeGraphQL(ViewerIdentityQuery_default, options.context, options.variables);
}

// common/util/convertToExternal/user.ts
function userToUserData(internalUser) {
  return {
    id: internalUser.externalID,
    name: internalUser.name,
    shortName: internalUser.shortName,
    displayName: internalUser.displayName,
    secondaryDisplayName: internalUser.fullName,
    profilePictureURL: internalUser.profilePictureURL,
    metadata: internalUser.metadata
  };
}
function usersToUserData(internalUsers) {
  return internalUsers.map((u) => userToUserData(u));
}

// server/src/public/routes/platform/client/ClientGetViewerHandler.ts
async function getClientViewerHandler(req, res) {
  const context = assertRequestHasContext(req);
  const userID = assertViewerHasUser(context.session.viewer);
  const user = await context.loaders.userLoader.loadUser(userID);
  if (!user) {
    throw new ApiCallerError("user_not_found", { code: 404 });
  }
  const [data, loadedPreferences] = await Promise.all([
    executeViewerIdentityQuery({
      context,
      variables: {
        _externalOrgID: void 0
      }
    }),
    context.loaders.userPreferenceLoader.loadPreferenceValueForViewer(
      NOTIFICATION_CHANNELS
    )
  ]);
  const identity = data.viewerIdentity;
  const preferences = {
    ...defaultNotificationPreference,
    ...loadedPreferences
  };
  const result = {
    ...userToUserData(identity.user),
    organizationID: identity.organization?.externalID ?? null,
    groupID: identity.organization?.externalID ?? null,
    notificationPreferences: {
      sendViaEmail: preferences.email,
      sendViaSlack: preferences.slack
    },
    isSlackConnected: identity.isSlackConnected,
    organizationIsSlackConnected: Boolean(
      identity.organization?.linkedOrganization
    ),
    groupIsSlackConnected: Boolean(identity.organization?.linkedOrganization),
    groups: identity.organizations.map((org) => org.externalID)
  };
  return res.status(200).json(result);
}
var ClientGetViewerHandler_default = forwardHandlerExceptionsToNext(getClientViewerHandler);

// server/src/public/routes/platform/client/ClientGetUserHandler.ts
async function getClientUserHandler(req, res) {
  const context = assertRequestHasContext(req);
  const data = await executeUsersByExternalIDQuery({
    context,
    variables: {
      externalIDs: [req.params.userID]
    }
  });
  if (data.usersByExternalID.length !== 1) {
    throw new ApiCallerError("user_not_found");
  }
  const result = userToUserData(data.usersByExternalID[0]);
  return res.status(200).json(result);
}
var ClientGetUserHandler_default = forwardHandlerExceptionsToNext(getClientUserHandler);

// server/src/public/routes/platform/client/ClientGetUsersHandler.ts
function parseUserList(req) {
  if (typeof req.query.users !== "string") {
    throw new ApiCallerError("invalid_request");
  }
  let users;
  try {
    users = JSON.parse(req.query.users);
  } catch (e) {
    throw new ApiCallerError("invalid_request");
  }
  if (!Array.isArray(users) || users.some((u) => typeof u !== "string" && typeof u !== "number")) {
    throw new ApiCallerError("invalid_request");
  }
  return users.map((u) => u.toString());
}
async function getClientUsersHandler(req, res) {
  const context = assertRequestHasContext(req);
  const users = parseUserList(req);
  const data = await executeUsersByExternalIDQuery({
    context,
    variables: {
      externalIDs: users
    }
  });
  const fetched = /* @__PURE__ */ new Map();
  data.usersByExternalID.forEach((u) => fetched.set(u.externalID, u));
  const result = {};
  for (const user of users) {
    result[user] = fetched.has(user) ? userToUserData(fetched.get(user)) : null;
  }
  return res.status(200).json(result);
}
var ClientGetUsersHandler_default = forwardHandlerExceptionsToNext(getClientUsersHandler);

// common/util/convertToExternal/thread.ts
import * as base642 from "js-base64";
function convertMessageReactionsToMessageDataReactions(messageReactions) {
  return messageReactions.map((reaction) => {
    return {
      reaction: reaction.unicodeReaction,
      userID: reaction.user.externalID,
      timestamp: new Date(reaction.timestamp)
    };
  });
}
function getMessageData({
  message,
  thread,
  userByInternalID
}) {
  const attachments = message.attachments.filter(
    (a) => {
      if (a.__typename === "MessageFileAttachment") {
        return isDefined(a.file);
      } else if (a.__typename === "MessageAnnotationAttachment") {
        return true;
      } else if (a.__typename === "MessageScreenshotAttachment") {
        return isDefined(a.screenshot);
      } else if (a.__typename === "MessageLinkPreview") {
        return true;
      } else {
        console.error("Unexpected MessageAttachment type");
        return false;
      }
    }
  ).map((a) => {
    if (a.__typename === "MessageFileAttachment") {
      return {
        id: a.file.id,
        type: "file",
        name: a.file.name,
        url: a.file.url,
        mimeType: a.file.mimeType,
        size: a.file.size,
        uploadStatus: a.file.uploadStatus
      };
    } else if (a.__typename === "MessageAnnotationAttachment") {
      return {
        type: "annotation",
        textContent: a.location?.highlightedTextConfig?.textToDisplay ?? a.customHighlightedTextConfig?.textToDisplay ?? null,
        locationData: a.location ? base642.encode(JSON.stringify(a.location)) : null,
        customData: a.customLocation ? {
          location: a.customLocation,
          coordsRelativeToTarget: a.coordsRelativeToTarget,
          // always set when custom locations used
          label: a.customLabel
        } : null,
        screenshot: a.screenshot ? {
          id: a.id,
          name: thread.name ?? "annotation",
          url: a.screenshot.url,
          mimeType: a.screenshot.mimeType,
          size: a.screenshot.size,
          uploadStatus: a.screenshot.uploadStatus
        } : null
      };
    } else if (a.__typename === "MessageScreenshotAttachment") {
      return {
        type: "screenshot",
        screenshot: {
          id: a.id,
          name: thread.name ?? "screenshotConfig-generated-screenshot",
          url: a.screenshot.url,
          mimeType: a.screenshot.mimeType,
          size: a.screenshot.size,
          uploadStatus: a.screenshot.uploadStatus
        }
      };
    } else if (a.__typename === "MessageLinkPreview") {
      return {
        type: "link_preview",
        id: a.id,
        url: a.url,
        imageURL: a.img,
        title: a.title,
        description: a.description
      };
    } else {
      return {};
    }
  });
  return {
    id: message.externalID ?? externalizeID(message.id),
    organizationID: thread.externalOrgID,
    groupID: thread.externalOrgID,
    threadID: thread.externalID,
    authorID: message.source.externalID,
    url: message.url,
    content: message.content ? externalizeMessageContent(message.content, userByInternalID) : [],
    plaintext: message.content ? convertStructuredMessageToText(message.content) : "",
    type: message.type,
    iconURL: message.iconURL,
    translationKey: message.translationKey,
    metadata: message.metadata,
    createdTimestamp: new Date(message.timestamp),
    updatedTimestamp: message.lastUpdatedTimestamp ? new Date(message.lastUpdatedTimestamp) : null,
    deletedTimestamp: message.deletedTimestamp ? new Date(message.deletedTimestamp) : null,
    // TODO: is `seen` properly live updating? I don't think it is. Too much
    // memoization?
    seen: message.seen,
    seenBy: message.seenBy.map((user) => user.externalID),
    extraClassnames: message.extraClassnames,
    attachments,
    reactions: convertMessageReactionsToMessageDataReactions(message.reactions),
    skipLinkPreviews: message.skipLinkPreviews
  };
}
function externalizeMessageContent(content, userByInternalID) {
  return content.map((node) => {
    if (node.type === import_types2.MessageNodeType.MENTION) {
      const user = userByInternalID(node.user.id);
      const id = user?.externalID ? user.externalID : externalizeID(node.user.id);
      return {
        ...node,
        user: { id }
      };
    } else if ("children" in node) {
      return {
        ...node,
        children: externalizeMessageContent(node.children, userByInternalID)
      };
    }
    return node;
  });
}
function getThreadSummary(thread, userByInternalID) {
  const firstMessage = thread.messages[0];
  const lastMessage = thread.messages[thread.messages.length - 1];
  const coreThreadData = getThreadData(thread, userByInternalID);
  return {
    ...coreThreadData,
    unread: thread.newMessagesCount,
    viewerIsThreadParticipant: thread.viewerIsThreadParticipant,
    firstMessage: firstMessage ? getMessageData({
      message: firstMessage,
      thread,
      userByInternalID
    }) : null,
    lastMessage: lastMessage ? getMessageData({
      message: lastMessage,
      thread,
      userByInternalID
    }) : null
  };
}
function getThreadData(thread, userByInternalID) {
  const externalThreadID = thread.externalID ?? externalizeID(thread.id);
  const subscribers = thread.participants.filter((p) => p.subscribed && p.user?.externalID).map((p) => p.user.externalID);
  return {
    id: externalThreadID,
    organizationID: thread.externalOrgID,
    groupID: thread.externalOrgID,
    total: thread.messagesCountExcludingDeleted,
    userMessages: thread.userMessagesCount,
    actionMessages: thread.actionMessagesCount,
    deletedMessages: thread.allMessagesCount - thread.messagesCountExcludingDeleted,
    resolved: thread.resolved,
    resolvedTimestamp: thread.resolvedTimestamp ? new Date(thread.resolvedTimestamp) : null,
    participants: thread.participants.map((participant) => {
      return {
        lastSeenTimestamp: participant.lastSeenTimestamp ? new Date(participant.lastSeenTimestamp) : null,
        userID: participant.user ? participant.user.externalID : null,
        displayName: participant.user ? participant.user.displayName : null
      };
    }),
    mentioned: thread.mentioned.map((mention) => mention.externalID),
    subscribers,
    repliers: thread.replyingUserIDs.map(
      (u) => userByInternalID(u)?.externalID ?? ""
    ),
    actionMessageRepliers: thread.actionMessageReplyingUserIDs.map(
      (u) => userByInternalID(u)?.externalID ?? ""
    ),
    typing: thread.typingUsers.map((user) => user.externalID),
    name: thread.name ?? "",
    url: thread.url,
    location: thread.location,
    metadata: thread.metadata,
    extraClassnames: thread.extraClassnames
  };
}

// server/src/public/routes/platform/client/util.ts
function collectNeededUserIDs(thread) {
  const users = /* @__PURE__ */ new Set();
  thread.replyingUserIDs.forEach((u) => users.add(u));
  thread.actionMessageReplyingUserIDs.forEach((u) => users.add(u));
  thread.initialMessagesInclDeleted.forEach(
    (m) => getMentionedUserIDs(m.content ?? []).forEach((u) => users.add(u))
  );
  return [...users];
}
async function getUserByInternalIdFunction(context, userIDs) {
  const userGraphQL = await executeUsersQuery({
    context,
    variables: {
      ids: userIDs
    }
  });
  const users = /* @__PURE__ */ new Map();
  userGraphQL.users.forEach((u) => users.set(u.id, u));
  return (id) => users.get(id);
}

// server/src/public/routes/platform/client/ClientGetThreadHandler.ts
async function getClientThreadHandler(req, res) {
  const context = assertRequestHasContext(req);
  const initialFetchCount = req.query.initialFetchCount ? Number.parseInt(req.query.initialFetchCount) : void 0;
  if (isNaN(initialFetchCount ?? 0)) {
    throw new ApiCallerError("invalid_field", {
      message: `initialFetchCount must be a number.`
    });
  }
  const threadGraphQL = await executeThreadByExternalID2Query({
    context,
    variables: {
      _externalOrgID: void 0,
      input: {
        externalThreadID: req.params.threadID
      },
      initialFetchCount
    }
  });
  if (!threadGraphQL.threadByExternalID2.thread) {
    throw new ApiCallerError("thread_not_found");
  }
  const thread = threadGraphQL.threadByExternalID2.thread;
  const userByInternalID = await getUserByInternalIdFunction(
    context,
    collectNeededUserIDs(thread)
  );
  const messages = thread.initialMessagesInclDeleted.map(
    (message) => getMessageData({ message, thread, userByInternalID })
  );
  const allMessagesFetched = messages.length === thread.allMessagesCount;
  if (!allMessagesFetched) {
    messages.shift();
  }
  const result = {
    thread: getThreadSummary(
      { ...thread, messages: thread.initialMessagesInclDeleted },
      userByInternalID
    ),
    messages,
    loading: false,
    hasMore: !allMessagesFetched
  };
  return res.status(200).json(result);
}
var ClientGetThreadHandler_default = forwardHandlerExceptionsToNext(getClientThreadHandler);

// server/src/public/routes/platform/client/ClientGetMessageHandler.ts
async function getClientMessageHandler(req, res) {
  const context = assertRequestHasContext(req);
  const data = await executeMessageByExternalIDWithThreadQuery({
    context,
    variables: {
      _externalOrgID: void 0,
      id: req.params.messageID
    }
  });
  if (!data.messageByExternalID) {
    throw new ApiCallerError("message_not_found");
  }
  const message = data.messageByExternalID;
  const userByInternalID = await getUserByInternalIdFunction(
    context,
    getMentionedUserIDs(message.content ?? [])
  );
  const result = getMessageData({
    message,
    thread: message.thread,
    userByInternalID
  });
  return res.status(200).json(result);
}
var ClientGetMessageHandler_default = forwardHandlerExceptionsToNext(getClientMessageHandler);

// server/src/public/routes/platform/client/ClientGetThreadCountsHandler.ts
async function getClientThreadCountsHandler(req, res) {
  const context = assertRequestHasContext(req);
  const { location, metadata, resolvedStatus, groupID, viewer } = validateFilter(req.query, {
    location: true,
    metadata: true,
    resolvedStatus: true,
    groupID: true,
    viewer: true,
    firstMessageTimestamp: false,
    mostRecentMessageTimestamp: false,
    authorID: false
  });
  const data = await executeThreadActivityQuery({
    context,
    variables: {
      _externalOrgID: groupID,
      pageContext: location ? { data: location.value, providerID: null } : void 0,
      partialMatch: location?.partialMatch,
      viewer,
      metadata,
      resolved: resolvedStatus === "resolved" ? true : resolvedStatus === "unresolved" ? false : void 0
    }
  });
  const activity = data.activity.threadSummary;
  const result = {
    total: activity.totalThreadCount,
    unread: activity.unreadThreadCount,
    new: activity.newThreadCount,
    unreadSubscribed: activity.unreadSubscribedThreadCount,
    resolved: activity.resolvedThreadCount,
    empty: activity.emptyThreadCount
  };
  return res.status(200).json(result);
}
var ClientGetThreadCountsHandler_default = forwardHandlerExceptionsToNext(getClientThreadCountsHandler);

// server/src/public/routes/platform/client/ClientGetThreadsHandler.ts
import { unique as unique15 } from "radash";
async function getClientThreadsHandler(req, res) {
  const context = assertRequestHasContext(req);
  const { location, metadata, resolvedStatus, groupID, viewer } = validateFilter(req.query, {
    location: true,
    metadata: true,
    resolvedStatus: true,
    groupID: true,
    viewer: true,
    firstMessageTimestamp: false,
    mostRecentMessageTimestamp: false,
    authorID: false
  });
  const sort = validateSort(req.query);
  const limit = validateInitialFetchCount(req.query);
  const [threadsGraphQL, countsGraphQL] = await Promise.all([
    executeThreadListQuery({
      context,
      variables: {
        _externalOrgID: groupID,
        location: location?.value,
        partialMatch: location?.partialMatch,
        filter: { metadata, viewer },
        resolved: resolvedStatus === "resolved" ? true : resolvedStatus === "unresolved" ? false : void 0,
        sort,
        limit,
        after: void 0
      }
    }),
    executeThreadActivityQuery({
      context,
      variables: {
        _externalOrgID: groupID,
        pageContext: location ? { data: location.value, providerID: null } : void 0,
        partialMatch: location?.partialMatch,
        viewer,
        metadata,
        resolved: resolvedStatus === "resolved" ? true : resolvedStatus === "unresolved" ? false : void 0
      }
    })
  ]);
  const userIDs = unique15(
    threadsGraphQL.threadsAtLocation.threads.flatMap(
      (t) => collectNeededUserIDs(t)
    )
  );
  const userByInternalID = await getUserByInternalIdFunction(context, userIDs);
  const activity = countsGraphQL.activity.threadSummary;
  const result = {
    threads: threadsGraphQL.threadsAtLocation.threads.map(
      (t) => getThreadSummary(
        { ...t, messages: t.initialMessagesInclDeleted },
        userByInternalID
      )
    ),
    counts: {
      total: activity.totalThreadCount,
      unread: activity.unreadThreadCount,
      new: activity.newThreadCount,
      unreadSubscribed: activity.unreadSubscribedThreadCount,
      resolved: activity.resolvedThreadCount,
      empty: activity.emptyThreadCount
    },
    loading: false,
    hasMore: threadsGraphQL.threadsAtLocation.hasMore
  };
  return res.status(200).json(result);
}
var ClientGetThreadsHandler_default = forwardHandlerExceptionsToNext(getClientThreadsHandler);

// server/src/public/routes/platform/client/ClientGetNotificationsHandler.ts
import { unique as unique16 } from "radash";

// common/util/convertToExternal/notification.ts
function gqlNotificationFragmentHeaderToNotificationVariables(gqlHeader) {
  if ("user" in gqlHeader) {
    return {
      type: "user",
      userID: gqlHeader.user.externalID,
      user: userToUserData(gqlHeader.user)
    };
  } else if ("text" in gqlHeader) {
    return { type: "text", text: gqlHeader.text, bold: gqlHeader.bold };
  } else {
    const _ = gqlHeader;
    return { type: "text", text: "", bold: false };
  }
}
function gqlNotificationFragmentAttachmentToNotificationVariables(gqlAttachment, userByInternalID) {
  if (!gqlAttachment) {
    return null;
  } else if ("message" in gqlAttachment) {
    return {
      type: "message",
      messageID: gqlAttachment.message.externalID,
      threadID: gqlAttachment.message.thread.externalID,
      message: getMessageData({
        message: gqlAttachment.message,
        thread: gqlAttachment.message.thread,
        userByInternalID
      })
    };
  } else if ("url" in gqlAttachment) {
    return {
      type: "url",
      url: gqlAttachment.url
    };
  } else if ("thread" in gqlAttachment) {
    return {
      type: "thread",
      thread: getThreadData(gqlAttachment.thread, userByInternalID)
    };
  } else {
    const _ = gqlAttachment;
    return null;
  }
}
function convertGqlNotificationHeaderTranslation2(gqlNotif) {
  if (!gqlNotif.headerTranslationKey) {
    return null;
  }
  if (!gqlNotif.headerSimpleTranslationParams) {
    throw new Error("Got notification with translation key but no parameters");
  }
  const parameters = {
    ...gqlNotif.headerSimpleTranslationParams,
    senders: gqlNotif.senders.map(userToUserData)
  };
  return {
    key: gqlNotif.headerTranslationKey,
    parameters
  };
}
function gqlNotificationFragmentToNotificationVariables(gqlNotif, userByInternalID) {
  return {
    id: gqlNotif.externalID,
    senderUserIDs: gqlNotif.senders.map((u) => u.externalID),
    iconUrl: gqlNotif.iconUrl ?? null,
    header: gqlNotif.header.map(
      gqlNotificationFragmentHeaderToNotificationVariables
    ),
    headerTranslation: convertGqlNotificationHeaderTranslation2(gqlNotif),
    attachment: gqlNotificationFragmentAttachmentToNotificationVariables(
      gqlNotif.attachment,
      userByInternalID
    ),
    readStatus: gqlNotif.readStatus,
    timestamp: typeof gqlNotif.timestamp === "string" ? new Date(gqlNotif.timestamp) : gqlNotif.timestamp,
    extraClassnames: gqlNotif.extraClassnames,
    metadata: gqlNotif.metadata
  };
}

// server/src/public/routes/platform/client/ClientGetNotificationsHandler.ts
async function getClientNotificationsHandler(req, res) {
  const context = assertRequestHasContext(req);
  const { location, metadata, groupID } = validateFilter(req.query, {
    location: true,
    metadata: true,
    groupID: true,
    resolvedStatus: false,
    viewer: false,
    firstMessageTimestamp: false,
    mostRecentMessageTimestamp: false,
    authorID: false
  });
  const data = await executeNotificationsQuery({
    context,
    variables: {
      first: DEFAULT_NOTIFICATION_INITIAL_PAGE_SIZE,
      after: void 0,
      filter: {
        location: location?.value,
        partialMatch: location?.partialMatch,
        metadata,
        organizationID: groupID
      }
    }
  });
  const userIDs = unique16(
    data.notifications.nodes.flatMap(
      (n) => n.attachment && "message" in n.attachment ? getMentionedUserIDs(n.attachment.message.content ?? []) : []
    )
  );
  const userByInternalID = await getUserByInternalIdFunction(context, userIDs);
  const result = {
    notifications: data.notifications.nodes.map(
      (n) => gqlNotificationFragmentToNotificationVariables(n, userByInternalID)
    ),
    loading: false,
    hasMore: data.notifications.paginationInfo.hasNextPage
  };
  return res.status(200).json(result);
}
var ClientGetNotificationsHandler_default = forwardHandlerExceptionsToNext(getClientNotificationsHandler);

// server/src/public/routes/platform/client/ClientGetNotificationCountsHandler.ts
async function getClientNotificationCountsHandler(req, res) {
  const context = assertRequestHasContext(req);
  const { location, metadata, groupID } = validateFilter(req.query, {
    location: true,
    metadata: true,
    groupID: true,
    resolvedStatus: false,
    viewer: false,
    firstMessageTimestamp: false,
    mostRecentMessageTimestamp: false,
    authorID: false
  });
  const data = await executeNotificationSummaryQuery({
    context,
    variables: {
      filter: {
        location: location?.value,
        partialMatch: location?.partialMatch,
        metadata,
        organizationID: groupID
      }
    }
  });
  const result = {
    unread: data.notificationSummary.unreadNotificationCount
  };
  return res.status(200).json(result);
}
var ClientGetNotificationCountsHandler_default = forwardHandlerExceptionsToNext(
  getClientNotificationCountsHandler
);

// server/src/public/routes/platform/client/ClientGetGroupMembersHandler.ts
async function getClientGroupMembersHandler(req, res) {
  const context = assertRequestHasContext(req);
  const data = await executeOrgMembersByExtIDPaginatedQuery({
    context,
    variables: {
      externalOrgID: req.params.groupID,
      limit: DEFAULT_GROUP_MEMBERS_INITIAL_PAGE_SIZE,
      after: void 0
    }
  });
  const result = {
    groupMembers: usersToUserData(data.orgMembersByExternalIDPaginated.users),
    loading: false,
    hasMore: data.orgMembersByExternalIDPaginated.hasMore
  };
  return res.status(200).json(result);
}
var ClientGetGroupMembersHandler_default = forwardHandlerExceptionsToNext(getClientGroupMembersHandler);

// common/util/convertToExternal/presence.ts
function toUserLocationData(u) {
  const result = {
    id: u.externalUserID
  };
  if (u.ephemeral) {
    result.ephemeral = {
      locations: u.ephemeral.contexts?.filter(isLocation) ?? null
    };
  }
  if (u.durable) {
    result.durable = {
      location: toLocation(u.durable.context),
      timestamp: new Date(u.durable.timestamp)
    };
  }
  return result;
}
function fillUserLocationData(d) {
  return { ...d, ephemeral: { locations: d?.ephemeral?.locations ?? [] } };
}

// server/src/public/routes/platform/client/ClientGetPresenceHandler.ts
async function getClientPresenceHandler(req, res) {
  const context = assertRequestHasContext(req);
  const excludeDurable = validateBooleanValue(
    req.query,
    "exclude_durable",
    false
  );
  const exactMatch = !validateBooleanValue(req.query, "partial_match", false);
  const matcher = validateLocationValue(req.query, "location");
  if (!matcher) {
    throw new ApiCallerError("invalid_request", {
      message: '"location" parameter is required'
    });
  }
  const subscription = await subscribePresenceLiveQuerySubscription({
    context,
    variables: {
      input: { matcher, excludeDurable, exactMatch },
      _externalOrgID: void 0
    }
  });
  for await (const item of subscription) {
    const data = extractResult(item);
    if (!data.presenceLiveQuery.complete) {
      throw new Error("Unknown error");
    }
    const result = data.presenceLiveQuery.data.map(
      (update) => fillUserLocationData(toUserLocationData(update))
    );
    return res.status(200).json(result);
  }
  return res.status(200).json([]);
}
var ClientGetPresenceHandler_default = forwardHandlerExceptionsToNext(getClientPresenceHandler);

// server/src/public/routes/platform/customer/GetDbDumpHandler.ts
import Pg2 from "pg";
import { to as copyTo } from "pg-copy-streams";
async function GetDbDumpHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_access_token");
  }
  res.statusCode = 200;
  res.setHeader("Content-type", "text/plain");
  try {
    await streamPartialDump(
      res,
      getReadReplicaDbConfigFromEnv(Env_default),
      customerID
    );
  } catch (err) {
    res.write(`

-- ${err}
`);
  }
  res.end();
}
var { escapeIdentifier } = Pg2.Client.prototype;
var tableHandling = {
  console_users: (alias, customerID) => `${alias}."customerID" = '${customerID}' OR ${alias}."pendingCustomerID" = '${customerID}'`,
  users: (alias, customerID) => `${alias}."platformApplicationID" IS NOT NULL
      OR (
        ${alias}."platformApplicationID" IS NULL
        AND (
          -- Include Slack users that have sent a message
          ${alias}.id IN (
            SELECT "sourceID" FROM messages m
              INNER JOIN applications a ON m."platformApplicationID" = a.id
            WHERE a."customerID" = '${customerID}')
          -- ...and Slack users that a platform user has linked to
          OR ${alias}.id IN (
            SELECT "linkedUserID" FROM linked_users lu
              INNER JOIN users u ON lu."sourceUserID" = u.id
              INNER JOIN applications a ON u."platformApplicationID" = a.id
            WHERE a."customerID" = '${customerID}')
          -- ...and Slack users that have notifications
          OR ${alias}.id IN (
            SELECT "recipientID" FROM notifications n
              INNER JOIN applications a ON n."platformApplicationID" = a.id
            WHERE a."customerID" = '${customerID}')))`,
  orgs: (alias, customerID) => `${alias}."platformApplicationID" IS NOT NULL
    OR (
      ${alias}."platformApplicationID" IS NULL
      AND ${alias}.id IN (
        SELECT "linkedOrgID" FROM linked_orgs lo
          INNER JOIN orgs o ON lo."sourceOrgID" = o.id
          INNER JOIN applications a ON o."platformApplicationID" = a.id
        WHERE a."customerID" = '${customerID}'))`,
  linked_users: (alias, customerID) => `${alias}."sourceUserID" IN (
      SELECT u.id FROM users u
        INNER JOIN applications a ON u."platformApplicationID" = a.id
      WHERE a."customerID" = '${customerID}')`,
  linked_orgs: (alias, customerID) => `${alias}."sourceOrgID" IN (
      SELECT o.id FROM orgs o
        INNER JOIN applications a ON o."platformApplicationID" = a.id
      WHERE a."customerID" = '${customerID}')`,
  // Contains customer secrets for their s3_buckets, don't include
  s3_buckets: "ignore",
  // Big tables that we don't need.
  events: "ignore",
  application_usage_metrics: "ignore",
  sessions: "ignore",
  // Tables that are irrelevant for customers
  deploys: "ignore",
  org_org_members: "ignore",
  permission_rules: "ignore",
  admin_go_redirects: "ignore",
  admin_crt_customer_issues: "ignore",
  admin_crt_customer_issue_changes: "ignore",
  admin_crt_customer_issue_subscriptions: "ignore",
  warm_demo_users: "ignore",
  external_assets: "ignore",
  image_variants: "ignore",
  slack_channels: "ignore",
  // The existing email notifications can't possibly be responded to, they'll be
  // responding to us, not them, so don't export them
  email_notifications: "ignore"
};
var firstTables = [
  "customers",
  "applications",
  "users",
  "orgs",
  "threads",
  "messages",
  "tasks",
  "task_todos"
];
var ignoredColumns = ["supportBotID", "supportOrgID"];
async function streamPartialDump(output, dbconfig, customerID) {
  const pg = new Pg2.Client(dbconfig);
  await pg.connect();
  try {
    await pg.query("SET search_path=cord,public;");
    await pg.query(
      "BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE READ ONLY DEFERRABLE;"
    ).catch((error) => {
      if (error.toString() === "error: cannot use serializable mode in a hot standby") {
        return pg.query(
          "BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ READ ONLY;"
        );
      } else {
        return Promise.reject(error);
      }
    });
    output.write("SET search_path = cord, public;\n\n");
    output.write("BEGIN;\n\n");
    await streamPartialDumpImpl(output, pg, customerID);
    output.write("\n\nCOMMIT;\n");
  } finally {
    pg.end().catch(
      anonymousLogger().exceptionLogger("pg.end() threw exception")
    );
  }
}
async function streamPartialDumpImpl(output, pg, customerID) {
  const tables = /* @__PURE__ */ new Map();
  for (const row of (await pg.query(`
      WITH "attributes" AS (
          SELECT
              attrelid,
              jsonb_agg(attname::text ORDER BY attnum) AS attributes
          FROM pg_catalog.pg_attribute
          WHERE attnum >= 1
          AND NOT attisdropped
          AND attgenerated != 's'
          GROUP BY attrelid
      )
      SELECT
          cls.oid::int4 AS oid,
          cls.relname AS name,
          COALESCE(attributes.attributes, '[]'::jsonb) AS columns
      FROM pg_catalog.pg_class cls
      LEFT OUTER JOIN attributes ON cls.oid = attributes.attrelid
      WHERE relnamespace='cord'::regnamespace AND relkind='r';`)).rows) {
    tables.set(row.oid, {
      ...row,
      fkeys: [],
      handling: tableHandling[row.name] ?? null
    });
  }
  for (const row of (await pg.query(`
      SELECT
        constraints.conrelid AS "tableOid",
        constraints.confrelid AS "referencedTableOid",
        ARRAY_AGG(jsonb_build_object(
          'column', fatt.attname::text,
          'nullable', NOT fatt.attnotnull
        )) AS fkey,
        ARRAY_AGG(ratt.attname::text) AS rkey
      FROM
        (SELECT
            conrelid,
            confrelid,
            UNNEST(conkey) AS conkey,
            UNNEST(confkey) AS confkey
          FROM pg_catalog.pg_constraint
          WHERE contype='f'
        ) AS constraints
        INNER JOIN pg_catalog.pg_attribute fatt
          ON fatt.attnum=conkey AND fatt.attrelid=conrelid
        INNER JOIN pg_catalog.pg_attribute ratt
          ON ratt.attnum=confkey AND ratt.attrelid=confrelid
        GROUP BY 1, 2;`)).rows) {
    const table = tables.get(row.tableOid);
    const referencedTable = tables.get(row.referencedTableOid);
    if (table && referencedTable) {
      const keys = row.fkey.map(({ column, nullable }, idx) => ({
        column,
        nullable,
        referencedColumn: row.rkey[idx],
        operator: "="
      })).filter(({ column }) => !ignoredColumns.includes(column));
      if (keys.length) {
        const nullable = keys.some(({ nullable: keyIsNullable }) => keyIsNullable) && // HACK: the notifications table has complex checks that this script
        // doesn't understand to know what rows to pull. However, those checks
        // more-or-less have the property that if an fkey column is non-null,
        // it needs to remain non-null, so we can just treat all of the notif
        // table's fkeys as non-nullable.
        table.name !== "notifications";
        table.fkeys.push({
          referencedTable,
          nullable,
          keys
        });
      }
    }
  }
  const sortedTables = [...tables.values()];
  sortedTables.sort((a, b) => {
    const aIndex = firstTables.indexOf(a.name);
    const bIndex = firstTables.indexOf(b.name);
    if (aIndex === bIndex) {
      return 0;
    }
    if (aIndex === -1 && bIndex !== -1) {
      return 1;
    }
    if (aIndex !== -1 && bIndex === -1) {
      return -1;
    }
    return aIndex - bIndex;
  });
  for (const table of sortedTables) {
    await dumpTable(output, pg, table, customerID);
  }
  await pg.query("ROLLBACK");
  for (const table of tables.values()) {
    if (table.handling === "ignore") {
      continue;
    }
    for (const fkey of table.fkeys) {
      if (fkey.nullable) {
        output.write(
          `\\echo Fixing dangling foreign keys in ${table.name} (${fkey.keys.map(({ column }) => column).join(", ")})
`
        );
        output.write(`UPDATE ${escapeIdentifier(table.name)} AS _t SET `);
        output.write(
          fkey.keys.filter(({ nullable }) => nullable).map(({ column }) => `${escapeIdentifier(column)}=NULL`).join(", ")
        );
        output.write(` WHERE NOT (${foreignKeyNullCheck("_t", fkey.keys)})`);
        output.write(
          ` AND (${fkey.keys.map(({ column }) => `_t.${escapeIdentifier(column)}`).join(", ")}) NOT IN (SELECT ${fkey.keys.map(({ referencedColumn }) => escapeIdentifier(referencedColumn)).join(", ")} FROM ${escapeIdentifier(
            fkey.referencedTable.name
          )});
`
        );
      }
    }
  }
}
var serial = 1337;
async function dumpTable(output, pg, table, customerID) {
  const alias = `t_${serial++}`;
  const foreignKeys = resolveForeignKeys(table, customerID, alias, []);
  if (!foreignKeys) {
    return;
  }
  const start = performance.now();
  const { joins, where } = foreignKeys;
  const query = `SELECT
     ${table.columns.map((n) => `${alias}.${escapeIdentifier(n)}`).join(", ")}
     FROM ${escapeIdentifier(table.name)} ${alias}
     ${joins.join("\n")}
     ${where ? "WHERE " : ""}${where}`;
  output.write(
    `\\echo Loading data into table ${table.name}...
-- ${query.replace(/\n/g, "\n-- ")};
     

COPY ${escapeIdentifier(table.name)} (${table.columns.map(escapeIdentifier).join(", ")}) FROM stdin;
`
  );
  await dumpData(pg, query, output);
  output.write("\\.\n\n");
  output.write(
    `-- Elapsed time for ${table.name}: ${Math.round(
      performance.now() - start
    )}ms


`
  );
}
function resolveForeignKeys(table, customerID, alias, visitedTables) {
  if (table.handling === "ignore") {
    return void 0;
  }
  if (table.name === "customers") {
    const where2 = `${alias}.id = '${customerID}'`;
    return { joins: [], where: where2 };
  }
  if (table.name === "notifications") {
    const referencedAlias = `j_${serial++}`;
    return {
      joins: [
        `LEFT OUTER JOIN applications ${referencedAlias}
    ON (${alias}."platformApplicationID" = ${referencedAlias}.id)`
      ],
      where: `${referencedAlias}."customerID" = '${customerID}'`
    };
  }
  if (visitedTables.includes(table)) {
    anonymousLogger().warn(
      `Foreign keys self-join: ${visitedTables.map((t) => t.name).join(", ")} => ${table.name}`
    );
    return { where: "", joins: [] };
  }
  visitedTables = [...visitedTables, table];
  const where = [];
  const joins = [];
  if (table.handling) {
    where.push(`(${table.handling(alias, customerID)})`);
  }
  for (const { referencedTable, keys } of table.fkeys) {
    if (referencedTable.name === "customers" && keys.length === 1 && keys[0].referencedColumn === "id") {
      if (keys[0].nullable) {
        where.push(
          `(
            ${alias}.${escapeIdentifier(keys[0].column)} IS NULL OR
            ${alias}.${escapeIdentifier(keys[0].column)} = '${customerID}')`
        );
      } else {
        where.push(
          `${alias}.${escapeIdentifier(keys[0].column)} = '${customerID}'`
        );
      }
    } else if (referencedTable.handling !== "ignore") {
      const referencedAlias = `j_${serial++}`;
      const foreignKeys = resolveForeignKeys(
        referencedTable,
        customerID,
        referencedAlias,
        visitedTables
      );
      if (!foreignKeys) {
        return void 0;
      }
      const { where: fwhere, joins: fjoins } = foreignKeys;
      if (fwhere) {
        joins.push(`LEFT OUTER JOIN ${escapeIdentifier(
          referencedTable.name
        )} ${referencedAlias}
    ON (${keys.map(
          ({ column, referencedColumn, operator }) => `${alias}.${escapeIdentifier(
            column
          )} ${operator} ${referencedAlias}.${escapeIdentifier(
            referencedColumn
          )}`
        ).join(" AND ")})`);
        joins.push(...fjoins);
        if (keys.some((k) => k.nullable)) {
          where.push(`(${foreignKeyNullCheck(alias, keys)} OR (${fwhere}))`);
        } else {
          where.push(fwhere);
        }
      }
    }
  }
  return { where: where.join(" AND "), joins };
}
function foreignKeyNullCheck(alias, keys) {
  return keys.length === 0 ? "FALSE" : keys.length === 1 ? `${alias}.${escapeIdentifier(keys[0].column)} IS NULL` : "num_nulls(" + keys.map(({ column }) => `${alias}.${escapeIdentifier(column)}`).join(", ") + ") > 0";
}
function dumpData(pg, query, output) {
  return new Promise((resolve2, reject) => {
    const stream = pg.query(copyTo(`COPY (${query}) TO STDOUT;`));
    stream.on("end", resolve2);
    stream.on("error", reject);
    stream.on("data", (chunk) => output.write(chunk));
  });
}
var GetDbDumpHandler_default = forwardHandlerExceptionsToNext(GetDbDumpHandler);

// server/src/public/routes/platform/customer/CopyFilesHandler.ts
import {
  CopyObjectCommand,
  ListObjectsV2Command,
  S3Client
} from "@aws-sdk/client-s3";
var DEFAULT_LIMIT5 = 10;
var MAX_LIMIT2 = 1e3;
async function CopyFilesHandler(req, res) {
  const customerID = req.customerID;
  if (!customerID) {
    throw new ApiCallerError("invalid_access_token");
  }
  const region = req.query["region"];
  if (typeof region !== "string") {
    throw new ApiCallerError("invalid_field", {
      message: "The region field must be a string"
    });
  }
  const bucket = req.query["bucket"];
  if (typeof bucket !== "string") {
    throw new ApiCallerError("invalid_field", {
      message: "The bucket field must be a string"
    });
  }
  const limitString = req.query["limit"];
  if (limitString && typeof limitString !== "string") {
    throw new ApiCallerError("invalid_field", {
      message: "Invalid copy limit"
    });
  }
  const limit = limitString ? parseInt(limitString, 10) : DEFAULT_LIMIT5;
  if (limit <= 0 || MAX_LIMIT2 < limit) {
    throw new ApiCallerError("invalid_field", {
      message: `The limit must be between 1 and ${MAX_LIMIT2}`
    });
  }
  const applications = await ApplicationEntity.findAll({
    where: { customerID }
  });
  const destClient = new S3Client({
    region,
    endpoint: Env_default.S3_ENDPOINT.replace("<REGION>", region)
  });
  const [files, s3Contents] = await Promise.all([
    FileEntity.findAll({
      where: {
        platformApplicationID: applications.map((a) => a.id),
        uploadStatus: "uploaded"
      }
    }),
    getAllFilesFromBucket(destClient, bucket)
  ]);
  const filesToCopy = files.filter((f) => !s3Contents.has(f.id));
  const credentialsCache = /* @__PURE__ */ new Map();
  let copied = 0;
  await doCopy(filesToCopy[copied], region, bucket, credentialsCache);
  copied++;
  const promises = [];
  for (; copied < limit && copied < filesToCopy.length; copied++) {
    promises.push(
      doCopy(filesToCopy[copied], region, bucket, credentialsCache)
    );
  }
  await Promise.all(promises);
  return res.status(200).json({
    copied
  });
}
async function doCopy(fileToCopy, region, bucket, credentialsCache) {
  const config = await getConfigForCopy(fileToCopy, credentialsCache);
  const srcClient = new S3Client({
    region,
    endpoint: Env_default.S3_ENDPOINT.replace("<REGION>", region),
    ...config.accessKeyID && config.accessKeySecret && {
      credentials: {
        accessKeyId: config.accessKeyID,
        secretAccessKey: config.accessKeySecret
      }
    }
  });
  const command = new CopyObjectCommand({
    CopySource: `${config.bucket}/${fileToCopy.id}`,
    Bucket: bucket,
    Key: fileToCopy.id
  });
  await srcClient.send(command);
}
async function getConfigForCopy(file, credentialsCache) {
  if (!file.s3Bucket) {
    return {
      bucket: Env_default.S3_BUCKET,
      region: Env_default.S3_REGION
    };
  }
  let credentials2;
  if (credentialsCache.has(file.s3Bucket)) {
    credentials2 = credentialsCache.get(file.s3Bucket);
  } else {
    const s3Bucket = await S3BucketEntity.findByPk(file.s3Bucket);
    if (!s3Bucket) {
      throw new Error("Could not find S3 bucket config");
    }
    credentials2 = s3Bucket.getS3BucketConfig_DO_NOT_EXPOSE_TO_CLIENT();
    credentialsCache.set(file.s3Bucket, credentials2);
  }
  return credentials2;
}
async function getAllFilesFromBucket(client2, bucket) {
  const command = new ListObjectsV2Command({
    Bucket: bucket
  });
  const files = /* @__PURE__ */ new Set();
  let more = true;
  while (more) {
    const response = await client2.send(command);
    (response.Contents ?? []).forEach((c) => files.add(c.Key ?? ""));
    if (response.IsTruncated) {
      command.input.ContinuationToken = response.NextContinuationToken;
    } else {
      more = false;
    }
  }
  return files;
}
var CopyFilesHandler_default = forwardHandlerExceptionsToNext(CopyFilesHandler);

// server/src/public/routes/MainRouter.ts
var ASANA_EVENTS_PATH = "/asana/events";
var LINEAR_EVENTS_PATH = "/linear/events";
var MONDAY_EVENTS_PATH_BASE = "/monday/events";
var MONDAY_EVENTS_PATH = MONDAY_EVENTS_PATH_BASE + "/:subscriptionId";
var UNSUBSCRIBE_PATH = "/email/unsubscribe_thread";
var TYPEFORM_NOTIFICATION_LOGGING_PATH = "/typeform";
var DEFAULT_NOTIFICATION_LOGGING_PATH = "/redirect";
var TEMPORARY_V5_CORD_DOT_COM_ORIGINS = [
  "https://cord-v5-cord.vercel.app",
  "https://v5.cord.com/"
];
var restApiCalls = Counter2({
  name: "RestApiCalls",
  help: "Tracks how often each REST API method is called",
  labelNames: ["route", "appID", "statusCode", "cordSource"]
});
var restApiCallExecTime = TimeHistogram({
  name: "RestApiCallExecTime",
  help: "Tracks how long each REST API path call takes in s",
  labelNames: ["route", "appID"]
});
var MainRouter = Router();
MainRouter.get("/", IndexHandler);
MainRouter.get("/auth/slack/redirect", SlackAuthRedirectHandler);
MainRouter.get("/auth/slack/redirect/dev", SlackAuthRedirectHandler);
MainRouter.get(
  "/auth/slack/linking-confirmation",
  // eslint-disable-next-line @typescript-eslint/no-misused-promises -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
  SlackLinkingConfirmationHandler
);
MainRouter.get("/auth/jira/redirect/", JiraAuthRedirectHandler);
MainRouter.get("/auth/asana/redirect/", AsanaAuthRedirectHandler);
MainRouter.get("/auth/linear/redirect", LinearAuthRedirectHandler);
MainRouter.get("/auth/trello/login", TrelloAuthLoginHandler);
MainRouter.get("/auth/trello/redirect", TrelloAuthRedirectHandler);
MainRouter.get("/auth/monday/redirect", MondayAuthRedirectHandler);
MainRouter.get(UNSUBSCRIBE_PATH, RenderUnsubscribeThreadPage);
MainRouter.post(UNSUBSCRIBE_PATH, UnsubscribeThreadHandler);
MainRouter.get("/file", FileProxyHandler);
MainRouter.post(SLACK_EVENT_PATH, SlackEventApiHandler);
MainRouter.post(SLACK_INTERACTIVE_EVENT_PATH, SlackInteractiveEventApiHandler);
MainRouter.post(ASANA_EVENTS_PATH, AsanaEventApiHandler);
MainRouter.post(LINEAR_EVENTS_PATH, LinearEventApiHandler);
MainRouter.post(MONDAY_EVENTS_PATH, MondayEventApiHandler);
var ignoreUploadedFiles = multer({
  // Filter out all files to not store them for now but
  // still pass on the message.
  fileFilter: (_req, _file, cb) => {
    cb(null, false);
  }
});
var uploadedFiles = multer({
  dest: "/tmp/uploads/",
  limits: {
    fileSize: MAX_UPLOAD_SIZE
  }
});
MainRouter.post(
  "/sendgrid",
  // Only SendGrid should be able to post to this endpoint
  basicAuth({
    users: {
      [Env_default.SENDGRID_INBOUND_WEBHOOK_USER]: Env_default.SENDGRID_INBOUND_WEBHOOK_PASSWORD
    }
  }),
  // parse multipart/form-data
  // Allow all files through to not throw an error
  // and drop replies with attachments.
  // (TODO) Properly implement support for attachments by
  // uploading files to s3 and attaching to message.
  ignoreUploadedFiles.any(),
  // eslint-disable-next-line @typescript-eslint/no-misused-promises -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
  SendGridWebhookHandler
);
MainRouter.get(
  TYPEFORM_NOTIFICATION_LOGGING_PATH + "/:redirectID",
  // eslint-disable-next-line @typescript-eslint/no-misused-promises -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
  NotificationLoggingHandler
);
MainRouter.get(
  DEFAULT_NOTIFICATION_LOGGING_PATH + "/:redirectID",
  // eslint-disable-next-line @typescript-eslint/no-misused-promises -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
  NotificationLoggingHandler
);
MainRouter.use(cors());
MainRouter.use(
  "/v1/*",
  (req, _res, next) => asyncLocalStorage ? asyncLocalStorage.run(
    {
      operationName: `REST: ${req.method} ${req.baseUrl}`,
      operationID: uuid23(),
      logger: anonymousLogger(),
      // Filled in by VerifyAppServerAuthToken.
      platformApplicationID: void 0
    },
    next
  ) : next(),
  responseTime((req, res, time) => {
    const request = req;
    const { appID, body, query, headers } = request;
    if (appID) {
      const route = `${request.method} ${request.route?.path}`;
      const cordSource = headers["x-cord-source"] && typeof headers["x-cord-source"] === "string" ? headers["x-cord-source"] : "";
      if (cordSource === "cli") {
        const md = `*${route}* called from app: <${ADMIN_ORIGIN}/applications/${appID}|${appID}>`;
        void sendMessageToCord(md, void 0, "cli-events");
      }
      restApiCalls.inc({
        route,
        appID,
        statusCode: res.statusCode,
        cordSource
      });
      restApiCallExecTime.observe({ route, appID }, time / 1e3);
    }
    const operationID = asyncLocalStorage?.getStore()?.operationID;
    anonymousLogger().debug("Platform", {
      appID,
      headers,
      endpoint: `${req.method} ${req.url}`,
      statusCode: res.statusCode,
      duration: time,
      payload: body,
      query,
      ...operationID && { operationID }
    });
  })
);
MainRouter.post("/v1/authorize", APIAuthorizeHandler_default);
MainRouter.get("/v1/verify", VerifyAppServerAuthToken, ApplicationTokenHandler_default);
MainRouter.use("/v1/organizations", (req, _res, next) => {
  deprecated("api: /v1/organizations", req.appID);
  next();
});
MainRouter.get(
  "/v1/organizations",
  VerifyAppServerAuthToken,
  ListPlatformOrganizationsHandler_default
);
MainRouter.get(
  "/v1/organizations/:orgID",
  VerifyAppServerAuthToken,
  GetPlatformOrganizationHandler_default
);
MainRouter.post(
  "/v1/organizations",
  VerifyAppServerAuthToken,
  CreatePlatformOrganizationsHandler_default
);
MainRouter.put(
  "/v1/organizations/:orgID",
  VerifyAppServerAuthToken,
  UpdatePlatformOrganizationsHandler_default
);
MainRouter.delete(
  "/v1/organizations/:orgID",
  VerifyAppServerAuthToken,
  DeletePlatformOrganizationsHandler_default
);
MainRouter.post(
  "/v1/organizations/:orgID/members",
  VerifyAppServerAuthToken,
  UpdatePlatformOrganizationMembersHandler_default
);
MainRouter.get(
  "/v1/groups",
  VerifyAppServerAuthToken,
  ListPlatformOrganizationsHandler_default
);
MainRouter.get(
  "/v1/groups/:orgID",
  VerifyAppServerAuthToken,
  GetPlatformOrganizationHandler_default
);
MainRouter.put(
  "/v1/groups/:orgID",
  VerifyAppServerAuthToken,
  UpdatePlatformOrganizationsHandler_default
);
MainRouter.delete(
  "/v1/groups/:orgID",
  VerifyAppServerAuthToken,
  DeletePlatformOrganizationsHandler_default
);
MainRouter.get(
  "/v1/groups/:orgID/members",
  VerifyAppServerAuthToken,
  ListPlatformOrganizationMembersHandler_default
);
MainRouter.post(
  "/v1/groups/:orgID/members",
  VerifyAppServerAuthToken,
  UpdatePlatformOrganizationMembersHandler_default
);
MainRouter.get("/v1/users", VerifyAppServerAuthToken, ListPlatformUsersHandler_default);
MainRouter.get(
  "/v1/users/:userID",
  VerifyAppServerAuthToken,
  GetPlatformUserHandler_default
);
MainRouter.post(
  "/v1/users",
  VerifyAppServerAuthToken,
  CreatePlatformUserHandler_default
);
MainRouter.put(
  "/v1/users/:userID",
  VerifyAppServerAuthToken,
  UpdatePlatformUserHandler_default
);
MainRouter.put(
  "/v1/users/:userID/presence",
  VerifyAppServerAuthToken,
  UpdateUserPresenceHandler_default
);
MainRouter.get(
  "/v1/users/:userID/preferences",
  VerifyAppServerAuthToken,
  ListUserPreferencesHandler_default
);
MainRouter.put(
  "/v1/users/:userID/preferences",
  VerifyAppServerAuthToken,
  UpdateUserPreferencesHandler_default
);
MainRouter.delete(
  "/v1/users/:userID",
  VerifyAppServerAuthToken,
  DeletePlatformUserDataHandler_default
);
MainRouter.get("/v1/threads", VerifyAppServerAuthToken, ListThreadsHandler_default);
MainRouter.post("/v1/threads", VerifyAppServerAuthToken, CreateThreadHandler_default);
MainRouter.get(
  "/v1/threads/:threadID/messages/:messageID",
  VerifyAppServerAuthToken,
  GetThreadMessageHandler_default
);
MainRouter.post(
  "/v1/threads/:threadID/messages",
  VerifyAppServerAuthToken,
  CreateThreadMessageHandler_default
);
MainRouter.put(
  "/v1/threads/:threadID/messages/:messageID",
  VerifyAppServerAuthToken,
  UpdateThreadMessageHandler_default
);
MainRouter.post(
  "/v1/threads/:threadID/messages/:messageID/append",
  VerifyAppServerAuthToken,
  AppendMessageHandler_default
);
MainRouter.get(
  "/v1/threads/:threadID/messages",
  VerifyAppServerAuthToken,
  ListThreadMessagesHandler_default
);
MainRouter.delete(
  "/v1/threads/:threadID/messages/:messageID",
  VerifyAppServerAuthToken,
  DeleteThreadMessageHandler_default
);
MainRouter.get("/v1/messages", VerifyAppServerAuthToken, ListMessagesHandler_default);
MainRouter.post(
  "/v1/notifications",
  VerifyAppServerAuthToken,
  CreateNotificationHandler_default
);
MainRouter.delete(
  "/v1/notifications/:notificationID",
  VerifyAppServerAuthToken,
  DeleteNotificationHandler_default
);
MainRouter.get(
  "/v1/users/:userID/notifications",
  VerifyAppServerAuthToken,
  ListNotificationsHandler_default
);
MainRouter.get(
  "/v1/threads/:threadID",
  VerifyAppServerAuthToken,
  GetThreadHandler_default
);
MainRouter.put(
  "/v1/threads/:threadID",
  VerifyAppServerAuthToken,
  UpdateThreadHandler_default
);
MainRouter.delete(
  "/v1/threads/:threadID",
  VerifyAppServerAuthToken,
  DeleteThreadHandler_default
);
MainRouter.post(
  "/v1/files",
  VerifyAppServerAuthToken,
  uploadedFiles.single("file"),
  CreateFileHandler_default
);
MainRouter.get(
  ["/v1/applications", "/v1/projects"],
  VerifyCustomerServerAuthToken,
  ListApplicationsHandler_default
);
MainRouter.get(
  ["/v1/applications/:appID", "/v1/projects/:appID"],
  VerifyCustomerServerAuthToken,
  GetApplicationHandler_default
);
MainRouter.post(
  ["/v1/applications", "/v1/projects"],
  VerifyCustomerServerAuthToken,
  CreateApplicationHandler_default
);
MainRouter.put(
  ["/v1/applications/:appID", "/v1/projects/:appID"],
  VerifyCustomerServerAuthToken,
  UpdateApplicationHandler_default
);
MainRouter.delete(
  ["/v1/applications/:appID", "/v1/projects/:appID"],
  VerifyCustomerServerAuthToken,
  DeleteApplicationHandler_default
);
MainRouter.post(
  ["/v1/applications/:appID/webhooks", "/v1/projects/:appID/webhooks"],
  VerifyAppServerAuthToken,
  CreateWebhookHandler_default
);
MainRouter.delete(
  [
    "/v1/applications/:appID/webhooks/:webhookID",
    "/v1/projects/:appID/webhooks/:webhookID"
  ],
  VerifyAppServerAuthToken,
  DeleteWebhookHandler_default
);
MainRouter.get(
  "/v1/customer/dbdump",
  VerifyCustomerServerAuthToken,
  GetDbDumpHandler_default
);
MainRouter.get(
  `/v1/customer/copyfiles`,
  VerifyCustomerServerAuthToken,
  CopyFilesHandler_default
);
MainRouter.get(
  "/v1/client/viewer",
  RequestContextMiddleware,
  ClientGetViewerHandler_default
);
MainRouter.get(
  "/v1/client/user/:userID",
  RequestContextMiddleware,
  ClientGetUserHandler_default
);
MainRouter.get(
  "/v1/client/users",
  RequestContextMiddleware,
  ClientGetUsersHandler_default
);
MainRouter.get(
  "/v1/client/threads",
  RequestContextMiddleware,
  ClientGetThreadsHandler_default
);
MainRouter.get(
  "/v1/client/thread/:threadID",
  RequestContextMiddleware,
  ClientGetThreadHandler_default
);
MainRouter.get(
  "/v1/client/threadCounts",
  RequestContextMiddleware,
  ClientGetThreadCountsHandler_default
);
MainRouter.get(
  "/v1/client/message/:messageID",
  RequestContextMiddleware,
  ClientGetMessageHandler_default
);
MainRouter.get(
  "/v1/client/notifications",
  RequestContextMiddleware,
  ClientGetNotificationsHandler_default
);
MainRouter.get(
  "/v1/client/notificationCounts",
  RequestContextMiddleware,
  ClientGetNotificationCountsHandler_default
);
MainRouter.get(
  "/v1/client/groupMembers/:groupID",
  RequestContextMiddleware,
  ClientGetGroupMembersHandler_default
);
MainRouter.get(
  "/v1/client/presence",
  RequestContextMiddleware,
  ClientGetPresenceHandler_default
);
MainRouter.post(
  "/v1/experimental/permissions",
  VerifyAppServerAuthToken,
  ExperimentalPlatformPermissionHandlers_default.create
);
MainRouter.delete(
  "/v1/experimental/permissions/:ruleID",
  VerifyAppServerAuthToken,
  ExperimentalPlatformPermissionHandlers_default.delete
);
MainRouter.post("/v1/batch", VerifyAppServerAuthToken, PlatformBatchHandler_default);
MainRouter.post(
  "/v1/thoughtspot/application_migration",
  VerifyCustomerServerAuthToken,
  ThoughtspotApplicationMigrationHandler_default
);
MainRouter.get(
  "/v1/community/users/:userID",
  VerifyAppServerAuthToken,
  CommunityGetUserHandler_default
);
MainRouter.use("/v1", PlatformErrorHandler);
MainRouter.get("/cpu-profile", RequestContextMiddleware, writeOutCPUProfile);
MainRouter.get("/heap-snapshot", RequestContextMiddleware, takeHeapSnapshot);
MainRouter.get("/debug/redirect-uri", NotificationRedirectURIHandler);
MainRouter.post(
  "/playground-token",
  cors({
    origin: [DOCS_ORIGIN, ...TEMPORARY_V5_CORD_DOT_COM_ORIGINS, TOP_ORIGIN],
    optionsSuccessStatus: 200
  }),
  deprecatedFunction(GetDemoAppsSignedTokenHandler_default, "api: /playground-token")
);
MainRouter.post(
  "/demo-apps-token",
  cors({
    origin: [DOCS_ORIGIN, ...TEMPORARY_V5_CORD_DOT_COM_ORIGINS, TOP_ORIGIN],
    optionsSuccessStatus: 200
  }),
  GetDemoAppsSignedTokenHandler_default
);
MainRouter.post("/sample-token", GetSampleSignedTokenHandler_default);
MainRouter.post(
  "/docs-sample-token",
  cors({
    origin: [DOCS_ORIGIN, /https:\/\/pr\d+-docs\.dev\.cord\.com$/],
    optionsSuccessStatus: 200
  }),
  GetDocsSampleSignedTokenHandler_default
);
MainRouter.get(
  "/demo-token",
  cors({
    origin: [
      DOCS_ORIGIN,
      MARKETING_ORIGIN,
      ...TEMPORARY_V5_CORD_DOT_COM_ORIGINS
    ],
    optionsSuccessStatus: 200
  }),
  DemoUserHandler_default
);
MainRouter.post("/logs/auth0", Auth0LogsHandler);
if (Env_default.INCLUDE_SDK_TESTBED) {
  MainRouter.get("/sdk/test/tokens", TestbedTokensHandler);
}
MainRouter.get("/v1/cli-version", CliVersionHandler_default);
MainRouter.post("/stripe/webhook", StripeWebhookHandler_default);

// server/src/third_party_tasks/asana/api.ts
async function completeOAuthFlow2(code) {
  const params = new URLSearchParams();
  params.append("grant_type", "authorization_code");
  params.append("client_id", Env_default.ASANA_APP_CLIENT_ID);
  params.append("client_secret", Env_default.ASANA_APP_CLIENT_SECRET);
  params.append("redirect_uri", ASANA_AUTH_REDIRECT_URL);
  params.append("code", code);
  const response = await fetch("https://app.asana.com/-/oauth_token", {
    method: "post",
    headers: {
      Accept: "application/json"
    },
    body: params
  });
  const { access_token, refresh_token } = await response.json();
  const userInfo2 = await getUserInfo3(access_token, "me");
  if (userInfo2 === void 0) {
    throw new Error("Could not fetch Asana user information");
  }
  return [refresh_token, userInfo2];
}
async function getAccessToken2(refreshToken) {
  const params = new URLSearchParams();
  params.append("grant_type", "refresh_token");
  params.append("refresh_token", refreshToken);
  params.append("client_id", Env_default.ASANA_APP_CLIENT_ID);
  params.append("client_secret", Env_default.ASANA_APP_CLIENT_SECRET);
  params.append("redirect_uri", ASANA_AUTH_REDIRECT_URL);
  const response = await fetch("https://app.asana.com/-/oauth_token", {
    method: "post",
    headers: {
      Accept: "application/json"
    },
    body: params
  });
  const data = await response.json();
  return {
    success: response.status === 200,
    ...data
  };
}
async function getUserInfo3(accessToken, asanaUserGID = "me") {
  const response = await fetch(
    `https://app.asana.com/api/1.0/users/${asanaUserGID}`,
    {
      method: "get",
      headers: {
        Accept: "application/json",
        Authorization: `Bearer ${accessToken}`
      }
    }
  );
  const json = await handleResponseJSON2(response);
  return json.data;
}
async function createTask(accessToken, workspaceGID, project, title, htmlNotes, parentAsanaTaskGID, completed) {
  const params = {
    data: {
      name: title,
      html_notes: htmlNotes,
      workspace: workspaceGID,
      parent: parentAsanaTaskGID,
      projects: project ? [project] : void 0,
      completed: completed ? true : false
    }
  };
  const response = await fetch("https://app.asana.com/api/1.0/tasks", {
    method: "post",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
      Authorization: `Bearer ${accessToken}`
    },
    body: JSON.stringify(params)
  });
  const json = await handleResponseJSON2(response);
  return json.data.gid;
}
async function getTask(accessToken, taskGID) {
  const response = await fetch(
    `https://app.asana.com/api/1.0/tasks/${taskGID}`,
    {
      method: "get",
      headers: {
        Accept: "application/json",
        Authorization: `Bearer ${accessToken}`
      }
    }
  );
  const json = await handleResponseJSON2(response);
  return json.data;
}
async function setAsanaTaskAsignee(accessToken, assigneeGID, taskGID) {
  const params = {
    data: {
      assignee: assigneeGID
    }
  };
  const response = await fetch(
    `https://app.asana.com/api/1.0/tasks/${taskGID}`,
    {
      method: "put",
      headers: {
        Accept: "application/json",
        Authorization: `Bearer ${accessToken}`
      },
      body: JSON.stringify(params)
    }
  );
  return await handleResponseJSON2(response);
}
async function addAsanaTaskFollowers(accessToken, followerGIDs, taskGID) {
  const params = {
    data: {
      followers: followerGIDs
    }
  };
  const response = await fetch(
    `https://app.asana.com/api/1.0/tasks/${taskGID}/addFollowers`,
    {
      method: "post",
      headers: {
        Accept: "application/json",
        Authorization: `Bearer ${accessToken}`
      },
      body: JSON.stringify(params)
    }
  );
  return await handleResponseJSON2(response);
}
async function addCommentOnAsanaTask(accessToken, comment, taskGID, isPinned = false) {
  const params = {
    data: {
      text: comment,
      is_pinned: isPinned
    }
  };
  const response = await fetch(
    `https://app.asana.com/api/1.0/tasks/${taskGID}/stories`,
    {
      method: "post",
      headers: {
        Accept: "application/json",
        Authorization: `Bearer ${accessToken}`
      },
      body: JSON.stringify(params)
    }
  );
  return await handleResponseJSON2(response);
}
async function attachFile(accessToken, taskGID, filename, contentType, stream, filesize) {
  const formData = new FormData3();
  formData.append("file", stream, {
    contentType,
    filename,
    knownLength: filesize
  });
  const response = await fetch(
    `https://app.asana.com/api/1.0/tasks/${taskGID}/attachments`,
    {
      method: "post",
      headers: {
        Accept: "application/json",
        Authorization: `Bearer ${accessToken}`
      },
      body: formData.getBuffer()
    }
  );
  return await handleResponseJSON2(response);
}
async function setTaskClosed(accessToken, closed, taskGID) {
  const params = {
    data: {
      completed: closed
    }
  };
  const response = await fetch(
    `https://app.asana.com/api/1.0/tasks/${taskGID}`,
    {
      method: "put",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`
      },
      body: JSON.stringify(params)
    }
  );
  return await handleResponseJSON2(response);
}
async function subscribeToUpdates(logger, accessToken, taskGID) {
  let targetHost = API_SERVER_HOST;
  if (process.env.NODE_ENV === "development") {
    if (!process.env.EXTERNAL_API_HOST_FOR_DEVELOPMENT) {
      logger.error(
        "A publicly available URL is needed to set up Asana webhook. Set EXTERNAL_API_HOST_FOR_DEVELOPMENT in your .env file if you want to receive webhooks locally."
      );
      return;
    }
    targetHost = process.env.EXTERNAL_API_HOST_FOR_DEVELOPMENT;
  }
  const params = {
    data: {
      target: `https://${targetHost}${ASANA_EVENTS_PATH}`,
      resource: taskGID
    }
  };
  const response = await fetch(`https://app.asana.com/api/1.0/webhooks`, {
    method: "post",
    headers: {
      Accept: "application/json",
      "Content-Type": "application/json",
      Authorization: `Bearer ${accessToken}`
    },
    body: JSON.stringify(params)
  });
  return await handleResponseJSON2(response);
}
async function getAsanaUsers(logger, accessToken, workspace) {
  const users = [];
  let fetchUrl = `https://app.asana.com/api/1.0/users?opt_fields=gid,email&limit=100&workspace=${workspace}`;
  let maxFetchCount = 100;
  while (maxFetchCount-- > 0 && fetchUrl) {
    const response = await fetch(fetchUrl, {
      method: "get",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`
      }
    });
    const json = await handleResponseJSON2(response);
    if (json.errors || !json.data) {
      logger.error(`Could not fetch Asana users: ${json.errors}`);
      return void 0;
    }
    const newUsers = json.data;
    users.push(...newUsers);
    fetchUrl = json.next_page?.uri;
  }
  return users;
}
async function getAsanaProjects(accessToken, workspace) {
  const response = await fetch(
    `https://app.asana.com/api/1.0/projects?workspace=${workspace}`,
    {
      method: "get",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
        Authorization: `Bearer ${accessToken}`
      }
    }
  );
  const json = await handleResponseJSON2(response);
  return json.data;
}
async function handleResponseJSON2(response) {
  const textResponse = await response.text();
  if (response.status >= 400) {
    if (response.status === 401) {
      throw new Error("external_api_forbidden_response" /* EXTERNAL_API_FORBIDDEN_RESPONSE */);
    } else {
      throw new Error(textResponse);
    }
  }
  try {
    return JSON.parse(textResponse);
  } catch (e) {
    throw new Error("Could not deserialize response JSON: " + textResponse);
  }
}

// server/src/third_party_tasks/asana/actions.ts
async function getAsanaCredentials(viewer) {
  try {
    const { userID, orgID } = assertViewerHasIdentity(viewer);
    const key = cacheKey({ type: "asana_credentials", userID, orgID });
    let credentials2 = cache.get(key);
    if (credentials2 !== void 0) {
      return credentials2;
    }
    const externalData = await getExternalAuthData(viewer, "asana");
    if (externalData === null) {
      return null;
    }
    const response = await getAccessToken2(externalData.refreshToken);
    if (!response.success) {
      if (response.error === "invalid_grant") {
        cache.del(key);
        await removeExternalConnection(viewer, "asana");
      }
      throw new Error(response.error);
    }
    credentials2 = {
      accessToken: response.access_token,
      workspace: externalData.workspace
    };
    cache.set(
      key,
      credentials2,
      // subtract a small amount of time (30 seconds) to avoid the risk of the
      // action happening between when the token expires as determined by the
      // remote server versus when we receive and store it here (probably a
      // couple of seconds).
      response.expires_in - 30
    );
    return credentials2;
  } catch (e) {
    handleThirdPartyException(
      `Couldn't obtain Asana credentials`,
      e,
      "asana",
      viewer
    );
    return null;
  }
}
async function getSelectedProject(viewer) {
  const userID = assertViewerHasUser(viewer);
  const response = await UserPreferenceEntity.findOne({
    where: {
      userID,
      key: ASANA_CONNECTION_PREFERENCES
    }
  });
  return response ? response.value : void 0;
}
async function createAsanaTask(viewer, task) {
  const logger = new Logger(viewer);
  try {
    const credentials2 = await getAsanaCredentials(viewer);
    if (credentials2 === null) {
      return;
    }
    const { accessToken, workspace } = credentials2;
    const message = await MessageEntity.findByPk(task.messageID);
    if (!message) {
      throw new Error(
        `Failed to fetch message ${task.messageID} linked to task ${task.id}`
      );
    }
    const title = taskTitleFromMessageContent(message.content);
    let footerText = await getTaskFooterText(viewer, message, "asana");
    if (typeof footerText !== "string") {
      footerText = "";
    }
    const htmlNotes = messageContentToAsanaHtml(message.content, footerText);
    const project = (await getSelectedProject(viewer))?.projectID;
    const asanaTaskGID = await createTask(
      accessToken,
      workspace,
      project,
      title,
      htmlNotes,
      void 0,
      // no parent task
      task.done
    );
    if (!asanaTaskGID) {
      throw new Error(`failed to create Asana task for task ${task.id}`);
    }
    const previewData = await getAsanaTaskPreviewData(viewer, asanaTaskGID);
    await TaskThirdPartyReference.create({
      taskID: task.id,
      externalID: asanaTaskGID,
      externalConnectionType: "asana",
      previewData
    });
    await subscribeToUpdates(logger, accessToken, asanaTaskGID);
  } catch (e) {
    handleThirdPartyException(
      `Failed to create Asana task for task ${task.id}`,
      e,
      "asana",
      viewer
    );
  }
}
async function addAsanaTaskAssignees(viewer, taskID, taskAssignees) {
  try {
    const credentials2 = await getAsanaCredentials(viewer);
    if (credentials2 === null) {
      return;
    }
    const { accessToken, workspace } = credentials2;
    const [asanaUserIDs, unmatchedUsers] = await getAsanaAsigneeAndFollowers(
      viewer,
      accessToken,
      workspace,
      taskAssignees
    );
    const taskConnection = await TaskThirdPartyReference.findForTask(
      taskID,
      "asana"
    );
    if (!taskConnection) {
      throw new Error(`Failed to find taskConnection for task ${taskID}`);
    }
    const asanaTask = await getTask(accessToken, taskConnection.externalID);
    if (!asanaTask) {
      throw new Error(
        `Failed to get Asana task ${taskConnection.externalID} when updating task ${taskID}`
      );
    }
    const [assigneeGID, ...followerGIDs] = asanaUserIDs;
    const promises = [];
    if (assigneeGID) {
      promises.push(
        setAsanaTaskAsignee(
          accessToken,
          assigneeGID,
          taskConnection.externalID
        )
      );
    }
    if (followerGIDs.length > 0) {
      promises.push(
        addAsanaTaskFollowers(
          accessToken,
          followerGIDs,
          taskConnection.externalID
        )
      );
    }
    if (unmatchedUsers.length > 0) {
      const additionalText = additionalTextForTask2(unmatchedUsers);
      promises.push(
        addCommentOnAsanaTask(
          accessToken,
          additionalText,
          taskConnection.externalID,
          true
          // isPinned - let's pin this comment
        )
      );
    }
    await Promise.all(promises);
    await updateAsanaTaskPreview(viewer, taskConnection);
  } catch (e) {
    handleThirdPartyException(
      `Failed to add Asana assignees to task ${taskID}`,
      e,
      "asana",
      viewer
    );
  }
}
async function getAsanaAsigneeAndFollowers(viewer, accessToken, workspace, taskAssigneeUserIDs) {
  if (taskAssigneeUserIDs.length === 0) {
    return [[], []];
  }
  const orgID = assertViewerHasOrg(viewer);
  const userLoader = new UserLoader(viewer, () => null);
  const users = await userLoader.loadUsersInOrg(taskAssigneeUserIDs, orgID);
  const asanaUserGIDs = await getAsanaUserGIDs(
    viewer,
    accessToken,
    workspace,
    users
  );
  const foundAsanaUserIDs = asanaUserGIDs.filter(
    (gid) => gid !== void 0
  );
  const unmatchedUsers = users.filter((_user, i) => !asanaUserGIDs[i]);
  return [foundAsanaUserIDs, unmatchedUsers];
}
function additionalTextForTask2(noMatchUsers) {
  if (noMatchUsers.length === 0) {
    return "";
  }
  return [
    "This task was assigned to the following Cord users who did not have Asana connected:",
    ...noMatchUsers.map((user) => `${userDisplayName(user)} (${user.email})`)
  ].join("\n");
}
async function getAsanaUserGIDs(viewer, accessToken, workspace, users) {
  const logger = new Logger(viewer);
  const orgID = assertViewerHasOrg(viewer);
  const connections = await ThirdPartyConnectionEntity.findAll({
    where: {
      userID: users.map(({ id }) => id),
      orgID,
      type: "asana"
    }
  });
  const idToAsanaID = new Map(
    connections.map((connection) => [connection.userID, connection.externalID])
  );
  const asanaUsers = await getAsanaUsers(logger, accessToken, workspace) ?? [];
  const emailToAsanaID = new Map(
    asanaUsers.map((asanaUser) => [asanaUser.email, asanaUser.gid])
  );
  return users.map((user) => {
    return idToAsanaID.get(user.id) || (user.email ? emailToAsanaID.get(user.email) : void 0);
  });
}
async function addAsanaTaskAttachments(viewer, asanaTaskGID, files) {
  try {
    const credentials2 = await getAsanaCredentials(viewer);
    const s3BucketLoader = new S3BucketLoader(viewer);
    if (credentials2 === null) {
      return;
    }
    const { accessToken } = credentials2;
    await Promise.all(
      files.filter((file) => file.uploadStatus === "uploaded").map(async (file) => {
        const url6 = await file.getSignedDownloadURL(s3BucketLoader);
        const response = await fetch(url6);
        if (response.status === 200) {
          await attachFile(
            accessToken,
            asanaTaskGID,
            file.name,
            file.mimeType,
            response.body,
            file.size
          );
        } else {
          throw new Error(
            `failed to attach file ${file.id} to Asana task ${asanaTaskGID}`
          );
        }
      })
    );
  } catch (e) {
    handleThirdPartyException(
      `Failed to attach file to Asana task ${asanaTaskGID}`,
      e,
      "asana",
      viewer
    );
  }
}
async function updateAsanaTask(viewer, externalReference, done) {
  try {
    if (externalReference.externalConnectionType !== "asana") {
      throw new Error(
        `Expected connection type "asana", got ${externalReference.externalConnectionType}`
      );
    }
    const credentials2 = await getAsanaCredentials(viewer);
    if (credentials2 === null) {
      return;
    }
    const { accessToken } = credentials2;
    await setTaskClosed(accessToken, done, externalReference.externalID);
    await updateAsanaTaskPreview(viewer, externalReference);
  } catch (e) {
    handleThirdPartyException(
      `Failed to update task ${externalReference.taskID} on Asana`,
      e,
      "asana",
      viewer
    );
  }
}
async function createAsanaSubtasks(viewer, taskID, todos) {
  try {
    const credentials2 = await getAsanaCredentials(viewer);
    if (credentials2 === null) {
      return [];
    }
    const { accessToken, workspace } = credentials2;
    const [task, taskConnection] = await Promise.all([
      TaskEntity.findByPk(taskID),
      TaskThirdPartyReference.findForTask(taskID, "asana")
    ]);
    if (task === null) {
      throw new Error(`Failed to fetch task ${taskID}`);
    }
    if (taskConnection === null) {
      throw new Error(
        `Failed to fetch asana taskConnection for task ${taskID}`
      );
    }
    const message = await MessageEntity.findByPk(task.messageID);
    if (!message) {
      throw new Error(
        `Failed to fetch message ${task.messageID} linked to task ${task.id}`
      );
    }
    const createdTodoMap = new Map(todos.map((todo) => [todo.id, todo]));
    let footerText = await getTaskFooterText(viewer, message, "asana");
    if (typeof footerText !== "string") {
      footerText = "";
    }
    const htmlNotes = messageContentToAsanaHtml([], footerText);
    const todoNodes = todoNodesFromMessage(message.content).filter(
      (node) => createdTodoMap.has(node.todoID)
    );
    const project = (await getSelectedProject(viewer))?.projectID;
    const asanaTaskGIDs = await Promise.all(
      todoNodes.map(
        (todoNode) => createTask(
          accessToken,
          workspace,
          project,
          textFromNodeRecursive(todoNode),
          htmlNotes,
          taskConnection.externalID,
          createdTodoMap.get(todoNode.todoID)?.done
        )
      )
    );
    return await Promise.all(
      asanaTaskGIDs.map((asanaTaskGID, i) => {
        if (!asanaTaskGID) {
          throw new Error(`failed to create Asana subtask for task ${task.id}`);
        }
        return TaskThirdPartyReference.create({
          taskID: task.id,
          externalID: asanaTaskGID,
          externalConnectionType: "asana",
          taskTodoID: todoNodes[i].todoID,
          previewData: null
        });
      })
    );
  } catch (e) {
    handleThirdPartyException(
      `Failed to create subtasks on Asana for task ${taskID}`,
      e,
      "asana",
      viewer
    );
    return [];
  }
}
async function onAsanaUserChangedTaskStatus(asanaUserGID, taskGID) {
  try {
    let logger = anonymousLogger();
    const connection = await ThirdPartyConnectionEntity.findOne({
      where: {
        externalID: asanaUserGID,
        type: "asana"
      }
    });
    if (!connection?.externalAuthData) {
      logger.info(
        `Asana task's (${taskGID}) was updated, but we failed to find the extenal connection for user ${asanaUserGID}`
      );
      return;
    }
    const connectionViewer = Viewer.createLoggedInViewer(
      connection.userID,
      connection.orgID
    );
    logger = new Logger(connectionViewer);
    const taskConnectionPromise = TaskThirdPartyReference.findOne({
      where: {
        externalID: taskGID,
        externalConnectionType: "asana"
      },
      include: [
        {
          model: TaskEntity,
          required: true,
          as: "task"
        }
      ]
    });
    const [taskConnection, credentials2] = await Promise.all([
      taskConnectionPromise,
      getAsanaCredentials(connectionViewer)
    ]);
    if (!taskConnection) {
      throw new Error(`Failed to find Cord task for the Asana task ${taskGID}`);
    }
    if (!credentials2) {
      return;
    }
    const asanaTask = await getTask(credentials2.accessToken, taskGID);
    if (!asanaTask) {
      throw new Error(`Failed to fetch Asana task ${taskGID}`);
    }
    const completed = asanaTask.completed;
    if (completed !== true && completed !== false) {
      throw new Error(
        `Invalid value for asana 'completed' task field ${completed}`
      );
    }
    if (completed === taskConnection.task.done) {
      return;
    }
    await TaskEntity.update(
      {
        done: completed,
        doneStatusLastUpdatedBy: connection.userID
      },
      {
        where: {
          id: taskConnection.taskID
        }
      }
    );
    if (!taskConnection.previewData) {
      await updateAsanaTaskPreview(connectionViewer, taskConnection);
    } else {
      const newPreviewData = {
        ...taskConnection.previewData,
        done: completed
      };
      await setAsanaTaskPreview(taskConnection, newPreviewData);
    }
  } catch (e) {
    handleThirdPartyException(
      `Failed to update task from a webhook`,
      e,
      "asana"
    );
  }
}
async function updateAsanaTaskPreview(viewer, externalReference) {
  if (!externalReference.taskTodoID) {
    const taskID = externalReference.externalID;
    const previewData = await getAsanaTaskPreviewData(viewer, taskID);
    if (previewData) {
      await setAsanaTaskPreview(externalReference, previewData);
    }
  }
}
async function setAsanaTaskPreview(externalReference, previewData) {
  await externalReference.update({ previewData });
  await publishMessageUpdateForTask(externalReference);
}
async function fetchAsanaProjects(viewer) {
  try {
    const credentials2 = await getAsanaCredentials(viewer);
    if (credentials2 === null) {
      return [];
    }
    const projects = await getAsanaProjects(
      credentials2.accessToken,
      credentials2.workspace
    );
    if (!projects) {
      throw new Error(`Asana api returned undefined projects`);
    }
    return projects;
  } catch (e) {
    handleThirdPartyException(
      `Failed to fetch projects for Asana`,
      e,
      "asana",
      viewer
    );
    return [];
  }
}
async function getAsanaTaskPreviewData(viewer, asanaTaskGID) {
  try {
    const credentials2 = await getAsanaCredentials(viewer);
    if (credentials2 === null) {
      return null;
    }
    const task = await getTask(credentials2.accessToken, asanaTaskGID);
    if (!task) {
      throw new Error(`Failed to fetch Asana task ${asanaTaskGID}`);
    }
    return {
      title: task.name,
      assignee: task.assignee?.name,
      url: task.permalink_url,
      done: task.completed
    };
  } catch (e) {
    handleThirdPartyException(
      `Failed to fetch Asana task preview`,
      e,
      "asana",
      viewer
    );
    return null;
  }
}
async function onAsanaAssigneeChanged(asanaAssignerGID, taskGID, newAssigneeGID) {
  let logger = anonymousLogger();
  try {
    const taskConnection = await TaskThirdPartyReference.findOne({
      where: {
        externalID: taskGID,
        externalConnectionType: "asana"
      }
    });
    if (!taskConnection) {
      throw new Error(`Failed to find Cord task for the Asana task ${taskGID}`);
    }
    const message = await MessageEntity.findOne({
      include: [
        {
          model: TaskEntity,
          required: true,
          as: "tasks",
          where: {
            id: taskConnection.taskID
          }
        }
      ]
    });
    if (!message) {
      throw new Error(
        `Failed to find the message for the taskID ${taskConnection.taskID}`
      );
    }
    const connection = await ThirdPartyConnectionEntity.findOne({
      where: {
        externalID: asanaAssignerGID,
        type: "asana",
        orgID: message.orgID
      }
    });
    if (!connection?.externalAuthData) {
      throw new Error(
        `External connection ${connection} or external auth data ${connection?.externalAuthData} is missing`
      );
    }
    const connectionViewer = Viewer.createLoggedInViewer(
      connection.userID,
      connection.orgID
    );
    logger = new Logger(connectionViewer);
    const credentials2 = await getAsanaCredentials(connectionViewer);
    if (!credentials2) {
      return;
    }
    let newCordAssignee = void 0;
    let asanaAssigneeInfo = void 0;
    if (newAssigneeGID) {
      [newCordAssignee, asanaAssigneeInfo] = await getCordUserID(
        credentials2.accessToken,
        newAssigneeGID,
        connection.orgID
      );
    }
    if (newCordAssignee) {
      await TaskAssigneeEntity.upsert({
        taskID: taskConnection.taskID,
        userID: newCordAssignee,
        orgID: connection.orgID
      });
    }
    if (!taskConnection.previewData) {
      await updateAsanaTaskPreview(connectionViewer, taskConnection);
    } else if (!newAssigneeGID) {
      const newPreviewData = {
        ...taskConnection.previewData,
        assignee: void 0
      };
      await setAsanaTaskPreview(taskConnection, newPreviewData);
    } else if (asanaAssigneeInfo) {
      const newPreviewData = {
        ...taskConnection.previewData,
        assignee: asanaAssigneeInfo.name
      };
      await setAsanaTaskPreview(taskConnection, newPreviewData);
    } else {
      await updateAsanaTaskPreview(connectionViewer, taskConnection);
    }
  } catch (e) {
    logger.logException("Failed to update assignee from Asana webhook", e);
    return;
  }
}
async function getCordUserID(accessToken, asanaUserGID, orgID) {
  let logger = anonymousLogger();
  try {
    const connection = await ThirdPartyConnectionEntity.findOne({
      where: {
        externalID: asanaUserGID,
        orgID,
        type: "asana"
      }
    });
    if (connection) {
      return [connection.userID, void 0];
    }
    logger = new Logger(Viewer.createOrgViewer(orgID));
    const userInfo2 = await getUserInfo3(accessToken, asanaUserGID);
    if (!userInfo2?.email) {
      throw new Error(`Failed to get email for asana user ${asanaUserGID}`);
    }
    const users = await getSequelize().query(
      `
    SELECT users.* FROM users, org_members
    WHERE users.id = org_members."userID"
    AND users.email = $1
    AND org_members."orgID" = $2
    LIMIT 1;
    `,
      {
        bind: [userInfo2.email, orgID],
        type: QueryTypes27.SELECT,
        model: UserEntity
      }
    );
    const user = users.length > 0 ? users[0] : null;
    return [user?.id, userInfo2];
  } catch (e) {
    logger.logException(`Failed to convert Asana userGID to Cord userID`, e);
    return [void 0, void 0];
  }
}

// server/src/entity/message_attachment/MessageAttachmentMutator.ts
var MessageAttachmentMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.logger = new Logger(viewer);
  }
  async setMessageAttachments(message, attachments) {
    const userID = assertViewerHasUser(this.viewer);
    if (message.sourceID !== userID) {
      throw new Error("You can only attach files to your own message.");
    }
    const oldAttachments = await MessageAttachmentEntity.findAll({
      where: { messageID: message.id }
    });
    const oldAttachmentIDs = new Set(
      oldAttachments.map((attachment) => attachment.id)
    );
    const newAttachmentIDs = new Set(
      attachments.map((attachment) => attachment.id)
    );
    const attachmentsToCreate = attachments.filter(
      (attachment) => !oldAttachmentIDs.has(attachment.id)
    );
    const attachmentIDsToDelete = oldAttachments.filter((oldAttachment) => !newAttachmentIDs.has(oldAttachment.id)).map((attachment) => {
      return {
        attachmentID: attachment.id,
        // TODO(flooey): We used to delete files when their associated
        // attachments were deleted, but that makes our public APIs for
        // writing attachments annoying to use, because they look like you can
        // use the same file multiple times and it mostly works, but if you
        // delete an attachment the file isn't valid anymore and any other
        // uses of it break.  Instead, just leave the files there, and we can
        // garbage collect them later.
        fileIDs: attachment.type === "file" /* FILE */ ? [] : attachment.getFileIDs()
      };
    });
    const deleted = await Promise.all(
      attachmentIDsToDelete.map(
        (attachmentId) => this.deleteAttachment(attachmentId, message)
      )
    );
    const deletedAttachmentsCount = deleted.filter(
      (result) => result === true
    ).length;
    const fileIDs = attachmentsToCreate.map((attachment) => {
      switch (attachment.type) {
        case "file" /* FILE */:
          return attachment.data.fileID;
        case "annotation" /* ANNOTATION */:
          return attachment.data.screenshotFileID;
        case "screenshot" /* SCREENSHOT */:
          return attachment.data.screenshotFileID;
        default:
          return null;
      }
    }).filter(isDefined);
    let files = [];
    if (fileIDs.length > 0) {
      files = await this.loaders.fileLoader.loadFiles(fileIDs);
      if (files.length !== fileIDs.length) {
        throw new CordError("Not all attached files were loaded.", {
          files: JSON.stringify(files),
          fileIDs
        });
      }
      for (const file of files) {
        if (file.userID !== userID) {
          throw new Error("You can only attach your own files to a message.");
        }
      }
    }
    const createdAttachments = await Promise.all([
      ...attachmentsToCreate.map(
        (attachment) => MessageAttachmentEntity.create({
          messageID: message.id,
          id: attachment.id,
          type: attachment.type,
          data: attachment.data
        })
      )
    ]);
    await this.attachFilesToExternalTasksFromMessage(message, files);
    return [deletedAttachmentsCount, createdAttachments, files];
  }
  async deleteAttachment({ attachmentID, fileIDs }, message) {
    const deleted = await MessageAttachmentEntity.destroy({
      where: {
        messageID: message.id,
        id: attachmentID
      }
    });
    if (fileIDs.length > 0) {
      const mutator = new FileMutator(this.viewer, this.loaders);
      await Promise.all(fileIDs.map((f) => mutator.deleteFile(f)));
    }
    return deleted === 1;
  }
  async attachFilesToExternalTasksFromMessage(message, files) {
    if (files.length === 0) {
      return;
    }
    const task = await this.loaders.taskLoader.loadTaskForMessageNoOrgCheck(
      message.id
    );
    if (!task) {
      return;
    }
    return await this.attachFilesToExternalTasks(task, files);
  }
  async attachFilesToExternalTasks(task, files) {
    if (files.length === 0) {
      return;
    }
    const externalReferences = await TaskThirdPartyReference.findAllForTask(
      task.id
    );
    return await Promise.all(
      externalReferences.map((externalReference) => {
        switch (externalReference.externalConnectionType) {
          case "jira":
            return addJiraTaskAttachments(
              this.viewer,
              externalReference.externalID,
              files
            );
          case "asana":
            return addAsanaTaskAttachments(
              this.viewer,
              externalReference.externalID,
              files
            );
          case "linear":
            return addLinearTaskAttachments(
              this.viewer,
              externalReference.externalID,
              files
            );
          case "monday":
            return addMondayTaskAttachments(
              this.viewer,
              externalReference.externalID,
              files
            );
          default:
            this.logger.info(
              `attaching files to ${externalReference.externalConnectionType} tasks is not supported yet`
            );
            return null;
        }
      })
    );
  }
};

// server/src/entity/file/FileMutator.ts
var FileMutator = class {
  constructor(viewer, loaders) {
    this.viewer = viewer;
    this.loaders = loaders;
    this.logger = new Logger(viewer);
  }
  async createFileForUpload(id, name, mimeType, size, uploadStatus) {
    const { userID, platformApplicationID } = assertViewerHasPlatformUser(
      this.viewer
    );
    const application = await this.loaders.applicationLoader.load(
      platformApplicationID
    );
    const file = (await FileEntity.bulkCreate(
      [
        {
          id,
          name,
          mimeType,
          size,
          userID,
          platformApplicationID,
          uploadStatus: uploadStatus || "uploading",
          s3Bucket: application?.customS3Bucket
        }
      ],
      {
        // in case the request is retried - no need to error
        ignoreDuplicates: true
      }
    ))[0];
    setTimeout(() => {
      backgroundPromise(
        (async () => {
          try {
            const [updated] = await FileEntity.update(
              { uploadStatus: "cancelled" },
              {
                where: {
                  id,
                  userID,
                  uploadStatus: "uploading"
                }
              }
            );
            if (updated > 0) {
              const attachment = await MessageAttachmentEntity.findOne({
                where: { data: { fileID: id } }
              });
              if (!attachment) {
                return;
              }
              const message = await MessageEntity.findOne({
                where: { id: attachment.messageID }
              });
              if (!message) {
                return;
              }
              backgroundPromise(
                publishPubSubEvent(
                  "thread-message-updated",
                  { threadID: message.threadID },
                  { messageID: message.id }
                ),
                this.logger
              );
            }
          } catch (e) {
            this.logger.logException("File upload auto-cancel failed", e);
          }
        })()
      );
    }, MAX_FILE_UPLOADING_TIME_SECONDS * 1e3);
    return file;
  }
  async setFileUploadStatus(id, uploadStatus, size) {
    const userID = assertViewerHasUser(this.viewer);
    const [count, updatedEntities] = await FileEntity.update(
      size ? { uploadStatus, size } : { uploadStatus },
      { where: { id, userID }, returning: true }
    );
    const file = count > 0 ? updatedEntities[0] : null;
    if (file && uploadStatus === "uploaded") {
      const task = await this.getTaskFromFile(file);
      if (task) {
        await new MessageAttachmentMutator(
          this.viewer,
          this.loaders
        ).attachFilesToExternalTasks(task, [file]);
      }
    }
    return file;
  }
  async getTaskFromFile(file) {
    const attachment = await new MessageAttachmentLoader(
      this.viewer
    ).getAttachmentFromFileID(file.id);
    if (!attachment) {
      return null;
    }
    const message = await this.loaders.messageLoader.loadMessage(
      attachment.messageID
    );
    if (!message) {
      return null;
    }
    return await new TaskLoader(this.viewer).loadTaskForMessageNoOrgCheck(
      message.id
    );
  }
  async deleteFile(id) {
    const userID = assertViewerHasUser(this.viewer);
    const file = await new FileLoader(this.viewer).loadFile(id);
    const bucketLoader = new S3BucketLoader(this.viewer);
    const deletionURL = await file.getDeleteURL(bucketLoader);
    const headers = {
      method: "DELETE"
    };
    const deleteResponse = await fetch(deletionURL, headers);
    if (!deleteResponse.ok) {
      this.logger.error(
        `Attachment deletion failed with status ${deleteResponse.status}`,
        { id }
      );
      return false;
    }
    this.logger.info(
      "Deletion request has returned, and there is no longer a file in S3.",
      { id }
    );
    const deletedRows = await FileEntity.destroy({
      where: {
        id,
        userID
      }
    });
    return deletedRows === 1;
  }
};

// server/src/slack/message.ts
import { toHTML } from "slack-markdown";
import { JSDOM } from "jsdom";

// common/util/paste.ts
import { Text } from "slate";
import { jsx } from "slate-hyperscript";
var RICH_CONTENT_TAGS = ["BLOCKQUOTE", "PRE", "LI"];
function createSlackMentionNode(slackUserID) {
  return {
    type: "slack_mention",
    slackUserID,
    children: [{ text: slackUserID }]
  };
}
function createElement(type, children, nodeAttributes) {
  return jsx("element", { type, ...nodeAttributes }, children);
}
function isPLike(elementType) {
  return elementType === "P";
}
function isSlackMention(element) {
  return element.nodeName === "SPAN" && element.classList.contains("s-mention") && element.classList.contains("s-user");
}
function deserializeElementToMessageContent(element, excludeRichContent) {
  return deserializeElement(element, excludeRichContent, [], null);
}
var ELEMENT_NODE = 1;
var TEXT_NODE = 3;
function deserializeElement(element, excludeRichContent, parentTypes, listType) {
  const { nodeType, nodeName } = element;
  if (nodeType !== ELEMENT_NODE) {
    return nodeType === TEXT_NODE ? element.textContent : null;
  }
  parentTypes.push(nodeName);
  if (nodeName === "OL" || nodeName === "UL") {
    listType = nodeName;
  }
  const childNodes = Array.from(element.childNodes);
  const children = childNodes.map(
    (childNode) => deserializeElement(
      childNode,
      excludeRichContent,
      parentTypes,
      listType
    )
  ).flat();
  parentTypes.pop();
  if (isSlackMention(element)) {
    return createSlackMentionNode(
      trimStart((element.textContent ?? "").trim(), "@")
    );
  }
  const isParagraphElement = isPLike(nodeName) || excludeRichContent && RICH_CONTENT_TAGS.includes(nodeName);
  const inParagraphAlready = parentTypes.some(
    (x) => isPLike(x) || parentTypes.includes("LI") || excludeRichContent && RICH_CONTENT_TAGS.includes(x)
  );
  if (isParagraphElement) {
    if (!inParagraphAlready) {
      return createElement(import_types2.MessageNodeType.PARAGRAPH, children);
    } else {
      return children;
    }
  }
  switch (nodeName) {
    case "BODY":
      return jsx("fragment", {}, children);
    case "BLOCKQUOTE":
      return createElement(import_types2.MessageNodeType.QUOTE, children);
    case "PRE":
      return createElement(import_types2.MessageNodeType.CODE, children);
    case "LI":
      if (listType === "OL") {
        return createElement(
          import_types2.MessageNodeType.NUMBER_BULLET,
          [createElement(import_types2.MessageNodeType.PARAGRAPH, children)],
          {
            bulletNumber: 0,
            // This will get fixed up by withBullets
            indent: parentTypes.filter((p) => p === "OL" || p === "UL").length - 1
          }
        );
      } else {
        return createElement(
          import_types2.MessageNodeType.BULLET,
          [createElement(import_types2.MessageNodeType.PARAGRAPH, children)],
          {
            indent: parentTypes.filter((p) => p === "OL" || p === "UL").length - 1
          }
        );
      }
    case "A":
      return !element.getAttribute("href")?.startsWith("http") ? children : createLinkNode(
        element.getAttribute("href") ?? "",
        element.textContent
      );
    case "BR":
      return { text: "\n" };
    case "UL":
    case "OL":
      return children;
    case "STRONG":
      return { text: element.textContent, bold: true };
    case "EM":
    case "I":
      return { text: element.textContent, italic: true };
    case "U":
      return { text: element.textContent, underline: true };
    default:
      return children;
  }
}
function cleanPastedNodes(nodes, reduceNewlines = true) {
  const mergedNodes = mergeInlineNodesIntoParagraphs(nodes);
  const cleanNodes = [];
  for (const node of mergedNodes) {
    cleanNodes.push(...cleanTopLevelNode(node, reduceNewlines));
  }
  return cleanNodes;
}
function mergeInlineNodesIntoParagraphs(nodes) {
  const mergedNodes = [];
  let nodesToMerge = [];
  for (const node of nodes) {
    const inlineNode = !node.type || node.type === import_types2.MessageNodeType.LINK || node.type === import_types2.MessageNodeType.MENTION;
    if (inlineNode) {
      nodesToMerge.push(node);
    } else {
      if (nodesToMerge.length) {
        mergedNodes.push({
          type: import_types2.MessageNodeType.PARAGRAPH,
          children: nodesToMerge
        });
        nodesToMerge = [];
      }
      mergedNodes.push(node);
    }
  }
  if (nodesToMerge.length) {
    mergedNodes.push({
      type: import_types2.MessageNodeType.PARAGRAPH,
      children: nodesToMerge
    });
  }
  return mergedNodes;
}
function cleanTopLevelNode(node, reduceNewlines) {
  if (isMessageNodeType(node, import_types2.MessageNodeType.PARAGRAPH)) {
    const { children } = node;
    const paragraphNode = {
      type: import_types2.MessageNodeType.PARAGRAPH,
      children: []
    };
    const nodes = [paragraphNode];
    const addToParagraph = (node2) => {
      nodes[nodes.length - 1].children.push(node2);
    };
    for (const child of children) {
      if (!Text.isText(child)) {
        addToParagraph(child);
        continue;
      }
      const { text, ...otherProps } = child;
      if (text.includes("\n")) {
        let startChar = 0;
        for (let i = 0; i < text.length; i++) {
          const nextChar = text[i + 1];
          if (nextChar === "\n" || !nextChar) {
            const slice = text.slice(startChar, i + 1);
            if (slice) {
              if (!reduceNewlines || !isEmptyOrNewline(slice)) {
                paragraphNode.children.push({
                  text: slice,
                  ...otherProps
                });
              }
              startChar = i + 1;
              nodes.push({
                type: import_types2.MessageNodeType.PARAGRAPH,
                children: []
              });
            }
          }
        }
      } else if (!isNewlines(child.text)) {
        addToParagraph({ text: child.text, ...otherProps });
      }
    }
    const nodesToAdd = nodes.filter((node2) => node2.children.length);
    return nodesToAdd.length ? nodesToAdd : [];
  } else {
    const isBullet = isMessageNodeType(node, import_types2.MessageNodeType.BULLET) || isMessageNodeType(node, import_types2.MessageNodeType.NUMBER_BULLET);
    if (isBullet) {
      for (const child of node.children) {
        if ("text" in child) {
          child.text = replaceAll(child.text, "\n", "");
        }
      }
    }
  }
  return [node];
}
function isEmptyOrNewline(text) {
  return text.split("").every((char) => char === " " || char === "\n");
}
function isNewlines(text) {
  return text.split("").every((char) => char === "\n");
}

// server/src/slack/message.ts
function structuredMessageFromSlackMessage(msg, viewer) {
  const { text } = msg;
  if (typeof text === "string") {
    return structuredMessageFromSlackMrkdwn(text, viewer);
  } else {
    return Promise.resolve([]);
  }
}
async function replaceSlackMentionsWithUserMentions(viewer, messageContent) {
  const userLoader = new UserLoader(viewer, () => null);
  const replaceInNode = async (node) => {
    if (node.type === "slack_mention") {
      const user = await userLoader.loadUserForSlackUserWithinViewerOrg(
        node.slackUserID
      );
      if (user) {
        return createMentionNode(user.id, userDisplayName(user));
      } else {
        return createFormattedMessageTextNode({
          text: "unknown user",
          italic: true
        });
      }
    }
    if ("children" in node) {
      const children = node.children;
      const newChildren = await Promise.all(
        children.map((childNode) => replaceInNode(childNode))
      );
      node.children = newChildren;
    }
    return node;
  };
  const messageChildNodes = await Promise.all(
    messageContent.map((childNode) => replaceInNode(childNode))
  );
  return messageChildNodes;
}
async function structuredMessageFromSlackMrkdwn(mrkdwn, viewer) {
  const decodedMrkdwn = mrkdwn.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
  const html2 = toHTML(decodedMrkdwn);
  const dom = new JSDOM(html2);
  const slackMessageContent = deserializeElementToMessageContent(dom.window.document.body, false);
  const messageWithReplacedMentions = await replaceSlackMentionsWithUserMentions(viewer, slackMessageContent);
  const cleanNodes = cleanPastedNodes(messageWithReplacedMentions);
  return cleanNodes;
}

// server/src/admin/routes/SlackLoginHandler.ts
import * as url4 from "url";
import * as Slack3 from "@slack/web-api";
import * as jwt9 from "jsonwebtoken";
import * as cookie5 from "cookie";
var slackClient = new Slack3.WebClient();
var SLACK_LOGIN_ROUTE = "login/slack";
var ADMIN_LOGIN_SLACK_REDIRECT_URL = url4.format({
  protocol: "https",
  host: Env_default.SLACK_ADMIN_LOGIN_REDIRECT_HOST || ADMIN_SERVER_HOST,
  pathname: SLACK_LOGIN_ROUTE
});
var ADMIN_SESSION_EXPIRATION_SECONDS = 60 * 60 * 24;

// server/src/entity/slack_message/SlackMessageMutator.ts
var SlackMessageMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async unlinkSlackMessage(slackChannelID, slackMessageTimestamp) {
    const slackOrgID = assertViewerHasOrg(this.viewer);
    await SlackMessageEntity.destroy({
      where: { slackChannelID, slackMessageTimestamp, slackOrgID }
    });
  }
};

// server/src/image_processing/badge.ts
import sharp from "sharp";

// server/src/entity/image_variant/ImageVariantLoader.ts
import { QueryTypes as QueryTypes28 } from "sequelize";
var ImageVariantLoader = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async getTwoImageCompositionVariant(sourceURL, overlayURL, variantPrefix) {
    assertServiceViewer(this.viewer);
    const rows = await getSequelize().query(
      `SELECT
         iv.filename,
         iv."sourceSha384",
         EXTRACT(EPOCH FROM NOW()-src."downloadTimestamp") AS "sourceAgeSeconds",
         overlay."sha384" AS "overlaySha384",
         EXTRACT(EPOCH FROM NOW()-overlay."downloadTimestamp") AS "overlayAgeSeconds"
       FROM image_variants iv
       INNER JOIN external_assets src ON iv."sourceSha384"=src."sha384"
       INNER JOIN external_assets overlay
         ON iv."variant"=($1::text || overlay."sha384")
       WHERE src.url=$2 AND overlay.url=$3;`,
      {
        type: QueryTypes28.SELECT,
        bind: [variantPrefix, sourceURL, overlayURL]
      }
    );
    if (rows.length > 0) {
      return rows[0];
    }
    return null;
  }
  async getSingleImageVariant(sourceURL, variant) {
    assertServiceViewer(this.viewer);
    const rows = await getSequelize().query(
      `SELECT
         iv.filename,
         iv."sourceSha384",
         EXTRACT(EPOCH FROM NOW()-src."downloadTimestamp") AS "sourceAgeSeconds"
       FROM image_variants iv
       INNER JOIN external_assets src ON iv."sourceSha384"=src."sha384"
       WHERE iv.variant=$1
       AND src.url=$2;`,
      {
        type: QueryTypes28.SELECT,
        bind: [variant, sourceURL]
      }
    );
    if (rows.length > 0) {
      return rows[0];
    }
    return null;
  }
};

// server/src/entity/image_variant/ImageVariantMutator.ts
var ImageVariantMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async saveImageVariant(sourceSha384, variant, outputFilename) {
    assertServiceViewer(this.viewer);
    await getSequelize().query(
      `INSERT INTO image_variants ("sourceSha384", "variant", "filename")
       VALUES ($1,$2,$3)
       ON CONFLICT ("sourceSha384", "variant")
       DO UPDATE SET "filename"=EXCLUDED."filename", "timestamp"=DEFAULT;`,
      { bind: [sourceSha384, variant, outputFilename] }
    );
  }
};

// server/src/entity/extrernal_asset/ExternalAssetMutator.ts
var ExternalAssetMutator = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  async update(url6, sha3842) {
    assertServiceViewer(this.viewer);
    await getSequelize().query(
      `INSERT INTO external_assets ("url", "sha384") VALUES ($1,$2)
       ON CONFLICT ("url") DO UPDATE
       SET "sha384"=EXCLUDED."sha384", "downloadTimestamp"=DEFAULT;`,
      { bind: [url6, sha3842] }
    );
  }
};

// server/src/image_processing/util.ts
import * as crypto8 from "crypto";
function downloadURL(url6) {
  return safeFetch(url6).then((response) => response.blob()).then((blob) => blob.arrayBuffer()).then((arrayBuffer) => Buffer.from(arrayBuffer));
}
var sha384 = (buffer) => crypto8.createHash("sha384").update(buffer).digest("hex");
async function uploadImageToS3(outputFilename, outputImageBuffer, outputMimeType, publicS3Bucket2) {
  const uploadResponse = await fetch(
    getSignedUploadURL(
      outputFilename,
      outputImageBuffer.byteLength,
      outputMimeType,
      publicS3Bucket2
    ),
    {
      method: "PUT",
      body: outputImageBuffer,
      headers: {
        "Content-Length": `${outputImageBuffer.byteLength}`,
        "Content-Type": outputMimeType
      }
    }
  );
  if (uploadResponse.status !== 200) {
    throw new Error(`S3 upload failed: ${uploadResponse.statusText}`);
  }
}

// server/src/image_processing/badge.ts
async function getBadgedImageURL(sourceURL, badgeURL, options = {}, maxAgeSeconds = 48 * 3600) {
  const size = options.size || 112;
  const variantPrefix = `badge_${size}_br:`;
  const serviceViewer = Viewer.createServiceViewer();
  const logger = new Logger(serviceViewer);
  const imageVariantLoader = new ImageVariantLoader(serviceViewer);
  const savedVariant = await imageVariantLoader.getTwoImageCompositionVariant(
    sourceURL,
    badgeURL,
    variantPrefix
  );
  if (savedVariant && savedVariant.sourceAgeSeconds < maxAgeSeconds && savedVariant.overlayAgeSeconds < maxAgeSeconds) {
    return getPublicBucketDownloadURL(savedVariant.filename);
  }
  const [sourceDownload, badgeDownload] = await Promise.all([
    downloadURL(sourceURL),
    downloadURL(badgeURL)
  ]);
  const sourceSha384 = sha384(sourceDownload);
  const badgeSha384 = sha384(badgeDownload);
  const externalAssetMutator = new ExternalAssetMutator(serviceViewer);
  await Promise.all([
    externalAssetMutator.update(sourceURL, sourceSha384).catch(logger.exceptionLogger("update source image asset")),
    externalAssetMutator.update(badgeURL, badgeSha384).catch(logger.exceptionLogger("update badge image asset"))
  ]);
  if (savedVariant && savedVariant.sourceSha384 === sourceSha384 && savedVariant.overlaySha384 === badgeSha384) {
    return getPublicBucketDownloadURL(savedVariant.filename);
  }
  const sourceImage = sharp(sourceDownload).pipelineColourspace("rgb16").resize(size, size, { fit: "cover" }).rotate();
  const badgeImage = sharp(badgeDownload).pipelineColourspace("rgb16");
  const metadata = await badgeImage.metadata();
  const badgeInputAspectRatio = metadata.width && metadata.height ? metadata.width / metadata.height : 1;
  const scaledBadgeWidth = Math.round(size * 0.4 * badgeInputAspectRatio);
  const scaledBadgeHeight = Math.round(size * 0.4 / badgeInputAspectRatio);
  const scaledBadge = badgeImage.resize(scaledBadgeWidth, scaledBadgeHeight);
  const outputImageBuffer = await sourceImage.composite([
    {
      input: await scaledBadge.png().toBuffer(),
      gravity: "southeast"
    }
  ]).jpeg({ quality: 90 }).toBuffer();
  const outputSha384 = sha384(outputImageBuffer);
  const outputFilename = `${outputSha384}.jpg`;
  await uploadImageToS3(
    outputFilename,
    outputImageBuffer,
    "image/jpeg",
    publicS3Bucket
  );
  const variant = `${variantPrefix}${badgeSha384}`;
  const imageVariantMutator = new ImageVariantMutator(serviceViewer);
  await imageVariantMutator.saveImageVariant(sourceSha384, variant, outputFilename).catch(logger.exceptionLogger("update image_variants table"));
  return getPublicBucketDownloadURL(outputFilename);
}

// server/src/image_processing/resizeOnly.ts
import sharp2 from "sharp";
async function getResizedImageURL(sourceURL, options = {}, maxAgeSeconds = 48 * 3600) {
  const size = options.size || 72;
  const variant = `source_resized_${size}`;
  const serviceViewer = Viewer.createServiceViewer();
  const logger = new Logger(serviceViewer);
  const imageVariantLoader = new ImageVariantLoader(serviceViewer);
  const savedVariant = await imageVariantLoader.getSingleImageVariant(
    sourceURL,
    variant
  );
  if (savedVariant && savedVariant.sourceAgeSeconds < maxAgeSeconds) {
    return getPublicBucketDownloadURL(savedVariant.filename);
  }
  const sourceDownload = await downloadURL(sourceURL);
  const sourceSha384 = sha384(sourceDownload);
  const externalAssetMutator = new ExternalAssetMutator(serviceViewer);
  await externalAssetMutator.update(sourceURL, sourceSha384).catch(logger.exceptionLogger("update source image asset"));
  if (savedVariant && savedVariant.sourceSha384 === sourceSha384) {
    return getPublicBucketDownloadURL(savedVariant.filename);
  }
  const outputImageBuffer = await sharp2(sourceDownload).pipelineColourspace("rgb16").resize(size, size, { fit: "cover" }).rotate().jpeg({ quality: 90 }).toBuffer();
  const outputSha384 = sha384(outputImageBuffer);
  const outputFilename = `${outputSha384}.jpg`;
  await uploadImageToS3(
    outputFilename,
    outputImageBuffer,
    "image/jpeg",
    publicS3Bucket
  );
  const imageVariantMutator = new ImageVariantMutator(serviceViewer);
  await imageVariantMutator.saveImageVariant(sourceSha384, variant, outputFilename).catch(logger.exceptionLogger("update image_variants table"));
  return getPublicBucketDownloadURL(outputFilename);
}

// server/src/slack/util.ts
var addMessageToCorrectCordThreadCounter = Counter2({
  name: "AddMessageToCorrectCordThread",
  help: "Slack messages added to a cord thread",
  labelNames: ["channelType", "isReply", "hasAttachments"]
});
async function findSlackUserID(context, userID) {
  const originalOrLinkedUser = await context.loaders.userLoader.loadSlackUserForUserOrgScoped(
    context,
    userID
  );
  if (originalOrLinkedUser) {
    return originalOrLinkedUser.externalID;
  }
  const orgID = context.session.viewer.orgID;
  if (!orgID) {
    return null;
  }
  const org = await context.loaders.orgLoader.loadOrg(orgID);
  const user = await context.loaders.userLoader.loadUserInAnyViewerOrg(userID);
  if (!org || !user) {
    return null;
  }
  return (await findSlackUserEmailMatch(context, org, user))?.externalID ?? null;
}
async function findSlackBotCredentials(context) {
  const { orgID } = context.session.viewer;
  if (!orgID) {
    return null;
  }
  const org = await context.loaders.orgLoader.loadOrg(orgID);
  if (!org) {
    throw new Error("Could not find org with ID " + orgID);
  }
  return await org.getSlackBotCredentials();
}
async function sendSlackNotification({
  context,
  senderUserID,
  senderOrgID,
  slackBotCredentials,
  targetSlackUserID,
  notificationTextBlocks,
  messageBlocks,
  messageID
}) {
  const { username, iconURL } = await getUserAndAttributionForUser(
    context,
    senderUserID,
    senderOrgID
  );
  const notificationText = notificationTextBlocks.filter((text) => !!text).join(" ");
  const result = await sendPrivateMessage(
    slackBotCredentials.bot_access_token,
    targetSlackUserID,
    notificationText,
    messageBlocks,
    username,
    iconURL
  );
  if (!result) {
    return false;
  }
  const success = await SlackMessageEntity.create({
    slackOrgID: slackBotCredentials.org.id,
    slackChannelID: result.channelID,
    slackMessageTimestamp: result.timestamp,
    messageID,
    sharerOrgID: senderOrgID,
    sharerUserID: senderUserID
  });
  if (!success) {
    context.logger.warn("Failed call to SlackMessageEntity.create", {
      messageID,
      orgID: senderOrgID,
      userID: senderUserID,
      slackChannelId: result.channelID,
      slackTimestamp: result.timestamp
    });
  }
  return true;
}
async function sendSlackMentionNotification({
  actionText,
  allImageURLs,
  context,
  messageContent,
  messageID,
  pageName,
  providerName,
  senderName,
  senderOrgID,
  senderUserID,
  targetUserID,
  // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
  url: url6,
  annotationsHighlightedText
}) {
  const [senderSlackUserID, targetSlackUserID] = await Promise.all([
    findSlackUserID(context, senderUserID),
    findSlackUserID(context, targetUserID)
  ]);
  if (!targetSlackUserID) {
    return false;
  }
  const slackBotCredentials = await findSlackBotCredentials(context);
  if (!slackBotCredentials) {
    return false;
  }
  const messageAsMrkdwn = await slackMrkdwnFromMessageContent(
    messageContent,
    (userID) => findSlackUserID(context, userID)
  );
  const messageBlocks = [];
  const userName = senderSlackUserID ? `<@${senderSlackUserID}>` : senderName;
  const headerPrefix = `${userName} ${actionText}`;
  const pageNameTextWithURL = pageName ? url6 ? `on <${url6}|${mrkdwnEscapeText(pageName)}>` : `on ${mrkdwnEscapeText(pageName)}` : url6 ? `on <${url6}>` : "";
  const pageNameText = pageName ? `on ${pageName}` : "";
  const providerText = providerName ? `in ${providerName}:` : "";
  const messageHeaderText = [
    headerPrefix,
    // [name] mentioned you
    pageNameTextWithURL,
    // on [channel name](url)
    providerText
    // in [tool]
  ].filter((text) => !!text).join(" ");
  messageBlocks.push({
    type: "section",
    text: { type: "mrkdwn", text: messageHeaderText }
  });
  messageBlocks.push({
    type: "section",
    text: {
      type: "mrkdwn",
      text: "> " + messageAsMrkdwn.replace(/\n/g, "\n> ")
    }
  });
  for (const highlightedText of annotationsHighlightedText) {
    messageBlocks.push({
      type: "context",
      elements: [
        {
          type: "plain_text",
          text: `\u{1F4CC} "${highlightedText}"`
        }
      ]
    });
  }
  for (const allImageURL of allImageURLs) {
    messageBlocks.push({
      type: "image",
      image_url: allImageURL,
      alt_text: "Image attached to the message"
    });
  }
  const notificationTextBlocks = [
    headerPrefix,
    // [name] mentioned you
    pageNameText,
    // on [channel name]
    providerText,
    // in [tool]:
    `${messageAsMrkdwn}`
    // [message text]
  ];
  return await sendSlackNotification({
    context,
    senderUserID,
    senderOrgID,
    slackBotCredentials,
    targetSlackUserID,
    notificationTextBlocks,
    messageBlocks,
    messageID
  });
}
async function sendSlackThreadActionNotification({
  context,
  actionText,
  messageID,
  pageName,
  providerName,
  senderName,
  senderOrgID,
  senderUserID,
  targetUserID,
  // eslint-disable-next-line @typescript-eslint/no-shadow -- Disabling for pre-existing problems. Please do not copy this comment, and consider fixing this one!
  url: url6,
  ...rest
}) {
  const _ = rest;
  const [senderSlackUserID, targetSlackUserID] = await Promise.all([
    findSlackUserID(context, senderUserID),
    findSlackUserID(context, targetUserID)
  ]);
  if (!targetSlackUserID) {
    return false;
  }
  const slackBotCredentials = await findSlackBotCredentials(context);
  if (!slackBotCredentials) {
    return false;
  }
  const messageBlocks = [];
  const userName = senderSlackUserID ? `<@${senderSlackUserID}>` : senderName;
  const headerPrefix = `${userName} ${actionText}`;
  const threadNameWithURL = pageName ? url6 ? `<${url6}|${mrkdwnEscapeText(pageName)}>` : `${mrkdwnEscapeText(pageName)}` : url6 ? ` <${url6}>` : "";
  const pageNameText = pageName ? `${pageName}` : "";
  const providerText = providerName ? `in ${providerName}:` : "";
  const messageHeaderText = [
    headerPrefix,
    // [name] resolved thread
    threadNameWithURL,
    // [thread name](url)
    providerText
    // in [tool]
  ].filter((text) => !!text).join(" ");
  messageBlocks.push({
    type: "section",
    text: { type: "mrkdwn", text: messageHeaderText }
  });
  const notificationTextBlocks = [
    headerPrefix,
    // [name] resolved thread
    pageNameText,
    // [threadName]
    providerText
    // in [tool]:
  ];
  return await sendSlackNotification({
    context,
    senderUserID,
    senderOrgID,
    slackBotCredentials,
    targetSlackUserID,
    notificationTextBlocks,
    messageBlocks,
    messageID
  });
}
async function updateOrCreateSlackUserProfile(org, slackUser) {
  const userMutator = new UserMutator(Viewer.createServiceViewer(), null);
  let profilePictureURL = null;
  for (const key of [
    "image_192",
    // best compromise for looking good on retina screens but not being too large
    "image_72",
    "image_512",
    "image_1024",
    "image_original",
    "image_48",
    "image_32",
    "image_24"
  ]) {
    const value = slackUser.profile[key];
    if (value) {
      profilePictureURL = value;
      break;
    }
  }
  const [user, updated] = await getSequelize().transaction(async (tx) => {
    return await userMutator.updateOrCreateExternalUserInSlackOrg(
      {
        name: slackUser.real_name,
        screenName: slackUser.profile.display_name,
        email: slackUser.profile.email,
        profilePictureURL,
        externalProvider: "slack" /* SLACK */,
        externalID: slackUser.id
      },
      org.id,
      slackUser.deleted,
      // slack user.deleted - to infer what state should be if it's not set explicitly in orgMemberState
      tx
    );
  });
  if (user && updated) {
    backgroundPromise(
      publishUserIdentityUpdate({
        userID: user.id,
        platformApplicationID: "extension"
      })
    );
  }
  return user;
}
async function sendMessageToCord(text, slackChannelID, clackChannel) {
  if (process.env.IS_TEST) {
    return;
  }
  if (!slackChannelID && !clackChannel) {
    throw new Error(
      "Asked to send a message but gave no destinations, that probably is a bug"
    );
  }
  if (slackChannelID) {
    await sendChannelMessage({
      slackBotCredentials: { bot_access_token: Env_default.SLACK_INTERNAL_BOT_TOKEN },
      channelID: slackChannelID,
      text
    });
  }
  const clackBaseURL = Env_default.CLACK_SERVER_HOST;
  if (clackChannel && clackBaseURL) {
    const messageContent = await structuredMessageFromSlackMessage(
      { text },
      Viewer.createOrgViewer(RADICAL_ORG_ID)
    );
    await createThreadMessage({
      platformApplicationID: CLACK_APPLICATION_ID,
      id: uuid24(),
      threadID: uuid24(),
      internalMessageID: uuid24(),
      authorID: "ernest",
      content: forceExternalizeContent(messageContent),
      createThread: {
        groupID: "clack_all",
        organizationID: "clack_all",
        location: { channel: clackChannel },
        url: `https://${clackBaseURL}/channel/${clackChannel}`,
        name: `#${clackChannel} - Clack`
      },
      skipLinkPreviews: true
    });
  }
}
async function sendReplyHelpMessage(accessToken, recipientUserID) {
  const text = `\u{1F4A1} *Tip*: Click "Reply in thread" to respond to Cord messages using Slack.
  Your response will appear on the same page as the Cord conversation.`;
  return await sendHelpMessage(accessToken, recipientUserID, text);
}
async function sendWelcomeHelpMessage(accessToken, recipientUserID, slackWorkspaceDomain, onlyPostIfConversationEmpty = false) {
  const text = `Hi <@${recipientUserID}>, you'll be notified here when someone mentions you using Cord.

That way, you can chat, annotate, attach files, and create tasks with your team in any software.

<${APP_ORIGIN}/${slackWorkspaceDomain}|Start collaborating anywhere.>`;
  return await sendHelpMessage(
    accessToken,
    recipientUserID,
    text,
    onlyPostIfConversationEmpty
  );
}
async function addMessageToSelectedSlackChannel(context, slackBotCredentials, channelID, originalSharerUser, message, thread, mirrorType, originalMessageThreadTS) {
  const viewer = context.session.viewer;
  const blocks = [];
  let org = null;
  if (mirrorType === "support" && !originalMessageThreadTS) {
    org = await context.loaders.orgLoader.loadOrg(message.orgID);
  }
  const sharerSlackUser = await loadLinkedSlackUserOrgScoped(
    originalSharerUser,
    context,
    message.orgID
  );
  const sharerIsAuthor = message.sourceID === sharerSlackUser?.id || message.sourceID === originalSharerUser.id;
  const isScrapedSlackMessage = !!message.importedSlackMessageType;
  const {
    originalUser: authorOriginalUser,
    slackLinkedUser: authorSlackLinkedUser,
    username,
    iconURL
  } = await getUserAndAttributionForUser(
    context,
    message.sourceID,
    message.orgID,
    isScrapedSlackMessage,
    mirrorType
  );
  if (!authorOriginalUser) {
    return false;
  }
  const authorOriginalProfileDetailsForDisplay = await detailsForDisplay(
    authorOriginalUser,
    context
  );
  const findSlackUserIDHelper = mirrorType === "support" ? async () => null : (userID) => findSlackUserID(context, userID);
  const content = await slackMrkdwnFromMessageContent(
    message.content,
    findSlackUserIDHelper
  );
  const addQueryParamsToSharedToSlack = message.url !== null && await getFeatureFlagValue(
    "query_param_deep_links_in_share_to_slack" /* QUERY_PARAM_DEEP_LINKS_IN_SHARE_TO_SLACK */,
    flagsUserFromContext(context)
  );
  let messageUrl;
  if (message.url !== null && addQueryParamsToSharedToSlack) {
    messageUrl = injectDeeplinkQueryParamsV1(
      context.logger,
      message.url,
      thread.id,
      message.id
    );
  } else {
    messageUrl = message.url;
  }
  if (messageUrl !== null) {
    const { userID: sharerUserID, orgID: sharerOrgID } = assertViewerHasIdentity(context.session.viewer);
    messageUrl = await generateOutboundNotificationLoggingURL({
      messageID: message.id,
      url: messageUrl,
      targetOrgID: message.orgID,
      targetUserID: null,
      type: "sharedToSlackChannel",
      platformApplicationID: context.session.viewer.platformApplicationID,
      metadata: {
        type: "sharedToSlackChannel",
        targetSlackChannelID: channelID
      },
      sharerUserID,
      sharerOrgID
    });
  }
  let text = "";
  const authorName = (
    // A support-mirrored message goes to another Slack workspace so not helpful
    // to do a profile mention
    mirrorType === "support" ? authorOriginalProfileDetailsForDisplay.displayName : await userMention(authorSlackLinkedUser ?? authorOriginalUser, context)
  );
  if (message.type === "user_message") {
    if (originalMessageThreadTS) {
      text = `${authorName} replied: `;
    } else {
      const mrkdownLink = messageUrl === null ? thread.name : `<${messageUrl}${thread.name ? `|${mrkdwnEscapeText(thread.name)}` : ""}>`;
      if (mirrorType === "support") {
        text = `${(await detailsForDisplay(originalSharerUser, context)).displayName} from ${org?.name} (orgID: ${org?.externalID}) opened a support request in a thread${mrkdownLink ? " in " + mrkdownLink : ""}`;
      } else {
        text = `${await userMention(
          sharerSlackUser ?? originalSharerUser,
          context
        )} shared ${sharerIsAuthor ? "their message" : `this message from ${authorName}`}${mrkdownLink ? " in " + mrkdownLink : ""}`;
      }
    }
    blocks.push({ type: "section", text: { type: "mrkdwn", text } });
  }
  blocks.push({
    type: "section",
    text: { type: "mrkdwn", text: "> " + content.replace(/\n/g, "\n> ") }
  });
  const messageAttachmentLoader = new MessageAttachmentLoader(viewer);
  const fileLoader = new FileLoader(viewer);
  const attachedFiles = await messageAttachmentLoader.loadAttachmentsForMessage(message.id).then((attachments) => {
    const fileIDs = [];
    for (const attachment of attachments) {
      if (!("type" in attachment)) {
        break;
      }
      switch (attachment.type) {
        case "file" /* FILE */: {
          const { fileID } = attachment.data;
          fileIDs.push(fileID);
          break;
        }
        case "annotation" /* ANNOTATION */: {
          const { screenshotFileID, blurredScreenshotFileID } = attachment.data;
          if (blurredScreenshotFileID) {
            fileIDs.push(blurredScreenshotFileID);
          } else if (screenshotFileID) {
            fileIDs.push(screenshotFileID);
          }
          break;
        }
      }
    }
    return fileLoader.loadFiles(fileIDs);
  });
  for (const fileEntity of attachedFiles) {
    if (fileEntity.uploadStatus === "uploaded" && isInlineDisplayableImage(fileEntity.mimeType)) {
      blocks.push({
        type: "image",
        image_url: fileEntity.getPermanentDownloadURL(),
        alt_text: "attached image"
      });
    }
  }
  if (mirrorType === "support" && !originalMessageThreadTS) {
    blocks.push(
      {
        type: "divider"
      },
      supportStatusButton("close", thread.id)
    );
  }
  const result = await sendChannelMessage({
    slackBotCredentials,
    channelID,
    text,
    blocks,
    threadTS: originalMessageThreadTS,
    username,
    iconURL
  });
  if (!result) {
    return false;
  }
  const success = await SlackMessageEntity.create({
    slackOrgID: slackBotCredentials.org.id,
    slackChannelID: result.channelID,
    slackMessageTimestamp: result.timestamp,
    messageID: message.id,
    sharerOrgID: message.orgID,
    sharerUserID: originalSharerUser.id
  });
  if (!success) {
    context.logger.warn("Failed call to SlackMessageEntity.create", {
      messageID: message.id,
      sharerOrgID: message.orgID,
      sharerUserID: originalSharerUser.id,
      slackChannelID: result.channelID,
      slackMessageTimestamp: result.timestamp
    });
  }
  return result;
}
function addThreadToSelectedSlackChannel(context, slackBotCredentials, channelID, sharerUser, threadID, mirrorType) {
  return withSlackMirroredThreadLock(
    threadID,
    mirrorType
  )(async () => {
    const thread = await context.loaders.threadLoader.loadThread(threadID);
    if (mirrorType === "internal" && await context.loaders.slackMirroredThreadLoader.threadIsMirrored(
      threadID
    )) {
      throw new ApiCallerError("thread_already_shared");
    } else if (mirrorType === "support" && await SlackMirroredSupportThreadEntity.findByPk(threadID)) {
      return false;
    }
    if (!thread) {
      context.logger.warn("Failed to load thread", {
        threadID,
        slackChannelID: channelID,
        sharerUserID: sharerUser.id
      });
      return false;
    }
    const messagesInThread = await context.loaders.messageLoader.loadMessages({
      threadID,
      ignoreDeleted: true
    });
    if (messagesInThread.length === 0) {
      context.logger.warn("Failed to load any messages in thread", {
        threadID,
        slackChannelID: channelID,
        sharerUserID: sharerUser.id
      });
      return false;
    }
    const [firstThreadMessage, ...inThreadMessages] = messagesInThread;
    const originalSlackMessage = await addMessageToSelectedSlackChannel(
      context,
      slackBotCredentials,
      channelID,
      sharerUser,
      firstThreadMessage,
      thread,
      mirrorType
    );
    if (!originalSlackMessage) {
      context.logger.error(
        "Failed to call addMessageToSelectedSlackChannel for first message in thread",
        {
          threadID,
          messageID: firstThreadMessage.id,
          slackChannelID: channelID,
          sharerUserID: sharerUser.id,
          orgID: firstThreadMessage.orgID
        }
      );
      return false;
    }
    for (const message of inThreadMessages) {
      const sentMessage = await addMessageToSelectedSlackChannel(
        context,
        slackBotCredentials,
        channelID,
        sharerUser,
        message,
        thread,
        mirrorType,
        originalSlackMessage.timestamp
      );
      if (!sentMessage) {
        context.logger.error(
          "Failed call to addMessageToSelectedSlackChannel for a message in thread",
          {
            threadID,
            messageID: message.id,
            slackChannelID: channelID,
            sharerUserID: sharerUser.id,
            orgID: message.orgID
          }
        );
      }
    }
    if (mirrorType === "internal") {
      await SlackMirroredThreadEntity.create({
        threadID,
        threadOrgID: thread.orgID,
        slackOrgID: slackBotCredentials.org.id,
        slackChannelID: originalSlackMessage.channelID,
        slackMessageTimestamp: originalSlackMessage.timestamp
      });
    } else if (mirrorType === "support") {
      await getSequelize().transaction(async (transaction) => {
        await SlackMirroredSupportThreadEntity.create(
          {
            threadID,
            threadOrgID: thread.orgID,
            slackOrgID: slackBotCredentials.org.id,
            slackChannelID: originalSlackMessage.channelID,
            slackMessageTimestamp: originalSlackMessage.timestamp
          },
          { transaction }
        );
        const threadMutator = new ThreadMutator(
          context.session.viewer,
          context.loaders
        );
        await threadMutator.setThreadSupportStatus(
          threadID,
          "open",
          transaction
        );
      });
    }
    await publishPubSubEvent(
      "thread-share-to-slack",
      { threadID },
      {
        info: await context.loaders.threadLoader.loadSlackMirroredThreadInfoNoOrgCheck(
          threadID
        )
      }
    );
    return true;
  });
}
async function addMessageToCorrectCordThread(logger, accessToken, event, viewerFromSlack) {
  const { channel, ts, thread_ts, text, files } = event;
  const { userID: userIDFromSlack } = assertViewerHasIdentity(viewerFromSlack);
  const slackMirroredThreadLoader = new SlackMirroredThreadLoader(
    viewerFromSlack
  );
  const slackMirroredThread = await slackMirroredThreadLoader.loadFromSlackID(
    channel,
    thread_ts
  );
  const orgID = assertViewerHasOrg(viewerFromSlack);
  const slackMirroredSupportThread = await SlackMirroredSupportThreadEntity.findOne({
    where: {
      slackChannelID: channel,
      slackMessageTimestamp: thread_ts,
      [Op25.or]: { slackOrgID: orgID, threadOrgID: orgID }
    }
  });
  let threadID;
  let threadViewer;
  let context;
  let url6 = null;
  if (slackMirroredThread) {
    threadID = slackMirroredThread.threadID;
    threadViewer = Viewer.createLoggedInViewer(
      userIDFromSlack,
      slackMirroredThread.threadOrgID
    );
    context = await contextWithSession(
      { viewer: threadViewer },
      getSequelize(),
      null,
      null
    );
  } else if (slackMirroredSupportThread) {
    threadID = slackMirroredSupportThread.threadID;
    const application2 = await ApplicationEntity.findOne({
      where: {
        supportOrgID: slackMirroredSupportThread.slackOrgID,
        supportSlackChannelID: slackMirroredSupportThread.slackChannelID
      }
    });
    if (!application2) {
      logger.debug(
        "No application found with mirrored support thread details."
      );
      return;
    }
    if (!application2.supportBotID) {
      logger.debug(
        "Application matched with mirrored support thread details does not contain a support bot ID."
      );
      return;
    }
    const [user, org] = await Promise.all([
      UserEntity.findByPk(application2.supportBotID),
      OrgEntity.findOne({
        where: { id: slackMirroredSupportThread.threadOrgID }
      })
    ]);
    if (!user || !org) {
      logger.error(
        "Could not match the relevant user and organization for the support bot."
      );
      return;
    }
    threadViewer = await Viewer.createLoggedInPlatformViewer({
      user,
      org
    });
    context = await contextWithSession(
      { viewer: threadViewer },
      getSequelize(),
      null,
      null
    );
  } else {
    const slackMessageLoader = new SlackMessageLoader(viewerFromSlack);
    const slackMessage = await slackMessageLoader.loadSlackMessage(
      channel,
      thread_ts
    );
    if (slackMessage === null) {
      return;
    }
    threadViewer = Viewer.createLoggedInViewer(
      userIDFromSlack,
      slackMessage.sharerOrgID
    );
    context = await contextWithSession(
      { viewer: threadViewer },
      getSequelize(),
      null,
      null
    );
    const originalMessage = await context.loaders.messageLoader.loadMessage(
      slackMessage.messageID
    );
    if (originalMessage === null) {
      return;
    }
    threadID = originalMessage.threadID;
    url6 = originalMessage.url;
  }
  logger = logger.childLogger(threadViewer);
  addMessageToCorrectCordThreadCounter.inc({
    channelType: event.channel_type,
    isReply: event.thread_ts ? "true" : "false",
    hasAttachments: files ? files.length : "false"
  });
  const structuredMessage = await structuredMessageFromSlackMessage(
    { text },
    viewerFromSlack
  );
  const giphyFileID = await uploadGiphy(logger, event, viewerFromSlack);
  const timestamp = new Date(Number(ts) * 1e3);
  const messageMutator = new MessageMutator(threadViewer, context.loaders);
  const thread = await ThreadEntity.findByPk(threadID);
  if (!thread) {
    logger.debug("No thread found for this slack message.", {
      event
    });
    return;
  }
  const message = await messageMutator.createMessage({
    content: giphyFileID ? [] : structuredMessage,
    thread,
    id: uuid24(),
    url: url6,
    timestamp,
    importedSlackChannelID: channel,
    importedSlackMessageTS: ts,
    importedSlackMessageType: slackMirroredSupportThread ? "supportBotReply" : "reply",
    importedSlackMessageThreadTS: thread_ts || null
  });
  let fileAttachments = [];
  if (files && files.length) {
    fileAttachments = await uploadMessageAttachments(
      logger,
      accessToken,
      threadViewer,
      files
    );
  }
  if (giphyFileID) {
    fileAttachments.push({
      id: uuid24(),
      fileID: giphyFileID
    });
  }
  const application = await ApplicationEntity.findByPk(
    thread.platformApplicationID
  );
  if (!application) {
    throw new Error(`Could not find application for thread ${thread.id}`);
  }
  const page = await PageEntity.findOne({
    where: {
      contextHash: thread.pageContextHash
    }
  });
  if (!page) {
    throw new Error(
      `Could not find page for message ${message.id} and thread ${thread.id}`
    );
  }
  const flagsUser = {
    userID: threadViewer.userID || "",
    orgID: threadViewer.orgID,
    platformApplicationID: application?.id || "",
    version: context.clientVersion,
    customerID: application?.customerID || ""
  };
  await executeNewMessageCreationTasks({
    context,
    flagsUser,
    application,
    page,
    thread,
    message,
    fileAttachments,
    annotationAttachments: [],
    isFirstMessage: false,
    task: null,
    screenshotAttachment: null,
    // We only want to forward notifications to thread participants
    // when the reply is coming from a support bot
    sendNotifications: !!slackMirroredSupportThread,
    subscribeToThread: false
  });
}
async function userMention(user, context) {
  const { displayName } = await detailsForDisplay(user, context);
  return user.externalProvider === "slack" /* SLACK */ && user.externalID ? `<https://app.slack.com/team/${user.externalID}|${displayName}>` : displayName;
}
async function uploadMessageAttachments(logger, accessToken, viewer, files) {
  let fileAttachments = [];
  logger.debug(`uploadMessageAttachments`, { files });
  if (Array.isArray(files)) {
    fileAttachments = files.map(({ name, mimetype, size, url_private }) => ({
      id: uuid24(),
      name,
      mimetype,
      size,
      slackURL: url_private
    })).filter(
      (x) => typeof x.name === "string" && typeof x.mimetype === "string" && typeof x.size === "number" && validateFileForUpload("attachment", {
        name: x.name,
        mimeType: x.mimetype,
        size: x.size
      }).valid && typeof x.slackURL === "string"
    );
  }
  logger.debug(
    `addMessageAttachmentToCordMessage: attaching ${fileAttachments.length} of ${files.length} attachments`
  );
  const uploadedAndFailedAttachments = await Promise.all(
    fileAttachments.map(async (attachment) => {
      const slackFileResponse = await fetch(attachment.slackURL, {
        method: "GET",
        headers: {
          Accept: "application/json",
          Authorization: `Bearer ${accessToken}`
        }
      });
      if (slackFileResponse.status !== 200) {
        logger.error(
          `Attachment download failed with status ${slackFileResponse.status}`,
          { attachment }
        );
        return null;
      }
      await uploadToS3AndCreateFileEntity({
        logger,
        fileID: attachment.id,
        fileName: attachment.name,
        size: attachment.size,
        mimetype: attachment.mimetype,
        file: slackFileResponse.body,
        viewer
      });
      return attachment;
    })
  );
  const uploadedAttachments = uploadedAndFailedAttachments.filter(
    (attachment) => !!attachment
  );
  return uploadedAttachments.map(({ id }) => ({ id: uuid24(), fileID: id }));
}
var allowImportUser = (member) => member.id !== "USLACKBOT" && !member.is_bot;
async function getUserAndAttributionForUser(context, userID, orgID, isScrapedSlackMessage = false, mirrorType) {
  const originalUser = await context.loaders.userLoader.loadUserInAnyViewerOrg(userID);
  if (!originalUser) {
    context.logger.error("Cant find profile for user");
    return {};
  }
  const slackLinkedUser = await loadLinkedSlackUserOrgScoped(
    originalUser,
    context,
    orgID
  );
  const originalProfileDisplayDetails = await detailsForDisplay(
    originalUser,
    context
  );
  let username;
  let iconURL;
  if (await getFeatureFlagValue("impersonate_slack_message_author", {
    userID,
    orgID,
    platformApplicationID: context.session.viewer.platformApplicationID ?? "extension",
    version: context.clientVersion,
    customerID: context.application?.customerID
  })) {
    username = mirrorType === "support" ? originalProfileDisplayDetails.displayName : slackLinkedUser ? userDisplayName(slackLinkedUser) : originalProfileDisplayDetails.displayName;
    let badgeLogoURL = null;
    if (originalUser.externalProvider === "platform" /* PLATFORM */ && originalUser.platformApplicationID) {
      const application = await context.loaders.applicationLoader.load(
        originalUser.platformApplicationID
      );
      if (application) {
        username = `${username} (on ${application.name})`;
        badgeLogoURL = application.iconURL;
      }
    } else if (!isScrapedSlackMessage) {
      username = `${username} (via Cord)`;
      badgeLogoURL = `${APP_ORIGIN}/static/provider-icons/cord.png`;
    }
    iconURL = mirrorType === "support" ? originalProfileDisplayDetails.profilePictureURL ?? void 0 : slackLinkedUser?.profilePictureURL ?? originalProfileDisplayDetails.profilePictureURL ?? void 0;
    if (iconURL && (badgeLogoURL || isScrapedSlackMessage) && await getFeatureFlagValue("badge_attribution_avatar", {
      userID,
      orgID,
      platformApplicationID: context.session.viewer.platformApplicationID ?? "extension",
      version: context.clientVersion
    })) {
      try {
        iconURL = badgeLogoURL ? await getBadgedImageURL(iconURL, badgeLogoURL) : await getResizedImageURL(iconURL);
      } catch (err) {
        context.logger.logException(
          "getBadgedImageURL or getResizedImageURL",
          err,
          void 0,
          void 0,
          "warn"
        );
      }
    }
  }
  return {
    originalUser,
    slackLinkedUser,
    username,
    iconURL
  };
}
function getSlackMessageURL(domain, slackChannelID, slackMessageTS, SlackThreadTS) {
  const tsWithoutPeriod = slackMessageTS.replace(".", "");
  let slackURL = `https://${domain}.slack.com/archives/${slackChannelID}/p${tsWithoutPeriod}`;
  if (SlackThreadTS) {
    const threadTsWithoutPeriod = SlackThreadTS.replace(".", "");
    slackURL += `?thread_ts=${threadTsWithoutPeriod}&cid=${slackChannelID}`;
  }
  return slackURL;
}
async function unlinkThreadOnSlackMessageDelete(event, org) {
  if (event.subtype === "message_deleted" || event.subtype === "message_changed" && event.message && event.message.subtype === "tombstone") {
    const { channel } = event;
    const timestamp = event.deleted_ts ?? event.message?.ts;
    if (typeof channel === "string" && typeof timestamp === "string") {
      const viewer = Viewer.createOrgViewer(org.id);
      const slackMessageMutator = new SlackMessageMutator(viewer);
      await slackMessageMutator.unlinkSlackMessage(channel, timestamp);
      const slackMirroredThreadMutator = new SlackMirroredThreadMutator(viewer);
      const linkedThreadInfo = await slackMirroredThreadMutator.unlinkSlackThread(channel, timestamp);
      if (linkedThreadInfo) {
        const { threadID, threadOrgID } = linkedThreadInfo;
        const orgViewer = Viewer.createOrgViewer(threadOrgID);
        const orgLoaders = await getNewLoaders(orgViewer);
        const messageMutator = new MessageMutator(
          Viewer.createOrgViewer(threadOrgID),
          orgLoaders
        );
        await messageMutator.resetSlackImportForThread(threadID);
        if (event.subtype === "message_changed") {
          const slackBotCredentials = await org.getSlackBotCredentials();
          if (slackBotCredentials) {
            await sendChannelMessage({
              slackBotCredentials,
              channelID: channel,
              text: "This message thread is no longer shared with Cord, because the top message has been deleted in Slack.",
              threadTS: timestamp
            });
          }
        }
        await publishPubSubEvent(
          "thread-share-to-slack",
          { threadID },
          { info: null }
        );
      }
    }
    return;
  }
}
async function uploadToS3AndCreateFileEntity({
  logger,
  fileID,
  fileName,
  size,
  mimetype,
  file,
  viewer
}) {
  const uploadURL = getSignedUploadURL(fileID, size, mimetype);
  let fileUploadStatus = "uploading";
  const uploadResponse = await fetch(uploadURL, {
    method: "PUT",
    body: file,
    headers: {
      "Content-Length": `${size}`,
      "Content-Type": mimetype
    }
  });
  if (uploadResponse.status !== 200) {
    logger.error(
      `Slack attachment upload failed with status ${uploadResponse.status}`,
      {
        fileID,
        fileName,
        status: uploadResponse.status,
        statusText: uploadResponse.statusText
      }
    );
    return null;
  }
  fileUploadStatus = "uploaded";
  const loaders = await getNewLoaders(viewer);
  const fileMutator = new FileMutator(viewer, loaders);
  await fileMutator.createFileForUpload(
    fileID,
    fileName,
    mimetype,
    size,
    fileUploadStatus
  );
  return fileID;
}
async function uploadGiphy(logger, msg, viewer) {
  if (msg.bot_profile?.name !== "giphy" || !msg.blocks?.[0]?.image_url) {
    return null;
  }
  const giphyURL = msg.blocks[0].image_url;
  const image = await fetch(giphyURL);
  if (image.status !== 200) {
    logger.error(
      `Giphy attachment download failed with status ${image.status}`,
      { url: msg.blocks?.[0]?.image_url }
    );
    return null;
  }
  const contentLength = image.headers.get("Content-Length");
  const contentType = image.headers.get("Content-Type");
  if (!contentLength || !contentType) {
    logger.error(
      `Couldn't find necessary headers in order to upload giphy image`,
      { url: msg.blocks?.[0]?.image_url, contentLength, contentType }
    );
    return null;
  }
  const fileID = uuid24();
  const result = await uploadToS3AndCreateFileEntity({
    logger,
    fileID,
    fileName: `giphy_${msg.blocks[0].title?.text}`,
    size: Number(contentLength),
    mimetype: contentType,
    file: image.body,
    viewer
  });
  if (!result) {
    return null;
  }
  return fileID;
}

// server/src/asyncTier/jobs/checkAWSCredentials.ts
var DAYS_MS = 24 * 60 * 60 * 1e3;
var MAX_PW_AGE_MS = 79 * DAYS_MS;
var MAX_ACCESS_KEY_AGE_MS = 79 * DAYS_MS;
var MAX_CREDENTIALS_REPORT_AGE_MS = 7 * DAYS_MS;
var checkAWSCredentials_default = new AsyncTierJobDefinition(
  "awsCredentialsCheck",
  checkAWSCredentials
).schedule({
  tier: "staging",
  name: "daily",
  cron: "0 10 * * 1-5",
  // Everyday at 10:00, excluding Sat/Sun
  data: {}
});
async function checkAWSCredentials(_, logger) {
  const result = await new IAMClient({ region: AWS_REGION }).send(
    new GetCredentialReportCommand({})
  );
  if (!result || !result.Content) {
    logger.error(`No result for AWS Credentials report`);
    return;
  }
  const { default: neatCsv } = await import("neat-csv");
  const { Content: csvContent, GeneratedTime } = result;
  const csv = await neatCsv(
    Buffer.from(csvContent.buffer)
  );
  if (csv) {
    const today = (/* @__PURE__ */ new Date()).getTime();
    const usersWithoutMFA = [];
    const usersWithAccessKeyTooOld = [];
    const usersWithPwTooOld = [];
    for (const data of csv) {
      const {
        user,
        password_enabled,
        password_last_changed,
        mfa_active,
        access_key_1_active,
        access_key_2_active,
        access_key_1_last_rotated,
        access_key_2_last_rotated
      } = data;
      if (password_enabled !== "true") {
        continue;
      }
      const passwordTooOld = password_last_changed !== "n/a" && today - new Date(password_last_changed).getTime() > MAX_PW_AGE_MS;
      if (passwordTooOld) {
        usersWithPwTooOld.push(user);
      }
      if (mfa_active !== "true") {
        usersWithoutMFA.push(user);
      }
      const noAccessKey = access_key_1_active !== "true" && access_key_2_active !== "true";
      if (noAccessKey) {
        continue;
      }
      const activeAccessKeyTooOld = isAccessKeyTooOld(
        access_key_1_active,
        access_key_1_last_rotated,
        today
      ) || isAccessKeyTooOld(
        access_key_2_active,
        access_key_2_last_rotated,
        today
      );
      if (activeAccessKeyTooOld) {
        usersWithAccessKeyTooOld.push(user);
      }
    }
    if (!Env_default.CORD_SECURITY_SLACK_CHANNEL_ID) {
      return;
    }
    if (GeneratedTime && today - GeneratedTime.getTime() > MAX_CREDENTIALS_REPORT_AGE_MS) {
      backgroundPromise(
        sendMessageToCord(
          `AWS Credentials Report is too old. Is "generateAWSCredentials" async job running correctly?`,
          Env_default.CORD_SECURITY_SLACK_CHANNEL_ID,
          "security"
        )
      );
      return;
    }
    if (usersWithAccessKeyTooOld.length || usersWithoutMFA.length || usersWithPwTooOld.length) {
      let msg = `AWS Credentials Report ${GeneratedTime ? `(Generated ${GeneratedTime.toUTCString()})` : ""} :
`;
      if (usersWithoutMFA.length) {
        msg += `
Users that must turn on MFA: ${usersWithoutMFA.join(",")}
`;
        msg += 'To turn on MFA, log into the AWS console and visit "Security Credentials" in the top right menu\n';
      }
      if (usersWithPwTooOld.length) {
        msg += `
Users that must rotate their password: ${usersWithPwTooOld.join(
          ","
        )}
`;
        msg += 'To rotate your password, log into the AWS console and visit "Security Credentials" in the top right menu\n';
      }
      if (usersWithAccessKeyTooOld.length) {
        msg += `
Users that must rotate access key: ${usersWithAccessKeyTooOld.join(
          ","
        )}`;
        msg += "\nTo rotate your key, you can run `./scripts/rotate-aws-access-key.sh`";
      }
      backgroundPromise(
        sendMessageToCord(msg, Env_default.CORD_SECURITY_SLACK_CHANNEL_ID, "security")
      );
    }
  }
}
function isAccessKeyTooOld(accessKeyActive, accessKeyLastRotated, today) {
  return accessKeyActive === "true" && accessKeyLastRotated !== "n/a" && today - new Date(accessKeyLastRotated).getTime() > MAX_ACCESS_KEY_AGE_MS;
}

// server/src/asyncTier/jobs/databaseTidyUp.ts
var databaseTidyUp_default = new AsyncTierJobDefinition(
  "databaseTidyUp",
  databaseTidyUpJob
).schedule({
  tier: "staging",
  name: "every15Minutes",
  cron: "0,15,30,45 * * * *",
  data: {}
});
async function databaseTidyUpJob() {
  await getSequelize().query(
    `UPDATE "${FileEntity.tableName}"
     SET "uploadStatus" = $1
     WHERE "uploadStatus" = $2
     AND "timestamp" < NOW() - $3::INTERVAL;`,
    {
      bind: [
        "cancelled",
        "uploading",
        `${MAX_FILE_UPLOADING_TIME_SECONDS} seconds`
      ]
    }
  );
}

// server/src/asyncTier/jobs/example.ts
var example_default = new AsyncTierJobDefinition("example", exampleJob);
async function exampleJob(data, logger) {
  const { message } = data;
  logger.info(`ExampleJob: ${message}`);
}

// server/src/asyncTier/jobs/generateAWSCredentials.ts
import {
  GenerateCredentialReportCommand,
  IAMClient as IAMClient2
} from "@aws-sdk/client-iam";
var generateAWSCredentials_default = new AsyncTierJobDefinition(
  "awsGenerateCredentialsReport",
  generateAWSCredentialsReports
).schedule({
  tier: "staging",
  name: "daily",
  cron: "0 9  * * 1-5",
  // Everyday at 09:00, excluding Sat/Sun
  data: {}
});
async function generateAWSCredentialsReports() {
  await new IAMClient2({ region: AWS_REGION }).send(
    new GenerateCredentialReportCommand({})
  );
}

// server/src/asyncTier/jobs/resizeProfilePicture.ts
import { parse as parse8 } from "url";
import { Readable } from "stream";
import {
  S3Client as S3Client2,
  PutObjectCommand,
  GetObjectCommand
} from "@aws-sdk/client-s3";
import sharp3 from "sharp";
var streamToBuffer = (stream) => new Promise((resolve2, reject) => {
  const chunks = [];
  stream.on("data", (chunk) => chunks.push(chunk));
  stream.once("error", reject);
  stream.once("end", () => resolve2(Buffer.concat(chunks)));
});
var resizeProfilePicture_default = new AsyncTierJobDefinition(
  "resizeProfilePicture",
  resizeProfilePicture
);
async function resizeProfilePicture(data, logger) {
  const { profilePictureURL, userID, orgID } = data;
  const parsedURL = parse8(profilePictureURL);
  if (parsedURL.host !== Env_default.PUBLIC_UPLOADS_HOST || !parsedURL.path) {
    logger.error(
      `Bad profile picture url submitted for resizing: ${profilePictureURL}`
    );
    return;
  }
  const fileID = Env_default.S3_USE_PATH_BASED_URLS === "true" ? (
    // Remove slash before and after bucket name
    parsedURL.path.substring(2 + Env_default.S3_PUBLIC_BUCKET.length)
  ) : (
    // Just remove leading slash
    parsedURL.path.substring(1)
  );
  const s3Client = new S3Client2({
    region: Env_default.S3_REGION,
    endpoint: Env_default.S3_ENDPOINT.replace("<REGION>", Env_default.S3_REGION)
  });
  const { originalImageBuffer, size } = await getUserUploadedImage(
    fileID,
    s3Client,
    logger
  );
  if (size < RESIZE_PROFILE_PICTURE_THRESHOLD) {
    logger.info(
      `Skipping resize of ${profilePictureURL}: size is ${Math.round(
        size / 1024
      )} KB`
    );
    return;
  }
  const resizedImgBuffer = await sharp3(originalImageBuffer).resize({
    width: MIN_RESIZED_PROFILE_PICTURE_DIMENSION,
    // Scale image proportionally
    fit: "outside"
  }).jpeg({ quality: 90 }).toBuffer();
  const resizedImageFileName = `${fileID}_resized_${MIN_RESIZED_PROFILE_PICTURE_DIMENSION}`;
  const putObjectCommand = new PutObjectCommand({
    Body: resizedImgBuffer,
    Bucket: Env_default.S3_PUBLIC_BUCKET,
    Key: getPublicBucketKey(resizedImageFileName),
    ContentType: "image/jpeg"
  });
  await s3Client.send(putObjectCommand);
  await new UserMutator(
    Viewer.createLoggedInViewer(userID, orgID),
    null
  ).updateProfilePictureURL(getPublicBucketDownloadURL(resizedImageFileName));
}
var getUserUploadedImage = async (fileID, s3, logger) => {
  let originalImageBuffer;
  let size;
  for (let i = 0; i < 6; i++) {
    await sleep(10 * 1e3);
    try {
      const getObjectCommand = new GetObjectCommand({
        Bucket: Env_default.S3_PUBLIC_BUCKET,
        Key: getPublicBucketKey(fileID)
      });
      const { ContentLength, Body } = await s3.send(getObjectCommand);
      if (Body instanceof Readable) {
        originalImageBuffer = await streamToBuffer(Body);
      } else if (Body instanceof Blob) {
        originalImageBuffer = Buffer.from(await Body.arrayBuffer());
      } else {
        throw new Error(
          `Body returned from s3 is not of of type Readable or Blob, ${typeof Body}`
        );
      }
      size = ContentLength;
      break;
    } catch (e) {
      if (e.name.includes("NoSuchKey")) {
      } else {
        logger.error(
          `Unexpected error when resizing profile picture ${fileID}`
        );
        throw e;
      }
    }
  }
  if (!originalImageBuffer || !size) {
    throw new Error(`Cant find file ${fileID} in public uploads bucket`);
  }
  return { originalImageBuffer, size };
};

// server/src/webhook/util.ts
function processResponseMessage(responseMessage) {
  try {
    return JSON.parse(responseMessage);
  } catch (err) {
    return responseMessage;
  }
}

// server/src/asyncTier/jobs/notifyWebhook.ts
var notifyWebhook_default = new AsyncTierJobDefinition("notifyWebhook", notifyWebhook);
var counter7 = Counter2({
  name: "eventsWebhook",
  help: "Webhook events sent",
  labelNames: ["appID", "type", "success"]
});
async function notifyWebhook(data, logger) {
  const { eventType, appID, url: url6 } = data;
  let { timestamp, signature, payload } = data;
  if (data.event) {
    const app = await ApplicationEntity.findOne({
      where: { id: appID }
    });
    if (app !== null) {
      [payload, timestamp, signature] = authenticationHeader(
        eventType,
        app,
        data.event
      );
    }
  }
  logger.debug("Sending webhook event", {
    appID,
    url: url6,
    eventType,
    payload
  });
  try {
    const res = await safeFetch(url6, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-Cord-Timestamp": timestamp,
        "X-Cord-Signature": signature
      },
      body: payload
    });
    if (res.ok) {
      counter7.inc({ appID, type: eventType, success: "true" });
    } else {
      const responseMessage = await res.text();
      logger.warn("Unsuccessful HTTP request when sending webhook", {
        appID,
        url: url6,
        eventType,
        payload,
        status: res.status,
        statusText: res.statusText,
        responseMessage: processResponseMessage(responseMessage)
      });
      counter7.inc({ appID, type: eventType, success: "false" });
      retry(data);
    }
  } catch (e) {
    logger.logException(
      `Error making webhook call to ${url6} for application: ${appID}`,
      e,
      void 0,
      void 0,
      "warn"
    );
    counter7.inc({ appID, type: eventType, success: "false" });
    retry(data);
  }
}
var RETRY_MAX_COUNT = 5;
var NUM_SECONDS_WAIT = 5;
function retry(workItemData) {
  if (workItemData.retryCount < RETRY_MAX_COUNT) {
    workItemData.retryCount++;
    void submitAsync("notifyWebhook", workItemData, {
      startAfter: NUM_SECONDS_WAIT * workItemData.retryCount * workItemData.retryCount
    });
  }
}

// server/src/asyncTier/jobs/jiraRefreshTokenRotate.ts
var jiraRefreshTokenRotate_default = new AsyncTierJobDefinition(
  "rotateJiraRefreshTokens",
  rotateAllJiraRefreshTokens
).schedule({
  tier: "staging",
  name: "weekly",
  cron: "0 6 * * 3",
  // 6am every Wednesday https://crontab.guru/#0_6_*_*_3
  data: {}
});
async function rotateAllJiraRefreshTokens(_, jobLogger) {
  const jiraConnections = await ThirdPartyConnectionEntity.findAll({
    where: {
      type: "jira"
    }
  });
  jobLogger.debug(`Found ${jiraConnections.length} jira connections`);
  await Promise.all(
    jiraConnections.map(async (jiraConnection) => {
      const viewer = Viewer.createLoggedInViewer(
        jiraConnection.userID,
        jiraConnection.orgID
      );
      const externalData = jiraConnection.externalAuthData;
      const logger = jobLogger.childLogger(viewer, externalData);
      try {
        logger.debug("Going to rotate JIRA refreshToken");
        await fetchAccessToken(
          viewer,
          externalData.refreshToken,
          externalData.cloudID
        );
        logger.debug("Successfully rotated refreshToken");
      } catch (e) {
        const deleteConnection = getErrorMessage2(e) === "external_api_forbidden_response" /* EXTERNAL_API_FORBIDDEN_RESPONSE */;
        logger.logException("Failed to rotate JIRA refreshToken", e);
        if (deleteConnection) {
          await removeExternalConnection(viewer, "jira");
        }
      } finally {
        logger.debug("Done rotating JIRA refreshToken");
      }
    })
  );
}
function getErrorMessage2(e) {
  if (typeof e === "object" && e !== null && "message" in e && typeof e.message === "string") {
    return e.message;
  }
  return void 0;
}

// server/src/asyncTier/jobs/syncSlackChannelsList.ts
import * as Slack4 from "@slack/web-api";
import bluebird from "bluebird";
var syncSlackChannelsList_default = new AsyncTierJobDefinition(
  "syncSlackChannelsList",
  syncSlackChannelsList
).schedule({
  tier: "staging",
  name: "daily",
  cron: "0 10 * * *",
  data: {}
});
async function syncSlackChannelsList(_, logger) {
  logger.info("Starting Slack channel list sync for all active orgs");
  const orgLoader = new OrgLoader(Viewer.createAnonymousViewer());
  const orgs = await orgLoader.loadAllActiveSlackOrgs();
  await bluebird.Promise.map(
    orgs,
    (org) => fetchAndSaveSlackChannels(org, logger),
    {
      concurrency: 10
    }
  );
}
async function fetchAndSaveSlackChannels(org, jobLogger) {
  const viewer = Viewer.createOrgViewer(org.id);
  const logger = jobLogger.childLogger(viewer, {
    id: org.id,
    externalId: org.externalID,
    appId: org.platformApplicationID,
    name: org.name
  });
  logger.debug("Fetching an org's Slack channels");
  const slackBotCredentials = await org.getSlackBotCredentials();
  if (!slackBotCredentials) {
    logger.warn("fetchAndSaveSlackChannels: no SlackBotCredentials");
    return;
  }
  const { bot_access_token } = slackBotCredentials;
  try {
    const channelList = await fetchSlackChannelList(
      new Slack4.WebClient(bot_access_token)
    );
    await new SlackChannelMutator(viewer).createMany(channelList);
  } catch (error) {
    if (error?.data?.error === "account_inactive") {
      logger.warn(
        "Failed to scrape list of Slack channels because company removed Cord from Slack",
        error
      );
      await org.update({ externalAuthData: null });
    } else {
      logger.logException("Error scraping list of Slack channels", error);
    }
  }
}

// server/src/asyncTier/jobs/syncSlackGreyUsers.ts
var MAX_SLACK_USERS_PER_BATCH = 100;
var syncSlackGreyUsers_default = new AsyncTierJobDefinition(
  "syncSlackGreyUsers",
  syncSlackGreyUsers
);
async function syncSlackGreyUsers(data, logger) {
  logger.info("Starting Slack org grey users sync");
  const { orgID } = data;
  try {
    const org = await OrgEntity.findByPk(orgID);
    if (!org) {
      throw new Error("Org does not exist");
    }
    const viewer = Viewer.createOrgViewer(org.id);
    logger = logger.childLogger(viewer, {
      id: org.id,
      externalId: org.externalID,
      appId: org.platformApplicationID,
      name: org.name
    });
    const slackBotCredentials = await org.getSlackBotCredentials();
    if (!slackBotCredentials) {
      logger.warn("syncSlackGreyUsers: no SlackBotCredentials");
      return;
    }
    const { bot_access_token } = slackBotCredentials;
    const membersToAdd = (await fetchSlackUsersList(bot_access_token)).filter(allowImportUser).filter((member) => member.team_id === org.externalID).sort((a, b) => Number(a.deleted) - Number(b.deleted));
    for (let offset = 0; offset < membersToAdd.length; offset += MAX_SLACK_USERS_PER_BATCH) {
      await Promise.all(
        membersToAdd.slice(offset, offset + MAX_SLACK_USERS_PER_BATCH).map(
          // account is inactive and we don't know their access token
          (member) => updateOrCreateSlackUserProfile(org, member)
        )
      );
    }
  } catch (error) {
    logger.logException("Error updating Slack grey users", error, {
      orgID
    });
  }
}

// server/src/asyncTier/jobs/wipeTemporaryTokensData.ts
import { QueryTypes as QueryTypes29 } from "sequelize";
var wipeTemporaryTokensData_default = new AsyncTierJobDefinition(
  "wipeTemporaryTokensData",
  wipeTemporaryTokensData
).schedule({
  tier: "staging",
  name: "daily",
  cron: "0 0 * * *",
  data: {}
});
var MAX_ORGS_PER_ITERATION = 100;
async function wipeTemporaryTokensData(_, logger) {
  for (let iteration = 1; await jobIteration(logger, iteration); ++iteration) {
  }
}
async function jobIteration(logger, iteration) {
  const sequelize2 = getSequelize();
  logger.info(`Starting iteration #${iteration}`);
  return await sequelize2.transaction(async (transaction) => {
    const query = (sql, bind) => sequelize2.query(sql, { bind, transaction, type: QueryTypes29.RAW });
    await query(
      `CREATE TEMPORARY TABLE inactive_org_ids (
        id uuid NOT NULL
      ) ON COMMIT DROP;`
    );
    await query(
      `INSERT INTO inactive_org_ids (id)
      -- Docs live component orgs
      SELECT o.id
        FROM cord.orgs o
        LEFT OUTER JOIN cord.page_visitors pv ON pv."orgID"=o.id
        WHERE o."platformApplicationID"=$1
        AND NOW() - o."createdTimestamp" > '24 hours'
        GROUP BY o.id
        HAVING COALESCE(NOW() - MAX(pv."lastPresentTimestamp") > '24 hours', true)
      -- Demo token apps (canvas app etc on docs.cord.com and cord.com homepage)
        UNION SELECT o.id
          FROM cord.orgs o
          INNER JOIN cord.applications a ON a.id=o."platformApplicationID"
          LEFT OUTER JOIN cord.page_visitors pv ON pv."orgID"=o.id
          WHERE a.environment='demo'
          AND NOW() - o."createdTimestamp" > '24 hours'
          GROUP BY o.id
          HAVING COALESCE(NOW() - MAX(pv."lastPresentTimestamp") > '24 hours', true)  
      -- Sample token apps (integration guide/opensource demo app repos)
      UNION SELECT o.id
        FROM cord.orgs o
        INNER JOIN cord.applications a ON a.id=o."platformApplicationID"
        LEFT OUTER JOIN cord.page_visitors pv ON pv."orgID"=o.id
        WHERE a.environment='sampletoken'
        AND NOW() - o."createdTimestamp" > '1 week'
        GROUP BY o.id
        HAVING COALESCE(NOW() - MAX(pv."lastPresentTimestamp") > '1 week', true)
      -- Automated test app orgs
      UNION SELECT o.id
        FROM cord.orgs o
        WHERE o."platformApplicationID" = $2
        AND NOW() - o."createdTimestamp" > '1 hour'
      -- The following limit applies to the whole of this query
      LIMIT $3;`,
      [
        CORD_DOCS_SAMPLE_TOKEN_APPLICATION_ID,
        CORD_AUTOMATED_TESTS_APPLICATION_ID,
        MAX_ORGS_PER_ITERATION
      ]
    );
    const [{ orgCount }] = await sequelize2.query(
      `SELECT COUNT(*) AS "orgCount" FROM inactive_org_ids;`,
      { type: QueryTypes29.SELECT, transaction }
    );
    if (orgCount === 0) {
      logger.info(`No orgs found to delete in iteration #${iteration}`, {
        orgCount,
        iteration
      });
      return false;
    }
    logger.info(`Identified ${orgCount} orgs to delete`, {
      orgCount,
      iteration
    });
    await query(
      `CREATE TEMPORARY TABLE inactive_app_ids (
        id uuid NOT NULL
      ) ON COMMIT DROP;`
    );
    await query(`
      INSERT INTO inactive_app_ids (id)
      -- sampletoken apps
      SELECT a.id
        FROM cord.applications a
        LEFT OUTER JOIN orgs o ON o."platformApplicationID"=a.id
        LEFT OUTER JOIN inactive_org_ids ON o.id=inactive_org_ids.id
        WHERE a.environment='sampletoken'
        AND a."createdTimestamp" < NOW() - '1 week'::interval
        GROUP BY a.id
        HAVING COUNT(o)=COUNT(inactive_org_ids)
      -- demo apps
      UNION SELECT a.id
        FROM cord.applications a
        LEFT OUTER JOIN orgs o ON o."platformApplicationID"=a.id
        LEFT OUTER JOIN inactive_org_ids ON o.id=inactive_org_ids.id
        WHERE a.environment='demo'
        AND a."createdTimestamp" < NOW() - '24 hours'::interval
        GROUP BY a.id
        HAVING COUNT(o)=COUNT(inactive_org_ids);
        `);
    await query(
      `CREATE TEMPORARY TABLE inactive_user_ids ON COMMIT DROP AS
      -- users that are members only in inactive orgs
      SELECT m."userID" AS id
        FROM org_members m LEFT OUTER JOIN inactive_org_ids ON m."orgID"=inactive_org_ids.id
        GROUP BY m."userID"
        HAVING COUNT(m)=COUNT(inactive_org_ids)
      -- users of an application to-be-removed who is not a member of any org (we need to
      -- delete those in order to delete the apps, and these are not caught by the
      -- previous branch)
      UNION SELECT u.id
        FROM users u
        INNER JOIN inactive_app_ids ON u."platformApplicationID"=inactive_app_ids.id
        WHERE NOT EXISTS (
          SELECT 1 FROM cord.org_members om WHERE om."userID"=u.id
        );`
    );
    await query(
      `DELETE FROM cord.message_notifications
        USING inactive_org_ids, cord.org_members
        WHERE "targetUserID"=org_members."userID" AND org_members."orgID"=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.linked_orgs
        USING inactive_org_ids
        WHERE "sourceOrgID"=inactive_org_ids.id
        OR "linkedOrgID"=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.linked_users
        USING inactive_org_ids
        WHERE "sourceOrgID"=inactive_org_ids.id
        OR "linkedOrgID"=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.org_members
        USING inactive_org_ids
        WHERE "orgID"=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.messages
        USING inactive_org_ids
        WHERE "orgID"=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.threads
        USING inactive_org_ids
        WHERE "orgID"=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.pages
        USING inactive_org_ids
        WHERE "orgID"=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.users
        USING inactive_user_ids
        WHERE cord.users.id=inactive_user_ids.id;`
    );
    await query(
      `DELETE FROM cord.orgs
        USING inactive_org_ids
        WHERE orgs.id=inactive_org_ids.id;`
    );
    await query(
      `DELETE FROM cord.applications
        USING inactive_app_ids
        WHERE applications.id=inactive_app_ids.id;`
    );
    const needAnotherIteration = orgCount >= MAX_ORGS_PER_ITERATION;
    logger.info(`Completed iteration #${iteration}`, {
      iteration,
      orgCount,
      needAnotherIteration
    });
    return needAnotherIteration;
  });
}

// server/src/asyncTier/jobs/asyncWorkerHealthHeartbeatStaging.ts
import { QueryTypes as QueryTypes31 } from "sequelize";

// server/src/asyncTier/jobs/asyncWorkerHealthHeartbeatProd.ts
import { QueryTypes as QueryTypes30 } from "sequelize";
var UNACCEPTABLY_LONG_QUEUE_LENGTH = 200;
var asyncWorkerHealthHeartbeatProd_default = new AsyncTierJobDefinition(
  "asyncWorkerHealthHeartbeatProd",
  asyncWorkerHealthHeartbeatProd
).schedule({
  tier: "prod",
  name: "everyFiveMinutes",
  cron: "*/5 * * * *",
  // At every 5th minute https://crontab.guru/#*/5_*_*_*_*
  data: {}
});
async function asyncWorkerHealthHeartbeatProd(_, logger) {
  logger.info("Running asyncWorkerHealthHeartbeatProd");
  const [{ count: jobCount }] = await getSequelize().query(
    `SELECT count(*) FROM pgboss_prod.job WHERE state = 'created';`,
    {
      type: QueryTypes30.SELECT
    }
  );
  logger.info(`${jobCount} jobs currently in the prod queue`);
  if (jobCount < UNACCEPTABLY_LONG_QUEUE_LENGTH) {
    try {
      void fetch(
        "https://uptime.betterstack.com/api/v1/heartbeat/4QK52h4vc1RADyCX5CDeW9ZT"
      );
    } catch (e) {
      logger.logException("Error sending prod async heartbeat", e);
    }
  } else {
    logger.logException("Async queue size too big - not sending heartbeat", {
      jobCount,
      tier: "prod"
    });
  }
}

// server/src/asyncTier/jobs/asyncWorkerHealthHeartbeatStaging.ts
var asyncWorkerHealthHeartbeatStaging_default = new AsyncTierJobDefinition(
  "asyncWorkerHealthHeartbeatStaging",
  asyncWorkerHealthHeartbeatStaging
).schedule({
  tier: "staging",
  name: "everyFiveMinutes",
  cron: "*/5 * * * *",
  // At every 5th minute https://crontab.guru/#*/5_*_*_*_*
  data: {}
});
async function asyncWorkerHealthHeartbeatStaging(_, logger) {
  logger.info("Running asyncWorkerHealthHeartbeatStaging");
  const [{ count: jobCount }] = await getSequelize().query(
    `SELECT count(*) FROM pgboss_staging.job WHERE state = 'created';`,
    {
      type: QueryTypes31.SELECT
    }
  );
  logger.info(`${jobCount} jobs currently in the staging queue`);
  if (jobCount < UNACCEPTABLY_LONG_QUEUE_LENGTH) {
    try {
      void fetch(
        "https://uptime.betterstack.com/api/v1/heartbeat/GxRoHJQNRfoC26kNmjZAvrEm"
      );
    } catch (e) {
      logger.logException("Error sending staging async heartbeat", e);
    }
  } else {
    logger.logException("Async queue size too big - not sending heartbeat", {
      jobCount,
      tier: "staging"
    });
  }
}

// server/src/asyncTier/jobs.ts
var asyncJobList = [
  applicationUsageMetrics_default,
  asyncWorkerHealthCheck_default,
  asyncWorkerHealthHeartbeatStaging_default,
  asyncWorkerHealthHeartbeatProd_default,
  checkAWSCredentials_default,
  databaseTidyUp_default,
  example_default,
  generateAWSCredentials_default,
  generateLinkPreviews_default,
  resizeProfilePicture_default,
  jiraRefreshTokenRotate_default,
  sendEmailNotificationWithDelay_default,
  sendSlackNotificationWithDelay_default,
  syncSlackChannelsList_default,
  syncSlackGreyUsers_default,
  wipeTemporaryTokensData_default,
  notifyWebhook_default
];

// server/src/asyncTier/asyncWorkerMain.ts
async function main() {
  const boss2 = await initBoss();
  await initSequelize("async");
  initRedis();
  await initPubSub();
  await initializeLinkSigningCredentials();
  await initFeatureFlags().catch(
    anonymousLogger().exceptionLogger("initFeatureFlags failed")
  );
  anonymousLogger().logLoggerInfo();
  const existingSchedulesByName = new Map(
    (await boss2.getSchedules()).map((schedule) => [schedule.name, schedule])
  );
  for (const job of asyncJobList) {
    await job.register(boss2, Env_default.CORD_TIER, existingSchedulesByName);
  }
  for (const abandonedSchedule of existingSchedulesByName.keys()) {
    await boss2.unschedule(abandonedSchedule);
  }
  await subscribeToPubSubEvent(
    "pub-sub-health-check",
    null,
    handlePubSubHealthCheckEvent
  );
  anonymousLogger().info("Registered all async jobs - ready to do work");
}
function handleFailedHealthCheck() {
  const { CORD_OPS_SLACK_CHANNEL_ID } = Env_default;
  if (CORD_OPS_SLACK_CHANNEL_ID) {
    backgroundPromise(
      sendMessageToCord(
        "\u274C PgBoss pubSub health check failed",
        CORD_OPS_SLACK_CHANNEL_ID
      )
    );
  }
}
var HEALTH_CHECK_TIMEOUT = 5 * 6e4;
var lastTimeout = void 0;
function handlePubSubHealthCheckEvent() {
  if (lastTimeout) {
    clearTimeout(lastTimeout);
  }
  lastTimeout = setTimeout(handleFailedHealthCheck, HEALTH_CHECK_TIMEOUT);
}
main().catch((err) => {
  console.error(err);
  process.exit(1);
});

//# sourceMappingURL=asyncWorker.js.map
